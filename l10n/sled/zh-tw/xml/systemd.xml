<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="systemd.xml" version="5.0" xml:id="cha-systemd">
 <title><systemitem class="daemon">systemd</systemitem> 精靈</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>
 <para>
  <systemitem class="daemon">systemd</systemitem> 負責啟始化系統，它的程序 ID 為 1。<systemitem class="daemon">systemd</systemitem> 由核心直接啟動，訊號 9 (通常會終止程序) 對它不起作用。所有其他程式或由 <systemitem class="daemon">systemd</systemitem> 直接啟動，或由它的其中一個子程序啟動。<systemitem class="daemon">systemd</systemitem> 取代了 System V init 精靈，並且透過支援 init 程序檔與 System V init 完全相容。
 </para>
 <para>
  <systemitem class="daemon">systemd</systemitem> 的主要優點是透過平行化服務啟動，大大加快了開機速度。另外，<systemitem class="daemon">systemd</systemitem> 僅在確實需要服務時才會啟動該服務。即不會在開機時無條件啟動精靈，而是在第一次需要時才會啟動。<systemitem class="daemon">systemd</systemitem> 還支援核心控制群組 (cgroup)、建立快照和還原系統狀態。如需詳細資訊，請造訪 <link xlink:href="http://www.freedesktop.org/wiki/Software/systemd/"/>。
 </para>
   
 <sect1 xml:id="sec-boot-systemd-concept">
  <title><systemitem class="daemon">systemd</systemitem> 概念</title>
  <para>
   以下幾節介紹 <systemitem class="daemon">systemd</systemitem> 背後的概念。
  </para>
  <para>
    <systemitem class="daemon">systemd</systemitem> 是適用於 Linux 的系統和工作階段管理員，它與 System V 及 LSB init 程序檔相容。<systemitem class="daemon">systemd</systemitem> 的主要功能包括：
  </para>
    <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>
      平行化能力
     </para>
    </listitem>
    <listitem>
     <para>
      使用通訊端和 D-Bus 啟用來啟動服務
     </para>
    </listitem>
    <listitem>
     <para>
      依需求啟動精靈
     </para>
    </listitem>
    <listitem>
     <para>
      使用 Linux cgroup 追蹤程序
     </para>
    </listitem>
    <listitem>
     <para>
      建立快照和還原系統狀態
     </para>
    </listitem>
    <listitem>
     <para>
      維護掛接點和自動掛接點
     </para>
    </listitem>
    <listitem>
     <para>
      實作事務相關型複雜的服務控制邏輯
     </para>
    </listitem>
   </itemizedlist>

   <sect2 xml:id="sec-boot-systemd-unitfile">
   <title>單位檔案</title>
   <para>
    單位組態檔案包含有關以下項目的資訊：服務、通訊端、裝置、掛接點、自動掛接點、交換檔案或分割區、啟動目標、監控的檔案系統路徑、受 <systemitem class="daemon">systemd</systemitem> 控制和監督的計時器、暫時系統狀態快照、資源管理片段，或一組外部建立的程序。
   </para>
   <para>
    <quote>單位檔案</quote>是 <systemitem class="daemon">systemd</systemitem> 用於表示下列項目的通用術語：
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <formalpara>
      <title>服務</title>
      <para>
       程序相關資訊 (例如執行精靈)；檔案名以 .service 結尾
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>目標</title>
      <para>
       用於將單位分組以及在啟動期間用作同步點；檔案名以 .target 結尾
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>插槽</title>
      <para>
       IPC 或網路插槽或檔案系統 FIFO 的相關資訊，適用於插槽型啟動 (如 <systemitem class="daemon">inetd</systemitem>)；檔案名以 .socket 結尾
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>路徑</title>
      <para>
       用於觸發其他單位 (例如，在檔案變更時執行服務)；檔案名以 .path 結尾
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>計時器</title>
      <para>
       受控計時器的相關資訊，適用於計時器型啟動；檔案名以 .timer 結尾
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>掛接點</title>
      <para>
       通常由 fstab 產生器自動產生；檔案名以 .mount 結尾
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>自動掛接點</title>
      <para>
       檔案系統自動掛接點的相關資訊；檔案名以 .automount 結尾
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Swap</title>
      <para>
       用於記憶體分頁之交換裝置或檔案相關資訊；檔案名以 .swap 結尾
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>裝置</title>
      <para>
       sysfs/udev(7) 裝置樹中所展示之裝置的相關資訊；檔案名以 .automount 結尾
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>範圍/片段</title>
      <para>
       分階層管理程序群組之資源的概念；檔案名以 .scope/.slice 結尾
      </para>
     </formalpara>
    </listitem>
   </itemizedlist>
     
   <para>
    如需 <systemitem class="daemon">systemd</systemitem> 單位檔案的詳細資訊，請參閱 <link xlink:href="http://www.freedesktop.org/software/systemd/man/systemd.unit.html"/>
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-boot-systemd-basics">
  <title>基本用法</title>

  <para>
   System V init 系統使用若干個指令來處理服務 - init 程序檔、<command>insserv</command>、<command>telinit</command> 及其他。<systemitem class="daemon">systemd</systemitem> 可簡化服務管理，因為對於大部分處理服務的任務，只需記住一條指令：<command>systemctl</command>。它使用<quote>
指令加子指令</quote>表示法，與 <command>git</command> 或 <command>zypper</command> 相似：
  </para>

<screen>systemctl <replaceable>GENERAL OPTIONS</replaceable> <replaceable>SUBCOMMAND</replaceable> <replaceable>SUBCOMMAND OPTIONS</replaceable></screen>

  <para>
   如需完整的手冊，請參閱 <command>man 1 systemctl</command>。
  </para>

  <tip>
   <title>終端機輸出和 Bash 補齊</title>
   <para>
    如果輸出進入終端機 (而不是進入管線或檔案之類)，<systemitem class="daemon">systemd</systemitem> 指令依預設會將長輸出傳送到頁面巡覽區。使用 <option>--no-pager</option> 選項可關閉切換模式。
   </para>
   <para>
    <systemitem class="daemon">systemd</systemitem> 還支援 bash 補齊，允許您輸入子指令的頭幾個字母，然後按 <keycap function="tab"/>。此功能僅可用於 <systemitem>bash</systemitem> 外圍程序，並且需要安裝套件 <systemitem class="resource">bash-completion</systemitem>。
   </para>
  </tip>

  <sect2 xml:id="sec-boot-systemd-basics-services">
   <title>管理正在執行系統中的服務</title>
   <para>
    用於管理服務的子指令與透過 System V init 管理服務的子指令相同 (<command>start</command>、<command>stop</command>、...)。下面列出了服務管理指令的通用語法：
   </para>
   <variablelist>
    <varlistentry>
     <term><systemitem class="daemon">systemd</systemitem></term>
     <listitem>
<screen>systemctl reload|restart|start|status|stop|<replaceable>...</replaceable> <replaceable>MY_SERVICE(S)</replaceable></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>System V init</term>
     <listitem>
<screen>rc<replaceable>MY_SERVICE(S)</replaceable> reload|restart|start|status|stop|<replaceable>...</replaceable></screen>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    <systemitem class="daemon">systemd</systemitem> 可讓您一次管理多個服務。它不是像 System V init 那樣依次執行 init 程序檔，而是執行類似如下的指令：
   </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl start <replaceable>MY_1ST_SERVICE</replaceable> <replaceable>MY_2ND_SERVICE</replaceable></screen>
   <para>
    若要列出系統上所有可用的服務：
   </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl list-unit-files --type=service</screen>
   <para>
    下表列出了 <systemitem class="daemon">systemd</systemitem> 和 System V init 最重要的服務管理指令：
   </para>
   <table rowsep="1">
    <title>服務管理指令</title>
    <tgroup cols="3">
     <colspec colnum="1" colname="1" colwidth="50*"/>
     <colspec colnum="2" colname="2" colwidth="30*"/>
     <colspec colnum="3" colname="3" colwidth="20*"/>
     <thead>
      <row>
       <entry colname="1">
        <para>
         任務
        </para>
       </entry>
       <entry colname="2">
        <para>
         <systemitem class="daemon">systemd</systemitem> 指令
        </para>
       </entry>
       <entry colname="3">
        <para>
         System V init 指令
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry colname="1">
        <formalpara>
         <title>啟動</title>
         <para/>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>start</screen>
       </entry>
       <entry colname="3">
<screen>start</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>停止</title>
         <para/>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>stop</screen>
       </entry>
       <entry colname="3">
<screen>stop</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>重新啟動</title>
         <para>
          關閉服務，然後啟動這些服務。如果某項服務並未執行，則會將其啟動。
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>restart</screen>
       </entry>
       <entry colname="3">
<screen>restart</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>有條件地重新啟動</title>
         <para>
          如果服務目前正在執行中，則予以重新啟動。對於未在執行中的服務，則不執行任何動作。
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>try-restart</screen>
       </entry>
       <entry colname="3">
<screen>try-restart</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>重新載入</title>
         <para>
          指示服務重新載入它們的組態檔案，而不中斷操作。使用案例：指示 Apache 重新載入修改過的 <filename>httpd.conf</filename> 組態檔案。請注意，並非所有服務都支援重新載入。
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>reload</screen>
       </entry>
       <entry colname="3">
<screen>reload</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>重新載入或重新啟動</title>
         <para>
          如果服務支援重新載入，則重新載入服務，否則重新啟動服務。如果某項服務並未執行，則會將其啟動。
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>reload-or-restart</screen>
       </entry>
       <entry colname="3">
<screen>n/a</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>有條件地重新載入或重新啟動</title>
         <para>
          如果服務支援重新載入，則重新載入服務，否則重新啟動那些目前正在執行的服務。對於未在執行中的服務，則不執行任何動作。
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>reload-or-try-restart</screen>
       </entry>
       <entry colname="3">
<screen>n/a</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>取得詳細的狀態資訊</title>
         <para>
          列出服務狀態的相關資訊。<systemitem class="daemon">systemd</systemitem> 指令顯示詳細資料，例如描述、可執行檔、狀態、cgroup 及服務發出的最新訊息 (請參閱<xref linkend="sec-boot-systemd-basics-services-debugging"/>)。使用 System V init 顯示的詳細資料級別因服務而異。
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>status</screen>
       </entry>
       <entry colname="3">
<screen>status</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>取得簡要的狀態資訊</title>
         <para>
          顯示服務是否處於使用中狀態。
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>is-active</screen>
       </entry>
       <entry colname="3">
<screen>status</screen>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-basics-services-enabling">
   <title>永久啟用/停用服務</title>
   <para>
    上一節中提及的服務管理指令可讓您操作目前工作階段的服務。<systemitem class="daemon">systemd</systemitem> 還可讓您永久啟用或停用服務，使之可以按要求自動啟動，或者始終無法使用。此操作可以透過 YaST 或在指令行上執行。
   </para>
   <sect3 xml:id="sec-boot-systemd-basics-services-enabling-cmd">
    <title>在指令行上啟用/停用服務</title>
    <para>
     下表列出了 <systemitem class="daemon">systemd</systemitem> 和 System V init 用於啟用和停用服務的指令：
    </para>
    <important>
     <title>服務啟動</title>
     <para>
      在指令行上啟用服務時，服務不會自動啟動。系統將其排定為下一次系統啟動或執行層級/目標變更時啟動。若要在啟用服務之後立即啟動它，請明確執行 <command>systemctl start <replaceable>MY_SERVICE</replaceable></command> 或 <command>rc <replaceable>MY_SERVICE</replaceable> start</command>。
     </para>
    </important>
    <table rowsep="1">
     <title>用於啟用和停用服務的指令</title>
     <tgroup cols="3">
      <colspec colnum="1" colname="1" colwidth="32*"/>
      <colspec colnum="2" colname="2" colwidth="40*"/>
      <colspec colnum="3" colname="3" colwidth="28*"/>
      <thead>
       <row>
        <entry colname="1">
         <para>
          任務
         </para>
        </entry>
        <entry colname="2">
         <para>
          <systemitem class="daemon">systemd</systemitem> 指令
         </para>
        </entry>
        <entry colname="3">
         <para>
          System V init 指令
         </para>
        </entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry colname="1">
         <formalpara>
          <title>啟用</title>
          <para/>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl enable <replaceable>MY_SERVICE(S)</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>insserv <replaceable>MY_SERVICE(S)</replaceable></command>、<command>chkconfig -a <replaceable>MY_SERVICE(S)</replaceable></command>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>停用</title>
          <para/>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl disable <replaceable>MY_SERVICE(S)</replaceable>.service</command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>insserv -r <replaceable>MY_SERVICE(S)</replaceable></command>、<command>chkconfig -d <replaceable>MY_SERVICE(S)</replaceable></command>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>檢查</title>
          <para>
           顯示是否已啟用某個服務。
          </para>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl is-enabled <replaceable>MY_SERVICE</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>chkconfig <replaceable>MY_SERVICE</replaceable></command>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>重新啟用</title>
          <para>
           與重新啟動服務相似，此指令先停用服務，然後再啟用該服務。若要使用服務的預設值重新啟用服務，可使用此任務。
          </para>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl reenable <replaceable>MY_SERVICE</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          無
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>遮罩</title>
          <para>
           <quote>
停用</quote>某項服務之後，仍然可以手動啟動它。若要徹底停用服務，您需要予以遮罩。使用須謹慎。
          </para>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl mask <replaceable>MY_SERVICE</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          無
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>取消遮罩</title>
          <para>
           遮罩某項服務之後，惟有先將其取消遮罩，才能再次予以使用。
          </para>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl unmask <replaceable>MY_SERVICE</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          無
         </para>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-boot-systemd-boot">
  <title>系統啟動和目標管理</title>

  <para>
   啟動和關閉系統的整個程序由 <systemitem class="daemon">systemd</systemitem> 維護。依此觀點，核心可以視為背景程序，以維護所有其他程序，並根據其他程式的要求來調整 CPU 時間和硬體存取。
  </para>

  <sect2 xml:id="sec-boot-systemd-targets">
   <title>目標與執行層級的比較</title>
   <para>
    使用 System V init 時，系統將開機進入<quote>
執行層級</quote>。執行層級定義了系統的啟動方式，以及在所執行的系統中可以使用哪些服務。執行層級標有編號；最常見的執行層級是 <literal>0</literal> (關閉系統)、<literal>3</literal> (多重使用者，包含網路) 和 <literal>5</literal> (多重使用者，包含網路及顯示管理員)。
   </para>
   <para>
    <systemitem class="daemon">systemd</systemitem> 使用所謂的<quote>目標單位</quote>引入新的概念。不過，它仍然與執行層級概念完全相容。目標單位是有名稱而不是有編號的，它有多個作用。例如，目標 <systemitem>local-fs.target</systemitem> 和 <systemitem>swap.target</systemitem> 掛接本地檔案系統和交換空間。
   </para>
   <para>
    目標 <systemitem>graphical.target</systemitem> 提供包含網路和顯示管理員功能的多重使用者系統，與執行層級 5 相當。複雜的目標，例如 <systemitem>graphical.target</systemitem> 透過結合其他目標的子集用作<quote>
中繼</quote>目標。因為 <systemitem class="daemon">systemd</systemitem> 能夠組合現有目標，便於建立自訂目標，因此提供了極大的靈活性。
   </para>
   <para>
    下列清單顯示了最重要的 <systemitem class="daemon">systemd</systemitem> 目標單位。如需完整清單，請參閱 <command>man 7 systemd.special</command>。
   </para>
   <variablelist>
    <title>選取的 <systemitem class="daemon">systemd</systemitem> 目標單位</title>
    <varlistentry>
     <term><systemitem>default.target</systemitem></term>
     <listitem>
      <para>
       預設開機的目標。這並非<quote>
真實</quote>目標，而是一個符號連結，指向 <systemitem>graphic.target</systemitem> 之類的另一個目標。可透過 YaST 永久變更 (請參閱<xref linkend="sec-boot-runlevel-edit"/>)。若要為某個工作階段變更它，請在開機提示處使用核心參數 <literal>systemd.unit=<replaceable>MY_TARGET.target</replaceable></literal>。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>emergency.target</systemitem></term>
     <listitem>
      <para>
       在主控台上啟動緊急外圍程序。請僅在開機提示符處以如下格式使用它：<literal>systemd.unit=emergency.target</literal>。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>graphical.target</systemitem></term>
     <listitem>
      <para>
       啟動包含網路、多重使用者支援和顯示管理員功能的系統。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>halt.target</systemitem></term>
     <listitem>
      <para>
       關閉系統。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mail-transfer-agent.target</systemitem></term>
     <listitem>
      <para>
       啟動傳送和接收郵件所需的所有服務。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>multi-user.target</systemitem></term>
     <listitem>
      <para>
       啟動包含網路的多重使用者系統。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>reboot.target</systemitem></term>
     <listitem>
      <para>
       系統重新開機。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>rescue.target</systemitem></term>
     <listitem>
      <para>
       啟動不包含網路的單一使用者系統。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    為了保持與 System V init 執行層級系統的相容，<systemitem class="daemon">systemd</systemitem> 提供了名為 <literal>runlevel<replaceable>X</replaceable>.target</literal> 的特殊目標，對應於編號為 <replaceable>X</replaceable> 的相應執行層級。
   </para>
   <para>
    如果您要知道目前的目標，請使用指令：<command>systemctl get-default</command>
   </para>
   <table rowsep="1">
    <title>System V 執行層級和 <systemitem class="daemon">systemd</systemitem> 目標單位</title>
    <tgroup cols="3">
     <colspec colnum="1" colname="1" colwidth="20*"/>
     <colspec colnum="2" colname="2" colwidth="40*"/>
     <colspec colnum="3" colname="3" colwidth="40*"/>
     <thead>
      <row>
       <entry>
        <para>
         System V 執行層級
        </para>
       </entry>
       <entry>
        <para>
         <systemitem class="daemon">systemd</systemitem> 目標
        </para>
       </entry>
       <entry>
        <para>
         用途
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         0
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel0.target</systemitem>、&#x200b;<systemitem>halt.target</systemitem>、&#x200b;<systemitem>poweroff.target</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         關閉系統
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         1、S
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel1.target</systemitem>、&#x200b;<systemitem>rescue.target</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         單一使用者模式
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         2
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel2.target</systemitem>、<systemitem>multi-user.target</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         本地多重使用者，不包含遠端網路
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         3
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel3.target</systemitem>、<systemitem>multi-user.target</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         完整的多重使用者，包含網路
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         4
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel4.target</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         未使用/使用者定義
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         5
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel5.target</systemitem>、&#x200b;<systemitem>graphical.target</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         完整的多重使用者，包含網路及顯示管理員
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         6
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel6.target</systemitem>、&#x200b;<systemitem>reboot.target</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         系統重新開機
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <important>
    <title><systemitem class="daemon">systemd</systemitem> 會忽略 <filename>/etc/inittab</filename></title>
    <para>
     System V init 系統中的執行層級在 <filename>/etc/inittab</filename> 中設定。<systemitem class="daemon">systemd</systemitem> <emphasis>不</emphasis>使用此組態。如需如何建立您自己的可開機目標的指示，請參閱<xref linkend="sec-boot-systemd-custom-targets"/>。
    </para>
   </important>
   <sect3 xml:id="sec-boot-systemd-targets-commands">
    <title>用於變更目標的指令</title>
    <para>
     請使用下列指令來操作目標單位：
    </para>
    <informaltable rowsep="1">
     <tgroup cols="3">
      <colspec colnum="1" colname="1" colwidth="20*"/>
      <colspec colnum="2" colname="2" colwidth="50*"/>
      <colspec colnum="3" colname="3" colwidth="30*"/>
      <thead>
       <row>
        <entry colname="1">
         <para>
          任務
         </para>
        </entry>
        <entry colname="2">
         <para>
          <systemitem class="daemon">systemd</systemitem> 指令
         </para>
        </entry>
        <entry colname="3">
         <para>
          System V init 指令
         </para>
        </entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry colname="1">
         <para>
          變更目前的目標/執行層級
         </para>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl isolate</command> <replaceable>MY_TARGET</replaceable>.target
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>telinit</command> <replaceable> X</replaceable>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          變更為預設目標/執行層級
         </para>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl default</command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          無
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          取得目前的目標/執行層級
         </para>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl list-units --type=target</command>
         </para>
         <para>
          對於 <systemitem class="daemon">systemd</systemitem>，通常會有多個作用中目標。該指令列出目前處於使用中狀態的所有目標。
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>who -r</command>
         </para>
         <para>
          或
         </para>
         <para>
          <command>runlevel</command>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          永久性變更預設的執行層級
         </para>
        </entry>
        <entry colname="2">
         <para>
          使用服務管理員或執行下列指令：
         </para>
         <para>
          <command>ln -sf /usr/lib/systemd/system/</command> <replaceable>MY_TARGET</replaceable>.target /etc/systemd/system/default.target
         </para>
        </entry>
        <entry colname="3">
         <para>
          使用服務管理員或變更以下行
         </para>
         <para>
          <command>id:</command> <replaceable>X</replaceable>:initdefault:
         </para>
         <para>
          (位於 <filename>/etc/inittab</filename> 中)
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          變更目前開機程序的預設執行層級
         </para>
        </entry>
        <entry colname="2">
         <para>
          在開機提示的選項中輸入下列文字：
         </para>
         <para>
          <command>systemd.unit=</command> <replaceable>MY_TARGET</replaceable>.target
         </para>
        </entry>
        <entry colname="3">
         <para>
          在開機提示中輸入所需的執行層級編號。
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          顯示目標/執行層級的相依性
         </para>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl show -p &quot;Requires&quot;</command> <replaceable>MY_TARGET</replaceable>.target
         </para>
         <para>
          <command>systemctl show -p &quot;Wants&quot;</command> <replaceable>MY_TARGET</replaceable>.target
         </para>
         <para>
          <quote>Requires</quote> 會列出硬相依性 (必須解析的相依性)，而 <quote>Wants</quote> 則列出軟相依性 (可行時解析的相依性)。
         </para>
        </entry>
        <entry colname="3">
         <para>
          無
         </para>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-debug">
   <title>系統啟動除錯</title>
   <para>
    <systemitem class="daemon">systemd</systemitem> 針對系統啟動過程提供了分析方法。您可以查看所有服務及其狀態的清單 (而不必剖析 <filename>/var/log/</filename>)。<systemitem class="daemon">systemd</systemitem> 還允許您掃描啟動程序，以瞭解每項服務耗費多長時間啟動。
   </para>
   <sect3 xml:id="sec-boot-systemd-debug-review">
    <title>檢視服務的啟動情況</title>
    <para>
     若要檢閱自從系統開機以來已啟動的完整服務清單，請輸入指令 <command>systemctl</command>。這將列出所有使用中的服務，如下方所述 (已縮短)。若要獲得特定服務的詳細資訊，請使用 <command>systemctl status <replaceable>MY_SERVICE</replaceable></command>。
    </para>
    <example>
     <title>列出作用中的服務</title>
<screen><prompt role="root"># </prompt>systemctl
UNIT                        LOAD   ACTIVE SUB       JOB DESCRIPTION
[...]
iscsi.service               loaded active exited    Login and scanning of iSC+
kmod-static-nodes.service   loaded active exited    Create list of required s+
libvirtd.service            loaded active running   Virtualization daemon
nscd.service                loaded active running   Name Service Cache Daemon
chronyd.service             loaded active running   NTP Server Daemon
polkit.service              loaded active running   Authorization Manager
postfix.service             loaded active running   Postfix Mail Transport Ag+
rc-local.service            loaded active exited    /etc/init.d/boot.local Co+
rsyslog.service             loaded active running   System Logging Service
[...]
LOAD   = Reflects whether the unit definition was properly loaded.
ACTIVE = The high-level unit activation state, i.e. generalization of SUB.
SUB    = The low-level unit activation state, values depend on unit type.

161 loaded units listed. Pass --all to see loaded but inactive units, too.
To show all installed unit files use 'systemctl list-unit-files'.</screen>
    </example>
    <para>
     若要限制為輸出無法啟動的服務，請使用 <option>--failed</option> 選項：
    </para>
    <example>
     <title>列出失敗的服務</title>
<screen><prompt role="root"># </prompt>systemctl --failed
UNIT                   LOAD   ACTIVE SUB    JOB DESCRIPTION
apache2.service        loaded failed failed     apache
NetworkManager.service loaded failed failed     Network Manager
plymouth-start.service loaded failed failed     Show Plymouth Boot Screen

[...]</screen>
    </example>
   </sect3>
   <sect3 xml:id="sec-boot-systemd-debug-time">
    <title>啟動時間除錯</title>
    <para>
     為了對系統啟動時間除錯，<systemitem class="daemon">systemd</systemitem> 提供了 <command>systemd-analyze</command> 指令。它會顯示總啟動時間以及按啟動時間排序的服務清單，還可以產生 SVG 圖，其中顯示各服務相對於其他服務所耗費的啟動時間。
    </para>
    <variablelist>
     <varlistentry>
      <term>列出系統啟動時間</term>
      <listitem>
<screen><prompt role="root"># </prompt>systemd-analyze
Startup finished in 2666ms (kernel) + 21961ms (userspace) = 24628ms</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>列出服務啟動時間</term>
      <listitem>
<screen><prompt role="root"># </prompt>systemd-analyze blame
    15.000s backup-rpmdb.service
    14.879s mandb.service
     7.646s backup-sysconfig.service
     4.940s postfix.service
     4.921s logrotate.service
     4.640s libvirtd.service
     4.519s display-manager.service
     3.921s btrfsmaintenance-refresh.service
     3.466s lvm2-monitor.service
     2.774s plymouth-quit-wait.service
     2.591s firewalld.service
     2.137s initrd-switch-root.service
     1.954s ModemManager.service
     1.528s rsyslog.service
     1.378s apparmor.service
    [...]
</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>服務啟動時間圖</term>
      <listitem>
<screen><prompt role="root"># </prompt>systemd-analyze plot &gt; jupiter.example.com-startup.svg</screen>
       <informalfigure>
        <mediaobject>
         <imageobject role="fo">
          <imagedata fileref="systemd_startup.svg" width="75%"/>
         </imageobject>
         <imageobject role="html">
          <imagedata fileref="systemd_startup.png" width="75%"/>
         </imageobject>
        </mediaobject>
       </informalfigure>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3 xml:id="sec-boot-systemd-debug-complete">
    <title>檢視完整的啟動程序</title>
    <para>
     上面的指令行出了已啟動的服務及其啟動時間。如需更詳細的綜覽，請在開機提示符處指定以下參數，以指示 <systemitem class="daemon">systemd</systemitem> 建立完整啟動程序的詳細記錄。
    </para>
<screen>systemd.log_level=debug systemd.log_target=kmsg</screen>
    <para>
     現在，<systemitem class="daemon">systemd</systemitem> 會將記錄訊息寫入核心環緩衝區。該緩衝區可透過 <command>dmesg</command> 檢視：
    </para>
<screen><prompt>&gt; </prompt>dmesg -T | less</screen>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-sysv-compatibility">
   <title>System V 相容性</title>
   <para>
    <systemitem class="daemon">systemd</systemitem> 與 System V 相容，因此，您仍可以使用現有的 System V init 程序檔。但是，至少有一個已知問題會導致 System V init 程序檔不能立即與 <systemitem class="daemon">systemd</systemitem> 配合使用：透過 init 程序檔中的 <command>su</command> 或 <command>sudo</command> 以其他使用者身分啟動服務會導致程序檔失敗，產生<quote>拒絕存取</quote>錯誤。
   </para>
   <para>
    使用 <command>su</command> 或 <command>sudo</command> 變更使用者時，會啟動 PAM 工作階段。完成 init 程序檔後會終止此工作階段。因此，init 程序檔啟動的服務也會終止。若要解決此問題，請執行下列步驟：
   </para>
   <procedure>
    <step>
     <para>
      建立與 init 程序檔同名、副檔名為 <filename>.service</filename> 的服務檔案包裝程式。
     </para>
<screen>[Unit]
Description=<replaceable>DESCRIPTION</replaceable>
After=network.target

[Service]
User=<replaceable>USER</replaceable>
Type=forking<co xml:id="co-service-wrapper-type"/>
PIDFile=<replaceable>PATH TO PID FILE</replaceable><xref linkend="co-service-wrapper-type" xrefstyle="select:label nopage"/>
ExecStart=<replaceable>PATH TO INIT SCRIPT</replaceable> start
ExecStop=<replaceable>PATH TO INIT SCRIPT</replaceable> stop
ExecStopPost=/usr/bin/rm -f <replaceable>PATH TO PID FILE</replaceable><xref linkend="co-service-wrapper-type" xrefstyle="select:label nopage"/>

[Install]
WantedBy=multi-user.target<co xml:id="co-service-wrapper-target"/></screen>
     <para>
      以適當的值取代 <replaceable>UPPERCASE LETTERS</replaceable> 中寫入的所有值。
     </para>
     <calloutlist>
      <callout arearefs="co-service-wrapper-type">
       <para>
        選擇性 — 僅當 init 程序檔啟動精靈時才使用。
       </para>
      </callout>
      <callout arearefs="co-service-wrapper-target">
       <para>
        <literal>multi-user.target</literal> 在開機到 <literal>graphical.target</literal> 時也會啟動 init 程序檔。如果只應在開機到顯示管理員時才將它啟動，請在此處使用 <literal>graphical.target</literal>。
       </para>
      </callout>
     </calloutlist>
    </step>
    <step>
     <para>
      使用 <command>systemctl start <replaceable>應用程式</replaceable></command>啟動精靈。
     </para>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-boot-runlevel-edit">
  <title>使用 YaST 管理服務</title>

  <para>
   基本服務管理也可以透過 YaST 服務管理員模組實現。該模組不僅支援啟動、停止、啟用和停用服務，還可用於顯示服務的狀態以及變更預設目標。若要啟動 YaST 模組，請選取<menuchoice> <guimenu>YaST</guimenu> <guimenu> 系統</guimenu> <guimenu> 服務管理員</guimenu> </menuchoice>。
  </para>

  <figure xml:id="fig-yast2-runlevel">
   <title>服務管理員</title>
   <mediaobject>
    <imageobject role="fo">
     <imagedata fileref="yast2_runlevel.png" width="75%"/>
    </imageobject>
    <imageobject role="html">
     <imagedata fileref="yast2_runlevel.png" width="75%"/>
    </imageobject>
   </mediaobject>
  </figure>

  <variablelist>
   <varlistentry>
    <term>變更<guimenu>預設系統目標</guimenu></term>
    <listitem>
     <para>
      若要變更系統開機進入的目標，請從<guimenu>預設系統目標</guimenu>下拉方塊中選擇目標。最常用的目標是<guimenu>圖形介面</guimenu> (啟動圖形登入畫面) 和<guimenu>多重使用者</guimenu> (以指令行模式啟動系統)。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>啟動或停止服務</term>
    <listitem>
     <para>
      從表中選取服務。<guimenu>狀態</guimenu>欄顯示它目前是正在執行 (<guimenu>作用中</guimenu>) 還是未在執行 (<guimenu>非作用中</guimenu>)。透過選擇<guimenu>啟動</guimenu>或<guimenu>停止</guimenu>可切換其狀態。
     </para>
     <para>
      如果啟動或停止服務，會變更其對目前執行中工作階段而言的狀態。若要在整個重新開機期間變更服務的狀態，您需要啟用或停用服務。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>定義服務啟動行為</term>
    <listitem>
     <para>
      服務可以在開機時自動啟動，也可以手動啟動。從表中選取服務。<guimenu>啟動</guimenu>欄顯示它目前是<guimenu>手動</guimenu>啟動還是<guimenu>開機時</guimenu>啟動。透過選擇<guimenu>啟動模式</guimenu>可切換其狀態。
     </para>
     <para>
      若要在目前工作階段中變更服務狀態，您需要依據上述方式啟動或停止服務。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>檢視狀態訊息</term>
    <listitem>
     <para>
      若要檢視服務的狀態訊息，請從清單中選取該服務，然後選擇<guimenu>
顯示詳細資料</guimenu>。您看到的輸出與 <command>systemctl </command> <option>-l</option> status <replaceable>MY_SERVICE</replaceable> 指令產生的輸出完全相同。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 xml:id="sec-boot-systemd-custom">
  <title>自定 <systemitem>systemd</systemitem></title>

  <para>
   下列各節列出了 <systemitem>systemd</systemitem> 自訂的一些範例。
  </para>

  <warning>
   <title>防止您的自訂被覆寫</title>
   <para>
    在自訂 <systemitem class="daemon">systemd</systemitem> 時，請務必使用目錄 <filename>/etc/systemd/</filename>，<emphasis>切勿</emphasis>使用 <filename>/usr/lib/systemd/</filename>。否則，<systemitem class="daemon">systemd</systemitem> 下次更新時會覆寫您的變更。
   </para>
  </warning>

  <sect2 xml:id="sec-boot-systemd-custom-service">
   <title>自訂單位檔案</title>
   <para>
    建議使用 <command>systemctl edit <replaceable>SERVICE</replaceable></command> 指令來自訂單位檔案。此指令會啟動預設的文字編輯器，並建立一個在 <filename>/etc/systemd/system/<replaceable>NAME</replaceable>.service.d/</filename> 中包含 <filename>override.conf</filename> 檔案的目錄。該指令還確定會向正在執行的 <systemitem class="daemon">systemd</systemitem> 程序通知這些變更。
   </para>
   <para>
    或者，您可以透過執行 <command>systemctl edit --full <replaceable>SERVICE</replaceable></command> 來開啟原始檔案的副本進行編輯，而不是開啟一個空白檔案。編輯檔案時，請確定未移除任何現有區段。
   </para>
   <para>
    下面將練習如何變更系統等待 MariaDB 啟動的時間。以 root 身分執行 <command>systemctl edit --full mariadb.service</command>。開啟的檔案如下所示：
   </para>
<screen>
[Unit]
Description=MySQL server
Wants=basic.target
Conflicts=mariadb.target
After=basic.target network.target

[Install]
WantedBy=multi-user.target
Alias=mysql.service

[Service]
Restart=on-abort
Type=notify
ExecStartPre=/usr/lib/mysql/mysql-systemd-helper  install
ExecStartPre=/usr/lib/mysql/mysql-systemd-helper  upgrade
ExecStart=/usr/lib/mysql/mysql-systemd-helper     start

# Configures the time to wait for start-up/stop
TimeoutSec=300

# Prevent writes to /usr, /boot, and /etc
ProtectSystem=full

# Prevent accessing /home, /root and /run/user
ProtectHome=true

UMask=007</screen>
   <para>
    調整 <literal>TimeoutSec</literal> 值並儲存變更。若要啟用變更，請以 root 身分執行 <command>systemctl daemon-reload</command>。
   </para>
   <para>
    如需詳細資訊，請參閱可使用 <command>man 1 systemctl</command> 指令呼叫的 man 頁面。
   </para>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-custom-drop-in">
   <title>建立放入式檔案</title>
   <para>
    若要對組態檔案進行微小變更，請使用所謂的放入式檔案。放入式檔案可讓您延伸單位檔案的組態，而不必編輯或覆寫單位檔案本身。
   </para>
   <para>
    例如，若要變更位於 <filename>/usr/lib/systemd/system/<replaceable>FOOBAR.SERVICE</replaceable></filename> 中 <replaceable>FOOBAR</replaceable> 服務的單個值，請依照以下步驟操作：
   </para>
   <procedure>
    <step>
     <para>
      建立名為 <filename>/etc/systemd/system/<replaceable>FOOBAR</replaceable>.service.d/</filename> 的目錄。
     </para>
     <para>
      注意字尾為 <literal>.d</literal>。該目錄必須命名為要透過所放入之檔案修補的服務。
     </para>
    </step>
    <step>
     <para>
      在該目錄中，建立 <filename><replaceable>your_modification</replaceable>.conf</filename> 檔案。
     </para>
     <para>
      確保該檔案僅包含待修改值所在的行。
     </para>
    </step>
    <step>
     <para>
      將您所做的變更儲存到檔案中。
     </para>
    </step>
   </procedure>
   
   <note>
    <title>避免名稱衝突</title>
    <para>
    為避免插入式檔案與 SUSE 隨附的檔案之間出現名稱衝突，建議在所有插入式檔案名稱前加上一個兩位數和一個破折號：例如，<filename>80-override.conf</filename>。
    </para>
    <para>
     以下範圍為保留值範圍：
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <literal>0-19</literal>，為 <systemitem class="daemon">systemd</systemitem> 上游保留
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>20-25</literal>，為 SUSE 隨附的 <systemitem class="daemon">systemd</systemitem> 保留
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>26-29</literal>，為 SUSE 套件 (systemd 除外) 保留
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>50</literal>，為使用 <command>systemctl set-property</command> 建立的放入式檔案保留
      </para>
     </listitem>
    </itemizedlist>
    <para>
    請使用大於此範圍的兩位數，以確定 SUSE 隨附的任何放入式檔案都不會覆寫您自己的放入式檔案。
    </para>
    <para>
    您可以使用 <command>systemctl cat $UNIT</command> 來列出並驗證考慮將哪些檔案納入單位組態。
    </para>
   </note>
  </sect2>

  <sect2 xml:id="systemd-xinetd-conversion">
   <title>將 <systemitem>xinetd</systemitem> 服務轉換為 <systemitem class="daemon">systemd</systemitem></title>
   <para>
    從 <phrase role="productname"><phrase os="sled">SUSE Linux Enterprise Desktop</phrase></phrase> 15 版本開始，移除了 <systemitem>xinetd</systemitem> 基礎架構。本節概述如何將現有的自訂 <systemitem>xinetd</systemitem> 服務檔案轉換為 <systemitem class="daemon">systemd</systemitem> 通訊端。
   </para>
   <para>
    對於每個 <systemitem>xinetd</systemitem> 服務檔案，您至少需要兩個 <systemitem class="daemon">systemd</systemitem> 單位檔案：通訊端檔案 (<filename>*.socket</filename>) 和關聯的服務檔案 (<filename>*.service</filename>)。通訊端檔案告訴 <systemitem class="daemon">systemd</systemitem> 要建立哪個通訊端，服務檔案告訴 <systemitem class="daemon">systemd</systemitem> 要啟動哪個可執行檔。
   </para>
   <para>
    以下面的 <systemitem>xinetd</systemitem> 服務檔案為例：
   </para>
<screen><prompt role="root"># </prompt>cat /etc/xinetd.d/example
service example
{
  socket_type = stream
  protocol = tcp
  port = 10085
  wait = no
  user = user
  group = users
  groups = yes
  server = /usr/libexec/example/exampled
  server_args = -auth=bsdtcp exampledump
  disable = no
}</screen>
   <para>
    若要將它轉換為 <systemitem class="daemon">systemd</systemitem>，需要下面兩個相配的檔案：
   </para>
<screen><prompt role="root"># </prompt>cat /usr/lib/systemd/system/example.socket
[Socket]
ListenStream=0.0.0.0:10085
Accept=false

[Install]
WantedBy=sockets.target</screen>
<screen><prompt role="root"># </prompt>cat /usr/lib/systemd/system/example.service
[Unit]
Description=example

[Service]
ExecStart=/usr/libexec/example/exampled -auth=bsdtcp exampledump
User=user
Group=users
StandardInput=socket
</screen>
   <para>
    如需 <systemitem class="daemon">systemd</systemitem> 的「通訊端」和「服務」檔案選項的完整清單，請參閱 systemd.socket 和 systemd.service 手冊頁 (<command>man 5 systemd.socket</command>、<command>man 5 systemd.service</command>)。
   </para>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-custom-targets">
   <title>建立自訂目標</title>
   <para>
    在 System V init SUSE 系統上並未使用執行層級 4，便於管理員自行建立執行層級組態。<systemitem class="daemon">systemd</systemitem> 可讓您建立任意個自訂目標。建議您在開始時先在 <systemitem>graphical.target</systemitem> 等現有的目標上調整。
   </para>
   <procedure>
    <step>
     <para>
      將組態檔案 <filename>/usr/lib/systemd/system/graphical.target</filename> 複製到 <filename>/etc/systemd/system/<replaceable>MY_TARGET</replaceable>.target</filename>，並依據需要調整該檔案。
     </para>
    </step>
    <step>
     <para>
      上一步中複製的組態檔案已涵蓋該目標的必要的 (<quote>
硬</quote>) 相依性。若要一併納入需要的 (<quote>軟</quote>) 相依項，請建立目錄 <filename>/etc/systemd/system/<replaceable>MY_TARGET</replaceable>.target.wants</filename>。
     </para>
    </step>
    <step>
     <para>
      對每個需要的服務，建立從 <filename>/usr/lib/systemd/system</filename> 連到 <filename>/etc/systemd/system/<replaceable>MY_TARGET</replaceable>.target.wants</filename> 的符號連結。
     </para>
    </step>
    <step>
     <para>
      設定好目標後，重新載入 <systemitem class="daemon">systemd</systemitem> 組態以使新目標可用：
     </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl daemon-reload</screen>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-boot-systemd-advanced">
  <title>進階用法</title>

  <para>
   下列各節涵蓋進階主題，適用於系統管理員。如需更為進階的 <systemitem class="daemon">systemd</systemitem> 文件，請參閱 Lennart Pöttering 撰寫的適用於管理員的 <systemitem class="daemon">systemd</systemitem> 相關系列文章，網址為 <link xlink:href="http://0pointer.de/blog/projects"/>。
  </para>

  <sect2 xml:id="sec-boot-systemd-advanced-tmp">
   <title>清理暫存目錄</title>
   <para>
    <systemitem class="daemon">systemd</systemitem> 支援定期清理暫存目錄。將會自動移轉並啟用前一系統版本中的組態。<literal>tmpfiles.d</literal> (負責管理暫存檔案) 將從 <filename>/etc/tmpfiles.d/*.conf</filename>、<filename>/run/tmpfiles.d/*.conf</filename> 和 <filename>/usr/lib/tmpfiles.d/*.conf</filename> 檔案中讀取其組態。<filename>/etc/tmpfiles.d/*.conf</filename> 中的組態將會覆寫其他兩個目錄中的相關組態 (<filename>/usr/lib/tmpfiles.d/*.conf</filename> 是套件將其組態檔案儲存到的位置)。
   </para>
   <para>
    組態格式為每個路徑一行，該行包含動作與路徑、(選擇性) 模式、擁有權、期限和引數欄位，具體視動作而定。以下範例將取消連結 X11 鎖定檔案：
   </para>
<screen>Type Path               Mode UID  GID  Age Argument
r    /tmp/.X[0-9]*-lock</screen>
   <para>
    若要取得 tmpfile 計時器的狀態：
   </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl status systemd-tmpfiles-clean.timer
systemd-tmpfiles-clean.timer - Daily Cleanup of Temporary Directories
 Loaded: loaded (/usr/lib/systemd/system/systemd-tmpfiles-clean.timer; static)
 Active: active (waiting) since Tue 2018-04-09 15:30:36 CEST; 1 weeks 6 days ago
   Docs: man:tmpfiles.d(5)
         man:systemd-tmpfiles(8)

Apr 09 15:30:36 jupiter systemd[1]: Starting Daily Cleanup of Temporary Directories.
Apr 09 15:30:36 jupiter systemd[1]: Started Daily Cleanup of Temporary Directories.</screen>
   <para>
    如需處理暫存檔案的詳細資訊，請參閱 <command>man 5 tmpfiles.d</command>。
   </para>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-advanced-logging">
   <title>系統記錄</title>
   <para>
    <xref linkend="sec-boot-systemd-basics-services-debugging"/>說明如何檢視給定服務的記錄訊息。然而，記錄的訊息顯示並不局限為服務記錄。您還可以存取和查詢 <systemitem class="daemon">systemd</systemitem> 寫入的完整記錄訊息 — 亦即<quote>日誌</quote>。使用 <command>journalctl</command> 指令可顯示從最舊項目開始的完整記錄訊息。如需套用過濾器或變更輸出格式等選項的資訊，請參閱 <command>man 1 journalctl</command>。
   </para>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-advanced-snapshots">
   <title>快照</title>
   <para>
    您可以使用 <command>isolate</command> 子指令將 <systemitem class="daemon">systemd</systemitem> 的目前狀態儲存到指定的快照，日後可以回復到該狀態。此功能在測試服務或自訂目標時非常有用，因為它允許您隨時回到定義的狀態。快照僅在目前工作階段中可用，重新開機時將自動刪除。快照名稱必須以 <filename>.snapshot</filename> 結尾。
   </para>
   <variablelist>
    <varlistentry>
     <term>建立快照</term>
     <listitem>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl snapshot <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>刪除快照</term>
     <listitem>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl delete <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>檢視快照</term>
     <listitem>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl show <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>啟用快照</term>
     <listitem>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl isolate <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  

  

  <sect2 xml:id="sec-boot-systemd-advanced-kernel-modules">
   <title>載入核心模組</title>
   <para>
    使用 <systemitem class="daemon">systemd</systemitem>，可透過 <filename>/etc/modules-load.d</filename> 中的組態檔案，在開機時自動載入核心模組。該檔案應命名為 <replaceable>MODULE</replaceable>.conf 並包含以下內容：
   </para>
<screen># load module <replaceable>MODULE</replaceable> at boot time
<replaceable>MODULE</replaceable></screen>
   <para>
    如果某個套件安裝了用於載入核心模組的組態檔案，該檔案將安裝到 <filename>/usr/lib/modules-load.d</filename>。如果存在兩個同名的組態檔案，將優先使用 <filename>/etc/modules-load.d</filename> 中的組態檔案。
   </para>
   <para>
    如需詳細資訊，請參閱 <systemitem>modules-load.d(5)</systemitem> 的 man 頁面。
   </para>
  </sect2>

  

  <sect2 xml:id="sec-boot-systemd-advanced-before-local">
   <title>載入服務之前執行動作</title>
   <para>
    使用 System V 時，需要在載入服務之前執行的 init 動作必須在 <filename>/etc/init.d/before.local</filename> 中指定。<systemitem class="daemon">systemd</systemitem> 不再支援此程序。如果您需要在啟動服務之前執行動作，請執行以下步驟：
   </para>
   <variablelist>
    <varlistentry>
     <term>載入核心模組</term>
     <listitem>
      <para>
       在 <filename>/etc/modules-load.d</filename> 目錄中建立一個 drop-in 檔案 (如需語法，請參閱 <command>man modules-load.d</command>)
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>建立檔案或目錄，清理目錄，變更擁有權</term>
     <listitem>
      <para>
       在 <filename>/etc/tmpfiles.d</filename> 中建立一個 drop-in 檔案 (如需語法，請參閱 <command>man tmpfiles.d</command>)
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>其他任務</term>
     <listitem>
      <para>
       從以下範本建立一個系統服務檔案，例如 <filename>/etc/systemd/system/before.service</filename>：
      </para>
<screen>[Unit]
Before=<replaceable>NAME OF THE SERVICE YOU WANT THIS SERVICE TO BE STARTED BEFORE</replaceable>
[Service]
Type=oneshot
RemainAfterExit=true
ExecStart=<replaceable>YOUR_COMMAND</replaceable>
# beware, executable is run directly, not through a shell, check the man pages
# systemd.service and systemd.unit for full syntax
[Install]
# target in which to start the service
WantedBy=multi-user.target
#WantedBy=graphical.target</screen>
      <para>
       建立服務檔案後，應執行以下指令 (以 <systemitem class="username">root</systemitem> 身分)：
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl daemon-reload
<prompt>&gt; </prompt><command>sudo</command> systemctl enable before</screen>
      <para>
       每次修改服務檔案時，都需要執行：
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl daemon-reload</screen>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  

  <sect2 xml:id="sec-boot-systemd-advanced-cgroups">
   <title>核心控制群組 (cgroup)</title>
   <para>
    在傳統 System V init 系統上不一定能將程序明確指派給繁衍它的服務。有些服務 (例如 Apache) 會繁衍許多協力廠商程序 (例如 CGI 或 Java 程序)，這些程序本身又會繁衍許多程序。這導致您很難明確指派，甚至根本無法明確指派。另外，服務在不當終止後，可能殘留部分子項保持活動狀態。
   </para>
   <para>
    <systemitem class="daemon">systemd</systemitem> 將每個服務放入它自己的 cgroup 中，從而解決此問題。cgroup 是一項核心功能，允許將程序及其所有子程序聚合至分層組織的群組中。<systemitem class="daemon">systemd</systemitem> 根據相應的服務為每個 cgroup 命名。由於程序未經特許不得<quote>離開</quote>其 cgroup，因此這樣可以有效地使用服務名稱標記該服務繁衍的所有程序。
   </para>
   <para>
    若要列出屬於服務的所有程序，請使用指令 <command>systemd-cgls</command>。結果類似於以下範例 (已縮短)：
   </para>
   <example>
    <title>列出屬於某個服務的所有程序</title>
<screen><prompt role="root"># </prompt>systemd-cgls --no-pager
├─1 /usr/lib/systemd/systemd --switched-root --system --deserialize 20
├─user.slice
│ └─user-1000.slice
│   ├─session-102.scope
│   │ ├─12426 gdm-session-worker [pam/gdm-password]
│   │ ├─15831 gdm-session-worker [pam/gdm-password]
│   │ ├─15839 gdm-session-worker [pam/gdm-password]
│   │ ├─15858 /usr/lib/gnome-terminal-server

[...]

└─system.slice
  ├─systemd-hostnamed.service
  │ └─17616 /usr/lib/systemd/systemd-hostnamed
  ├─cron.service
  │ └─1689 /usr/sbin/cron -n
  ├─postfix.service
  │ ├─ 1676 /usr/lib/postfix/master -w
  │ ├─ 1679 qmgr -l -t fifo -u
  │ └─15590 pickup -l -t fifo -u
  ├─sshd.service
  │ └─1436 /usr/sbin/sshd -D

[...]</screen>
   </example>
   <para>
    如需 cgroup 的詳細資訊，請參閱<xref linkend="cha-tuning-cgroups"/>。
   </para>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-advanced-kill">
   <title>終止服務 (傳送訊號)</title>
   <para>
    如<xref linkend="sec-boot-systemd-advanced-cgroups"/>中所述，在 System V init 系統中不一定能將程序指派給其父服務，導致難以終止服務及其所有子項。未終止的子程序將保留為廢止程序。
   </para>
   <para>
    <systemitem class="daemon">systemd</systemitem> 的概念是將每個服務限制在某個 cgroup 中，從而可以明確識別一個服務的所有子程序，因此可讓您將訊號傳送給這些程序中的每個程序。可使用 <command>systemctl kill</command> 將信號傳送給服務。如需可用信號清單，請參閱 <command>man 7 signals</command>。
   </para>
   <variablelist>
    <varlistentry>
     <term>將 <systemitem>SIGTERM</systemitem> 傳送給服務</term>
     <listitem>
      <para>
       <systemitem>SIGTERM</systemitem> 是傳送的預設信號。
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl kill <replaceable>MY_SERVICE</replaceable></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>將 <replaceable>SIGNAL</replaceable> 傳送給服務</term>
     <listitem>
      <para>
       可使用 <option>-s</option> 選項指定應傳送的信號。
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl kill -s <replaceable>SIGNAL</replaceable> <replaceable>MY_SERVICE</replaceable></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>選取程序</term>
     <listitem>
      <para>
       依預設，<command>kill</command> 指令會將信號傳送給指定 cgroup 的 <option>all</option> 程序。您可以將傳送目標限制為 <option>control</option> 或 <option>main</option> 程序。後者非常實用，如下例透過傳送 <systemitem>SIGHUP</systemitem> 強制服務重新載入其組態所示：
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl kill -s SIGHUP --kill-who=main <replaceable>MY_SERVICE</replaceable></screen>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-dbus">
   <title>有關 D-Bus 服務的重要說明</title>
   <para>
    D-Bus 服務是 <systemitem class="daemon">systemd</systemitem> 用戶端與做為 pid 1 執行的 systemd 管理員之間進行通訊的訊息匯流排。雖然 <systemitem class="daemon">dbus</systemitem> 是個獨立的精靈，但它也是 init 基礎架構的組成部分。
   </para>
   <para>
    在執行中的系統中終止或重新啟動 <systemitem class="daemon">dbus</systemitem> 的效果類似於嘗試終止或重新啟動 pid 1。此操作將中斷 <systemitem class="daemon">systemd</systemitem> 用戶端與伺服器間的通訊，並使大部分 <systemitem class="daemon">systemd</systemitem> 功能不可用。
   </para>
   <para>
    因此，不建議也不支援終止或重新啟動 <systemitem class="daemon">dbus</systemitem>。
   </para>
   <para>
    更新 <systemitem>dbus</systemitem> 或與 <systemitem>dbus</systemitem> 有關的套件需要重新開機。如果不確定是否需要重新開機，請執行 <command>sudo zypper ps -s</command>。如果 <literal>dbus</literal> 顯示在所列服務之中，則表明您需要將系統重新開機。
   </para>
   <para>
    請記住，即使自動更新設定為跳過需要重新開機的套件，<systemitem>dbus</systemitem> 仍會更新。
   </para>
  </sect2>

  

  <sect2 xml:id="sec-boot-systemd-basics-services-debugging">
   <title>服務除錯</title>
   <para>
    依預設，<systemitem class="daemon">systemd</systemitem> 的輸出不會太詳細。如果服務啟動成功，則不會產生任何輸出。如果啟動失敗，則會顯示簡短的錯誤訊息。不過，<command>systemctl status</command> 可讓您以不同方式對服務的啟動和作業進行除錯。
   </para>
   <para>
    <systemitem class="daemon">systemd</systemitem> 隨附自己的記錄機製 (<quote>日誌</quote>)，可以記錄系統訊息，便於您一併顯示服務訊息與狀態訊息。<command>status</command> 指令的工作方式與 <command>tail</command> 相似，也可以採用不同的格式顯示記錄訊息，因此成為功能強大的除錯工具。
   </para>
   <variablelist>
    <varlistentry>
     <term>顯示服務啟動失敗訊息</term>
     <listitem>
      <para>
       每當服務啟動失敗時，使用 <command>systemctl status <replaceable>MY_SERVICE</replaceable></command> 可獲得詳細的錯誤訊息：
      </para>
<screen><prompt role="root"># </prompt>systemctl start apache2
Job failed. See system journal and 'systemctl status' for details.
<prompt role="root"># </prompt>systemctl status apache2
   Loaded: loaded (/usr/lib/systemd/system/apache2.service; disabled)
   Active: failed (Result: exit-code) since Mon, 04 Apr 2018 16:52:26 +0200; 29s ago
   Process: 3088 ExecStart=/usr/sbin/start_apache2 -D SYSTEMD -k start (code=exited, status=1/FAILURE)
   CGroup: name=systemd:/system/apache2.service

Apr 04 16:52:26 g144 start_apache2[3088]: httpd2-prefork: Syntax error on line
205 of /etc/apache2/httpd.conf: Syntax error on li...alHost&gt;</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>顯示最後 <replaceable>N</replaceable> 條服務訊息</term>
     <listitem>
      <para>
       <command>status</command> 子指令的預設行為是顯示服務發出的最近 10 條訊息。若要變更要顯示的訊息數，請使用 <option>--lines=<replaceable>N</replaceable></option> 參數：
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl status chronyd
<prompt>&gt; </prompt><command>sudo</command> systemctl --lines=20 status chronyd</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>以附加模式顯示服務訊息</term>
     <listitem>
      <para>
       若要顯示服務訊息的<quote>
即時串流</quote>，請使用 <option>--follow</option> 選項，其工作方式與 <command>tail </command> <option>-f</option> 相似：
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl --follow status chronyd</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>訊息輸出格式</term>
     <listitem>
      <para>
       <option>--output=<replaceable>模式</replaceable></option>參數可讓您變更服務訊息的輸出格式。最重要的可用模式如下：
      </para>
      <variablelist>
       <varlistentry>
        <term><option>short</option></term>
        <listitem>
         <para>
          預設格式。顯示記錄訊息及易於理解的時戳。
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><option>verbose</option></term>
        <listitem>
         <para>
          完整輸出所有欄位。
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><option>cat</option></term>
        <listitem>
         <para>
          精簡輸出，不含時戳。
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-boot-systemd-timer-units">
  <title><systemitem class="daemon">systemd</systemitem> 計時器單位</title>

  <para>
   與 cron 類似，<systemitem class="daemon">systemd</systemitem> 計時器單位提供了一種在 Linux 上排程工作的機制。雖然 <systemitem class="daemon">systemd</systemitem> 計時器單位的用途與 cron 相同，但其具備幾項優點。
  </para>

  <itemizedlist>
   <listitem>
    <para>
     使用計時器單位排程的工作可以依賴於其他 <systemitem class="daemon">systemd</systemitem> 服務。
    </para>
   </listitem>
   <listitem>
    <para>
     計時器單位被視為一般 <systemitem class="daemon">systemd</systemitem> 服務，因此可以使用 <command>systemctl</command> 進行管理。
    </para>
   </listitem>
   <listitem>
    <para>
     計時器可以是即時計時器，也可以是單純計時器。
    </para>
   </listitem>
   <listitem>
    <para>
     時間單位會被記錄到 <systemitem class="daemon">systemd</systemitem> 日誌中，使得更易於監控和疑難排解。
    </para>
   </listitem>
  </itemizedlist>

  <para>
   <systemitem class="daemon">systemd</systemitem> 計時器單位透過 <literal>.timer</literal> 副檔名識別。
  </para>

  <sect2 xml:id="sec-boot-systemd-timer-types">
   <title><systemitem class="daemon">systemd</systemitem> 計時器類型</title>
   <para>
    計時器單位可以使用單純計時器和即時計時器。
   </para>
   <itemizedlist>
    <listitem>
     <para>
      與 cron 工作類似，即時計時器是依據行事曆事件觸發的。即時計時器使用選項 <option>OnCalendar</option> 進行定義。
     </para>
    </listitem>
    <listitem>
     <para>
      單純計時器將從某個特定起點開始經過指定時間後觸發。後者可以是系統開機或系統單位啟用事件。有幾個選項可用於定義單純計時器，包括 <option>OnBootSec</option>、<option>OnUnitActiveSec</option> 和 <option>OnTypeSec</option>。單純計時器不是永久的，每次重新開機後都將被重設。
     </para>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-timer-service-units">
   <title><systemitem class="daemon">systemd</systemitem> 計時器和服務單位</title>
   <para>
    每個計時器單位都必須有一個其所控制的相應 <systemitem class="daemon">systemd</systemitem> 單位檔案。也就是說，將由 <filename>.timer</filename> 檔案啟用並管理相應的 <filename>.service</filename> 檔案。使用計時器時，<filename>.service</filename> 檔案不需要 <literal>[Install]</literal> 區段，因為服務將由計時器管理。
   </para>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-timer-example">
   <title>具體範例</title>
   <para>
    為了理解 <systemitem class="daemon">systemd</systemitem> 計時器單位的基本知識，我們設定了一個觸發 <filename>foo.sh</filename> 外圍程序程序檔的計時器。
   </para>
   <para>
    第一步是建立用於控制外圍程序程序檔的 <systemitem class="daemon">systemd</systemitem> 服務單位。為此，請開啟一個新的文字檔案進行編輯，並新增以下服務單位定義：
   </para>
<screen>[Unit]
Description="Foo shell script"

[Service]
ExecStart=/usr/local/bin/foo.sh</screen>
   <para>
    將檔案以名稱 <filename>foo.service</filename> 儲存到目錄 <filename>/etc/systemd/system/</filename> 中。
   </para>
   <para>
    接下來，開啟一個新的文字檔案進行編輯，並新增以下計時器定義：
   </para>
<screen>[Unit]
Description="Run foo shell script"

[Timer]
OnBootSec=5min
OnUnitActiveSec=24h
Unit=foo.service

[Install]
WantedBy=multi-user.target</screen>
   <para>
    上述範例中的 <literal>[Timer]</literal> 區段指定了要觸發的服務 (<literal>foo.service</literal>) 以及觸發時間。在此範例中，選項 <option>OnBootSec</option> 指定了一個在系統開機後五分鐘觸發服務的單純計時器，而選項 <option>OnUnitActiveSec</option> 會在服務被啟用後 24 小時觸發服務 (即計時器將每天觸發一次服務)。最後，選項 <option>WantedBy</option> 指定應在系統達到多使用者目標時啟動計時器。
   </para>
   <para>
    您也可以不指定單純計時器，而是使用選項 <option>OnCalendar</option> 指定即時計時器。下面的即時計時器定義從星期一 12:00 開始，每週觸發一次相關服務單位。
   </para>
<screen>[Timer]
OnCalendar=weekly
Persistent=true</screen>
   <para>
    選項 <option>Persistent=true</option> 表示如果計時器錯過了上一次啟動時間 (例如，由於系統關閉)，則會在計時器啟動後立即觸發服務。
   </para>
   <para>
    選項 <option>OnCalendar</option> 還可以用於使用以下格式來定義觸發服務的具體日期和時間：<literal>DayOfWeek Year-Month-Day Hour:Minute:Second</literal>。下面的範例會在每天早上 5 點觸發服務：
   </para>
<screen>OnCalendar=*-*-* 5:00:00</screen>
   <para>
    您可以使用星號指定任何值，使用逗號列出可能的值。使用由 .. 分隔的兩個值可表示一個連續的範圍。下面的範例會在每個月的星期五下午 6 點觸發服務：
   </para>
<screen>OnCalendar=Fri *-*-1..7 18:00:00</screen>
   <para>
    若要在不同的時間觸發服務，您可以指定多個 <option>OnCalendar</option> 項目：
   </para>
<screen>OnCalendar=Mon..Fri 10:00
OnCalendar=Sat,Sun 22:00</screen>
   <para>
    在上面的範例中，會在工作日的上午 10 點和週末的晚上 10 點觸發服務。
   </para>
   <para>
    編輯好計時器單位檔案後，使用名稱 <filename>foo.timer</filename> 將其儲存到 <filename>/etc/systemd/system/</filename> 目錄中。若要檢查所建立的單位檔案是否正確，請執行以下指令：
   </para>
<screen><prompt>&gt; </prompt><command>sudo</command>  systemd-analyze verify /etc/systemd/system/foo.*</screen>
   <para>
    如果指令未傳回任何輸出，則表示檔案成功通過驗證。
   </para>
   <para>
    若要啟動計時器，請使用指令 <command>sudo systemctl start foo.timer</command>。若要在開機時啟用計時器，請執行指令 <command>sudo systemctl enable foo.timer</command>。
   </para>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-timer-manage">
   <title>管理 <systemitem class="daemon">systemd</systemitem> 計時器</title>
   <para>
    由於計時器被視為一般 <systemitem class="daemon">systemd</systemitem> 單位，因此您可以使用 <command>systemctl</command> 來管理它們。您可以使用 <command>systemctl start</command> 啟動計時器，使用 <command>systemctl enable</command> 啟用計時器，依此類推。除此之外，您還可以使用指令 <command>systemctl list-timers</command> 列出所有作用中計時器。若要列出包括非作用中計時器在內的所有計時器，請執行指令 <command>systemctl list-timers --all</command>。
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-boot-systemd-info">
  <title>更多資訊</title>

  <para>
   如需 <systemitem class="daemon">systemd</systemitem> 的詳細資訊，請參閱以下線上資源：
  </para>

  <variablelist>
   <varlistentry>
    <term>首頁</term>
    <listitem>
     <para>
      <link xlink:href="http://www.freedesktop.org/wiki/Software/systemd"/>
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>面向管理員的 <systemitem class="daemon">systemd</systemitem></term>
    <listitem>
     <para>
      Lennart Pöttering 是 <systemitem class="daemon">systemd</systemitem> 的原著者之一，他撰寫了一系列部落格文章 (寫本章時已有 13 篇)。其網址為 <link xlink:href="http://0pointer.de/blog/projects"/>。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
</chapter>
