<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="adm_shell.xml" version="5.0" xml:id="cha-adm-shell">
 <title>Bash-Shell und Bash-Skripte</title>
 <info>
      <abstract>
        <para>
    Heutzutage werden zunehmend Computer mit einer grafischen Bedienoberfläche (GUI) wie GNOME verwendet. GUIs bieten zwar viele Funktionen, kommen jedoch an ihre Grenzen, wenn automatische Aufgaben ausgeführt werden sollen. Shells sind eine gute Ergänzung für GUIs. In diesem Kapitel erhalten Sie einen Überblick über einige Aspekte von Shells, in diesem Fall Bash-Shells.
   </para>
      </abstract>
      <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
        <dm:bugtracker/>
        <dm:translation>yes</dm:translation>
      </dm:docmanager>
    </info>
    
 <sect1 xml:id="sec-adm-whatistheshell">
  <title>Was ist <quote>die Shell</quote>?</title>



  <para>
   Traditionell handelt es sich bei <emphasis>der</emphasis> Linux-Shell um Bash (Bourne again Shell). Wenn in diesem Kapitel die Rede von <quote>der Shell</quote> ist, ist die Bash-Shell gemeint. Außer Bash sind noch weitere Shells verfügbar (ash, csh, ksh, zsh und viele mehr), von denen jede unterschiedliche Funktionen und Merkmale aufweist. Wenn Sie weitere Informationen über andere Shells wünschen, suchen Sie in YaST nach <emphasis>shell</emphasis>.
  </para>

  <sect2 xml:id="sec-adm-configfiles">
   <title>Bash-Konfigurationsdateien</title>
   <para>
    Eine Shell lässt sich aufrufen als:
   </para>
   <orderedlist spacing="normal">
    <listitem>
     <formalpara>
      <title>Interaktive Login-Shell</title>
      <para>
       Diese wird zum Anmelden bei einem Computer durch den Aufruf von Bash mit der Option <option>--login</option> verwendet oder beim Anmelden an einem entfernten Computer mit SSH.
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title><quote>Gewöhnliche</quote> interaktive Shell</title>
      <para>
       Dies ist normalerweise beim Starten von xterm, konsole, gnome-terminal oder ähnlichen Kommandozeilenschnittstellen-Tools (CLI-Tools) der Fall.
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Nicht interaktive Shell</title>
      <para>
       Dies wird beim Aufrufen eines Shell-Skripts in der Kommandozeile verwendet.
      </para>
     </formalpara>
    </listitem>
   </orderedlist>
   <para>
    Abhängig vom verwendeten Shell-Typ werden unterschiedliche Konfigurationsdateien gelesen. Die folgenden Tabellen zeigen die Login- und Nicht-Login-Shell-Konfigurationsdateien.
   </para>
   <table xml:id="tab-adm-shell-config-loginshells">
    <title>Bash-Konfigurationsdateien für Login-Shells</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>
        <para>
         Datei
        </para>
       </entry>
       <entry>
        <para>
         Beschreibung
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         <filename>/etc/profile</filename>
        </para>
       </entry>
       <entry>
        <para>
         Bearbeiten Sie diese Datei nicht, andernfalls werden Ihre Änderungen beim nächsten Update möglicherweise zerstört.
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>/etc/profile.local</filename>
        </para>
       </entry>
       <entry>
        <para>
         Verwenden Sie diese Datei, wenn Sie <filename>/etc/profile</filename> erweitern.
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>/etc/profile.d/</filename>
        </para>
       </entry>
       <entry>
        <para>
         Enthält systemweite Konfigurationsdateien für bestimmte Programme
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>~/.profile</filename>
        </para>
       </entry>
       <entry>
        <para>
         Fügen Sie hier benutzerspezifische Konfigurationsdaten für Login-Shells ein.
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Die Login-Shell greift außerdem auf die unter <xref linkend="tab-adm-shell-configs-nonloginshells"/> aufgeführten Konfigurationsdateien zu.
   </para>
   <table xml:id="tab-adm-shell-configs-nonloginshells">
    <title>Bash-Konfigurationsdateien für Nicht-Login-Shells</title>
    <tgroup cols="2">
     <tbody>
      <row>
       <entry>
        <para>
         <filename>/etc/bash.bashrc</filename>
        </para>
       </entry>
       <entry>
        <para>
         Bearbeiten Sie diese Datei nicht, andernfalls werden Ihre Änderungen beim nächsten Update möglicherweise zerstört.
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>/etc/bash.bashrc.local</filename>
        </para>
       </entry>
       <entry>
        <para>
         Verwenden Sie diese Datei, um Ihre systemweiten Änderungen nur für die Bash-Shell einzufügen.
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>~/.bashrc</filename>
        </para>
       </entry>
       <entry>
        <para>
         Fügen Sie hier benutzerspezifische Konfigurationsdaten ein.
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Daneben verwendet die Bash-Shell einige weitere Dateien:
   </para>
   <table>
    <title>Besondere Dateien für die Bash-Shell</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>
        <para>
         Datei
        </para>
       </entry>
       <entry>
        <para>
         Beschreibung
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         <filename>~/.bash_history</filename>
        </para>
       </entry>
       <entry>
        <para>
         Enthält eine Liste aller Kommandos, die Sie eingegeben haben.
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>~/.bash_logout</filename>
        </para>
       </entry>
       <entry>
        <para>
         Wird beim Abmelden ausgeführt.
        </para>
       </entry>
       </row>
       <row>
       <entry>
        <para>
         <filename>~/.alias</filename>
        </para>
       </entry>
       <entry>
        <para>
         Benutzerdefinierte Aliase für häufig verwendete Kommandos. Weitere Details zum Definieren von Aliasen finden Sie unter <command>man 1 alias</command>.
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <bridgehead>Shells zur Verhinderung der Anmeldung</bridgehead>
   <para>
    Bestimmte Shells verhindern die Anmeldung von Benutzern im System: <systemitem>/bin/false</systemitem> und <systemitem>/sbin/nologin</systemitem>. Beide geben bei Anmeldeversuchen von Benutzern im System automatisch einen Fehler aus. Diese Methode war als Sicherheitsmaßnahme für Systembenutzer gedacht. Moderne Linux-Betriebssysteme kontrollieren den Systemzugriff jedoch inzwischen mit effektiveren Tools wie PAM und AppArmor.
   </para>
   <para>
    Standardmäßig ist bei <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> die Shell <systemitem>/bin/bash</systemitem> menschlichen Benutzern zugewiesen und die Shell <systemitem>/bin/false</systemitem> oder <systemitem>/sbin/nologin</systemitem> Systembenutzern. Dem Benutzer <systemitem class="username">Niemand</systemitem> ist aus historischen Gründen <systemitem>/bin/bash</systemitem> zugewiesen. Es handelt sich dabei um einen Benutzer mit minimalen Rechten, der standardmäßig als Systembenutzer verwendet wurde. Jegliche Sicherheit, die durch den Benutzer <systemitem class="username">Niemand</systemitem> erreicht wird, geht jedoch verloren, wenn er von mehreren Systembenutzern verwendet wird. Es sollte möglich sein, ihn in <systemitem>/sbin/nologin</systemitem> zu ändern. Am schnellsten lässt sich dies testen, wenn Sie die Änderung vornehmen und sehen, ob dadurch Dienste oder Anwendungen beschädigt werden.
   </para>
   <para>
    Mit folgendem Kommando wird unter <filename>/etc/passwd</filename>aufgelistet, welche Shells allen Benutzern, Systembenutzern und menschlichen Benutzern zugewiesen sind. Die Ausgabe unterscheidet sich je nach Services und Benutzer in Ihrem System:
   </para>
<screen><prompt>tux &gt; </prompt>sort -t: -k 7 /etc/passwd | awk -F: '{print $1"\t" $7}' | column -t
tux               /bin/bash
nobody            /bin/bash
root              /bin/bash
avahi             /bin/false
chrony            /bin/false
dhcpd             /bin/false
dnsmasq           /bin/false
ftpsecure         /bin/false
lightdm           /bin/false
mysql             /bin/false
postfix           /bin/false
rtkit             /bin/false
sshd              /bin/false
tftp              /bin/false
unbound           /bin/false
bin               /sbin/nologin
daemon            /sbin/nologin
ftp               /sbin/nologin
lp                /sbin/nologin
mail              /sbin/nologin
man               /sbin/nologin
nscd              /sbin/nologin
polkitd           /sbin/nologin
pulse             /sbin/nologin
qemu              /sbin/nologin
radvd             /sbin/nologin
rpc               /sbin/nologin
statd             /sbin/nologin
svn               /sbin/nologin
systemd-coredump  /sbin/nologin
systemd-network   /sbin/nologin
systemd-timesync  /sbin/nologin
usbmux            /sbin/nologin
vnc               /sbin/nologin
wwwrun            /sbin/nologin
messagebus        /usr/bin/false
scard             /usr/sbin/nologin</screen>
  </sect2>

  <xi:include href="fs_structure_i.xml"/>
 </sect1>
 <sect1 xml:id="sec-adm-shellscripts">
  <title>Schreiben von Shell-Skripten</title>

  <para>
   Shell-Skripte bieten eine bequeme Möglichkeit, die verschiedensten Aufgaben zu erledigen: Erfassen von Daten, Suche nach einem Wort oder Begriff in einem Text und andere nützliche Dinge. Das folgende Beispiel zeigt ein kleines Shell-Skript, das einen Text druckt:
  </para>

  <example>
   <title>Ein Shell-Skript, das einen Text druckt</title>
<screen>#!/bin/sh <co xml:id="co-adm-shell-shebang"/>
# Output the following line: <co xml:id="co-adm-shell-comment"/>
echo "Hello World" <co xml:id="co-adm-shell-echo"/></screen>
   <calloutlist>
    <callout arearefs="co-adm-shell-shebang">
     <para>
      Die erste Zeile beginnt mit den <emphasis>Shebang</emphasis>-Zeichen (<literal>#!</literal>), die angeben, dass diese Datei ein Skript ist. Der Interpreter, der nach dem <emphasis>Shebang</emphasis> angegeben wird, führt das Skript aus. In diesem Fall ist <command>/bin/sh</command> der angegebene Interpreter.
     </para>
    </callout>
    <callout arearefs="co-adm-shell-comment">
     <para>
      Die zweite Zeile ist ein Kommentar, der mit dem Hash-Zeichen beginnt. Wir empfehlen Ihnen, schwierige Zeilen zu kommentieren. Richtiges Kommentieren erinnert Sie an den Zweck und die Funktion der Zeile. Ihr Skript wird zudem hoffentlich auch von anderen Lesern verstanden. Das Kommentieren wird in der Entwickler-Community als gute Vorgehensweise angesehen.
     </para>
    </callout>
    <callout arearefs="co-adm-shell-echo">
     <para>
      Die dritte Zeile verwendet das integrierte Kommando <command>echo</command>, um den entsprechenden Text zu drucken.
     </para>
    </callout>
   </calloutlist>
  </example>

  <para>
   Vor Ausführung dieses Skripts sind einige Voraussetzungen zu erfüllen:
  </para>

  <orderedlist spacing="normal">
   <listitem>
    <para>
     Jedes Skript muss eine Shebang-Zeile enthalten (wie im obigen Beispiel). Falls die Zeile fehlt, müssen Sie den Interpreter manuell aufrufen.
    </para>
   </listitem>
   <listitem>
    <para>
     Sie können das Skript an beliebiger Stelle speichern. Jedoch empfiehlt es sich, es in einem Verzeichnis zu speichern, in dem die Shell es finden kann. Der Suchpfad in einer Shell wird durch die Umgebungsvariable <envar>PATH</envar> bestimmt. In der Regel verfügt ein normaler Benutzer über keinen Schreibzugriff auf <filename>/usr/bin</filename>. Daher sollten Sie Ihre Skripten im Benutzerverzeichnis <filename>~/bin/</filename> speichern. Das obige Beispiel erhält den Namen <filename>hello.sh</filename>.
    </para>
   </listitem>
   <listitem>
    <para>
     Das Skript muss zum Ausführen von Dateien berechtigt sein. Stellen Sie die Berechtigungen mit dem folgenden Kommando ein:
    </para>
<screen><prompt>tux &gt; </prompt>chmod +x ~/bin/hello.sh</screen>
   </listitem>
  </orderedlist>

  <para>
   Wenn Sie alle oben genannten Voraussetzungen erfüllt haben, können Sie das Skript mithilfe der folgenden Methoden ausführen:
  </para>

  <orderedlist spacing="normal">
   <listitem>
    <formalpara>
     <title>Als absoluten Pfad</title>
     <para>
      Das Skript kann mit einem absoluten Pfad ausgeführt werden. In unserem Fall lautet er <command>~/bin/hello.sh</command>.
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>Überall</title>
     <para>
      Wenn die Umgebungsvariable <envar>PATH</envar> das Verzeichnis enthält, in dem sich das Skript befindet, können Sie das Skript mit <command>hello.sh</command> ausführen.
     </para>
    </formalpara>
   </listitem>
  </orderedlist>
 </sect1>
 <sect1 xml:id="sec-adm-shell-redirect">
  <title>Umlenken von Kommandoereignissen</title>

  <para>
   Jedes Kommando kann drei Kanäle für Eingabe oder Ausgabe verwenden:
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <formalpara>
     <title>Standardausgabe</title>
     <para>
      Dies ist der Standardausgabe-Kanal. Immer wenn ein Kommando eine Ausgabe erzeugt, verwendet es den Standardausgabe-Kanal.
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>Standardeingabe</title>
     <para>
      Wenn ein Kommando Eingaben von Benutzern oder anderen Kommandos benötigt, verwendet es diesen Kanal.
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>Standardfehler</title>
     <para>
      Kommandos verwenden diesen Kanal zum Melden von Fehlern.
     </para>
    </formalpara>
   </listitem>
  </itemizedlist>

  <para>
   Zum Umlenken dieser Kanäle bestehen folgende Möglichkeiten:
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>Kommando &gt; Datei</literal>
    </term>
    <listitem>
     <para>
      Speichert die Ausgabe des Kommandos in eine Datei; eine etwaige bestehende Datei wird gelöscht. Beispielsweise schreibt das Kommando <command>ls</command> seine Ausgabe in die Datei <filename>listing.txt</filename>:
     </para>
<screen><prompt>tux &gt; </prompt>ls &gt; listing.txt</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>Kommando &gt;&gt; Datei</literal>
    </term>
    <listitem>
     <para>
      Hängt die Ausgabe des Kommandos an eine Datei an. Beispielsweise hängt das Kommando <command>ls</command> seine Ausgabe an die Datei <filename>listing.txt</filename> an:
     </para>
<screen><prompt>tux &gt; </prompt>ls &gt;&gt; listing.txt</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>Kommando &lt; Datei</literal>
    </term>
    <listitem>
     <para>
      Liest die Datei als Eingabe für das angegebene Kommando. Beispielsweise liest das Kommando <command>read</command> den Inhalt der Datei in die Variable  ein:
     </para>
<screen><prompt>tux &gt; </prompt>read a &lt; foo</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>Kommando1 | Kommando2</literal>
    </term>
    <listitem>
     <para>
      Leitet die Ausgabe des linken Kommandos als Eingabe für das rechte Kommando um. Beispiel: Das Kommando <command>cat</command> gibt den Inhalt der Datei <filename>/proc/cpuinfo</filename> aus. Diese Ausgabe wird von <command>grep</command> verwendet, um nur diejenigen Zeilen herauszufiltern, die <literal>cpu</literal> enthalten:
     </para>
<screen><prompt>tux &gt; </prompt>cat /proc/cpuinfo | grep cpu</screen>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Jeder Kanal verfügt über einen <emphasis>Dateideskriptor</emphasis>: 0 (Null) für Standardeingabe, 1 für Standardausgabe und 2 für Standardfehler. Es ist zulässig, diesen Dateideskriptor vor einem <literal>&lt;</literal>- oder <literal>&gt;</literal>-Zeichen einzufügen. Beispielsweise sucht die folgende Zeile nach einer Datei, die mit <filename>foo</filename> beginnt, aber seine Fehlermeldungen durch Umlenkung zu <filename>/dev/null</filename> unterdrückt:
  </para>

<screen><prompt>tux &gt; </prompt>find / -name "foo*" 2&gt;/dev/null</screen>
 </sect1>
 <sect1 xml:id="sec-adm-alias">
  <title>Verwenden von Aliassen</title>

  <para>
   Ein Alias ist ein Definitionskürzel für einen oder mehrere Kommandos. Die Syntax für einen Alias lautet:
  </para>

<screen>alias <replaceable>NAME</replaceable>=<replaceable>DEFINITION</replaceable></screen>

  <para>
   Beispielsweise definiert die folgende Zeile den Alias <command>lt</command>, der eine lange Liste ausgibt (Option <option>-l</option>), sie nach Änderungszeit sortiert (<option>-t</option>) und sie in umgekehrter Reihenfolge sortiert ausgibt (<option>-r</option>):
  </para>

<screen><prompt>tux &gt; </prompt>alias lt='ls -ltr'</screen>

  <para>
   Zur Anzeige aller Aliasdefinitionen verwenden Sie <command>alias</command>. Entfernen Sie den Alias mit <command>unalias</command> und dem entsprechenden Aliasnamen.
  </para>
 </sect1>
 <sect1 xml:id="sec-adm-variables">
  <title>Verwenden von Variablen in der Bash-Shell</title>

  <para>
   Eine Shell-Variable kann global oder lokal sein. Auf globale Variablen, z. B. Umgebungsvariablen, kann in allen Shells zugegriffen werden. Lokale Variablen sind hingegen nur in der aktuellen Shell sichtbar.
  </para>

  <para>
   Verwenden Sie zur Anzeige von allen Umgebungsvariablen das Kommando <command>printenv</command>. Wenn Sie den Wert einer Variable kennen müssen, fügen Sie den Namen Ihrer Variablen als ein Argument ein:
  </para>

<screen><prompt>tux &gt; </prompt>printenv PATH</screen>

  <para>
   Eine Variable (global oder lokal) kann auch mit <command>echo</command> angezeigt werden:
  </para>

<screen><prompt>tux &gt; </prompt>echo $PATH</screen>

  <para>
   Verwenden Sie zum Festlegen einer lokalen Variablen einen Variablennamen, gefolgt vom Gleichheitszeichen und dem Wert für den Namen:
  </para>

<screen><prompt>tux &gt; </prompt>PROJECT="SLED"</screen>

  <para>
   Geben Sie keine Leerzeichen um das Gleichheitszeichen ein, sonst erhalten Sie einen Fehler. Verwenden Sie zum Setzen einer Umgebungsvariablen <command>export</command>:
  </para>

<screen><prompt>tux &gt; </prompt>export NAME="tux"</screen>

  <para>
   Zum Entfernen einer Variable verwenden Sie <command>unset</command>:
  </para>

<screen><prompt>tux &gt; </prompt>unset NAME</screen>

  <para>
   Die folgende Tabelle enthält einige häufige Umgebungsvariablen, die Sie in Ihren Shell-Skripten verwenden können:
  </para>

  <table xml:id="tab-adm-envars">
   <title>Nützliche Umgebungsvariablen</title>
   <tgroup cols="2">
    <tbody>
     <row>
      <entry>
       <para>
        <envar>HOME</envar>
       </para>
      </entry>
      <entry>
       <para>
        Home-Verzeichnis des aktuellen Benutzers
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>HOST</envar>
       </para>
      </entry>
      <entry>
       <para>
        Aktueller Hostname
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>LANG</envar>
       </para>
      </entry>
      <entry>
       <para>
        Wenn ein Werkzeug lokalisiert wird, verwendet es die Sprache aus dieser Umgebungsvariablen. Englisch kann auch auf <literal>C</literal> gesetzt werden
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>PFAD</envar>
       </para>
      </entry>
      <entry>
       <para>
        Suchpfad der Shell, eine Liste von Verzeichnissen, die durch Doppelpunkte getrennt sind
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>PS1</envar>
       </para>
      </entry>
      <entry>
       <para>
        Gibt die normale Eingabeaufforderung an, die vor jedem Kommando angezeigt wird
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>PS2</envar>
       </para>
      </entry>
      <entry>
       <para>
        Gibt die sekundäre Eingabeaufforderung an, die beim Ausführen eines mehrzeiligen Kommandos angezeigt wird
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>PWD</envar>
       </para>
      </entry>
      <entry>
       <para>
        Aktuelles Arbeitsverzeichnis
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>USER</envar>
       </para>
      </entry>
      <entry>
       <para>
        Aktueller Benutzer
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <sect2 xml:id="sec-adm-variables-argument">
   <title>Verwenden von Argumentvariablen</title>

   <para>
    Wenn Sie beispielsweise über das Skript <command>foo.sh</command> verfügen, können Sie es wie folgt ausführen:
   </para>
<screen><prompt>tux &gt; </prompt>foo.sh "Tux Penguin" 2000 </screen>
   <para>
    Für den Zugriff auf alle Argumente, die an Ihr Skript übergeben werden, benötigen Sie Positionsparameter. Diese sind <envar>$1</envar> für das erste Argument, <envar>$2</envar> für das zweite usw. Sie können bis zu neun Parameter verwenden. Verwenden Sie <envar>$0</envar> zum Abrufen des Skriptnamens.
   </para>
   <para>
    Das folgende Skript <command>foo.sh</command> gibt alle Argumente von 1 bis 4 aus:
   </para>
<screen>#!/bin/sh
echo \"$1\" \"$2\" \"$3\" \"$4\"</screen>
   <para>
    Wenn Sie das Skript mit den obigen Argumenten ausführen, erhalten Sie Folgendes:
   </para>
<screen>"Tux Penguin" "2000" "" ""</screen>

  </sect2>

  <sect2 xml:id="sec-adm-shell-varsubst">
   <title>Verwenden der Variablenersetzung</title>
   <para>
    Variablenersetzungen wenden beginnend von links oder rechts ein Schema auf den Inhalt einer Variable an. Die folgende Liste enthält die möglichen Syntaxformen:
   </para>
   <variablelist>
    <varlistentry>
     <term><literal>${VAR#schema}</literal>
     </term>
     <listitem>
      <para>
       entfernt die kürzeste mögliche Übereinstimmung von links:
      </para>
<screen><prompt>tux &gt; </prompt>file=/home/tux/book/book.tar.bz2
<prompt>tux &gt; </prompt>echo ${file#*/}
home/tux/book/book.tar.bz2</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>${VAR##schema}</literal>
     </term>
     <listitem>
      <para>
       entfernt die längste mögliche Übereinstimmung von links:
      </para>
<screen><prompt>tux &gt; </prompt>file=/home/tux/book/book.tar.bz2
<prompt>tux &gt; </prompt>echo ${file##*/}
book.tar.bz2</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>${VAR%schema}</literal>
     </term>
     <listitem>
      <para>
       entfernt die kürzeste mögliche Übereinstimmung von rechts:
      </para>
<screen><prompt>tux &gt; </prompt>file=/home/tux/book/book.tar.bz2
<prompt>tux &gt; </prompt>echo ${file%.*}
/home/tux/book/book.tar</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>${VAR%%schema}</literal>
     </term>
     <listitem>
      <para>
       entfernt die längste mögliche Übereinstimmung von rechts:
      </para>
<screen><prompt>tux &gt; </prompt>file=/home/tux/book/book.tar.bz2
<prompt>tux &gt; </prompt>echo ${file%%.*}
/home/tux/book/book</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>${VAR/pattern_1/pattern_2}</literal>
     </term>
     <listitem>
      <para>
       ersetzt den Inhalt von <replaceable>VAR</replaceable> von <replaceable>PATTERN_1</replaceable> durch <replaceable>PATTERN_2</replaceable>:
      </para>
<screen><prompt>tux &gt; </prompt>file=/home/tux/book/book.tar.bz2
<prompt>tux &gt; </prompt>echo ${file/tux/wilber}
/home/wilber/book/book.tar.bz2</screen>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>
 </sect1>
 <sect1 xml:id="sec-adm-shell-grouping">
  <title>Gruppieren und Kombinieren von Kommandos</title>

  <para>
   In Shells können Sie Kommandos für die bedingte Ausführung verketten und gruppieren. Jedes Kommando übergibt einen Endcode, der den Erfolg oder Misserfolg seiner Ausführung bestimmt. Wenn er 0 (Null) lautet, war das Kommando erfolgreich, alle anderen Codes bezeichnen einen Fehler, der spezifisch für das Kommando ist.
  </para>

  <para>
   Die folgende Liste zeigt, wie sich Kommandos gruppieren lassen:
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>Kommando1 ; Kommando2</literal>
    </term>
    <listitem>
     <para>
      führt die Kommandos in sequenzieller Reihenfolge aus. Der Endcode wird nicht geprüft. Die folgende Zeile zeigt den Inhalt der Datei mit <command>cat</command> an und gibt deren Dateieigenschaften unabhängig von deren Endcodes mit <command>ls</command> aus:
     </para>
<screen><prompt>tux &gt; </prompt>cat filelist.txt ; ls -l filelist.txt</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>Kommando1 &amp;&amp; Kommando2</literal>
    </term>
    <listitem>
     <para>
      führt das rechte Kommando aus, wenn das linke Kommando erfolgreich war (logisches UND). Die folgende Zeile zeigt den Inahlt der Datei an und gibt deren Dateieigenschaften nur aus, wenn das vorherige Kommando erfolgreich war (vgl. mit dem vorherigen Eintrag in dieser Liste):
     </para>
<screen><prompt>tux &gt; </prompt>cat filelist.txt &amp;&amp; ls -l filelist.txt</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>Kommando1 || Kommando2</literal>
    </term>
    <listitem>
     <para>
      führt das rechte Kommando aus, wenn das linke Kommando fehlgeschlagen ist (logisches ODER). Die folgende Zeile legt nur ein Verzeichnis in <filename>/home/wilber/bar</filename> an, wenn die Erstellung des Verzeichnisses in <filename>/home/tux/foo</filename> fehlgeschlagen ist:
     </para>
<screen><prompt>tux &gt; </prompt>mkdir /home/tux/foo || mkdir /home/wilber/bar</screen>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>funcname(){ ... }</literal>
    </term>
    <listitem>
     <para>
      erstellt eine Shell-Funktion. Sie können mithilfe der Positionsparameter auf ihre Argumente zugreifen. Die folgende Zeile definiert die Funktion <literal>hello</literal> für die Ausgabe einer kurzen Meldung:
     </para>
<screen><prompt>tux &gt; </prompt>hello() { echo "Hello $1"; }</screen>
     <para>
      Sie können diese Funktion wie folgt aufrufen:
     </para>
<screen><prompt>tux &gt; </prompt>hello Tux</screen>
     <para>
      Die Ausgabe sieht wie folgt aus:
     </para>
<screen>Hello Tux</screen>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 xml:id="sec-adm-shell-commonconstructs">
  <title>Arbeiten mit häufigen Ablaufkonstrukten</title>

  <para>
   Zur Steuerung des Ablaufs Ihres Skripts verfügt eine Shell über <command>while</command>-, <command>if</command>-, <command>for</command>- und <command>case</command>-Konstrukte.
  </para>



  <sect2 xml:id="sec-adm-shell-if">
   <title>Das Steuerungskommando „if“</title>
   <para>
    Das Kommando <command>if</command> wird verwendet, um Ausdrücke zu prüfen. Beispielsweise testet der folgende Code, ob es sich beim aktuellen Benutzer um Tux handelt:
   </para>
<screen>if test $USER = "tux"; then
  echo "Hello Tux."
else
  echo "You are not Tux."
fi</screen>
   <para>
    Der Testausdruck kann so komplex oder einfach wie möglich sein. Der folgende Ausdruck prüft, ob die Datei <filename>foo.txt</filename> existiert:
   </para>
<screen>if test -e /tmp/foo.txt ; then
  echo "Found foo.txt"
fi</screen>
   <para>
    Der Testausdruck kann auch in eckigen Klammern abgekürzt werden:
   </para>
<screen>if [ -e /tmp/foo.txt ] ; then
  echo "Found foo.txt"
fi</screen>
   <para>
    Weitere nützliche Ausdrücke finden Sie unter <link xlink:href="https://bash.cyberciti.biz/guide/If..else..fi"/>.
   </para>
  </sect2>

  <sect2 xml:id="sec-adm-shell-for">
   <title>Erstellen von Schleifen mit dem Kommando <command>for</command></title>
   <para>
    Mithilfe der <command>for</command>-Schleife können Sie Kommandos an einer Liste von Einträgen ausführen. Beispielsweise gibt der folgende Code einige Informationen über PNG-Dateien im aktuellen Verzeichnis aus:
   </para>
<screen>for i in *.png; do
 ls -l $i
done</screen>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-adm-shell-moreinfo">
  <title>Weitere Informationen</title>

  <para>
   Wichtige Informationen über die Bash-Shell finden Sie auf den man-Seiten zu <command>man bash</command>. Für weitere Informationen zu diesem Thema siehe die folgende Liste:
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     <link xlink:href="http://tldp.org/LDP/Bash-Beginners-Guide/html/index.html"/> – Bash-Anleitungen für Anfänger
    </para>
   </listitem>
   <listitem>
    <para>
     <link xlink:href="http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html"/> – BASH-Programmierung – Einführende schrittweise Anleitungen
    </para>
   </listitem>
   <listitem>
    <para>
     <link xlink:href="http://tldp.org/LDP/abs/html/index.html"/> – Anleitung für erweiterte Bash-Skripts
    </para>
   </listitem>
   <listitem>
    <para>
     <link xlink:href="http://www.grymoire.com/Unix/Sh.html"/> – Sh - the Bourne Shell (Sh – die Bourne-Shell)
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
</chapter>
