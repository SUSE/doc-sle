<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "generic-entities.ent">
    %entities;
]>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="cha-filesystems" xml:lang="en">
 <title>Overview of file systems in Linux</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker></dm:bugtracker>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
  <abstract>
   <para>
    &productname; ships with different file systems from which to choose,
    including Btrfs, Ext4, Ext3, Ext2 and XFS. Each file system has its own
    advantages and disadvantages. For a side-by-side feature comparison of the
    major file systems in &productname;, see
    <link xlink:href="https://www.suse.com/releasenotes/x86_64/SUSE-SLES/15-SP3/#file-system-comparison"/>
    (<citetitle>Comparison of supported file systems</citetitle>). This chapter
    contains an overview of how these file systems work and what advantages
    they offer.
   </para>
  </abstract>
 </info>
 <para>
  With &sle; 12, Btrfs is the default file system for the operating system and
  XFS is the default for all other use cases. &suse; also continues to support
  the Ext family of file systems and OCFS2. By default, the Btrfs file system
  will be set up with subvolumes. Snapshots will be automatically enabled for
  the root file system using the snapper infrastructure. For more information
  about snapper, refer to <xref linkend="cha-snapper"/>.
 </para>
 <para>
  Professional high-performance setups might require a highly available storage
  system. To meet the requirements of high-performance clustering scenarios,
  &productname; includes OCFS2 (Oracle Cluster File System 2) and the
  Distributed Replicated Block Device (DRBD) in the &hasi; add-on. These
  advanced storage systems are not covered in this guide. For information, see
  the
  <link xlink:href="https://documentation.suse.com/sle-ha-15/html/SLE-HA-all/book-administration.html">
  <citetitle>&haguide; for the &sle; &hasi;</citetitle></link>.
 </para>
 <para>
  It is very important to remember that no file system best suits all kinds of
  applications. Each file system has its particular strengths and weaknesses,
  which must be taken into account. In addition, even the most sophisticated
  file system cannot replace a reasonable backup strategy.
 </para>
 <para>
  The terms <emphasis>data integrity</emphasis> and <emphasis>data
  consistency</emphasis>, when used in this section, do not refer to the
  consistency of the user space data (the data your application writes to its
  files). Whether this data is consistent must be controlled by the application
  itself.
 </para>
 <para>
  Unless stated otherwise in this section, all the steps required to set up or
  change partitions and file systems can be performed by using the &yast;
  Partitioner (which is also strongly recommended). For information, see
  <xref linkend="cha-expert-partitioner"/>.
 </para>
 <sect1 xml:id="sec-filesystems-glossary">
  <title>Terminology</title>

  <variablelist>
   <varlistentry>
    <term>metadata</term>
    <listitem>
     <para>
      A data structure that is internal to the file system. It ensures that all
      of the on-disk data is properly organized and accessible. Almost every
      file system has its own structure of metadata, which is one reason the
      file systems show different performance characteristics. It is extremely
      important to maintain metadata intact, because otherwise all data on the
      file system could become inaccessible.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>inode</term>
    <listitem>
     <para>
      A data structure on a file system that contains a variety of information
      about a file, including size, number of links, pointers to the disk
      blocks where the file contents are actually stored, and date and time of
      creation, modification, and access.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>journal</term>
    <listitem>
     <para>
      In the context of a file system, a journal is an on-disk structure
      containing a type of log in which the file system stores what it is about
      to change in the file systemâ€™s metadata. Journaling greatly reduces the
      recovery time of a file system because it has no need for the lengthy
      search process that checks the entire file system at system start-up.
      Instead, only the journal is replayed.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 xml:id="sec-filesystems-major-btrfs">
  <title>Btrfs</title>

  <para>
   Btrfs is a copy-on-write (COW) file system developed by Chris Mason. It is
   based on COW-friendly B-trees developed by Ohad Rodeh. Btrfs is a
   logging-style file system. Instead of journaling the block changes, it
   writes them in a new location, then links the change in. Until the last
   write, the new changes are not committed.
  </para>

  <sect2 xml:id="sec-filesystems-major-btrfs-features">
   <title>Key features</title>
   <para>
    Btrfs provides fault tolerance, repair, and easy management features, such
    as the following:
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>
      Writable snapshots that allow you to easily roll back your system if
      needed after applying updates, or to back up files.
     </para>
    </listitem>
    <listitem>
     <para>
      Subvolume support: Btrfs creates a default subvolume in its assigned pool
      of space. It allows you to create additional subvolumes that act as
      individual file systems within the same pool of space. The number of
      subvolumes is limited only by the space allocated to the pool.
     </para>
    </listitem>
    <listitem>
     <para>
      The online check and repair functionality <command>scrub</command> is
      available as part of the Btrfs command line tools. It verifies the
      integrity of data and metadata, assuming the tree structure is fine. You
      can run scrub periodically on a mounted file system; it runs as a
      background process during normal operation.
     </para>
    </listitem>
    <listitem>
     <para>
      Different RAID levels for metadata and user data.
     </para>
    </listitem>
    <listitem>
     <para>
      Different checksums for metadata and user data to improve error
      detection.
     </para>
    </listitem>
    <listitem>
     <para>
      Integration with Linux Logical Volume Manager (LVM) storage objects.
     </para>
    </listitem>
    <listitem>
     <para>
      Integration with the &yast; Partitioner and &ay; on &productname;. This
      also includes creating a Btrfs file system on Multiple Devices (MD) and
      Device Mapper (DM) storage configurations.
     </para>
    </listitem>
    <listitem>
     <para>
      Offline migration from existing Ext2, Ext3, and Ext4 file systems.
     </para>
    </listitem>
    <listitem>
     <para>
      Boot loader support for <filename>/boot</filename>, allowing to boot from
      a Btrfs partition.
     </para>
    </listitem>
    <listitem>
     <!--taroth 2015-08-07: fix for http://doccomments.provo.novell.com/comments/28887-->
     <para>
      Multivolume Btrfs is supported in RAID0, RAID1, and RAID10 profiles in
      &productname; &productnumber;. Higher RAID levels are not supported yet,
      but might be enabled with a future service pack.
     </para>
    </listitem>
    <listitem>
     <para>
      Use Btrfs commands to set up transparent compression.
     </para>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 xml:id="sec-filesystems-major-btrfs-suse">
   <title>The root file system setup on &productname;</title>
   <para>
    By default, &productname; is set up using Btrfs and snapshots for the root
    partition. Snapshots allow you to easily roll back your system if needed
    after applying updates, or to back up files. Snapshots can easily be
    managed with the &suse; Snapper infrastructure as explained in
    <xref linkend="cha-snapper"/>. For general information about the &suse;
    Snapper project, see the Snapper Portal wiki at OpenSUSE.org
    (<link xlink:href="http://snapper.io"/>).
   </para>
   <para>
    When using a snapshot to roll back the system, it must be ensured that data
    such as user's home directories, Web and FTP server contents or log files
    do not get lost or overwritten during a roll back. This is achieved by
    using Btrfs subvolumes on the root file system. Subvolumes can be excluded
    from snapshots. The default root file system setup on &productname; as
    proposed by &yast; during the installation contains the following
    subvolumes. They are excluded from snapshots for the reasons given below.
   </para>
   <xi:include href="snapshot_excludes_i.xml"/>
   <warning>
    <title>Support for rollbacks</title>
    <para>
     Rollbacks are only supported by &suse; if you do not remove any of the
     preconfigured subvolumes. You may, however, add subvolumes using the
     &yast; Partitioner.
    </para>
   </warning>
   <sect3 xml:id="sec-filesystems-major-btrfs-compress">
    <title>Mounting compressed Btrfs file systems</title>
    <para>
     The Btrfs file system supports transparent compression. While enabled,
     Btrfs compresses file data when written and uncompresses file data when
     read.
    </para>
    <para>
     Use the <option>compress</option> or <option>compress-force</option> mount
     option and select the compression algorithm, <literal>zstd</literal>,
     <literal>lzo</literal>, or <literal>zlib</literal> (the default). zlib
     compression has a higher compression ratio while lzo is faster and takes
     less CPU load. The zstd algorithm offers a modern compromise, with
     performance close to lzo and compression ratios similar to zlib.
    </para>
    <para>
     For example:
    </para>
<screen>&prompt.root;mount -o compress=zstd /dev/sdx /mnt</screen>
    <para>
     In case you create a file, write to it, and the compressed result is
     greater or equal to the uncompressed size, Btrfs will skip compression for
     future write operations forever for this file. If you do not like this
     behavior, use the <option>compress-force</option> option. This can be
     useful for files that have some initial non-compressible data.
    </para>
    <para>
     Note, compression takes effect for new files only. Files that were written
     without compression are not compressed when the file system is mounted
     with the <option>compress</option> or <option>compress-force</option>
     option. Furthermore, files with the <option>nodatacow</option> attribute
     never get their extents compressed:
    </para>
<screen>&prompt.root;<command>chattr</command> +C <replaceable>FILE</replaceable>
&prompt.root;<command>mount</command> -o nodatacow  /dev/sdx /mnt</screen>
    <para>
     In regard to encryption, this is independent from any compression. After
     you have written some data to this partition, print the details:
    </para>
<screen>&prompt.root;btrfs filesystem show /mnt
btrfs filesystem show /mnt
Label: 'Test-Btrfs'  uuid: 62f0c378-e93e-4aa1-9532-93c6b780749d
        Total devices 1 FS bytes used 3.22MiB
      devid    1 size 2.00GiB used 240.62MiB path /dev/sdb1</screen>
    <para>
     If you want this to be permanent, add the <option>compress</option> or
     <option>compress-force</option> option into the
     <filename>/etc/fstab</filename> configuration file. For example:
    </para>
<screen>UUID=1a2b3c4d /home btrfs subvol=@/home,<emphasis role="strong">compress</emphasis> 0 0</screen>
   </sect3>
   <sect3 xml:id="sec-filesystems-major-btrfs-suse-mount">
    <title>Mounting subvolumes</title>
    <para>
     A system rollback from a snapshot on &productname; is performed by booting
     from the snapshot first. This allows you to check the snapshot while
     running before doing the rollback. Being able to boot from snapshots is
     achieved by mounting the subvolumes (which would normally not be
     necessary).
    </para>
    <para>
     In addition to the subvolumes listed in
     <xref linkend="sec-filesystems-major-btrfs-suse"/> a volume named
     <literal>@</literal> exists. This is the default subvolume that will be
     mounted as the root partition (<filename>/</filename>). The other
     subvolumes will be mounted into this volume.
    </para>
    <para>
     When booting from a snapshot, not the <literal>@</literal> subvolume will
     be used, but rather the snapshot. The parts of the file system included in
     the snapshot will be mounted read-only as <filename>/</filename>. The
     other subvolumes will be mounted writable into the snapshot. This state is
     temporary by default: the previous configuration will be restored with the
     next reboot. To make it permanent, execute the <command>snapper
     rollback</command> command. This will make the snapshot that is currently
     booted the new <emphasis>default</emphasis> subvolume, which will be used
     after a reboot.
    </para>
   </sect3>
   <sect3 xml:id="sec-filesystems-major-btrfs-suse-space">
    <title>Checking for free space</title>
    <!--
     taroth 2019-05-06: TODO - for next release, consider moving the text
     below to a phrases entity and re-using it in sle_update_preparation.xml,
     sec.update-preparation.disk.btrfs-on-root (won't do this right now, as we are
     past locdrop for SLE 15 SP1 already)
     -->
    <para>
     File system usage is usually checked by running the <command>df</command>
     command. On a Btrfs file system, the output of <command>df</command> can
     be misleading, because in addition to the space the raw data allocates, a
     Btrfs file system also allocates and uses space for metadata.
    </para>
    <para>
     Consequently a Btrfs file system may report being out of space even though
     it seems that plenty of space is still available. In that case, all space
     allocated for the metadata is used up. Use the following commands to check
     for used and available space on a Btrfs file system:
    </para>
    <variablelist>
     <varlistentry>
      <term><command>btrfs filesystem show</command></term>
      <listitem>
<screen>&prompt.sudo;btrfs filesystem show /
Label: 'ROOT'  uuid: 52011c5e-5711-42d8-8c50-718a005ec4b3
        Total devices 1 FS bytes used 10.02GiB
        devid    1 size 20.02GiB used 13.78GiB path /dev/sda3</screen>
       <para>
        Shows the total size of the file system and its usage. If these two
        values in the last line match, all space on the file system has been
        allocated.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><command>btrfs filesystem df</command></term>
      <listitem>
<screen>&prompt.sudo;btrfs filesystem df /
Data, single: total=13.00GiB, used=9.61GiB
System, single: total=32.00MiB, used=16.00KiB
Metadata, single: total=768.00MiB, used=421.36MiB
GlobalReserve, single: total=144.00MiB, used=0.00B</screen>
       <para>
        Shows values for allocated (<literal>total</literal>) and used space of
        the file system. If the values for <literal>total</literal> and
        <literal>used</literal> for the metadata are almost equal, all space
        for metadata has been allocated.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><command>btrfs filesystem usage</command></term>
      <listitem>
<screen>&prompt.sudo;btrfs filesystem usage /
Overall:
    Device size:                  20.02GiB
    Device allocated:             13.78GiB
    Device unallocated:            6.24GiB
    Device missing:                  0.00B
    Used:                         10.02GiB
    Free (estimated):              9.63GiB      (min: 9.63GiB)
    Data ratio:                       1.00
    Metadata ratio:                   1.00
    Global reserve:              144.00MiB      (used: 0.00B)

             Data     Metadata  System
Id Path      single   single    single   Unallocated
-- --------- -------- --------- -------- -----------
 1 /dev/sda3 13.00GiB 768.00MiB 32.00MiB     6.24GiB
-- --------- -------- --------- -------- -----------
   Total     13.00GiB 768.00MiB 32.00MiB     6.24GiB
   Used       9.61GiB 421.36MiB 16.00KiB</screen>
       <para>
        Shows data similar to that of the two previous commands combined.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     For more information refer to <command>man 8 btrfs-filesystem</command>
     and <link xlink:href="https://btrfs.wiki.kernel.org/index.php/FAQ"/>.
    </para>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-filesystems-major-btrfs-migrate">
   <title>Migration from ReiserFS and ext file systems to Btrfs</title>
   <para>
    You can migrate data volumes from existing ReiserFS or Ext (Ext2, Ext3, or
    Ext4) to the Btrfs file system using the <command>btrfs-convert</command>
    tool. This allows you to do an in-place conversion of unmounted (offline)
    file systems, which may require a bootable install media with the
    <command>btrfs-convert</command> tool. The tool constructs a Btrfs file
    system within the free space of the original file system, directly linking
    to the data contained in it. There must be enough free space on the device
    to create the metadata or the conversion will fail. The original file
    system will be intact and no free space will be occupied by the Btrfs file
    system. The amount of space required is dependent on the content of the
    file system and can vary based on the number of file system objects (such
    as files, directories, extended attributes) contained in it. Since the data
    is directly referenced, the amount of data on the file system does not
    impact the space required for conversion, except for files that use tail
    packing and are larger than about 2 KiB in size.
   </para>
   <warning>
    <title>Root file system conversion not supported</title>
    <para>
     Converting the root file system to Btrfs is not supported and not
     recommended. Automating such a conversion is not possible due to various
     steps that need to be tailored to your specific setup&mdash;the process
     requires a complex configuration to provide a correct rollback,
     <filename>/boot</filename> must be on the root file system, and the system
     must have specific subvolumes, etc. Either keep the existing file system
     or re-install the whole system from scratch.
    </para>
   </warning>
   <para>
    To convert the original file system to the Btrfs file system, run:
   </para>
<screen>&prompt.root;btrfs-convert /path/to/device</screen>
   <important>
    <title>Check <filename>/etc/fstab</filename></title>
    <para>
     After the conversion, you need to ensure that any references to the
     original file system in <filename>/etc/fstab</filename> have been adjusted
     to indicate that the device contains a Btrfs file system.
    </para>
   </important>
   <para>
    When converted, the contents of the Btrfs file system will reflect the
    contents of the source file system. The source file system will be
    preserved until you remove the related read-only image created at
    <filename><replaceable>fs_root</replaceable>/reiserfs_saved/image</filename>.
    The image file is effectively a 'snapshot' of the ReiserFS file system
    prior to conversion and will not be modified as the Btrfs file system is
    modified. To remove the image file, remove the
    <filename>reiserfs_saved</filename> subvolume:
   </para>
<screen>&prompt.root;btrfs subvolume delete <replaceable>fs_root</replaceable>/reiserfs_saved</screen>
   <para>
    To revert the file system back to the original one, use the following
    command:
   </para>
<screen>&prompt.root;btrfs-convert -r /path/to/device</screen>
   <warning>
    <title>Lost changes</title>
    <para>
     Any changes you made to the file system while it was mounted as a Btrfs
     file system will be lost. A balance operation must not have been performed
     in the interim, or the file system will not be restored correctly.
    </para>
   </warning>
  </sect2>

  <sect2 xml:id="sec-filesystems-major-btrfs-admin">
   <title>Btrfs administration</title>
   <para>
    Btrfs is integrated in the &yast; Partitioner and &ay;. It is available
    during the installation to allow you to set up a solution for the root file
    system. You can use the &yast; Partitioner after the installation to view
    and manage Btrfs volumes.
   </para>
   <para>
    Btrfs administration tools are provided in the
    <filename>btrfsprogs</filename> package. For information about using Btrfs
    commands, see the <command>man 8 btrfs</command>, <command>man 8
    btrfsck</command>, and <command>man 8 mkfs.btrfs</command> commands. For
    information about Btrfs features, see the <citetitle>Btrfs wiki</citetitle>
    at <link xlink:href="http://btrfs.wiki.kernel.org"/>.
   </para>
  </sect2>

  <sect2 xml:id="sec-filesystems-major-btrfs-quota">
   <title>Btrfs quota support for subvolumes</title>
   <para>
    The Btrfs root file system subvolumes (for example,
    <filename>/var/log</filename>, <filename>/var/crash</filename>, or
    <filename>/var/cache</filename>) can use all the available disk space
    during normal operation, and cause a system malfunction. To help avoid this
    situation, &productname; offers quota support for Btrfs subvolumes. If you
    set up the root file system from a &yast; proposal, you are ready to enable
    and set subvolume quotas.
   </para>
   <sect3 xml:id="setting-btrfs-quotas-using-yast">
    <title>Setting Btrfs quotas using &yast;</title>
    <para>
     To set a quota for a subvolume of the root file system by using &yast;,
     proceed as follows:
    </para>
    <procedure>
     <step>
      <para>
       Start &yast; and select
       <menuchoice><guimenu>System</guimenu><guimenu>Partitioner</guimenu></menuchoice>
       and confirm the warning with <guimenu>Yes</guimenu>.
      </para>
     </step>
     <step>
      <para>
       In the left pane, click <guimenu>Btrfs</guimenu>.
      </para>
     </step>
     <step>
      <para>
       In the main window, select the device for which you want to enable
       subvolume quotas and click <guimenu>Edit</guimenu> at the bottom.
      </para>
     </step>
     <step>
      <para>
       In the <guimenu>Edit Btrfs</guimenu> window, activate the
       <guimenu>Enable Subvolume Quotas</guimenu> check box and confirm with
       <guimenu>Next</guimenu>.
      </para>
      <figure>
       <title>Enabling Btrfs quotas</title>
       <mediaobject>
        <imageobject role="fo">
         <imagedata fileref="yast2_btrfs_quotas_enable.png" width="75%"/>
        </imageobject>
        <imageobject role="html">
         <imagedata fileref="yast2_btrfs_quotas_enable.png" width="75%"/>
        </imageobject>
       </mediaobject>
      </figure>
     </step>
     <step>
      <para>
       From the list of existing subvolumes, click the subvolume whose size you
       intend to limit by quota and click <guimenu>Edit</guimenu> at the
       bottom.
      </para>
     </step>
     <step>
      <para>
       In the <guimenu>Edit subvolume of Btrfs</guimenu> window, activate
       <guimenu>Limit size</guimenu> and specify the maximum referenced size.
       Confirm with <guimenu>Accept</guimenu>.
      </para>
      <figure>
       <title>Setting quota for a subvolume</title>
       <mediaobject>
        <imageobject role="fo">
         <imagedata fileref="yast2_btrfs_quotas_set.png" width="75%"/>
        </imageobject>
        <imageobject role="html">
         <imagedata fileref="yast2_btrfs_quotas_set.png" width="75%"/>
        </imageobject>
       </mediaobject>
      </figure>
      <para>
       The new size limit will be displayed next to the subvolume name:
      </para>
      <figure>
       <title>List of subvolumes for a device</title>
       <mediaobject>
        <imageobject role="fo">
         <imagedata fileref="yast2_btrfs_quotas_edit.png" width="75%"/>
        </imageobject>
        <imageobject role="html">
         <imagedata fileref="yast2_btrfs_quotas_edit.png" width="75%"/>
        </imageobject>
       </mediaobject>
      </figure>
     </step>
     <step>
      <para>
       Apply changes with <guimenu>Next</guimenu>.
      </para>
     </step>
    </procedure>
   </sect3>
   <sect3 xml:id="setting-btrfs-quotas-using-cmdline">
    <title>Setting Btrfs quotas on the command line</title>
    <para>
     To set a quota for a subvolume of the root file system on the command
     line, proceed as follows:
    </para>
    <procedure>
     <step>
      <para>
       Enable quota support:
      </para>
<screen>&prompt.sudo;btrfs quota enable /</screen>
     </step>
     <step>
      <para>
       Get a list of subvolumes:
      </para>
<screen>&prompt.sudo;btrfs subvolume list /</screen>
      <para>
       Quotas can only be set for existing subvolumes.
      </para>
     </step>
     <step>
      <para>
       Set a quota for one of the subvolumes that was listed in the previous
       step. A subvolume can either be identified by path (for example
       <filename>/var/tmp</filename>) or by <literal>0/<replaceable>SUBVOLUME
       ID</replaceable></literal> (for example <literal>0/272</literal>). The
       following example sets a quota of 5&nbsp;GB for
       <filename>/var/tmp</filename>.
      </para>
<screen>&prompt.sudo;btrfs qgroup limit 5G /var/tmp</screen>
      <para>
       The size can either be specified in bytes (5000000000), kilobytes
       (5000000K), megabytes (5000M), or gigabytes (5G). The resulting values
       in bytes slightly differ, since 1024 Bytes = 1 KiB, 1024 KiB = 1 MiB,
       etc.
      </para>
     </step>
     <step>
      <para>
       To list the existing quotas, use the following command. The column
       <literal>max_rfer</literal> shows the quota in bytes.
      </para>
<screen>&prompt.sudo;btrfs qgroup show -r /</screen>
     </step>
    </procedure>
    <tip>
     <title>Nullifying a quota</title>
     <para>
      In case you want to nullify an existing quota, set a quota size of
      <literal>none</literal>:
     </para>
<screen>&prompt.sudo;btrfs qgroup limit none /var/tmp</screen>
     <para>
      To disable quota support for a partition and all its subvolumes, use
      <command>btrfs quota disable</command>:
     </para>
<screen>&prompt.sudo;btrfs quota disable /</screen>
    </tip>
   </sect3>
   <sect3 xml:id="setting-btrfs-quotas-for-more-info">
    <title>More information</title>
    <para>
     See the <command>man 8 btrfs-qgroup</command> and <command>man 8
     btrfs-quota</command> for more details. The
     <citetitle>UseCases</citetitle> page on the Btrfs wiki
     (<link
      xlink:href="https://btrfs.wiki.kernel.org/index.php/UseCases"/>)
     also provides more information.
    </para>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-filesystems-major-btrfs-swapping">
   <title>Swapping on Btrfs</title>
   <important>
    <title>Snapshots with swapping</title>
    <para>
     You will not be able to create a snapshot if the source subvolume contains
     any enabled swap files.
    </para>
   </important>
   <para>
    &slsa; supports swapping to a file on the Btrfs file system if the
    following criteria relating to the resulting swap file are fulfilled:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      The swap file must have the <option>NODATACOW</option> and
      <option>NODATASUM</option> mount options.
     </para>
    </listitem>
    <listitem>
     <para>
      The swap file can not be compressed&mdash;you can ensure this by setting
      the <option>NODATACOW</option> and <option>NODATASUM</option> mount
      options. Both options disable swap file compression.
     </para>
    </listitem>
    <listitem>
     <para>
      The swap file cannot be activated while exclusive operations are
      running&mdash;such as device resizing, adding, removing, or replacing, or
      when a balancing operation is running.
     </para>
    </listitem>
    <listitem>
     <para>
      The swap file cannot be sparse.
     </para>
    </listitem>
    <listitem>
     <para>
      The swap file can not be an inline file.
     </para>
    </listitem>
    <listitem>
     <para>
      The swap file must be on a <literal>single</literal> allocation profile
      file system.
     </para>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 xml:id="sec-filesystems-major-btrfs-s-r">
   <title>Btrfs send/receive</title>
   <para>
    Btrfs allows to make snapshots to capture the state of the file system.
    Snapper, for example, uses this feature to create snapshots before and
    after system changes, allowing a rollback. However, together with the
    send/receive feature, snapshots can also be used to create and maintain
    copies of a file system in a remote location. This feature can, for
    example, be used to do incremental backups.
   </para>
   <para>
    A <command>btrfs send</command> operation calculates the difference between
    two read-only snapshots from the same subvolume and sends it to a file or
    to STDOUT. A <command>btrfs receive</command> operation takes the result of
    the send command and applies it to a snapshot.
   </para>
   <sect3 xml:id="sec-filesystems-major-btrfs-s-r-requires">
    <title>Prerequisites</title>
    <para>
     To use the send/receive feature, the following requirements need to be
     met:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       A Btrfs file system is required on the source side
       (<literal>send</literal>) and on the target side
       (<literal>receive</literal>).
      </para>
     </listitem>
     <listitem>
      <para>
       Btrfs send/receive operates on snapshots, therefore the respective data
       needs to reside in a Btrfs subvolume.
      </para>
     </listitem>
     <listitem>
      <para>
       Snapshots on the source side need to be read-only.
      </para>
     </listitem>
     <listitem>
      <para>
       &sle; 12 SP2 or better. Earlier versions of &sle; do not support
       send/receive.
      </para>
     </listitem>
    </itemizedlist>
   </sect3>
   <sect3 xml:id="sec-filesystems-major-btrfs-s-r-backup">
    <title>Incremental backups</title>
    <para>
     The following procedure shows the basic usage of Btrfs send/receive using
     the example of creating incremental backups of <filename>/data</filename>
     (source side) in <filename>/backup/data</filename> (target side).
     <filename>/data</filename> needs to be a subvolume.
    </para>
    <procedure>
     <title>Initial setup</title>
     <step>
      <para>
       Create the initial snapshot (called <literal>snapshot_0</literal> in
       this example) on the source side and make sure it is written to the
       disk:
      </para>
<screen>&prompt.sudo;btrfs subvolume snapshot -r /data /data/bkp_data
sync</screen>
      <para>
       A new subvolume <filename>/data/bkp_data</filename> is created. It will
       be used as the basis for the next incremental backup and should be kept
       as a reference.
      </para>
     </step>
     <step>
      <para>
       Send the initial snapshot to the target side. Since this is the initial
       send/receive operation, the complete snapshot needs to be sent:
      </para>
<screen>&prompt.sudo;bash -c 'btrfs send /data/bkp_data | btrfs receive /backup'</screen>
      <para>
       A new subvolume <filename>/backup/bkp_data</filename> is created on the
       target side.
      </para>
     </step>
    </procedure>
    <para>
     When the initial setup has been finished, you can create incremental
     backups and send the differences between the current and previous
     snapshots to the target side. The procedure is always the same:
    </para>
    <orderedlist>
     <listitem>
      <para>
       Create a new snapshot on the source side.
      </para>
     </listitem>
     <listitem>
      <para>
       Send the differences to the target side.
      </para>
     </listitem>
     <listitem>
      <para>
       Optional: Rename and/or clean up snapshots on both sides.
      </para>
     </listitem>
    </orderedlist>
    <procedure>
     <title>Performing an incremental backup</title>
     <step>
      <para>
       Create a new snapshot on the source side and make sure it is written to
       the disk. In the following example the snapshot is named
       bkp_data_<replaceable>CURRENT_DATE</replaceable>:
      </para>
<screen>&prompt.sudo;btrfs subvolume snapshot -r /data /data/bkp_data_$(date +%F)
sync</screen>
      <para>
       A new subvolume, for example
       <filename>/data/bkp_data_2016-07-07</filename>, is created.
      </para>
     </step>
     <step>
      <para>
       Send the difference between the previous snapshot and the one you have
       created to the target side. This is achieved by specifying the previous
       snapshot with the option <option>-p
       <replaceable>SNAPSHOT</replaceable></option>.
      </para>
<screen>&prompt.sudo;bash -c 'btrfs send -p /data/bkp_data /data/bkp_data_2016-07-07 \
| btrfs receive /backup'</screen>
      <para>
       A new subvolume <filename>/backup/bkp_data_2016-07-07</filename> is
       created.
      </para>
     </step>
     <step>
      <para>
       As a result four snapshots, two on each side, exist:
      </para>
      <simplelist><member><filename>/data/bkp_data</filename></member><member><filename>/data/bkp_data_2016-07-07</filename></member><member><filename>/backup/bkp_data</filename></member><member><filename>/backup/bkp_data_2016-07-07</filename></member>
      </simplelist>
      <para>
       Now you have three options for how to proceed:
      </para>
      <itemizedlist>
       <listitem>
        <para>
         Keep all snapshots on both sides. With this option you can roll back
         to any snapshot on both sides while having all data duplicated at the
         same time. No further action is required. When doing the next
         incremental backup, keep in mind to use the next-to-last snapshot as
         parent for the send operation.
        </para>
       </listitem>
       <listitem>
        <para>
         Only keep the last snapshot on the source side and all snapshots on
         the target side. Also allows to roll back to any snapshot on both
         sides&mdash;to do a rollback to a specific snapshot on the source
         side, perform a send/receive operation of a complete snapshot from the
         target side to the source side. Do a delete/move operation on the
         source side.
        </para>
       </listitem>
       <listitem>
        <para>
         Only keep the last snapshot on both sides. This way you have a backup
         on the target side that represents the state of the last snapshot made
         on the source side. It is not possible to roll back to other
         snapshots. Do a delete/move operation on the source and the target
         side.
        </para>
       </listitem>
      </itemizedlist>
      <substeps>
       <step>
        <para>
         To only keep the last snapshot on the source side, perform the
         following commands:
        </para>
<screen>&prompt.sudo;btrfs subvolume delete /data/bkp_data
&prompt.sudo;mv /data/bkp_data_2016-07-07 /data/bkp_data</screen>
        <para>
         The first command will delete the previous snapshot, the second
         command renames the current snapshot to
         <filename>/data/bkp_data</filename>. This ensures that the last
         snapshot that was backed up is always named
         <filename>/data/bkp_data</filename>. As a consequence, you can also
         always use this subvolume name as a parent for the incremental send
         operation.
        </para>
       </step>
       <step>
        <para>
         To only keep the last snapshot on the target side, perform the
         following commands:
        </para>
<screen>&prompt.sudo;btrfs subvolume delete /backup/bkp_data
&prompt.sudo;mv /backup/bkp_data_2016-07-07 /backup/bkp_data</screen>
        <para>
         The first command will delete the previous backup snapshot, the second
         command renames the current backup snapshot to
         <filename>/backup/bkp_data</filename>. This ensures that the latest
         backup snapshot is always named <filename>/backup/bkp_data</filename>.
        </para>
       </step>
      </substeps>
     </step>
    </procedure>
    <tip>
     <title>Sending to a remote target side</title>
     <para>
      To send the snapshots to a remote machine, use SSH:
     </para>
<screen>&prompt.user;btrfs send /data/bkp_data | ssh root@&wsIname; 'btrfs receive /backup'</screen>
    </tip>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-filesystems-major-btrfs-deduplication">
   <title>Data deduplication support</title>
   <para>
    Btrfs supports data deduplication by replacing identical blocks in the file
    system with logical links to a single copy of the block in a common storage
    location. &productname; provides the tool <command>duperemove</command> for
    scanning the file system for identical blocks. When used on a Btrfs file
    system, it can also be used to deduplicate these blocks and thus save space
    on the file system. <command>duperemove</command> is not installed by
    default. To make it available, install the package
    <package>duperemove</package> .
   </para>
   <note>
    <title>Deduplicating large datasets</title>
    <para>
     If you intend to deduplicate a large amount of files, use the
     <option>--hashfile</option> option:
    </para>
<screen>&prompt.sudo;duperemove <option>--hashfile <replaceable>HASH_FILE</replaceable></option> file1 file2 file3</screen>
    <para>
     The <option>--hashfile</option> option stores hashes of all specified
     files into the <replaceable>HASH_FILE</replaceable> instead of RAM and
     prevents it from being exhausted. <replaceable>HASH_FILE</replaceable> is
     reusable&mdash;you can deduplicate changes to large datasets very quickly
     after an initial run that generated a baseline hash file.
    </para>
   </note>
   <para>
    <command>duperemove</command> can either operate on a list of files or
    recursively scan a directory:
   </para>
<screen>&prompt.sudo;duperemove <replaceable>OPTIONS</replaceable> file1 file2 file3
&prompt.sudo;duperemove -r <replaceable>OPTIONS</replaceable> directory</screen>
   <para>
    It operates in two modes: read-only and de-duping. When run in read-only
    mode (that is without the <option>-d</option> switch), it scans the given
    files or directories for duplicated blocks and prints them. This works on
    any file system.
   </para>
   <para>
    Running <command>duperemove</command> in de-duping mode is only supported
    on Btrfs file systems. After having scanned the given files or directories,
    the duplicated blocks will be submitted for deduplication.
   </para>
   <para>
    For more information see <command>man 8 duperemove</command>.
   </para>
  </sect2>

  <sect2 xml:id="btrfs-delete-subvolumes">
   <title>Deleting subvolumes from the root file system</title>
   <para>
    You may need to delete one of the default Btrfs subvolumes from the root
    file system for specific purposes. One of them is transforming a
    subvolume&mdash;for example <filename>@/home</filename> or
    <filename>@/srv</filename>&mdash;into a file system on a separate device.
    The following procedure illustrates how to delete a Btrfs subvolume:
   </para>
   <procedure>
    <step>
     <para>
      Identify the subvolume you need to delete (for example
      <filename>@/opt</filename>). Notice that the root path has always
      subvolume ID '5'.
     </para>
<screen>
&prompt.user;&sudo; btrfs subvolume list /
ID 256 gen 30 top level 5 path @
ID 258 gen 887 top level 256 path @/var
ID 259 gen 872 top level 256 path @/usr/local
ID 260 gen 886 top level 256 path @/tmp
ID 261 gen 60 top level 256 path @/srv
ID 262 gen 886 top level 256 path @/root
ID 263 gen 39 top level 256 path @/opt
[...]
</screen>
    </step>
    <step>
     <para>
      Find the device name that hosts the root partition:
     </para>
<screen>
&prompt.user;&sudo; btrfs device usage /
/dev/sda1, ID: 1
  Device size:            23.00GiB
  Device slack:              0.00B
  Data,single:             7.01GiB
  Metadata,DUP:            1.00GiB
  System,DUP:             16.00MiB
  Unallocated:            14.98GiB
</screen>
    </step>
    <step>
     <para>
      Mount the root file system (subvolume with ID 5) on a separate mount
      point (for example <filename>/mnt</filename>):
     </para>
<screen>&prompt.user;&sudo; mount -o subvolid=5 /dev/sda1 /mnt</screen>
    </step>
    <step>
     <para>
      Delete the <filename>@/opt</filename> partition from the mounted root
      file system:
     </para>
<screen>&prompt.user;&sudo; btrfs subvolume delete /mnt/@/opt</screen>
    </step>
    <step>
     <para>
      Unmount the previously mounted root file system:
     </para>
<screen>&prompt.user;&sudo; umount /mnt</screen>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-filesystems-major-xfs">
  <title>XFS</title>

  <para>
   Originally intended as the file system for their IRIX OS, SGI started XFS
   development in the early 1990s. The idea behind XFS was to create a
   high-performance 64-bit journaling file system to meet extreme computing
   challenges. XFS is very good at manipulating large files and performs well
   on high-end hardware.
   <!-- However, even XFS has a drawback.
    Like ReiserFS, XFS takes great care of metadata integrity, but less
    care of data integrity. -->
   XFS is the default file system for data partitions in &productname;.
  </para>

  <para>
   A quick review of XFSâ€™s key features explains why it might prove to be a
   strong competitor for other journaling file systems in high-end computing.
  </para>

  <variablelist>
   <varlistentry>
    <term>High scalability</term>
    <listitem>
     <para>
      XFS offers high scalability by using allocation groups
     </para>
     <para>
      At the creation time of an XFS file system, the block device underlying
      the file system is divided into eight or more linear regions of equal
      size. Those are called <emphasis>allocation groups</emphasis>. Each
      allocation group manages its own inodes and free disk space. Practically,
      allocation groups can be seen as file systems in a file system. Because
      allocation groups are rather independent of each other, more than one of
      them can be addressed by the kernel simultaneously. This feature is the
      key to XFSâ€™s great scalability. Naturally, the concept of independent
      allocation groups suits the needs of multiprocessor systems.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>High performance</term>
    <listitem>
     <para>
      XFS offers high performance through efficient management of disk space
     </para>
     <para>
      Free space and inodes are handled by B<superscript>+</superscript> trees
      inside the allocation groups. The use of B<superscript>+</superscript>
      trees greatly contributes to XFSâ€™s performance and scalability. XFS uses
      <emphasis>delayed allocation</emphasis>, which handles allocation by
      breaking the process into two pieces. A pending transaction is stored in
      RAM and the appropriate amount of space is reserved. XFS still does not
      decide where exactly (in file system blocks) the data should be stored.
      This decision is delayed until the last possible moment. Some short-lived
      temporary data might never make its way to disk, because it is obsolete
      by the time XFS decides where to save it. In this way, XFS
      increases write performance and reduces file system fragmentation.
      Because delayed allocation results in less frequent write events than in
      other file systems, it is likely that data loss after a crash during a
      write is more severe.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Preallocation to avoid file system fragmentation</term>
    <listitem>
     <para>
      Before writing the data to the file system, XFS
      <emphasis>reserves</emphasis> (preallocates) the free space needed for a
      file. Thus, file system fragmentation is greatly reduced. Performance is
      increased because the contents of a file are not distributed all over the
      file system.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <sect2 xml:id="sec-filesystems-major-prealloc">
   <title>XFS formats</title>
   <para>
    &productname; supports the <quote>on-disk format</quote> (v5) of the XFS
    file system. The main advantages of this format are automatic checksums of
    all XFS metadata, file type support, and support for a larger number of
    access control lists for a file.
   </para>
   <para>
    Note that this format is not supported by &sle; kernels older than version
    3.12, by <literal>xfsprogs</literal> older than version 3.2.0, and &grub;
    versions released before &sle; 12.
   </para>
   <important>
    <title>V4 is deprecated</title>
    <para>
     XFS is deprecating file systems with the V4 format. This file system
     format was created by the command:
    </para>
<screen>mkfs.xfs -m crc=0 <replaceable>DEVICE</replaceable></screen>
    <para>
     The format was used in SLE 11 and older releases and currently it creates
     a warning message by <command>dmesg</command>:
    </para>
<screen>Deprecated V4 format (crc=0) will not be supported after September 2030</screen>
    <para>
     If you see the message above in the output of the <command>dmesg</command>
     command, it is recommended that you update your file system to the V5
     format:
    </para>
    <procedure>
     <step>
      <para>
       Back up your data to another device.
      </para>
     </step>
     <step>
      <para>
       Create the file system on the device.
      </para>
<screen>mkfs.xfs -m crc=1 <replaceable>DEVICE</replaceable></screen>
     </step>
     <step>
      <para>
       Restore the data from the backup on the updated device.
      </para>
     </step>
    </procedure>
   </important>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-filesystems-major-ext2">
  <title>Ext2</title>

  <para>
   The origins of Ext2 go back to the early days of Linux history. Its
   predecessor, the Extended File System, was implemented in April 1992 and
   integrated in Linux 0.96c. The Extended File System underwent several
   modifications and, as Ext2, became the most popular Linux file system for
   years. With the creation of journaling file systems and their short recovery
   times, Ext2 became less important.
  </para>

  <para>
   A brief summary of Ext2â€™s strengths might help understand why it
   was&mdash;and in some areas still is&mdash;the favorite Linux file system of
   many Linux users.
  </para>

  <variablelist>
   <varlistentry>
    <term>Solidity and speed</term>
    <listitem>
     <para>
      Being an <quote>old-timer</quote>, Ext2 underwent many improvements and
      was heavily tested. This might be the reason people often refer to it as
      rock-solid. After a system outage when the file system could not be
      cleanly unmounted, e2fsck starts to analyze the file system data.
      Metadata is brought into a consistent state and pending files or data
      blocks are written to a designated directory (called
      <filename>lost+found</filename>). In contrast to journaling file systems,
      e2fsck analyzes the entire file system and not only the recently modified
      bits of metadata. This takes significantly longer than checking the log
      data of a journaling file system. Depending on file system size, this
      procedure can take half an hour or more. Therefore, it is not desirable
      to choose Ext2 for any server that needs high availability. However,
      because Ext2 does not maintain a journal and uses less memory, it is
      sometimes faster than other file systems.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Easy upgradability</term>
    <listitem>
     <para>
      Because Ext3 is based on the Ext2 code and shares its on-disk format and
      its metadata format, upgrades from Ext2 to Ext3 are very easy.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 xml:id="sec-filesystems-major-ext3">
  <title>Ext3</title>

  <para>
   Ext3 was designed by Stephen Tweedie. Unlike all other next-generation file
   systems, Ext3 does not follow a completely new design principle. It is based
   on Ext2. These two file systems are very closely related to each other. An
   Ext3 file system can be easily built on top of an Ext2 file system. The most
   important difference between Ext2 and Ext3 is that Ext3 supports journaling.
   In summary, Ext3 has three major advantages to offer:
  </para>

  <sect2 xml:id="sec-filesystems-major-ext3-upgrade">
   <title>Easy and highly reliable upgrades from ext2</title>
   <para>
    The code for Ext2 is the strong foundation on which Ext3 could become a
    highly acclaimed next-generation file system. Its reliability and solidity
    are elegantly combined in Ext3 with the advantages of a journaling file
    system. Unlike transitions to other journaling file systems, such as XFS,
    which can be quite tedious (making backups of the entire file system and
    re-creating it from scratch), a transition to Ext3 is a matter of minutes.
    It is also very safe, because re-creating an entire file system from
    scratch might not work flawlessly. Considering the number of existing Ext2
    systems that await an upgrade to a journaling file system, you can easily
    see why Ext3 might be of some importance to many system administrators.
    Downgrading from Ext3 to Ext2 is as easy as the upgrade. Perform a clean
    unmount of the Ext3 file system and remount it as an Ext2 file system.
   </para>
  </sect2>

  <!-- JH: Moved this to ext4.
   <sect2 xml:id="sec-filesystems-major-ext3-performance">
   <title>Reliability and performance</title>
   <para>
   Some other journaling file systems follow the <quote>metadata-only</quote>
   journaling approach. This means your metadata is always kept in a
   consistent state, but this cannot be automatically guaranteed for the file
   system data itself. Ext3 is designed to take care of both metadata and
   data. The degree of <quote>care</quote> can be customized. Enabling Ext3 in
   the <option>data=journal</option> mode offers maximum security (data
   integrity), but can slow down the system because both metadata and data are
   journaled. A relatively new approach is to use the
   <option>data=ordered</option> mode, which ensures both data and metadata
   integrity, but uses journaling only for metadata. The file system driver
   collects all data blocks that correspond to one metadata update. These data
   blocks are written to disk before the metadata is updated. As a result,
   consistency is achieved for metadata and data without sacrificing
   performance. A third option to use is <option>data=writeback</option>,
   which allows data to be written to the main file system after its metadata
   has been committed to the journal. This option is often considered the best
   in performance. It can, however, allow old data to reappear in files after
   crash and recovery while internal file system integrity is maintained. Ext3
   uses the <option>data=ordered</option> option as the default.
   </para>
   </sect2>
   -->

  <sect2 xml:id="sec-filesystems-major-ext3-ext22ext3a">
   <title>Converting an ext2 file system into ext3</title>
   <para>
    To convert an Ext2 file system to Ext3:
   </para>
   <procedure>
    <step>
     <para>
      Create an Ext3 journal by running <command>tune2fs -j</command> as the
      &rootuser; user.
     </para>
     <para>
      This creates an Ext3 journal with the default parameters.
     </para>
     <para>
      To specify how large the journal should be and on which device it should
      reside, run <command>tune2fs</command> <option>-J</option> instead
      together with the desired journal options <option>size=</option> and
      <option>device=</option>. More information about the
      <command>tune2fs</command> program is available in the
      <command>tune2fs</command> man page.
     </para>
    </step>
    <step>
     <para>
      Edit the file <filename>/etc/fstab</filename> as the &rootuser; user to
      change the file system type specified for the corresponding partition
      from <literal>ext2</literal> to <literal>ext3</literal>, then save the
      changes.
     </para>
     <para>
      This ensures that the Ext3 file system is recognized as such. The change
      takes effect after the next reboot.
     </para>
    </step>
    <step>
     <para>
      To boot a root file system that is set up as an Ext3 partition, add the
      modules <literal>ext3</literal> and <literal>jbd</literal> in the
      <filename>initrd</filename>. Do so by
     </para>
     <substeps performance="required">
      <step>
       <para>
        opening or creating
        <filename>/etc/dracut.conf.d/filesystem.conf</filename> and adding the
        following line (mind the leading blank space):
       </para>
<screen>force_drivers+=" ext3 jbd"</screen>
      </step>
      <step>
       <para>
        and running the <command>dracut</command> <option>-f</option> command.
       </para>
      </step>
     </substeps>
    </step>
    <step>
     <para>
      Reboot the system.
     </para>
    </step>
   </procedure>
  </sect2>

  <!-- moved to the ext4 section with updates, as this is heavily outdated
   <sect2 xml:id="sec-filesystems-major-ext3-inodesize">
   <title>Ext3 file system inode size and number of inodes</title>
   <para>
   An inode stores information about the file and its block location in the
   file system. To allow space in the inode for extended attributes and ACLs,
   the default inode size for Ext3 was increased from 128 bytes on SLES 10 to
   256 bytes on SLES 11. As compared to SLES 10, when you make a new Ext3 file
   system on SLES 11, the default amount of space preallocated for the same
   number of inodes is doubled, and the usable space for files in the file
   system is reduced by that amount. Thus, you must use larger partitions to
   accommodate the same number of inodes and files than were possible for an
   Ext3 file system on SLES 10.
   </para>
   <para>
   When you create a new Ext3 file system, the space in the inode table is
   preallocated for the total number of inodes that can be created. The
   bytes-per-inode ratio and the size of the file system determine how many
   inodes are possible. When the file system is made, an inode is created for
   every bytes-per-inode bytes of space:
   </para>
   <screen>number of inodes = total size of the file system divided by the number of bytes per inode</screen>
   <para>
   The number of inodes controls the number of files you can have in the file
   system: one inode for each file. To address the increased inode size and
   reduced usable space available, the default for the bytes-per-inode ratio
   was increased from 8192 bytes on SLES 10 to 16384 bytes on SLES 11. The
   doubled ratio means that the number of files that can be created is
   one-half of the number of files possible for an Ext3 file system on SLES
   10.
   </para>
   <important>
   <title>Changing the inode size of an existing ext3 file system</title>
   <para>
   After the inodes are allocated, you cannot change the settings for the
   inode size or bytes-per-inode ratio. No new inodes are possible without
   re-creating the file system with different settings, or unless the file
   system gets extended. When you exceed the maximum number of inodes, no new
   files can be created on the file system until some files are deleted.
   </para>
   </important>
   <para>
   When you make a new Ext3 file system, you can specify the inode size and
   bytes-per-inode ratio to control inode space usage and the number of files
   possible on the file system. If the blocks size, inode size, and
   bytes-per-inode ratio values are not specified, the default values in the
   <filename>/etc/mked2fs.conf</filename> file are applied. For information,
   see the <filename>mke2fs.conf(5)</filename> man page.
   </para>
   <para>
   Use the following guidelines:
   </para>
   <itemizedlist mark="bullet" spacing="normal">
   <listitem>
   <formalpara>
   <title>Inode size:</title>
   <para>
   The default inode size is 256 bytes. Specify a value in bytes that is a
   power of 2 and equal to 128 or larger in bytes and up to the block size,
   such as 128, 256, 512, and so on. Use 128 bytes only if you do not use
   extended attributes or ACLs on your Ext3 file systems.
   </para>
   </formalpara>
   </listitem>
   <listitem>
   <formalpara>
   <title>Bytes-per-inode ratio:</title>
   <para>
   The default bytes-per-inode ratio is 16384 bytes. Valid bytes-per-inode
   ratio values must be a power of 2 equal to 1024 or greater in bytes,
   such as 1024, 2048, 4096, 8192, 16384, 32768, and so on. This value
   should not be smaller than the block size of the file system, because
   the block size is the smallest chunk of space used to store data. The
   default block size for the Ext3 file system is 4 KB.
   </para>
   </formalpara>
   <para>
   In addition, consider the number of files and the size of files you need
   to store. For example, if your file system will have many small files,
   you can specify a smaller bytes-per-inode ratio, which increases the
   number of inodes. If your file system will have very large files, you can
   specify a larger bytes-per-inode ratio, which reduces the number of
   possible inodes.
   </para>
   <para>
   Generally, it is better to have too many inodes than to run out of them.
   If you have too few inodes and very small files, you could reach the
   maximum number of files on a disk that is practically empty. If you have
   too many inodes and very large files, you might have free space reported
   but be unable to use it because you cannot create new files in space
   reserved for inodes.
   </para>
   </listitem>
   </itemizedlist>
   <para>
   If you do not use extended attributes or ACLs on your Ext3 file systems,
   you can restore the SLES 10 behavior specifying 128 bytes as the inode size
   and 8192 bytes as the bytes-per-inode ratio when you make the file system.
   Use any of the following methods to set the inode size and bytes-per-inode
   ratio:
   </para>
   <itemizedlist mark="bullet" spacing="normal">
   <listitem>
   <formalpara>
   <title>Modifying the default settings for all new ext3 files:</title>
   <para>
   In a text editor, modify the <literal>defaults</literal> section of the
   <filename>/etc/mke2fs.conf</filename> file to set the
   <literal>inode_size</literal> and <literal>inode_ratio</literal> to the
   desired default values. The values apply to all new Ext3 file systems.
   For example:
   </para>
   </formalpara>
   <screen>blocksize = 4096
   inode_size = 128
   inode_ratio = 8192</screen>
   </listitem>
   <listitem>
   <formalpara>
   <title>At the command line:</title>
   <para>
   Pass the inode size (<literal>-I 128</literal>) and the bytes-per-inode
   ratio (<literal>-i 8192</literal>) to the
   <command>mkfs.ext3(8)</command> command or the
   <command>mke2fs(8)</command> command when you create a new Ext3 file
   system. For example, use either of the following commands:
   </para>
   </formalpara>
   <screen>&prompt.sudo;mkfs.ext3 -b 4096 -i 8092 -I 128 /dev/sda2
   &prompt.sudo;mke2fs -t ext3 -b 4096 -i 8192 -I 128 /dev/sda2</screen>
   </listitem>
   <listitem>
   <formalpara>
   <title>During installation with &yast;:</title>
   <para>
   Pass the inode size and bytes-per-inode ratio values when you create a
   new Ext3 file system during the installation. In the &yast; Partitioner
   on the <guimenu>Edit Partition</guimenu> page under<guimenu> Formatting
   Options</guimenu>, select <guimenu>Format
   partition</guimenu><guimenu>Ext3</guimenu>, then click
   <guimenu>Options</guimenu>. In the <guimenu>File system
   options</guimenu> dialog, select the desired values from the
   <guimenu>Block Size in Bytes</guimenu>,
   <guimenu>Bytes-per-inode</guimenu>, and <guimenu>Inode Size</guimenu>
   drop-down box.
   </para>
   </formalpara>
   <para>
   For example, select 4096 for the <guimenu>Block Size in Bytes</guimenu>
   drop-down box, select 8192 from the <guimenu>Bytes per inode</guimenu>
   drop-down box, select 128 from the <guimenu>Inode Size</guimenu>
   drop-down box, then click <guimenu>OK</guimenu>.
   </para>
   <informalfigure>
   <mediaobject>
   <imageobject role="fo">
   <imagedata fileref="ext3_inode_yast_a.png" width="80%"/>
   </imageobject>
   <imageobject role="html">
   <imagedata fileref="ext3_inode_yast_a.png" width="100%"/>
   </imageobject>
   </mediaobject>
   </informalfigure>
   </listitem>
   <listitem>
   <formalpara>
   <title>During installation with &ay;:</title>
   <para>
   In an &ay; profile, you can use the <literal>fs_options </literal>tag to
   set the <literal>opt_bytes_per_inode</literal> ratio value of 8192 for
   -i and the <literal>opt_inode_density</literal> value of 128 for -I:
   </para>
   </formalpara>
   <screen>
   &lt;partitioning config:type="list"&gt;
   &lt;drive&gt;
   &lt;device&gt;/dev/sda&lt;/device&gt;
   &lt;initialize config:type="boolean"&gt;true&lt;/initialize&gt;
   &lt;partitions config:type="list"&gt;
   &lt;partition&gt;
   &lt;filesystem config:type="symbol"&gt;ext3&lt;/filesystem&gt;
   &lt;format config:type="boolean"&gt;true&lt;/format&gt;
   &lt;fs_options&gt;
   &lt;opt_bytes_per_inode&gt;
   &lt;option_str&gt;-i&lt;/option_str&gt;
   &lt;option_value&gt;8192&lt;/option_value&gt;
   &lt;/opt_bytes_per_inode&gt;
   &lt;opt_inode_density&gt;
   &lt;option_str&gt;-I&lt;/option_str&gt;
   &lt;option_value&gt;128&lt;/option_value&gt;
   &lt;/opt_inode_density&gt;
   &lt;/fs_options&gt;
   &lt;mount&gt;/&lt;/mount&gt;
   &lt;partition_id config:type="integer"&gt;131&lt;/partition_id&gt;
   &lt;partition_type&gt;primary&lt;/partition_type&gt;
   &lt;size&gt;25G&lt;/size&gt;
   &lt;/partition&gt;
   &lt;/partitions&gt;
   &lt;/drive&gt;
   &lt;partitioning&gt;</screen>
   </listitem>
   </itemizedlist>
   <para>
   For information, see
   <link xlink:href="https://www.suse.com/support/kb/doc.php?id=7009075"/>
   (<citetitle>SLES11 ext3 partitions can only store 50% of the files that can
   be stored on SLES10</citetitle> [Technical Information Document 7009075]).
   </para>
   </sect2>
   -->
 </sect1>
 <sect1 xml:id="sec-filesystems-major-ext4">
  <title>Ext4</title>

  <para>
   In 2006, Ext4 started as a fork from Ext3. It is the latest file system in
   the extended file system version. Ext4 was originally designed to increase
   storage size by supporting volumes with a size of up to 1 exbibyte, files
   with a size of up to 16 tebibytes and an unlimited number of subdirectories.
   Ext4 uses extents, instead of the traditional direct and indirect block
   pointers, to map the file contents. Usage of extents improves both storage
   and retrieval of data from disks.
  </para>

  <para>
   Ext4 also introduces several performance enhancements such as delayed block
   allocation and a much faster file system checking routine. Ext4 is also more
   reliable by supporting journal checksums and by providing time stamps
   measured in nanoseconds. Ext4 is fully backward compatible to Ext2 and
   Ext3&mdash;both file systems can be mounted as Ext4.
  </para>

  <note>
   <title>Ext3 functionality on Ext4</title>
   <para>
    The Ext3 functionality is fully supported by the Ext4 driver in the Ext4
    kernel module.
   </para>
  </note>

  <sect2 xml:id="sec-filesystems-major-ext4-performance">
   <title>Reliability and performance</title>
   <para>
    Some other journaling file systems follow the <quote>metadata-only</quote>
    journaling approach. This means your metadata is always kept in a
    consistent state, but this cannot be automatically guaranteed for the file
    system data itself. Ext4 is designed to take care of both metadata and
    data. The degree of <quote>care</quote> can be customized. Mounting Ext4 in
    the <option>data=journal</option> mode offers maximum security (data
    integrity), but can slow down the system because both metadata and data are
    journaled. Another approach is to use the <option>data=ordered</option>
    mode, which ensures both data and metadata integrity, but uses journaling
    only for metadata. The file system driver collects all data blocks that
    correspond to one metadata update. These data blocks are written to disk
    before the metadata is updated. As a result, consistency is achieved for
    metadata and data without sacrificing performance. A third mount option to
    use is <option>data=writeback</option>, which allows data to be written to
    the main file system after its metadata has been committed to the journal.
    This option is often considered the best in performance. It can, however,
    allow old data to reappear in files after crash and recovery while internal
    file system integrity is maintained. Ext4 uses the
    <option>data=ordered</option> option as the default.
   </para>
  </sect2>

  <sect2 xml:id="sec-filesystems-major-ext4-inodesize">
   <title>Ext4 file system inode size and number of inodes</title>
   <para>
    An inode stores information about the file and its block location in the
    file system. To allow space in the inode for extended attributes and ACLs,
    the default inode size was increased to 256 bytes.
   </para>
   <para>
    When you create a new Ext4 file system, the space in the inode table is
    preallocated for the total number of inodes that can be created. The
    bytes-per-inode ratio and the size of the file system determine how many
    inodes are possible. When the file system is made, an inode is created for
    every bytes-per-inode bytes of space:
   </para>
<screen>number of inodes = total size of the file system divided by the number of bytes per inode</screen>
   <para>
    The number of inodes controls the number of files you can have in the file
    system: one inode for each file.
   </para>
   <important>
    <title>Changing the inode size of an existing Ext4 file system not possible</title>
    <para>
     After the inodes are allocated, you cannot change the settings for the
     inode size or bytes-per-inode ratio. No new inodes are possible without
     re-creating the file system with different settings, or unless the file
     system gets extended. When you exceed the maximum number of inodes, no new
     files can be created on the file system until some files are deleted.
    </para>
   </important>
   <para>
    When you make a new Ext4 file system, you can specify the inode size and
    bytes-per-inode ratio to control inode space usage and the number of files
    possible on the file system. If the blocks size, inode size, and
    bytes-per-inode ratio values are not specified, the default values in the
    <filename>/etc/mked2fs.conf</filename> file are applied. For information,
    see the <filename>mke2fs.conf(5)</filename> man page.
   </para>
   <para>
    Use the following guidelines:
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <formalpara>
      <title>Inode size:</title>
      <para>
       The default inode size is 256 bytes. Specify a value in bytes that is a
       power of 2 and equal to 128 or larger in bytes and up to the block size,
       such as 128, 256, 512, and so on. Use 128 bytes only if you do not use
       extended attributes or ACLs on your Ext4 file systems.
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Bytes-per-inode ratio:</title>
      <para>
       The default bytes-per-inode ratio is 16384 bytes. Valid bytes-per-inode
       ratio values must be a power of 2 equal to 1024 or greater in bytes,
       such as 1024, 2048, 4096, 8192, 16384, 32768, and so on. This value
       should not be smaller than the block size of the file system, because
       the block size is the smallest chunk of space used to store data. The
       default block size for the Ext4 file system is 4 KiB.
      </para>
     </formalpara>
     <para>
      In addition, consider the number of files and the size of files you need
      to store. For example, if your file system will have many small files,
      you can specify a smaller bytes-per-inode ratio, which increases the
      number of inodes. If your file system will have very large files, you can
      specify a larger bytes-per-inode ratio, which reduces the number of
      possible inodes.
     </para>
     <para>
      Generally, it is better to have too many inodes than to run out of them.
      If you have too few inodes and very small files, you could reach the
      maximum number of files on a disk that is practically empty. If you have
      too many inodes and very large files, you might have free space reported
      but be unable to use it because you cannot create new files in space
      reserved for inodes.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Use any of the following methods to set the inode size and bytes-per-inode
    ratio:
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <formalpara>
      <title>Modifying the default settings for all new Ext4 file systems:</title>
      <para>
       In a text editor, modify the <literal>defaults</literal> section of the
       <filename>/etc/mke2fs.conf</filename> file to set the
       <literal>inode_size</literal> and <literal>inode_ratio</literal> to the
       desired default values. The values apply to all new Ext4 file systems.
       For example:
      </para>
     </formalpara>
<screen>blocksize = 4096
inode_size = 128
inode_ratio = 8192</screen>
    </listitem>
    <listitem>
     <formalpara>
      <title>At the command line:</title>
      <para>
       Pass the inode size (<literal>-I 128</literal>) and the bytes-per-inode
       ratio (<literal>-i 8192</literal>) to the
       <command>mkfs.ext4(8)</command> command or the
       <command>mke2fs(8)</command> command when you create a new Ext4 file
       system. For example, use either of the following commands:
      </para>
     </formalpara>
<screen>&prompt.sudo;mkfs.ext4 -b 4096 -i 8092 -I 128 /dev/sda2
&prompt.sudo;mke2fs -t ext4 -b 4096 -i 8192 -I 128 /dev/sda2</screen>
    </listitem>
    <listitem>
     <formalpara>
      <title>During installation with &yast;:</title>
      <para>
       Pass the inode size and bytes-per-inode ratio values when you create a
       new Ext4 file system during the installation. In the <guimenu>Expert
       Partitioner</guimenu>, select the partition, click
       <guimenu>Edit</guimenu>. Under <guimenu>Formatting Options</guimenu>,
       select <guimenu>Format device</guimenu><guimenu>Ext4</guimenu>, then
       click <guimenu>Options</guimenu>. In the <guimenu>Format
       options</guimenu> dialog, select the desired values from the
       <guimenu>Block Size in Bytes</guimenu>,
       <guimenu>Bytes-per-inode</guimenu>, and <guimenu>Inode Size</guimenu>
       drop-down box.
      </para>
     </formalpara>
     <para>
      For example, select 4096 for the <guimenu>Block Size in Bytes</guimenu>
      drop-down box, select 8192 from the <guimenu>Bytes per inode</guimenu>
      drop-down box, select 128 from the <guimenu>Inode Size</guimenu>
      drop-down box, then click <guimenu>OK</guimenu>.
     </para>
     <informalfigure>
      <mediaobject>
       <imageobject role="fo">
        <imagedata fileref="ext4_inode_yast_a.png" width="60%"/>
       </imageobject>
       <imageobject role="html">
        <imagedata fileref="ext4_inode_yast_a.png" width="100%"/>
       </imageobject>
      </mediaobject>
     </informalfigure>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 xml:id="sec-upgrade-to-ext4">
   <title>Upgrading to Ext4</title>
   <important>
    <title>Backup of data</title>
    <para>
     Back up all data on the file system before performing any update of your
     file system.
    </para>
   </important>
   <procedure>
    <title>Upgrading to ext4</title>
    <step>
     <para>
      To upgrade from Ext2 or Ext3, you must enable the following:
     </para>
     <variablelist>
      <title>Features required by Ext4</title>
      <varlistentry>
       <term>extents</term>
       <listitem>
        <para>
         contiguous blocks on the hard disk that are used to keep files close
         together and prevent fragmentation
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>unint_bg</term>
       <listitem>
        <para>
         lazy inode table initialization
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>dir_index</term>
       <listitem>
        <para>
         hashed b-tree lookups for large directories
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>on Ext2: <literal>as_journal</literal></term>
       <listitem>
        <para>
         enable journaling on your Ext2 file system.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
     <para>
      To enable the features, run:
     </para>
     <itemizedlist>
      <listitem>
       <para>
        on Ext3:
       </para>
<screen>&prompt.root;tune2fs -O extents,uninit_bg,dir_index <replaceable>DEVICE_NAME</replaceable></screen>
      </listitem>
      <listitem>
       <para>
        on Ext2:
       </para>
<screen>&prompt.root;tune2fs -O extents,uninit_bg,dir_index,has_journal <replaceable>DEVICE_NAME</replaceable></screen>
      </listitem>
     </itemizedlist>
    </step>
    <step>
     <para>
      As &rootuser; edit the <filename>/etc/fstab</filename> file: change the
      <literal>ext3</literal> or <literal>ext2</literal> record to
      <literal>ext4</literal>. The change takes effect after the next reboot.
     </para>
    </step>
    <step>
     <para>
      To boot a file system that is set up on an ext4 partition, add the modules:
      <literal>ext4</literal> and <literal>jbd</literal> in the
      <literal>initramfs</literal>. Open or create
      <filename>/etc/dracut.conf.d/filesystem.conf</filename> and add the
      following line:
     </para>
<screen>force_drivers+=" ext4 jbd"</screen>
     <para>
      You need to overwrite the existing dracut <filename>initramfs</filename>
      by running:
     </para>
<screen>dracut -f</screen>
    </step>
    <step>
     <para>
      Reboot your system.
     </para>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-filesystems-major-reiser">
  <title>ReiserFS</title>

  <para>
   ReiserFS support was completely removed with &productname; 15. To migrate
   your existing partitions to Btrfs, refer to
   <xref
    linkend="sec-filesystems-major-btrfs-migrate"/>.
  </para>
 </sect1>
 <sect1 xml:id="sec-filessytems-zfs">
  <title>OpenZFS and ZFS</title>

  <para>
   Neither the OpenZFS nor ZFS file systems are supported by
&suse;. Although ZFS was originally released by Sun under an open source
licence, the current Oracle Solaris ZFS is now closed source, and
therefore cannot be used by &suse;.  OpenZFS (based on the original ZFS)
is under the CDDL license that is incompatible with the GPL license
and therefore cannot be included in our kernels.  However, Btrfs
provides an excellent alternative to OpenZFS with a similar design
philosophy and is fully supported by &suse;.
  </para>
 </sect1>
 <sect1 xml:id="sec-filesystems-other">
  <title>Other supported file systems</title>

  <para role="intro">
   <xref linkend="tab-filesystems-other" xrefstyle="TableXRef"/> summarizes
   some other file systems supported by Linux. They are supported mainly to
   ensure compatibility and interchange of data with different kinds of media
   or foreign operating systems.
  </para>

  <table xml:id="tab-filesystems-other">
   <title>File system types in Linux</title>
   <tgroup cols="2">
    <colspec colnum="1" colname="1" colwidth="2381*"/>
    <colspec colnum="2" colname="2" colwidth="7620*"/>
    <thead>
     <row>
      <entry>
       <para>
        File System Type
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>
    <tbody>
     <!-- <row>
      <entry>
      <para>
      <systemitem>cramfs</systemitem>
      </para>
      </entry>
      <entry>
      <para>
      Compressed ROM file system: A compressed read-only file system for
      ROMs.
      </para>
      </entry>
      </row> -->
     <!-- <row>
      <entry>
      <para>
      <systemitem>hpfs</systemitem>
      </para>
      </entry>
      <entry>
      <para>
      High Performance File System: The IBM OS/2 standard file system. Only
      supported in read-only mode.
      </para>
      </entry>
      </row> -->
     <row>
      <entry>
       <para>
        <systemitem>iso9660</systemitem>
       </para>
      </entry>
      <entry>
       <para>
        Standard file system on CD-ROMs.
       </para>
      </entry>
     </row>
     <!-- <row>
      <entry>
      <para>
      <systemitem>minix</systemitem>
      </para>
      </entry>
      <entry>
      <para>
      This file system originated from academic projects on operating systems
      and was the first file system used in Linux. Today, it is used as a
      file system for floppy disks.
      </para>
      </entry>
      </row> -->
     <row>
      <entry>
       <para>
        <systemitem>msdos</systemitem>
       </para>
      </entry>
      <entry>
       <para>
        <filename>fat</filename>, the file system originally used by DOS, is
        today used by various operating systems.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <systemitem>nfs</systemitem>
       </para>
      </entry>
      <entry>
       <para>
        Network File System: Here, data can be stored on any machine in a
        network and access might be granted via a network.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <systemitem>ntfs</systemitem>
       </para>
      </entry>
      <entry>
       <para>
        Windows&nbsp;NT file system; read-only.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <systemitem>exfat</systemitem>
       </para>
      </entry>
      <entry>
       <para>
        File system optimized for use with flash memory, such as USB flash
        drives and SD cards.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <systemitem>smbfs</systemitem>
       </para>
      </entry>
      <entry>
       <para>
        Server Message Block is used by products such as Windows to enable file
        access over a network.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <systemitem>ufs</systemitem>
       </para>
      </entry>
      <entry>
       <para>
        Used by BSD, SunOS, and NextStep. Only supported in read-only mode.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <systemitem>umsdos</systemitem>
       </para>
      </entry>
      <entry>
       <para>
        Unix on MS-DOS: Applied on top of a standard <filename>fat</filename>
        file system, achieves Unix functionality (permissions, links, long file
        names) by creating special files.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <systemitem>vfat</systemitem>
       </para>
      </entry>
      <entry>
       <para>
        Virtual FAT: Extension of the <literal>fat</literal> file system
        (supports long file names).
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>
 <sect1 xml:id="sec-blacklist-filsystem">
  <title>Blocked file systems</title>

  <para>
   Due to security reasons, some file systems have been blocked from automatic
   mounting. These file systems are usually not maintained anymore and are not
   in common use. However, the kernel module for this file system can be
   loaded, because the in-kernel API is still compatible. A combination of
   user-mountable file systems and the automatic mounting of file systems on
   removable devices could result in the situation where unprivileged users
   might trigger the automatic loading of kernel modules, and the removable
   devices could store potentially malicious data.
  </para>

  <para>
   To get a list of file systems that are not allowed to be mounted
   automatically, run the following command:
  </para>

<screen>&prompt.sudo;rpm -ql suse-module-tools  | sed -nE 's/.*blacklist_fs-(.*)\.conf/\1/p'</screen>

  <para>
   If you try to mount a device with a blocked file system using the
   <command>mount</command>command, the command outputs an error message, for
   example:
  </para>

<screen>mount: /mnt/mx: unknown filesystem type 'minix' (hint: possibly blacklisted, see mount(8)).</screen>

  <para>
   To enable the mounting of the file system, you need to remove the particular
   file system from the blocklist. Each blocked file system has its own
   configuration file, for example, for <systemitem>efs</systemitem> it is
   <filename>/lib/modules.d/60-blacklist_fs-efs.conf</filename>. However, do
   not edit these files, as they are overwritten whenever the package
   <literal>suse-module-tools</literal> is updated. To allow automatic mounting
   of the blocked file system, you have the following options:
  </para>

  <itemizedlist>
   <listitem>
    <para>
     Create a symbolic link to <filename>/dev/null</filename>, for example, for
     the <emphasis>efs</emphasis> file system:
    </para>
<screen>&prompt.sudo;ln -s /dev/null /etc/modules.d/60-blacklist_fs-efs.conf</screen>
   </listitem>
   <listitem>
    <para>
     Copy the configuration file to <filename>/etc/modprobe.d</filename>:
    </para>
<screen>&prompt.sudo;cp /lib/modules.d/60-blacklist_fs-efs.conf /etc/modprobe.d/60-blacklist_fs-efs.conf</screen>
    <para>
     And comment the following statement in the configuration file:
    </para>
<screen># blacklist omfs</screen>
   </listitem>
  </itemizedlist>

  <para>
   Even though a file system cannot be mounted automatically, you can load the
   corresponding kernel module for the file system directly using
   <command>modprobe</command>:
  </para>

<screen>&prompt.sudo;modprobe <replaceable>FILESYSTEM</replaceable>
</screen>

  <para>
   For example, for the <systemitem>cramfs</systemitem> file system, the output
   looks as follows:
  </para>

<screen>unblacklist: loading cramfs file system module
unblacklist: Do you want to un-blacklist cramfs permanently (&lt;y>es/&lt;n>o/n&lt;e>ver)? y
unblacklist: cramfs un-blacklisted by creating /etc/modprobe.d/60-blacklist_fs-cramfs.conf</screen>

  <para>
   If you select <emphasis>yes</emphasis>, the <command>modprobe</command>
   command calls a script that creates a symbolic link from the configuration
   file of the provided file system to <filename>/dev/null</filename>. Thus,
   the file system is removed from the blocklist.
  </para>
 </sect1>
 <sect1 xml:id="sec-filesystems-lfs">
  <title>Large file support in Linux</title>

  <para>
   Originally, Linux supported a maximum file size of 2&nbsp;GiB
   (2<superscript>31</superscript> bytes). Unless a file system comes with
   large file support, the maximum file size on a 32-bit system is 2 GiB.
  </para>

  <para>
   Currently, all our standard file systems have LFS (large file support),
   which gives a maximum file size of 2<superscript>63</superscript> bytes in
   theory. <xref linkend="tab-filesystems-maxsize" xrefstyle="TableXRef"/>
   offers an overview of the current on-disk format limitations of Linux files
   and file systems. The numbers in the table assume that the file systems are
   using 4 KiB block size, which is a common standard. When using different
   block sizes, the results are different. The maximum file sizes in
   <xref linkend="tab-filesystems-maxsize" xrefstyle="TableXRef"/> can be
   larger than the file system's actual size when using sparse blocks.
  </para>

  <note>
   <title>Binary multiples</title>
   <para>
    In this document: 1024 Bytes = 1 KiB; 1024 KiB = 1 MiB; 1024 MiB = 1 GiB;
    1024 GiB = 1 TiB; 1024 TiB = 1 PiB; 1024 PiB = 1 EiB (see also
    <link xlink:href="http://physics.nist.gov/cuu/Units/binary.html"><citetitle>NIST:
    Prefixes for Binary Multiples</citetitle></link>.
   </para>
  </note>

  <table xml:id="tab-filesystems-maxsize">
   <title>Maximum sizes of files and file systems (on-disk format, 4 KiB block size)</title>
   <tgroup cols="3">
    <colspec colnum="1" colname="1" colwidth="3334*"/>
    <colspec colnum="2" colname="2" colwidth="3334*"/>
    <colspec colnum="3" colname="3" colwidth="3334*"/>
    <thead>
     <row>
      <entry>
       <para>
        File System (4 KiB Block Size)
       </para>
      </entry>
      <entry>
       <para>
        Maximum File System Size
       </para>
      </entry>
      <entry>
       <para>
        Maximum File Size
       </para>
      </entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <para>
        Btrfs
       </para>
      </entry>
      <entry>
       <para>
        16 EiB
       </para>
      </entry>
      <entry>
       <para>
        16 EiB
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        Ext3
       </para>
      </entry>
      <entry>
       <para>
        16 TiB
       </para>
      </entry>
      <entry>
       <para>
        2 TiB
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        Ext4
       </para>
      </entry>
      <entry>
       <para>
        1 EiB
       </para>
      </entry>
      <entry>
       <para>
        16 TiB
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        OCFS2 (a cluster-aware file system available in the High Availability
        Extension)
       </para>
      </entry>
      <entry>
       <para>
        16 TiB
       </para>
      </entry>
      <entry>
       <para>
        1 EiB
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        XFS
       </para>
      </entry>
      <entry>
       <para>
        16 EiB
       </para>
      </entry>
      <entry>
       <para>
        8 EiB
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        NFSv2 (client side)
       </para>
      </entry>
      <entry>
       <para>
        8 EiB
       </para>
      </entry>
      <entry>
       <para>
        2 GiB
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        NFSv3/NFSv4 (client side)
       </para>
      </entry>
      <entry>
       <para>
        8 EiB
       </para>
      </entry>
      <entry>
       <para>
        8 EiB
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <important>
   <title>Limitations</title>
   <para>
    <xref linkend="tab-filesystems-maxsize" xrefstyle="TableXRef"/> describes
    the limitations regarding the on-disk format. The Linux kernel imposes its
    own limits on the size of files and file systems handled by it. These are
    as follows:
   </para>
   <variablelist>
    <varlistentry>
     <term>File size</term>
     <listitem>
      <para>
       On 32-bit systems, files cannot exceed 2 TiB
       (2<superscript>41</superscript> bytes).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>File system size</term>
     <listitem>
      <para>
       File systems can be up to 2<superscript>73</superscript> bytes in size.
       However, this limit is still out of reach for the currently available
       hardware.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </important>
 </sect1>
 <sect1 xml:id="sec-filesystems-stor-limits">
  <title>Linux kernel storage limitations</title>

  <para>
   <xref linkend="tab-filesystems-stor-limits" xrefstyle="TableXRef"/>
   summarizes the kernel limits for storage associated with &productname;.
  </para>

  <table xml:id="tab-filesystems-stor-limits">
   <title>Storage limitations</title>
   <tgroup cols="2">
    <colspec colnum="1" colname="1" colwidth="5001*"/>
    <colspec colnum="2" colname="2" colwidth="5001*"/>
    <thead>
     <row>
      <entry>
       <para>
        Storage Feature
       </para>
      </entry>
      <entry>
       <para>
        Limitation
       </para>
      </entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <para>
        Maximum number of LUNs supported
       </para>
      </entry>
      <entry>
       <para>
        16384 LUNs per target.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        Maximum number of paths per single LUN
       </para>
      </entry>
      <entry>
       <para>
        No limit by default. Each path is treated as a normal LUN.
       </para>
       <para>
        The actual limit is given by the number of LUNs per target and the
        number of targets per HBA (16777215 for a Fibre Channel HBA).
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        Maximum number of HBAs
       </para>
      </entry>
      <entry>
       <para>
        Unlimited. The actual limit is determined by the amount of PCI slots of
        the system.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        Maximum number of paths with device-mapper-multipath (in total) per
        operating system
       </para>
      </entry>
      <entry>
       <para>
        Approximately 1024. The actual number depends on the length of the
        device number strings for each multipath device. It is a compile-time
        variable within multipath-tools, which can be raised if this limit
        poses a problem.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        Maximum size per block device
       </para>
      </entry>
      <entry>
       <para>
        Up to 8 EiB.
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>
 <sect1 xml:id="sec-filesystems-trouble-trim">
  <title>Freeing unused file system blocks</title>

  <para>
   On solid-state drives (SSDs) and thinly provisioned volumes, it is useful to
   trim blocks that are not in use by the file system. &productname; fully
   supports <literal>unmap</literal> and <literal>TRIM</literal> operations on
   all file systems supporting them.
  </para>

  <para>
   There are two types of commonly used TRIM&mdash;online
   <literal>TRIM</literal> and periodic <literal>TRIM</literal>. The most
   suitable way of trimming devices depends on your use case. In general, it is
   recommended to use periodic TRIM, especially if the device has enough free
   blocks. If the device is often near its full capacity, online TRIM is
   preferable.
  </para>

  <important>
   <title><literal>TRIM</literal> support on devices</title>
   <para>
    Always verify that your device supports the <literal>TRIM</literal>
    operation before you attempt to use it. Otherwise, you might lose your data
    on that device. To verify the <literal>TRIM</literal> support, run the
    command:
   </para>
<screen>&prompt.sudo;lsblk --discard</screen>
   <para>
    The command outputs information about all available block devices. If the
    values of the columns <literal>DISC-GRAN</literal> and
    <literal>DISC-MAX</literal> are non-zero, the device supports the
    <literal>TRIM</literal> operation.
   </para>
  </important>

  <sect2 xml:id="sec-filesystems-periodic-trim">
   <title>Periodic TRIM</title>
   <para>
    Periodic TRIM is handled by the <command>fstrim</command> command invoked
    by &systemd; on a regular basis. You can also run the command manually.
   </para>
   <para>
    To schedule periodic TRIM, enable the <literal>fstrim.timer</literal> as
    follows:
   </para>
<screen>&prompt.sudo;systemctl enable fstrim.timer</screen>
   <para>
    &systemd; creates a unit file in
    <filename>/usr/lib/systemd/system</filename>. By default, the service runs
    once a week, which is usually sufficient. However, you can change the
    frequency by configuring the <literal>OnCalendar</literal> option to a
    required value.
   </para>
   <para>
    The default behaviour of <command>fstrim</command> is to discard all blocks
    in the file system. You can use options when invoking the command to modify
    this behaviour. For example, you can pass the <literal>offset</literal>
    option to define the place where to start the trimming procedure. For
    details, see <command>man fstrim</command>.
   </para>
   <para>
    The <command>fstrim</command> command can perform trimming on all devices
    stored in the <filename>/etc/fstab</filename> file, which support the
    <literal>TRIM</literal> operation&mdash;use the <literal>-A</literal>
    option when invoking the command for this purpose.
   </para>
   <para>
    To disable the trimming of a particular device, add the option
    <literal>X-fstrim.notrim</literal> to the <filename>/etc/fstab</filename>
    file as follows:
   </para>
<screen>UID=83df497d-bd6d-48a3-9275-37c0e3c8dc74  /  btrfs  defaults,X-fstrim.notrim                      0  0
</screen>
  </sect2>

  <sect2 xml:id="sec-filesystem-online-trim">
   <title>Online TRIM</title>
   <para>
    Online TRIM of a device is performed each time data is written to the
    device.
   </para>
   <para>
    To enable online TRIM on a device, add the <literal>discard</literal>
    option to the <filename>/etc/fstab</filename> file as follows:
   </para>
<screen>UID=83df497d-bd6d-48a3-9275-37c0e3c8dc74  /  btrfs  defaults,discard</screen>
   <para>
    Alternatively, on the Ext4 file system you can use the
    <command>tune2fs</command> command to set the <literal>discard</literal>
    option in <filename>/etc/fstab</filename>:
   </para>
<screen>&prompt.sudo;tune2fs -o discard <replaceable>DEVICE</replaceable></screen>
   <para>
    The <literal>discard</literal> option is also added to
    <filename>/etc/fstab</filename> in case the device was mounted by
    <command>mount</command> with the <literal>discard</literal> option:
   </para>
<screen>&prompt.sudo;mount -o discard <replaceable>DEVICE</replaceable></screen>
   <note>
    <title>Drawbacks of online TRIM</title>
    <para>
     Using the <literal>discard</literal> option may decrease the lifetime of some
     lower-quality SSD devices. Online TRIM can also impact the performance of
     the device, for example, if a larger amount of data is deleted. In this
     situation, an erase block might be reallocated, and shortly afterwards,
     the same erase block might be marked as unused again.
    </para>
   </note>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-filesystems-trouble">
  <title>Troubleshooting file systems</title>

  <para>
   This section describes some known issues and possible solutions for file
   systems.
  </para>

  <sect2 xml:id="sec-filesystems-trouble-btrfs-volfull">
   <title>Btrfs error: no space is left on device</title>
   <para>
    The root (<filename>/</filename>) partition using the Btrfs file system
    stops accepting data. You receive the error <quote><literal>No space left
    on device</literal></quote>.
   </para>
   <para>
    See the following sections for information about possible causes and
    prevention of this issue.
   </para>
   <sect3 xml:id="sec-filesystems-trouble-btrfs-volfull-snapshots">
    <title>Disk space consumed by Snapper snapshots</title>
    <para>
     If Snapper is running for the Btrfs file system, the <quote><literal>No
     space left on device</literal></quote> problem is typically caused by
     having too much data stored as snapshots on your system.
    </para>
    <para>
     You can remove some snapshots from Snapper, however, the snapshots are not
     deleted immediately and might not free up as much space as you need.
    </para>
    <para>
     To delete files from Snapper:
    </para>
    <procedure>
     <step>
      <para>
       Open a terminal.
      </para>
     </step>
     <step>
      <para>
       At the command prompt, enter <command>btrfs filesystem show</command>,
       for example:
      </para>
<screen>&prompt.sudo;btrfs filesystem show
Label: none uuid: 40123456-cb2c-4678-8b3d-d014d1c78c78
 Total devices 1 FS bytes used 20.00GB
 devid 1 size 20.00GB used 20.00GB path /dev/sda3</screen>
     </step>
     <step>
      <para>
       Enter
      </para>
<screen>&prompt.sudo;btrfs fi balance start <replaceable>MOUNTPOINT</replaceable> -dusage=5</screen>
      <para>
       This command attempts to relocate data in empty or near-empty data
       chunks, allowing the space to be reclaimed and reassigned to metadata.
       This can take a while (many hours for 1&nbsp;TB) although the system is
       otherwise usable during this time.
      </para>
     </step>
     <step>
      <para>
       List the snapshots in Snapper. Enter
      </para>
<screen>&prompt.sudo;snapper -c root list</screen>
     </step>
     <step>
      <para>
       Delete one or more snapshots from Snapper. Enter
      </para>
<screen>&prompt.sudo;snapper -c root delete <replaceable>SNAPSHOT_NUMBER(S)</replaceable></screen>
      <para>
       Ensure that you delete the oldest snapshots first. The older a snapshot
       is, the more disk space it occupies.
      </para>
     </step>
    </procedure>
    <para>
     To help prevent this problem, you can change the Snapper cleanup
     algorithms. See <xref linkend="sec-snapper-manage-metadata-cleanup"/> for
     details. The configuration values controlling snapshot cleanup are
     <envar>EMPTY_*</envar>, <envar>NUMBER_*</envar>, and
     <envar>TIMELINE_*</envar>.
    </para>
    <para>
     If you use Snapper with Btrfs on the file system disk, it is advisable to
     reserve twice the amount of disk space than the standard storage proposal.
     The &yast; Partitioner automatically proposes twice the standard disk
     space in the Btrfs storage proposal for the root file system.
    </para>
   </sect3>
   <sect3 xml:id="sec-filesystems-trouble-btrfs-volfull-var">
    <title>Disk space consumed by log, crash, and cache files</title>
    <para>
     If the system disk is filling up with data, you can try deleting files
     from <filename>/var/log</filename>, <filename>/var/crash</filename>,
     <filename>/var/lib/systemd/coredump</filename> and
     <filename>/var/cache</filename>.
    </para>
    <para>
     The Btrfs &rootuser; file system subvolumes <filename>/var/log</filename>,
     <filename>/var/crash</filename> and <filename>/var/cache</filename> can
     use all of the available disk space during normal operation, and cause a
     system malfunction. To help avoid this situation, &productname; offers
     Btrfs quota support for subvolumes. See
     <xref linkend="sec-filesystems-major-btrfs-quota"/> for details.
    </para>
    <para>
     On test and development machines, especially if you have frequent crashes
     of applications, you may also want to have a look at
     <filename>/var/lib/systemd/coredump</filename> where the core dumps are
     stored.
    </para>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-filesystems-trouble-balance">
   <title>Btrfs: balancing data across devices</title>
   <para>
    The <command>btrfs balance</command> command is part of the
    <package>btrfs-progs</package> package. It balances block groups on Btrfs
    file systems in the following example situations:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Assume you have a 1&nbsp;TB drive with 600&nbsp;GB used by data and you
      add another 1&nbsp;TB drive. The balancing will theoretically result in
      having 300&nbsp;GB of used space on each drive.
     </para>
    </listitem>
    <listitem>
     <para>
      You have a lot of near-empty chunks on a device. Their space will not be
      available until the balancing has cleared those chunks.
     </para>
    </listitem>
    <listitem>
     <para>
      You need to compact half-empty block group based on the percentage of
      their usage. The following command will balance block groups whose usage
      is 5% or less:
     </para>
<screen>&prompt.sudo;btrfs balance start -dusage=5 /</screen>
     <tip>
      <para>
       The <filename>/usr/lib/systemd/system/btrfs-balance.timer</filename>
       timer takes care of cleaning up unused block groups on a monthly basis.
      </para>
     </tip>
    </listitem>
    <listitem>
     <para>
      You need to clear out non-full portions of block devices and spread data
      more evenly.
     </para>
    </listitem>
    <listitem>
     <para>
      You need to migrate data between different RAID types. For example, to
      convert data on a set of disks from RAID1 to RAID5, run the following
      command:
     </para>
<screen>&prompt.sudo;btrfs balance start -dprofiles=raid1,convert=raid5 /</screen>
    </listitem>
   </itemizedlist>
   <tip>
    <para>
     To fine-tune the default behavior of balancing data on Btrfs file
     systems&mdash;for example, how frequently or which mount points to
     balance&mdash; inspect and customize
     <filename>/etc/sysconfig/btrfsmaintenance</filename>. The relevant options
     start with <option>BTRFS_BALANCE_</option>.
    </para>
   </tip>
   <para>
    For details about the <command>btrfs balance</command> command usage, see
    its manual pages (<command>man 8 btrfs-balance</command>).
   </para>
  </sect2>

  <sect2 xml:id="sec-filesystems-trouble-defrag">
   <title>No defragmentation on SSDs</title>
   <para>
    Linux file systems contain mechanisms to avoid data fragmentation and
    usually it is not necessary to defragment. However, there are use cases,
    where data fragmentation cannot be avoided and where defragmenting the hard
    disk significantly improves the performance.
   </para>
   <para>
    This only applies to conventional hard disks. On solid state disks (SSDs)
    which use flash memory to store data, the firmware provides an algorithm
    that determines to which chips the data is written. Data is usually spread
    all over the device. Therefore defragmenting an SSD does not have the
    desired effect and will reduce the lifespan of an SSD by writing
    unnecessary data.
   </para>
   <para>
    For the reasons mentioned above, &suse; explicitly recommends
    <emphasis>not</emphasis> to defragment SSDs. Some vendors also warn about
    defragmenting solid state disks. This includes, but it is not limited to
    the following:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      HPE 3PAR StoreServ All-Flash
     </para>
    </listitem>
    <listitem>
     <para>
      HPE 3PAR StoreServ Converged Flash
     </para>
    </listitem>
   </itemizedlist>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-filesystems-info">
  <title>More information</title>

  <para>
   Each of the file system projects described above maintains its own home page
   on which to find mailing list information, further documentation, and FAQs:
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     The Btrfs Wiki on Kernel.org:
     <link xlink:href="https://btrfs.wiki.kernel.org/"/>
    </para>
   </listitem>
   <listitem>
    <para>
     E2fsprogs: Ext2/3/4 File System Utilities:
     <link xlink:href="http://e2fsprogs.sourceforge.net/"/>
    </para>
   </listitem>
   <listitem>
    <para>
     The OCFS2 Project:
     <link xlink:href="https://oss.oracle.com/projects/ocfs2/"/>
    </para>
   </listitem>
  </itemizedlist>

  <para>
   An in-depth comparison of file systems (not only Linux file systems) is
   available from the Wikipedia project in Comparison of File Systems
   (<link xlink:href="http://en.wikipedia.org/wiki/Comparison_of_file_systems#Comparison"/>).
  </para>
 </sect1>
</chapter>
