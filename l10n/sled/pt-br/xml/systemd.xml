<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="systemd.xml" version="5.0" xml:id="cha-systemd">
  <title>Daemon <systemitem class="daemon">systemd</systemitem></title>
  <info>
    <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
      <dm:bugtracker/>
      <dm:translation>yes</dm:translation>
    </dm:docmanager>
  </info>
  <para>
    <systemitem class="daemon">systemd</systemitem> inicializa o sistema. Ele tem o ID de processo 1. <systemitem class="daemon">systemd</systemitem> é iniciado diretamente pelo kernel e resiste ao sinal 9, que normalmente termina os processos. Todos os outros programas são iniciados diretamente pelo <systemitem class="daemon">systemd</systemitem> ou por um de seus processos filho. <systemitem class="daemon">systemd</systemitem> é um substituto do daemon init do System V e é totalmente compatível com o init do System V (com suporte a scripts init).
  </para>
  <para>
    A principal vantagem do <systemitem class="daemon">systemd</systemitem> é que ele acelera consideravelmente o tempo de boot ao paralelizar as inicializações de serviços. Além disso, o <systemitem class="daemon">systemd</systemitem> apenas inicia um serviço quando é realmente necessário. Os daemons não são iniciados incondicionalmente no momento da inicialização, mas quando são solicitados pela primeira vez. O <systemitem class="daemon">systemd</systemitem> também suporta Grupos de Controle do Kernel (cgroups), criação de instantâneos e restauração do estado do sistema. Para obter mais detalhes, consulte <link xlink:href="https://www.freedesktop.org/wiki/Software/systemd/"/>.
  </para>
  <tip>
    <title><systemitem class="daemon">systemd</systemitem> no WSL</title>
    <para>
      O Windows Subsystem for Linux (WSL) permite executar aplicativos e distribuições Linux no sistema operacional Microsoft Windows. O WSL usa o processo init próprio, em vez do <systemitem class="daemon">systemd</systemitem>. Para habilitar o <systemitem class="daemon">systemd</systemitem> no <phrase role="productname"><phrase os="sled">SLED</phrase></phrase> executado no WSL, instale o padrão <literal>wsl_systemd</literal> que automatiza o processo:
    </para>
<screen><prompt>&gt; </prompt><command>sudo</command> zypper in -t pattern wsl_systemd</screen>
    <para>
      Se preferir, edite <filename>/etc/wsl.conf</filename> e adicione as seguintes linhas manualmente:
    </para>
<screen>[boot]
systemd=true</screen>
    <para>
      Lembre-se de que o suporte para <systemitem class="daemon">systemd</systemitem> no WSL é parcial: os arquivos de unidade do <systemitem class="daemon">systemd</systemitem> devem ter um comportamento de gerenciamento de processos razoável.
    </para>
  </tip>
  <sect1 xml:id="sec-boot-systemd-concept">
    <title>Conceito do <systemitem class="daemon">systemd</systemitem></title>

    <para>
      A seção a seguir explica o conceito por trás do <systemitem class="daemon">systemd</systemitem>.
    </para>

    <para>
      O <systemitem class="daemon">systemd</systemitem> é um gerenciador de sistemas e sessões para Linux, compatível com os scripts init do System V e do LSB. Os principais recursos do <systemitem class="daemon">systemd</systemitem> são:
    </para>

    <itemizedlist mark="bullet" spacing="normal">
      <listitem>
        <para>
          recursos de paralelização
        </para>
      </listitem>
      <listitem>
        <para>
          ativação de soquete e D-Bus para iniciar serviços
        </para>
      </listitem>
      <listitem>
        <para>
          iniciar daemons sob demanda
        </para>
      </listitem>
      <listitem>
        <para>
          monitoramento de processos usando cgroups do Linux
        </para>
      </listitem>
      <listitem>
        <para>
          criação de instantâneos e restauração do estado do sistema
        </para>
      </listitem>
      <listitem>
        <para>
          manutenção dos pontos de montagem e automount
        </para>
      </listitem>
      <listitem>
        <para>
          implementação de uma lógica elaborada de controle de serviço baseada em dependência transacional
        </para>
      </listitem>
    </itemizedlist>

    <sect2 xml:id="sec-boot-systemd-unitfile">
      <title>Arquivo unit</title>
      <para>
        O arquivo de configuração unit contém informações sobre serviço, soquete, dispositivo, ponto de montagem, ponto de montagem automática, arquivo de troca (swap) ou partição, destino de inicialização, caminho do sistema de arquivos monitorado, temporizador controlado e supervisionado pelo <systemitem class="daemon">systemd</systemitem>, instantâneo de estado do sistema temporário, seção de gerenciamento de recursos ou grupo de processos criados externamente.
      </para>
      <para>
        O <quote>arquivo unit</quote> é um termo genérico usado pelo <systemitem class="daemon">systemd</systemitem> para o seguinte:
      </para>
      <itemizedlist mark="bullet" spacing="normal">
        <listitem>
          <formalpara>
            <title>Serviço</title>
            <para>
              Informações sobre um processo (por exemplo, execução de um daemon); o arquivo termina com .service
            </para>
          </formalpara>
        </listitem>
        <listitem>
          <formalpara>
            <title>Destinos</title>
            <para>
              Usado para agrupar unidades e como pontos de sincronização durante a inicialização; o arquivo termina com .target
            </para>
          </formalpara>
        </listitem>
        <listitem>
          <formalpara>
            <title>Soquetes</title>
            <para>
              Informações sobre um soquete de rede, IPC ou FIFO do sistema de arquivos, para ativação baseada em soquete (como <systemitem class="daemon">inetd</systemitem>); o arquivo termina com .socket
            </para>
          </formalpara>
        </listitem>
        <listitem>
          <formalpara>
            <title>Caminho</title>
            <para>
              Usado para acionar outras unidades (por exemplo, executar um serviço quando há mudanças nos arquivos); o arquivo termina com .path
            </para>
          </formalpara>
        </listitem>
        <listitem>
          <formalpara>
            <title>Timer</title>
            <para>
              Informações sobre um temporizador controlado, para ativação baseada em temporizador; o arquivo termina com .timer
            </para>
          </formalpara>
        </listitem>
        <listitem>
          <formalpara>
            <title>Ponto de montagem</title>
            <para>
              Normalmente, gerado de forma automática pelo gerador fstab. O arquivo termina com .mount
            </para>
          </formalpara>
        </listitem>
        <listitem>
          <formalpara>
            <title>Ponto de automount</title>
            <para>
              Informações sobre um ponto de automount do sistema de arquivos; o arquivo termina com .automount
            </para>
          </formalpara>
        </listitem>
        <listitem>
          <formalpara>
            <title>Swap</title>
            <para>
              Informações sobre um dispositivo ou arquivo de troca para paginação de memória; o arquivo termina com .swap
            </para>
          </formalpara>
        </listitem>
        <listitem>
          <formalpara>
            <title>Dispositivo</title>
            <para>
              Informações sobre uma unidade de dispositivo conforme exposta na árvore de dispositivos do sysfs/udev(7); o arquivo termina com .device
            </para>
          </formalpara>
        </listitem>
        <listitem>
          <formalpara>
            <title>Escopo/Fração</title>
            <para>
              Um conceito de gerenciamento hierárquico de recursos de um grupo de processos; o arquivo termina com .scope/.slice
            </para>
          </formalpara>
        </listitem>
      </itemizedlist>
      <para>
        Para obter mais informações sobre arquivos de unidade do <systemitem class="daemon">systemd</systemitem>, acesse <link xlink:href="https://www.freedesktop.org/software/systemd/man/latest/systemd.unit.html"/>
      </para>
    </sect2>
  </sect1>
  <sect1 xml:id="sec-boot-systemd-basics">
    <title>Uso básico</title>

    <para>
      O sistema init do System V usa vários comandos para processar os serviços: scripts init, <command>insserv</command>, <command>telinit</command> e outros. O <systemitem class="daemon">systemd</systemitem> facilita o gerenciamento de serviços, pois há apenas um comando para processar a maioria das tarefas relacionadas a serviços: <command>systemctl</command>. Ele usa a notação <quote>command plus subcommand</quote>, como <command>git</command> ou <command>zypper</command>:
    </para>

<screen>systemctl <replaceable>GENERAL OPTIONS</replaceable> <replaceable>SUBCOMMAND</replaceable> <replaceable>SUBCOMMAND OPTIONS</replaceable></screen>

    <para>
      Consulte <command>man 1 systemctl</command> para obter o manual completo.
    </para>

    <tip>
      <title>Saída de terminal e complementação bash</title>
      <para>
        Se a saída chegar a um terminal (e não a um pipe ou arquivo, por exemplo), por padrão, os comandos do <systemitem class="daemon">systemd</systemitem> enviarão uma saída extensa para um pager. Use a opção <option>--no-pager</option> para desativar o modo de paginação.
      </para>
      <para>
        O <systemitem class="daemon">systemd</systemitem> também suporta a complementação bash, que permite digitar as primeiras letras de um subcomando e pressionar <keycap function="tab"/>. Esse recurso está disponível apenas no shell <systemitem>bash</systemitem> e requer a instalação do pacote <systemitem class="resource">bash-completion</systemitem>.
      </para>
    </tip>

    <sect2 xml:id="sec-boot-systemd-basics-services">
      <title>Gerenciando serviços em um sistema em execução</title>
      <para>
        Os subcomandos de gerenciamento de serviços são os mesmos usados para gerenciar um serviço com o init do System V (<command>start</command>, <command>stop</command>...). A sintaxe geral dos comandos de gerenciamento de serviços é a seguinte:
      </para>
      <variablelist>
        <varlistentry>
          <term><systemitem class="daemon">systemd</systemitem></term>
          <listitem>
<screen>systemctl reload|restart|start|status|stop|<replaceable>...</replaceable> <replaceable>MY_SERVICE(S)</replaceable></screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Init do System V</term>
          <listitem>
<screen>rc<replaceable>MY_SERVICE(S)</replaceable> reload|restart|start|status|stop|<replaceable>...</replaceable></screen>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
        O <systemitem class="daemon">systemd</systemitem> permite gerenciar vários serviços de uma só vez. Em vez de executar os scripts init um após o outro como acontece com o init do System V, execute um comando da seguinte forma:
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl start <replaceable>MY_1ST_SERVICE</replaceable> <replaceable>MY_2ND_SERVICE</replaceable></screen>
      <para>
        Para listar todos os serviços disponíveis no sistema:
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl list-unit-files --type=service</screen>
      <para>
        A tabela a seguir lista os comandos de gerenciamento de serviços mais importantes para o <systemitem class="daemon">systemd</systemitem> e o init do System V:
      </para>
      <table rowsep="1">
        <title>Comandos de gerenciamento de serviços</title>
        <tgroup cols="3">
          <colspec colnum="1" colname="1" colwidth="50*"/>
          <colspec colnum="2" colname="2" colwidth="30*"/>
          <colspec colnum="3" colname="3" colwidth="20*"/>
          <thead>
            <row>
              <entry colname="1">
                <para>
                  Tarefa
                </para>
              </entry>
              <entry colname="2">
                <para>
                  Comando <systemitem class="daemon">systemd</systemitem>
                </para>
              </entry>
              <entry colname="3">
                <para>
                  Comando init do System V
                </para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry colname="1">
                <formalpara>
                  <title>Iniciando</title>
                  <para/>
                </formalpara>
              </entry>
              <entry colname="2">
<screen>start</screen>
              </entry>
              <entry colname="3">
<screen>start</screen>
              </entry>
            </row>
            <row>
              <entry colname="1">
                <formalpara>
                  <title>Parar</title>
                  <para/>
                </formalpara>
              </entry>
              <entry colname="2">
<screen>stop</screen>
              </entry>
              <entry colname="3">
<screen>stop</screen>
              </entry>
            </row>
            <row>
              <entry colname="1">
                <formalpara>
                  <title>Reiniciar</title>
                  <para>
                    Encerra os serviços e os inicia na sequência. Se um serviço ainda não estiver em execução, ele será iniciado.
                  </para>
                </formalpara>
              </entry>
              <entry colname="2">
<screen>restart</screen>
              </entry>
              <entry colname="3">
<screen>restart</screen>
              </entry>
            </row>
            <row>
              <entry colname="1">
                <formalpara>
                  <title>Reiniciar condicionalmente</title>
                  <para>
                    Reinicia os serviços se já estiverem em execução. Não faz nada para os serviços que não estão em execução.
                  </para>
                </formalpara>
              </entry>
              <entry colname="2">
<screen>try-restart</screen>
              </entry>
              <entry colname="3">
<screen>try-restart</screen>
              </entry>
            </row>
            <row>
              <entry colname="1">
                <formalpara>
                  <title>Recarregar</title>
                  <para>
                    Instrui os serviços a recarregarem seus arquivos de configuração sem interromper a operação. Caso de uso: instruir o Apache a recarregar um arquivo de configuração <filename>httpd.conf</filename> modificado. Nem todos os serviços suportam o recarregamento.
                  </para>
                </formalpara>
              </entry>
              <entry colname="2">
<screen>reload</screen>
              </entry>
              <entry colname="3">
<screen>reload</screen>
              </entry>
            </row>
            <row>
              <entry colname="1">
                <formalpara>
                  <title>Recarregar ou reiniciar</title>
                  <para>
                    Recarrega os serviços quando o recarregamento é suportado; do contrário, reinicia-os. Se um serviço ainda não estiver em execução, ele será iniciado.
                  </para>
                </formalpara>
              </entry>
              <entry colname="2">
<screen>reload-or-restart</screen>
              </entry>
              <entry colname="3">
<screen>n/a</screen>
              </entry>
            </row>
            <row>
              <entry colname="1">
                <formalpara>
                  <title>Recarregar ou reiniciar condicionalmente</title>
                  <para>
                    Recarrega os serviços se o recarregamento for suportado; do contrário reinicia-os, se estiverem em execução. Não faz nada para os serviços que não estão em execução.
                  </para>
                </formalpara>
              </entry>
              <entry colname="2">
<screen>reload-or-try-restart</screen>
              </entry>
              <entry colname="3">
<screen>n/a</screen>
              </entry>
            </row>
            <row>
              <entry colname="1">
                <formalpara>
                  <title>Obter informações detalhadas sobre status</title>
                  <para>
                    Lista as informações sobre o status dos serviços. O comando <systemitem class="daemon">systemd</systemitem> mostra detalhes, como descrição, executável, status, cgroup e as últimas mensagens emitidas por um serviço (consulte a <xref linkend="sec-boot-systemd-basics-services-debugging"/>). O nível dos detalhes exibidos com o init do System V varia de acordo com cada serviço.
                  </para>
                </formalpara>
              </entry>
              <entry colname="2">
<screen>status</screen>
              </entry>
              <entry colname="3">
<screen>status</screen>
              </entry>
            </row>
            <row>
              <entry colname="1">
                <formalpara>
                  <title>Obter informações resumidas sobre status</title>
                  <para>
                    Mostra se os serviços estão ou não ativos.
                  </para>
                </formalpara>
              </entry>
              <entry colname="2">
<screen>is-active</screen>
              </entry>
              <entry colname="3">
<screen>status</screen>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-basics-services-enabling">
      <title>Habilitando/Desabilitando serviços permanentemente</title>
      <para>
        Os comandos de gerenciamento de serviços mencionados na seção anterior permitem manipular serviços na seção atual. O <systemitem class="daemon">systemd</systemitem> também permite habilitar ou desabilitar serviços permanentemente para serem iniciados automaticamente quando solicitados ou para ficarem sempre indisponíveis. É possível fazer isso com o YaST ou por linha de comando.
      </para>
      <sect3 xml:id="sec-boot-systemd-basics-services-enabling-cmd">
        <title>Habilitando/Desabilitando serviços na linha de comando</title>
        <para>
          A tabela a seguir lista os comandos de habilitação e desabilitação para <systemitem class="daemon">systemd</systemitem> e o init do System V:
        </para>
        <important>
          <title>Inicialização de serviço</title>
          <para>
            Ao habilitar um serviço na linha de comando, ele não é iniciado automaticamente. Ele é programado para iniciar na próxima inicialização do sistema ou mudança de nível de execução/destino. Para iniciar um serviço logo depois de habilitá-lo, execute explicitamente <command>systemctl start
            <replaceable>MY_SERVICE</replaceable></command> ou <command>rc
            <replaceable>MY_SERVICE</replaceable> start</command>.
          </para>
        </important>
        <table rowsep="1">
          <title>Comandos para habilitar e desabilitar serviços</title>
          <tgroup cols="3">
            <colspec colnum="1" colname="1" colwidth="32*"/>
            <colspec colnum="2" colname="2" colwidth="40*"/>
            <colspec colnum="3" colname="3" colwidth="28*"/>
            <thead>
              <row>
                <entry colname="1">
                  <para>
                    Tarefa
                  </para>
                </entry>
                <entry colname="2">
                  <para>
                    Comando <systemitem class="daemon">systemd</systemitem>
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    Comando init do System V
                  </para>
                </entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry colname="1">
                  <formalpara>
                    <title>Habilitar</title>
                    <para/>
                  </formalpara>
                </entry>
                <entry colname="2">
                  <para>
                    <command>systemctl enable
                    <replaceable>MY_SERVICE(S)</replaceable></command>
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    <command>insserv
                    <replaceable>MY_SERVICE(S)</replaceable></command>, <command>chkconfig -a
                    <replaceable>MY_SERVICE(S)</replaceable></command>
                  </para>
                </entry>
              </row>
              <row>
                <entry colname="1">
                  <formalpara>
                    <title>Desabilitar</title>
                    <para/>
                  </formalpara>
                </entry>
                <entry colname="2">
                  <para>
                    <command>systemctl disable
                    <replaceable>MY_SERVICE(S)</replaceable>.service</command>
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    <command>insserv -r
                    <replaceable>MY_SERVICE(S)</replaceable></command>, <command>chkconfig -d
                    <replaceable>MY_SERVICE(S)</replaceable></command>
                  </para>
                </entry>
              </row>
              <row>
                <entry colname="1">
                  <formalpara>
                    <title>Verificar</title>
                    <para>
                      Mostra se um serviço está ou não habilitado.
                    </para>
                  </formalpara>
                </entry>
                <entry colname="2">
                  <para>
                    <command>systemctl is-enabled
                    <replaceable>MY_SERVICE</replaceable></command>
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    <command>chkconfig
                    <replaceable>MY_SERVICE</replaceable></command>
                  </para>
                </entry>
              </row>
              <row>
                <entry colname="1">
                  <formalpara>
                    <title>Reabilitar</title>
                    <para>
                      Semelhante a reiniciar um serviço, este comando primeiro desabilita e depois habilita um serviço. Útil para restaurar um serviço aos seus padrões.
                    </para>
                  </formalpara>
                </entry>
                <entry colname="2">
                  <para>
                    <command>systemctl reenable
                    <replaceable>MY_SERVICE</replaceable></command>
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    n/d
                  </para>
                </entry>
              </row>
              <row>
                <entry colname="1">
                  <formalpara>
                    <title>Mascarar</title>
                    <para>
                      Após <quote>desabilitar</quote> um serviço, ele ainda poderá ser iniciado manualmente. Para desabilitar um serviço, é necessário mascará-lo. Use com cuidado.
                    </para>
                  </formalpara>
                </entry>
                <entry colname="2">
                  <para>
                    <command>systemctl mask
                    <replaceable>MY_SERVICE</replaceable></command>
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    n/d
                  </para>
                </entry>
              </row>
              <row>
                <entry colname="1">
                  <formalpara>
                    <title>Desmascarar</title>
                    <para>
                      Só será possível usar novamente um serviço mascarado depois que ele for desmascarado.
                    </para>
                  </formalpara>
                </entry>
                <entry colname="2">
                  <para>
                    <command>systemctl unmask
                    <replaceable>MY_SERVICE</replaceable></command>
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    n/d
                  </para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </sect3>
    </sect2>
  </sect1>
  <sect1 xml:id="sec-boot-systemd-boot">
    <title>Inicialização do sistema e gerenciamento de destino</title>

    <para>
      Todo o processo de inicialização e encerramento do sistema é mantido pelo <systemitem class="daemon">systemd</systemitem>. Desse ponto de vista, o kernel pode ser considerado um processo em segundo plano para manter todos os outros processos e ajustar o horário da CPU e o acesso ao hardware de acordo com as solicitações de outros programas.
    </para>

    <sect2 xml:id="sec-boot-systemd-targets">
      <title>Comparação entre destinos e níveis de execução</title>
      <para>
        Com o init do System V, o sistema era inicializado no chamado <quote>Nível de execução</quote>. O nível de execução define como o sistema é iniciado e quais serviços estão disponíveis no sistema em execução. Os níveis de execução são numerados: os mais conhecidos são <literal>0</literal> (encerramento do sistema), <literal>3</literal> (multiusuário com rede) e <literal>5</literal> (multiusuário com rede e gerenciador de exibição).
      </para>
      <para>
        O <systemitem class="daemon">systemd</systemitem> apresenta um novo conceito usando as chamadas <quote>unidades de destino</quote>. No entanto, ele continua totalmente compatível com o conceito de nível de execução. As unidades de destino são nomeadas, e não numeradas, e possuem finalidades específicas. Por exemplo, os destinos <systemitem>local-fs.target</systemitem> e <systemitem>swap.target</systemitem> montam sistemas de arquivos locais e espaços de troca (swap).
      </para>
      <para>
        O destino <systemitem>graphical.target</systemitem> oferece recursos de sistema multiusuário com rede e gerenciador de exibição e equivale ao nível de execução 5. Destinos complexos, como <systemitem>graphical.target</systemitem>, agem como destinos <quote>meta</quote>, combinando um subconjunto de outros destinos. Como o <systemitem class="daemon">systemd</systemitem> facilita criar destinos personalizados combinando destinos existentes, ele oferece excelente flexibilidade.
      </para>
      <para>
        A lista a seguir mostra as unidades de destino mais importantes do <systemitem class="daemon">systemd</systemitem>. Para ver a lista completa, consulte <command>man 7 systemd.special</command>.
      </para>
      <variablelist>
        <title>Unidades de destino selecionadas do <systemitem class="daemon">systemd</systemitem></title>
        <varlistentry>
          <term><systemitem>default.target</systemitem></term>
          <listitem>
            <para>
              O destino que é inicializado por padrão. Não um destino <quote>real</quote>, mas um link simbólico para outro destino, como <systemitem>graphic.target</systemitem>. Pode ser modificado permanentemente pelo YaST (consulte a <xref linkend="sec-boot-runlevel-edit"/>). Para mudá-lo em uma sessão, use o parâmetro do kernel <literal>systemd.unit=<replaceable>MY_TARGET.target</replaceable></literal> no prompt de boot.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><systemitem>emergency.target</systemitem></term>
          <listitem>
            <para>
              Inicia um shell de <systemitem class="username">root</systemitem> de emergência mínimo no console. Use-o apenas no prompt de boot como <literal>systemd.unit=emergency.target</literal>.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><systemitem>graphical.target</systemitem></term>
          <listitem>
            <para>
              Inicia um sistema com suporte a rede multiusuário e um gerenciador de exibição.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><systemitem>halt.target</systemitem></term>
          <listitem>
            <para>
              Encerra o sistema.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><systemitem>mail-transfer-agent.target</systemitem></term>
          <listitem>
            <para>
              Inicia todos os serviços necessários para enviar e receber e-mails.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><systemitem>multi-user.target</systemitem></term>
          <listitem>
            <para>
              Inicia um sistema multiusuário com rede.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><systemitem>reboot.target</systemitem></term>
          <listitem>
            <para>
              Reinicializa o sistema.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><systemitem>rescue.target</systemitem></term>
          <listitem>
            <para>
              Inicia uma sessão de <systemitem class="username">root</systemitem> de usuário único sem rede. Ferramentas básicas para administração do sistema estão disponíveis. O destino <literal>rescue</literal> é adequado para resolver vários problemas do sistema, por exemplo, logins com falha ou correção de problemas com um driver de vídeo.
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
        Para continuar compatível com o sistema de nível de execução init do System V, o <systemitem class="daemon">systemd</systemitem> oferece destinos especiais chamados <literal>runlevel<replaceable>X</replaceable>.target</literal> que mapeiam os níveis de execução correspondentes numerados <replaceable>X</replaceable>.
      </para>
      <para>
        Para inspecionar o destino atual, use o comando: <command>systemctl
        get-default</command>
      </para>
      <table rowsep="1">
        <title>Níveis de execução do System V e unidades de destino do <systemitem class="daemon">systemd</systemitem></title>
        <tgroup cols="3">
          <colspec colnum="1" colname="1" colwidth="20*"/>
          <colspec colnum="2" colname="2" colwidth="40*"/>
          <colspec colnum="3" colname="3" colwidth="40*"/>
          <thead>
            <row>
              <entry>
                <para>
                  Nível de execução do System V
                </para>
              </entry>
              <entry>
                <para>
                  <systemitem class="daemon">systemd</systemitem> destino
                </para>
              </entry>
              <entry>
                <para>
                  Finalidade
                </para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>
                  0
                </para>
              </entry>
              <entry>
                <para>
                  <systemitem>runlevel0.target</systemitem>, <systemitem>halt.target</systemitem>, <systemitem>poweroff.target</systemitem>
                </para>
              </entry>
              <entry>
                <para>
                  Encerramento do sistema
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  1, S
                </para>
              </entry>
              <entry>
                <para>
                  <systemitem>runlevel1.target</systemitem>, <systemitem>rescue.target</systemitem>,
                </para>
              </entry>
              <entry>
                <para>
                  Modo de usuário único
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  2
                </para>
              </entry>
              <entry>
                <para>
                  <systemitem>runlevel2.target</systemitem>, <systemitem>multi-user.target</systemitem>,
                </para>
              </entry>
              <entry>
                <para>
                  Multiusuário local sem rede remota
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  3
                </para>
              </entry>
              <entry>
                <para>
                  <systemitem>runlevel3.target</systemitem>, <systemitem>multi-user.target</systemitem>,
                </para>
              </entry>
              <entry>
                <para>
                  Multiusuário completo com rede
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  4
                </para>
              </entry>
              <entry>
                <para>
                  <systemitem>runlevel4.target</systemitem>
                </para>
              </entry>
              <entry>
                <para>
                  Não usado/Definido pelo usuário
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  5
                </para>
              </entry>
              <entry>
                <para>
                  <systemitem>runlevel5.target</systemitem>, <systemitem>graphical.target</systemitem>,
                </para>
              </entry>
              <entry>
                <para>
                  Multiusuário completo com rede e gerenciador de exibição
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  6
                </para>
              </entry>
              <entry>
                <para>
                  <systemitem>runlevel6.target</systemitem>, <systemitem>reboot.target</systemitem>,
                </para>
              </entry>
              <entry>
                <para>
                  Reinicialização do sistema
                </para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <important>
        <title><systemitem class="daemon">systemd</systemitem> ignora <filename>/etc/inittab</filename></title>
        <para>
          Os níveis de execução em um sistema init do System V são configurados em <filename>/etc/inittab</filename>. O <systemitem class="daemon">systemd</systemitem> <emphasis>não</emphasis> usa essa configuração. Consulte a <xref linkend="sec-boot-systemd-custom-targets"/> para obter instruções sobre como criar seu próprio destino inicializável.
        </para>
      </important>
      <sect3 xml:id="sec-boot-systemd-targets-commands">
        <title>Comandos para mudar os destinos</title>
        <para>
          Use os seguintes comandos para operar com unidades de destino:
        </para>
        <informaltable rowsep="1">
          <tgroup cols="3">
            <colspec colnum="1" colname="1" colwidth="20*"/>
            <colspec colnum="2" colname="2" colwidth="50*"/>
            <colspec colnum="3" colname="3" colwidth="30*"/>
            <thead>
              <row>
                <entry colname="1">
                  <para>
                    Tarefa
                  </para>
                </entry>
                <entry colname="2">
                  <para>
                    Comando <systemitem class="daemon">systemd</systemitem>
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    Comando init do System V
                  </para>
                </entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry colname="1">
                  <para>
                    Mudar o destino/nível de execução atual
                  </para>
                </entry>
                <entry colname="2">
                  <para>
                    <command>systemctl isolate</command>
                    <replaceable>MY_TARGET</replaceable>.destino
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    <command>telinit</command> <replaceable>X</replaceable>
                  </para>
                </entry>
              </row>
              <row>
                <entry colname="1">
                  <para>
                    Mudar para o destino/nível de execução padrão
                  </para>
                </entry>
                <entry colname="2">
                  <para>
                    <command>systemctl default</command>
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    n/d
                  </para>
                </entry>
              </row>
              <row>
                <entry colname="1">
                  <para>
                    Obter o destino/nível de execução atual
                  </para>
                </entry>
                <entry colname="2">
                  <para>
                    <command>systemctl list-units --type=target</command>
                  </para>
                  <para>
                    Com o <systemitem class="daemon">systemd</systemitem>, normalmente há mais de um destino ativo. O comando lista todos os destinos que estão ativos.
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    <command>who -r</command>
                  </para>
                  <para>
                    ou
                  </para>
                  <para>
                    <command>runlevel</command>
                  </para>
                </entry>
              </row>
              <row>
                <entry colname="1">
                  <para>
                    Mudar o nível de execução padrão de forma persistente
                  </para>
                </entry>
                <entry colname="2">
                  <para>
                    Use o Gerenciador de Serviços ou execute o seguinte comando:
                  </para>
                  <para>
                    <command>ln -sf /usr/lib/systemd/system/</command>
                    <replaceable>MY_TARGET</replaceable>.target /etc/systemd/system/default.target
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    Use o Gerenciador de Serviços ou mude a linha
                  </para>
                  <para>
                    <command>id:</command>
                    <replaceable>X</replaceable>:initdefault:
                  </para>
                  <para>
                    na <filename>/etc/inittab</filename>
                  </para>
                </entry>
              </row>
              <row>
                <entry colname="1">
                  <para>
                    Mudar o nível de execução padrão para o processo de boot atual
                  </para>
                </entry>
                <entry colname="2">
                  <para>
                    Digite a seguinte opção no prompt de boot
                  </para>
                  <para>
                    <command>systemd.unit=</command>
                    <replaceable>MY_TARGET</replaceable>.destino
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    Digite o número do nível de execução desejado no prompt de boot.
                  </para>
                </entry>
              </row>
              <row>
                <entry colname="1">
                  <para>
                    Mostrar as dependências de um destino/nível de execução
                  </para>
                </entry>
                <entry colname="2">
                  <para>
                    <command>systemctl show -p "Requires"</command>
                    <replaceable>MY_TARGET</replaceable>.destino
                  </para>
                  <para>
                    <command>systemctl show -p "Wants"</command>
                    <replaceable>MY_TARGET</replaceable>.destino
                  </para>
                  <para>
                    <quote>Requires</quote> lista as dependências obrigatórias (hard) (aquelas que devem ser resolvidas), enquanto <quote>Wants</quote> lista as dependências desejadas (soft) (aquelas que são resolvidas quando possível).
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    n/d
                  </para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </sect3>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-debug">
      <title>Depurando a inicialização do sistema</title>
      <para>
        O <systemitem class="daemon">systemd</systemitem> oferece os meios para a análise dos processos de inicialização do sistema. É possível revisar a lista de todos os serviços e status (em vez de analisar o <filename>/var/log/</filename>). O <systemitem class="daemon">systemd</systemitem> permite também explorar o procedimento de inicialização para descobrir quanto tempo leva para inicializar cada serviço.
      </para>
      <sect3 xml:id="sec-boot-systemd-debug-review">
        <title>Revisar inicialização dos serviços</title>
        <para>
          Para revisar a lista completa dos serviços que foram iniciados desde a inicialização do sistema, digite o comando <command>systemctl</command>. Ele lista todos os serviços ativos, conforme mostrado a seguir (resumidamente). Para obter mais informações sobre um determinado serviço, use <command>systemctl status
          <replaceable>MY_SERVICE</replaceable></command>.
        </para>
        <example>
          <title>Listar serviços ativos</title>
<screen><prompt role="root"># </prompt>systemctl
UNIT                        LOAD   ACTIVE SUB       JOB DESCRIPTION
[...]
iscsi.service               loaded active exited    Login and scanning of iSC+
kmod-static-nodes.service   loaded active exited    Create list of required s+
libvirtd.service            loaded active running   Virtualization daemon
nscd.service                loaded active running   Name Service Cache Daemon
chronyd.service             loaded active running   NTP Server Daemon
polkit.service              loaded active running   Authorization Manager
postfix.service             loaded active running   Postfix Mail Transport Ag+
rc-local.service            loaded active exited    /etc/init.d/boot.local Co+
rsyslog.service             loaded active running   System Logging Service
[...]
LOAD   = Reflects whether the unit definition was properly loaded.
ACTIVE = The high-level unit activation state, i.e. generalization of SUB.
SUB    = The low-level unit activation state, values depend on unit type.

161 loaded units listed. Pass --all to see loaded but inactive units, too.
To show all installed unit files use 'systemctl list-unit-files'.</screen>
        </example>
        <para>
          Para restringir a saída a serviços com falha na inicialização, use a opção <option>--failed</option>:
        </para>
        <example>
          <title>Listar serviços com falha</title>
<screen><prompt role="root"># </prompt>systemctl --failed
UNIT                   LOAD   ACTIVE SUB    JOB DESCRIPTION
apache2.service        loaded failed failed     apache
NetworkManager.service loaded failed failed     Network Manager
plymouth-start.service loaded failed failed     Show Plymouth Boot Screen

[...]</screen>
        </example>
      </sect3>
      <sect3 xml:id="sec-boot-systemd-debug-time">
        <title>Depurar o tempo de inicialização</title>
        <para>
          Para depurar o tempo de inicialização do sistema, o <systemitem class="daemon">systemd</systemitem> oferece o comando <command>systemd-analyze</command>. Ele mostra o tempo total de inicialização, uma lista dos serviços solicitados por tempo de inicialização e também gera um gráfico SVG mostrando o tempo que os serviços levaram para serem iniciados em relação a outros serviços.
        </para>
        <variablelist>
          <varlistentry>
            <term>Listando o tempo de inicialização do sistema</term>
            <listitem>
<screen><prompt role="root"># </prompt>systemd-analyze
Startup finished in 2666ms (kernel) + 21961ms (userspace) = 24628ms</screen>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Listando o tempo de inicialização dos serviços</term>
            <listitem>
<screen><prompt role="root"># </prompt>systemd-analyze blame
    15.000s backup-rpmdb.service
    14.879s mandb.service
     7.646s backup-sysconfig.service
     4.940s postfix.service
     4.921s logrotate.service
     4.640s libvirtd.service
     4.519s display-manager.service
     3.921s btrfsmaintenance-refresh.service
     3.466s lvm2-monitor.service
     2.774s plymouth-quit-wait.service
     2.591s firewalld.service
     2.137s initrd-switch-root.service
     1.954s ModemManager.service
     1.528s rsyslog.service
     1.378s apparmor.service
    [...]
</screen>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Gráficos do tempo de inicialização dos serviços</term>
            <listitem>
<screen><prompt role="root"># </prompt>systemd-analyze plot &gt; jupiter.example.com-startup.svg</screen>
              <informalfigure>
                <mediaobject>
                  <imageobject role="fo">
                    <imagedata fileref="systemd_startup.svg" width="75%"/>
                  </imageobject>
                  <imageobject role="html">
                    <imagedata fileref="systemd_startup.png" width="75%"/>
                  </imageobject>
                </mediaobject>
              </informalfigure>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect3>
      <sect3 xml:id="sec-boot-systemd-debug-complete">
        <title>Revisar o processo de inicialização completo</title>
        <para>
          Os comandos acima listam os serviços que são iniciados e os respectivos horários de inicialização. Para obter uma visão geral mais detalhada, especifique os parâmetros a seguir no prompt de boot para instruir o <systemitem class="daemon">systemd</systemitem> a criar um registro verboso do procedimento completo de inicialização.
        </para>
<screen>systemd.log_level=debug systemd.log_target=kmsg</screen>
        <para>
          Agora o <systemitem class="daemon">systemd</systemitem> grava suas mensagens de registro no buffer de anel do kernel. Veja esse buffer com <command>dmesg</command>:
        </para>
<screen><prompt>&gt; </prompt>dmesg -T | less</screen>
      </sect3>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-sysv-compatibility">
      <title>Compatibilidade com o System V</title>
      <para>
        O <systemitem class="daemon">systemd</systemitem> é compatível com o System V, o que ainda permite usar os scripts init existentes do System V. Entretanto, há pelo menos um problema conhecido em que o script init do System V não funciona com o <systemitem class="daemon">systemd</systemitem> pronto para uso: iniciar um serviço como outro usuário por meio de <command>su</command> ou <command>sudo</command> nos scripts init resulta em falha do script, gerando um erro de <quote>Acesso negado</quote>.
      </para>
      <para>
        Ao mudar o usuário com <command>su</command> ou <command>sudo</command>, é iniciada uma sessão PAM. Essa sessão será terminada após a conclusão do script init. Como consequência, o serviço que foi iniciado pelo script init também é terminado. Para solucionar esse erro, faça o seguinte:
      </para>
      <procedure>
        <step>
          <para>
            Crie um agrupador de arquivo de serviço com o mesmo nome do script init e mais a extensão de nome de arquivo <filename>.service</filename>:
          </para>
<screen>[Unit]
Description=<replaceable>DESCRIPTION</replaceable>
After=network.target

[Service]
User=<replaceable>USER</replaceable>
Type=forking<co xml:id="co-service-wrapper-type"/>
PIDFile=<replaceable>PATH TO PID FILE</replaceable><xref linkend="co-service-wrapper-type" xrefstyle="select:label nopage"/>
ExecStart=<replaceable>PATH TO INIT SCRIPT</replaceable> start
ExecStop=<replaceable>PATH TO INIT SCRIPT</replaceable> stop
ExecStopPost=/usr/bin/rm -f <replaceable>PATH TO PID FILE</replaceable><xref linkend="co-service-wrapper-type" xrefstyle="select:label nopage"/>

[Install]
WantedBy=multi-user.target<co xml:id="co-service-wrapper-target"/></screen>
          <para>
            Substitua todos os valores gravados em <replaceable>UPPERCASE
            LETTERS</replaceable> pelos valores apropriados.
          </para>
          <calloutlist>
            <callout arearefs="co-service-wrapper-type">
              <para>
                Opcional: use apenas se o script init iniciar um daemon.
              </para>
            </callout>
            <callout arearefs="co-service-wrapper-target">
              <para>
                O <literal>multi-user.target</literal> também inicia o script init ao inicializar no <literal>graphical.target</literal>. Se ele tiver que ser iniciado apenas ao inicializar no gerenciador de exibição, use <literal>graphical.target</literal>.
              </para>
            </callout>
          </calloutlist>
        </step>
        <step>
          <para>
            Inicie o daemon com <command>systemctl start
            <replaceable>APPLICATION</replaceable></command>.
          </para>
        </step>
      </procedure>
    </sect2>
  </sect1>
  <sect1 xml:id="sec-boot-runlevel-edit">
    <title>Gerenciando serviços com o YaST</title>

    <para>
      O gerenciamento básico de serviços também pode ser feito com o módulo Gerenciador de Serviços do YaST. Ele permite iniciar, parar, habilitar e desabilitar serviços. Ele permite também mostrar o status e mudar o destino padrão de um serviço. Inicie o módulo do YaST em <menuchoice> <guimenu>YaST</guimenu>
      <guimenu>Sistema</guimenu> <guimenu>Services Manager</guimenu>
      </menuchoice>  (Gerenciador de Serviços).
    </para>

    <figure xml:id="fig-yast2-runlevel">
      <title>Gerenciador de Serviços</title>
      <mediaobject>
        <imageobject role="fo">
          <imagedata fileref="yast2_runlevel.png" width="75%"/>
        </imageobject>
        <imageobject role="html">
          <imagedata fileref="yast2_runlevel.png" width="75%"/>
        </imageobject>
      </mediaobject>
    </figure>

    <variablelist>
      <varlistentry>
        <term>Mudando o <guimenu>destino padrão do sistema</guimenu></term>
        <listitem>
          <para>
            Para mudar o destino de inicialização do sistema, escolha o destino na caixa suspensa <guimenu>Default System Target</guimenu> (Destino Padrão do Sistema). Os destinos mais usados são <guimenu>Graphical Interface</guimenu> (Interface Gráfica) (iniciando uma tela gráfica de login) e <guimenu>Multiusuário</guimenu> (iniciando o sistema no modo de linha de comando).
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Iniciando ou parando um serviço</term>
        <listitem>
          <para>
            Selecione um serviço da tabela. A coluna <guimenu>Estado</guimenu> mostra se ele está em execução (<guimenu>Ativo</guimenu>) ou não (<guimenu>Inativo</guimenu>). Para alternar o status, escolha <guimenu>Iniciar</guimenu> ou <guimenu>Parar</guimenu>.
          </para>
          <para>
            Quando um serviço é iniciado ou parado, seu status muda na sessão que está em execução. Para mudar seu status em todas as reinicializações, é necessário habilitá-lo ou desabilitá-lo.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Definindo o comportamento de inicialização dos serviços</term>
        <listitem>
          <para>
            Os serviços podem ser iniciados automaticamente no momento da inicialização ou manualmente. Selecione um serviço da tabela. A coluna <guimenu>Início</guimenu> mostra se ele foi iniciado <guimenu>Manualmente</guimenu> ou <guimenu>Na inicialização</guimenu>. Para alternar o status, escolha <guimenu>Modo de início</guimenu>.
          </para>
          <para>
            Para mudar o status de um serviço na sessão atual, você precisa iniciá-lo ou interrompê-lo conforme descrito acima.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Ver uma mensagem de status</term>
        <listitem>
          <para>
            Para ver a mensagem de status de um serviço, selecione-o na lista e escolha <guimenu>Mostrar Detalhes</guimenu>. A saída é idêntica a que foi gerada pelo comando <command>systemctl</command>
            <option>-l</option> status <replaceable>MY_SERVICE</replaceable>.
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
  </sect1>
  <sect1 xml:id="sec-boot-systemd-custom">
    <title>Personalizando <systemitem>systemd</systemitem></title>

    <para>
      As seções a seguir descrevem como personalizar arquivos de unidade do <systemitem class="daemon">systemd</systemitem>.
    </para>
    <sect2 xml:id="systemd-unit-file-placement">
      <title>Onde os arquivos de unidade são armazenados?</title>
      <para>
        Os arquivos de unidade do <systemitem class="daemon">systemd</systemitem> oferecidos pela SUSE são armazenados em <filename>/usr/lib/systemd/</filename>. Os arquivos de unidade personalizados e os <emphasis>drop-ins</emphasis> de arquivo de unidade são armazenados em <filename>/etc/systemd/</filename>.
      </para>
      <warning>
        <title>Impedindo que sua personalização seja sobregravada</title>
        <para>
          Ao personalizar o <systemitem class="daemon">systemd</systemitem>, sempre use o diretório <filename>/etc/systemd/</filename> em vez de <filename>/usr/lib/systemd/</filename>. Do contrário, as mudanças serão sobregravadas na próxima atualização do <systemitem class="daemon">systemd</systemitem>.
        </para>
      </warning>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-custom-service">
      <title>Substituir por arquivos drop-in</title>
      <para>
        Os arquivos drop-in (ou <emphasis>drop-ins</emphasis>) são arquivos de unidade parciais que substituem apenas configurações específicas do arquivo de unidade. Os drop-ins têm prioridade sobre os arquivos de configuração principais. O comando <command>systemctl edit <replaceable>SERVICE</replaceable></command> inicia o editor de texto padrão e cria um diretório com um arquivo <filename>override.conf</filename> vazio em <filename>/etc/systemd/system/<replaceable>NAME</replaceable>.service.d/</filename>. O comando também garante que o processo <systemitem class="daemon">systemd</systemitem> em execução seja notificado sobre as mudanças.
      </para>
      <para>
        Por exemplo, para mudar a quantidade de tempo que o sistema espera até o MariaDB ser iniciado, execute <command>sudo systemctl edit mariadb.service</command> e edite o arquivo aberto para incluir apenas as linhas modificadas:
      </para>
<screen>
# Configures the time to wait for start-up/stop
TimeoutSec=300
</screen>
      <para>
        Ajuste o valor <literal>TimeoutSec</literal> e grave as mudanças. Para habilitar as mudanças, execute <command>sudo systemctl daemon-reload</command>.
      </para>
      <para>
        Para obter mais informações, consulte as páginas de manual que podem ser chamadas com o comando <command>man 1 systemctl</command>.
      </para>
      <warning>
        <title>Criar uma cópia de um arquivo de unidade completo</title>
        <para>
          Se você usar a opção <option>--full</option> no comando <command>systemctl edit --full
          <replaceable>SERVICE</replaceable></command>, será criada uma cópia do arquivo de unidade original, no qual poderá modificar opções específicas. Não recomendamos essa personalização porque, quando o arquivo de unidade é atualizado pela SUSE, suas mudanças são substituídas pela cópia personalizada no diretório <filename>/etc/systemd/system/</filename>. Além disso, se a SUSE disponibilizar atualizações para drop-ins de distribuição, elas substituirão a cópia do arquivo de unidade criado com <option>--full</option>. Para evitar esse tipo de confusão e manter sua personalização válida, use os drop-ins.
        </para>
      </warning>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-custom-drop-in">
      <title>Criando arquivos drop-in manualmente</title>
      <para>
        Além de usar o comando <command>systemctl edit</command>, você pode criar drop-ins manualmente para ter mais controle sobre a prioridade deles. Esses drop-ins permitem estender os arquivos de configuração da unidade e do daemon sem ter que editar ou substituir os próprios arquivos. Eles estão armazenados nos seguintes diretórios:
      </para>
      <variablelist>
        <varlistentry>
          <term><filename>/etc/systemd/*.conf.d/</filename>, <filename>/etc/systemd/system/*.service.d/</filename></term>
          <listitem>
            <para>
              Drop-ins adicionados e personalizados pelos administradores do sistema.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><filename>/usr/lib/systemd/*.conf.d/</filename>, <filename>/usr/lib/systemd/system/*.service.d/</filename></term>
          <listitem>
            <para>
              Drop-ins instalados por pacotes de personalização para substituir as configurações de upstream. Por exemplo, a SUSE fornece o pacote <package>systemd-default-settings</package>.
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
      <tip>
        <para>
          Consulte a página de manual <command>man 5 systemd.unit</command> para obter a lista completa de caminhos de pesquisa de unidade.
        </para>
      </tip>
      <para>
        Por exemplo, para desabilitar a limitação de taxa imposta pela configuração padrão do <systemitem class="daemon">systemd-journald</systemitem>, siga estas etapas:
      </para>
      <procedure>
        <step>
          <para>
            Crie um diretório chamado <filename>/etc/systemd/journald.conf.d</filename>.
          </para>
<screen><prompt>&gt; </prompt><command>sudo</command> mkdir /etc/systemd/journald.conf.d</screen>
          <note>
            <para>
              O nome do diretório deve seguir o nome do serviço que você deseja corrigir com o arquivo drop-in.
            </para>
          </note>
        </step>
        <step>
          <para>
            Nesse diretório, crie um arquivo <filename>/etc/systemd/journald.conf.d/60-rate-limit.conf</filename> com a opção que deseja substituir, por exemplo:
          </para>
<screen><prompt>&gt; </prompt><command>cat /etc/systemd/journald.conf.d/60-rate-limit.conf</command>
# Disable rate limiting
RateLimitIntervalSec=0</screen>
        </step>
        <step>
          <para>
            Grave as mudanças e reinicie o serviço do daemon do <systemitem class="daemon">systemd</systemitem> correspondente.
          </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl restart systemd-journald</screen>
        </step>
      </procedure>
      
      <note>
        <title>Evitando conflitos de nome</title>
        <para>
          Para evitar conflitos de nome entre os drop-ins e os arquivos fornecidos pela SUSE, é recomendado prefixar todos os drop-ins com um número de dois dígitos e um traço, por exemplo, <filename>80-override.conf</filename>.
        </para>
        <para>
          As seguintes faixas são reservadas:
        </para>
        <itemizedlist>
          <listitem>
            <para>
              <literal>0-19</literal> é reservada para upstream do. <systemitem class="daemon">systemd</systemitem>.
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>20-29</literal> é reservada para o <systemitem class="daemon">systemd</systemitem> fornecido pela SUSE.
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>30-39</literal> é reservada para pacotes da SUSE diferentes do <systemitem class="daemon">systemd</systemitem>.
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>40-49</literal> é reservada para pacotes de terceiros.
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>50</literal> é reservada para arquivos de unidade drop-in criados com <command>systemctl set-property</command>.
            </para>
          </listitem>
        </itemizedlist>
        <para>
          Use um número de dois dígitos acima dessa faixa para garantir que nenhum dos arquivos drop-in fornecidos pela SUSE substitua os seus próprios drop-ins.
        </para>
      </note>
      <tip>
        <para>
          Você pode usar <command>systemctl cat $UNIT</command> para listar e verificar quais arquivos são levados em consideração na configuração das unidades.
        </para>
      </tip>
      <tip>
        <para>
          Como a configuração dos componentes do <systemitem class="daemon">systemd</systemitem> pode estar distribuída por diferentes locais no sistema de arquivos, talvez seja difícil obter uma visão geral global. Para inspecionar a configuração de um componente do <systemitem class="daemon">systemd</systemitem>, use os seguintes comandos:
        </para>
        <itemizedlist>
          <listitem>
            <para>
              <command>systemctl cat
              <replaceable>UNIT_PATTERN</replaceable></command> imprime arquivos de configuração relacionados a uma ou mais unidades do <systemitem class="daemon">systemd</systemitem>, por exemplo:
            </para>
<screen><prompt>&gt; </prompt>systemctl cat atd.service</screen>
          </listitem>
          <listitem>
            <para>
              <command>systemd-analyze cat-config
              <replaceable>DAEMON_NAME_OR_PATH</replaceable></command> copia o conteúdo de um arquivo de configuração e dos drop-ins para um daemon do <systemitem class="daemon">systemd</systemitem>, por exemplo:
            </para>
<screen><prompt>&gt; </prompt>systemd-analyze cat-config systemd/journald.conf</screen>
          </listitem>
        </itemizedlist>
      </tip>
    </sect2>

    <sect2 xml:id="systemd-xinetd-conversion">
      <title>Convertendo serviços <systemitem>xinetd</systemitem> em <systemitem class="daemon">systemd</systemitem></title>
      <para>
        Desde o lançamento do <phrase role="productname"><phrase os="sled">SUSE Linux Enterprise Desktop</phrase></phrase> 15, a infraestrutura do <systemitem>xinetd</systemitem> foi removida. Esta seção descreve como converter arquivos existentes de serviço do <systemitem>xinetd</systemitem> em soquetes do <systemitem class="daemon">systemd</systemitem>.
      </para>
      <para>
        Para cada arquivo de serviço do <systemitem>xinetd</systemitem>, você precisa de pelo menos dois arquivos de unidade do <systemitem class="daemon">systemd</systemitem>: o arquivo de soquete (<filename>*.socket</filename>) e um arquivo de serviço associado (<filename>*.service</filename>). O arquivo de soquete informa ao <systemitem class="daemon">systemd</systemitem> qual soquete criar, e o arquivo de serviço informa ao <systemitem class="daemon">systemd</systemitem> qual executável iniciar.
      </para>
      <para>
        Considere o seguinte arquivo de serviço do <systemitem>xinetd</systemitem> de exemplo:
      </para>
<screen><prompt role="root"># </prompt>cat /etc/xinetd.d/example
service example
{
  socket_type = stream
  protocol = tcp
  port = 10085
  wait = no
  user = user
  group = users
  groups = yes
  server = /usr/libexec/example/exampled
  server_args = -auth=bsdtcp exampledump
  disable = no
}</screen>
      <para>
        Para convertê-lo em <systemitem class="daemon">systemd</systemitem>, você precisa dos dois arquivos correspondentes a seguir:
      </para>
<screen><prompt role="root"># </prompt>cat /usr/lib/systemd/system/example.socket
[Socket]
ListenStream=0.0.0.0:10085
Accept=false

[Install]
WantedBy=sockets.target</screen>
<screen><prompt role="root"># </prompt>cat /usr/lib/systemd/system/example.service
[Unit]
Description=example

[Service]
ExecStart=/usr/libexec/example/exampled -auth=bsdtcp exampledump
User=user
Group=users
StandardInput=socket
</screen>
      <para>
        Para obter uma lista completa das opções de arquivo de <systemitem class="daemon">systemd</systemitem> <quote>soquete</quote> e <quote>serviço</quote>, consulte as páginas de manual do systemd.socket e do systemd.service (<command>man 5 systemd.socket</command> e <command>man 5 systemd.service</command>).
      </para>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-custom-targets">
      <title>Criando destinos personalizados</title>
      <para>
        Nos sistemas init SUSE do System V, o nível de execução 4 não costuma ser usado para permitir que administradores criem sua própria configuração de nível de execução. O <systemitem class="daemon">systemd</systemitem> permite criar qualquer número de destinos personalizados. A sugestão é começar adaptando um destino existente, como <systemitem>graphical.target</systemitem>.
      </para>
      <procedure>
        <step>
          <para>
            Copie o arquivo de configuração <filename>/usr/lib/systemd/system/graphical.target</filename> para <filename>/etc/systemd/system/<replaceable>MY_TARGET</replaceable>.target</filename> e ajuste-o de acordo com as suas necessidades.
          </para>
        </step>
        <step>
          <para>
            O arquivo de configuração copiado na etapa anterior já inclui as dependências obrigatórias (<quote>hard</quote>) do destino. Para cobrir também as dependências desejadas (<quote>soft</quote>), crie um diretório <filename>/etc/systemd/system/<replaceable>MY_TARGET</replaceable>.target.wants</filename>.
          </para>
        </step>
        <step>
          <para>
            Para cada serviço desejado, crie um link simbólico de <filename>/usr/lib/systemd/system</filename> para <filename>/etc/systemd/system/<replaceable>MY_TARGET</replaceable>.target.wants</filename>.
          </para>
        </step>
        <step>
          <para>
            Após concluir a configuração do destino, recarregue a configuração do <systemitem class="daemon">systemd</systemitem> para disponibilizar o novo destino:
          </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl daemon-reload</screen>
        </step>
      </procedure>
    </sect2>
  </sect1>
  <sect1 xml:id="sec-boot-systemd-advanced">
    <title>Uso avançado</title>

    <para>
      As seções a seguir abordam tópicos avançados para administradores do sistema. Para conferir uma documentação ainda mais avançada do <systemitem class="daemon">systemd</systemitem>, consulte a série de Lennart Pöttering sobre o <systemitem class="daemon">systemd</systemitem> para administradores em <link xlink:href="https://0pointer.de/blog/projects/"/>.
    </para>

    <sect2 xml:id="sec-boot-systemd-advanced-tmp">
      <title>Limpando diretórios temporários</title>
      <para>
        O <systemitem class="daemon">systemd</systemitem> suporta a limpeza de diretórios temporários regularmente. A configuração da versão do sistema anterior é automaticamente migrada e ativada. <literal>tmpfiles.d</literal>, que é responsável pelo gerenciamento de arquivos temporários, lê a configuração dos arquivos <filename>/etc/tmpfiles.d/*.conf</filename>, <filename>/run/tmpfiles.d/*.conf</filename> e <filename>/usr/lib/tmpfiles.d/*.conf</filename>. A configuração armazenada no <filename>/etc/tmpfiles.d/*.conf</filename> anula as configurações relacionadas dos outros dois diretórios (<filename>/usr/lib/tmpfiles.d/*.conf</filename> é o local onde os pacotes armazenam seus arquivos de configuração).
      </para>
      <para>
        O formato da configuração é de uma linha por caminho incluindo ação e caminho; e, opcionalmente, modo, propriedade e os campos de idade e argumento, dependendo da ação. O exemplo a seguir desvincula os arquivos de bloqueio do X11:
      </para>
<screen>Type Path               Mode UID  GID  Age Argument
r    /tmp/.X[0-9]*-lock</screen>
      <para>
        Para obter o status do temporizador tmpfile:
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl status systemd-tmpfiles-clean.timer
systemd-tmpfiles-clean.timer - Daily Cleanup of Temporary Directories
 Loaded: loaded (/usr/lib/systemd/system/systemd-tmpfiles-clean.timer; static)
 Active: active (waiting) since Tue 2018-04-09 15:30:36 CEST; 1 weeks 6 days ago
   Docs: man:tmpfiles.d(5)
         man:systemd-tmpfiles(8)

Apr 09 15:30:36 jupiter systemd[1]: Starting Daily Cleanup of Temporary Directories.
Apr 09 15:30:36 jupiter systemd[1]: Started Daily Cleanup of Temporary Directories.</screen>
      <para>
        Para obter mais informações sobre como lidar com os arquivos temporários, consulte <command>man 5
        tmpfiles.d</command>.
      </para>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-advanced-logging">
      <title>Registro do sistema</title>
      <para>
        A <xref linkend="sec-boot-systemd-basics-services-debugging"/> explica como ver mensagens de registro de determinado serviço. No entanto, a exibição de mensagens de registro não se restringe a registros de serviços. É possível também acessar e consultar as mensagens de registro completas gravadas pelo <systemitem class="daemon">systemd</systemitem>, o chamado <quote>Diário</quote>. Use o comando <command>journalctl</command> para exibir as mensagens de registro completas começando pelas entradas mais antigas. Consulte <command>man 1
        journalctl</command> para ver as opções. Por exemplo, aplicação de filtros ou mudança do formato de saída.
      </para>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-advanced-snapshots">
      <title>Instantâneos</title>
      <para>
        É possível gravar o estado atual do <systemitem class="daemon">systemd</systemitem> em um instantâneo nomeado e depois revertê-lo para esse estado usando o subcomando <command>isolate</command>. Isso é útil para testar serviços ou destinos personalizados, pois permite retornar para um estado definido a qualquer momento. Um instantâneo só fica disponível na sessão atual e é apagado automaticamente na reinicialização. O nome do instantâneo deve terminar com <filename>.snapshot</filename>.
      </para>
      <variablelist>
        <varlistentry>
          <term>Criar um instantâneo</term>
          <listitem>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl snapshot <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Apagar um instantâneo</term>
          <listitem>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl delete <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Ver um instantâneo</term>
          <listitem>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl show <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Ativar um instantâneo</term>
          <listitem>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl isolate <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>

    

    

    <sect2 xml:id="sec-boot-systemd-advanced-kernel-modules">
      <title>Carregando módulos do kernel</title>
      <para>
        Com o <systemitem class="daemon">systemd</systemitem>, é possível carregar os módulos do kernel automaticamente no momento da inicialização, usando o arquivo de configuração em <filename>/etc/modules-load.d</filename>. O arquivo deve ser nomeado <replaceable>MODULE</replaceable>.conf e ter o seguinte conteúdo:
      </para>
<screen># load module <replaceable>MODULE</replaceable> at boot time
<replaceable>MODULE</replaceable></screen>
      <para>
        Se um pacote instalar um arquivo de configuração para carregar um módulo do kernel, o arquivo será instalado em <filename>/usr/lib/modules-load.d</filename>. Se houver dois arquivos de configuração com o mesmo nome, aquele em <filename>/etc/modules-load.d</filename> terá precedência.
      </para>
      <para>
        Para obter mais informações, consulte a página de manual de <systemitem>modules-load.d(5)</systemitem>.
      </para>
    </sect2>

    

    <sect2 xml:id="sec-boot-systemd-advanced-before-local">
      <title>Executando ações antes de carregar um serviço</title>
      <para>
        Com o System V, as ações init que precisam ser executadas antes de carregar um serviço tinham que ser especificadas em <filename>/etc/init.d/before.local
        </filename>. Esse procedimento não é mais suportado com o <systemitem class="daemon">systemd</systemitem>. Se você precisa executar ações antes de iniciar serviços, faça o seguinte:
      </para>
      <variablelist>
        <varlistentry>
          <term>Carregando módulos do kernel</term>
          <listitem>
            <para>
              Crie um arquivo drop-in no diretório <filename>/etc/modules-load.d</filename> (consulte <command>man modules-load.d</command> para ver a sintaxe)
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Criando arquivos ou diretórios, limpando diretórios, mudando a propriedade</term>
          <listitem>
            <para>
              Crie um arquivo drop-in em <filename>/etc/tmpfiles.d</filename> (consulte <command>man tmpfiles.d</command> para ver a sintaxe)
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Outras tarefas</term>
          <listitem>
            <para>
              Crie um arquivo de serviço do sistema, por exemplo, <filename>/etc/systemd/system/before.service</filename>, com base no seguinte gabarito:
            </para>
<screen>[Unit]
Before=<replaceable>NAME OF THE SERVICE YOU WANT THIS SERVICE TO BE STARTED BEFORE</replaceable>
[Service]
Type=oneshot
RemainAfterExit=true
ExecStart=<replaceable>YOUR_COMMAND</replaceable>
# beware, executable is run directly, not through a shell, check the man pages
# systemd.service and systemd.unit for full syntax
[Install]
# target in which to start the service
WantedBy=multi-user.target
#WantedBy=graphical.target</screen>
            <para>
              Quando o arquivo de serviço é criado, você deve executar os seguintes comandos (como <systemitem class="username">root</systemitem>):
            </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl daemon-reload
<prompt>&gt; </prompt><command>sudo</command> systemctl enable before</screen>
            <para>
              Toda vez que você modifica o arquivo de serviço, deve executar:
            </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl daemon-reload</screen>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>

    

    <sect2 xml:id="sec-boot-systemd-advanced-cgroups">
      <title>Grupos de controle (cgroups) do kernel</title>
      <para>
        Em um sistema init tradicional do System V, nem sempre é possível corresponder um processo ao serviço que o gerou. Alguns serviços, como o Apache, geram diversos processos de terceiros (por exemplo, CGI ou Java) que, por sua vez, geram mais processos. Isso dificulta ou até impossibilita uma atribuição clara. Além do mais, um serviço pode não ser terminado corretamente, deixando alguns filhos ativos.
      </para>
      <para>
        O <systemitem class="daemon">systemd</systemitem> resolve este problema colocando cada serviço em seu próprio grupo de controle (cgroup). Cgroups são recursos do kernel que possibilitam agregar processos e todos os seus filhos em grupos hierárquicos organizados. O <systemitem class="daemon">systemd</systemitem> nomeia cada cgroup de acordo com seu serviço. Como um processo não privilegiado não pode <quote>deixar</quote> seu cgroup, essa é uma forma eficiente de rotular todos os processos gerados por um serviço com o nome do serviço.
      </para>
      <para>
        Para listar todos os processos pertencentes a um serviço, use o comando <command>systemd-cgls</command>, por exemplo:
      </para>
      <example>
        <title>Listar todos os processos pertencentes a um serviço</title>
<screen><prompt role="root"># </prompt>systemd-cgls --no-pager
├─1 /usr/lib/systemd/systemd --switched-root --system --deserialize 20
├─user.slice
│ └─user-1000.slice
│   ├─session-102.scope
│   │ ├─12426 gdm-session-worker [pam/gdm-password]
│   │ ├─15831 gdm-session-worker [pam/gdm-password]
│   │ ├─15839 gdm-session-worker [pam/gdm-password]
│   │ ├─15858 /usr/lib/gnome-terminal-server

[...]

└─system.slice
  ├─systemd-hostnamed.service
  │ └─17616 /usr/lib/systemd/systemd-hostnamed
  ├─cron.service
  │ └─1689 /usr/sbin/cron -n
  ├─postfix.service
  │ ├─ 1676 /usr/lib/postfix/master -w
  │ ├─ 1679 qmgr -l -t fifo -u
  │ └─15590 pickup -l -t fifo -u
  ├─sshd.service
  │ └─1436 /usr/sbin/sshd -D

[...]</screen>
      </example>
      <para>
        Consulte o <xref linkend="cha-tuning-cgroups"/> para obter mais informações sobre os cgroups.
      </para>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-advanced-kill">
      <title>Terminando os serviços (enviando sinais)</title>
      <para>
        Conforme explicado na <xref linkend="sec-boot-systemd-advanced-cgroups"/>, nem sempre é possível atribuir um processo a seu processo de serviço pai em um sistema init do System V. Isso dificulta parar um serviço e os respectivos filhos. Os processos filhos que não forem terminados permanecerão como processos zumbis.
      </para>
      <para>
        O conceito do <systemitem class="daemon">systemd</systemitem> de confinar cada serviço em um cgroup possibilita identificar todos os processos filhos de um serviço e, portanto, permite enviar um sinal a cada um desses processos. Use <command>systemctl kill</command> para enviar sinais aos serviços. Para ver uma lista dos sinais disponíveis, consulte <command>man 7 signals</command>.
      </para>
      <variablelist>
        <varlistentry>
          <term>Enviando <systemitem>SIGTERM</systemitem> para um serviço</term>
          <listitem>
            <para>
              <systemitem>SIGTERM</systemitem> é o sinal padrão que é enviado.
            </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl kill <replaceable>MY_SERVICE</replaceable></screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Enviando <replaceable>SIGNAL</replaceable> para um serviço</term>
          <listitem>
            <para>
              Use a opção <option>-s</option> para especificar o sinal que deve ser enviado.
            </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl kill -s <replaceable>SIGNAL</replaceable> <replaceable>MY_SERVICE</replaceable></screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Selecionando processos</term>
          <listitem>
            <para>
              Por padrão, o comando <command>kill</command> envia o sinal para <option>all</option> os processos do cgroup especificado. É possível restringi-lo ao processo <option>control</option> ou <option>main</option>. Este último, por exemplo, é útil para forçar um serviço a recarregar sua configuração enviando <systemitem>SIGHUP</systemitem>:
            </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl kill -s SIGHUP --kill-who=main <replaceable>MY_SERVICE</replaceable></screen>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-dbus">
      <title>Notas importantes sobre o serviço D-Bus</title>
      <para>
        O serviço D-Bus é o barramento de mensagem para comunicação entre clientes <systemitem class="daemon">systemd</systemitem> e o gerenciador systemd que está sendo executado como pid 1. Embora o <systemitem class="daemon">dbus</systemitem> seja um daemon independente, ele é parte integrante da infraestrutura do init.
      </para>
      <para>
        Parar ou reiniciar o <systemitem class="daemon">dbus</systemitem> no sistema em execução é semelhante a uma tentativa de parar ou reiniciar o PID 1. Esse procedimento interrompe a comunicação entre cliente/servidor do <systemitem class="daemon">systemd</systemitem> e inutiliza a maioria das funções do <systemitem class="daemon">systemd</systemitem>.
      </para>
      <para>
        Portanto, terminar ou reiniciar o <systemitem class="daemon">dbus</systemitem> não é recomendado nem suportado.
      </para>
      <para>
        A atualização do <systemitem>dbus</systemitem> ou dos pacotes relacionados ao <systemitem>dbus</systemitem> requer uma reinicialização. Quando estiver em dúvida se uma reinicialização é necessária, execute o comando <command>sudo zypper ps
        -s</command>. Se <literal>dbus</literal> aparecer entre os serviços listados, será necessário reinicializar o sistema.
      </para>
      <para>
        Saiba que o <systemitem>dbus</systemitem> é atualizado mesmo quando as atualizações automáticas estão configuradas para ignorar os pacotes que exigem reinicialização.
      </para>
    </sect2>

    

    <sect2 xml:id="sec-boot-systemd-basics-services-debugging">
      <title>Depurando serviços</title>
      <para>
        Por padrão, o <systemitem class="daemon">systemd</systemitem> não é muito verboso. Se um serviço foi iniciado com êxito, nenhuma saída é gerada. Em caso de falha, uma breve mensagem de erro é exibida. No entanto, <command>systemctl
        status</command> oferece um meio para depurar a inicialização e a operação de um serviço.
      </para>
      <para>
        O <systemitem class="daemon">systemd</systemitem> já vem com um mecanismo de registro (<quote>The Journal</quote> — O Diário) que registra as mensagens do sistema. Isso permite exibir as mensagens de serviço juntamente com as mensagens de status. O comando <command>status</command> funciona de forma parecida com <command>tail</command> e também exibe as mensagens de registro em formatos diferentes, o que faz dele uma poderosa ferramenta de depuração.
      </para>
      <variablelist>
        <varlistentry>
          <term>Mostrar falha na inicialização de serviço</term>
          <listitem>
            <para>
              Sempre que houver falha ao iniciar um serviço, use <command>systemctl status
              <replaceable>MY_SERVICE</replaceable></command> para obter a mensagem de erro detalhada:
            </para>
<screen><prompt role="root"># </prompt>systemctl start apache2
Job failed. See system journal and 'systemctl status' for details.
<prompt role="root"># </prompt>systemctl status apache2
   Loaded: loaded (/usr/lib/systemd/system/apache2.service; disabled)
   Active: failed (Result: exit-code) since Mon, 04 Apr 2018 16:52:26 +0200; 29s ago
   Process: 3088 ExecStart=/usr/sbin/start_apache2 -D SYSTEMD -k start (code=exited, status=1/FAILURE)
   CGroup: name=systemd:/system/apache2.service

Apr 04 16:52:26 g144 start_apache2[3088]: httpd2-prefork: Syntax error on line
205 of /etc/apache2/httpd.conf: Syntax error on li...alHost&gt;</screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Mostrar as últimas <replaceable>N</replaceable> mensagens de serviço</term>
          <listitem>
            <para>
              O comportamento padrão do subcomando <command>status</command> é exibir as dez últimas mensagens emitidas por um serviço. Para mudar o número de mensagens exibidas, use o parâmetro <option>--lines=<replaceable>N</replaceable></option>:
            </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl status chronyd
<prompt>&gt; </prompt><command>sudo</command> systemctl --lines=20 status chronyd</screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Mostrar as mensagens de serviço no modo de anexação</term>
          <listitem>
            <para>
              Para exibir um <quote>fluxo ao vivo</quote> das mensagens de serviço, use a opção <option>--follow</option>, que funciona como o <command>tail</command> <option>-f</option>:
            </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl --follow status chronyd</screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Formato de saída das mensagens</term>
          <listitem>
            <para>
              O parâmetro <option>--output=<replaceable>MODE</replaceable></option> permite mudar o formato de saída das mensagens de serviço. Os modos mais importantes disponíveis são:
            </para>
            <variablelist>
              <varlistentry>
                <term><option>short</option></term>
                <listitem>
                  <para>
                    O formato padrão. Mostra as mensagens de registro com uma marcação de horário legível.
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><option>verbose</option></term>
                <listitem>
                  <para>
                    Saída completa com todos os campos.
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><option>cat</option></term>
                <listitem>
                  <para>
                    Saída resumida sem marcações de horário.
                  </para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>
  </sect1>
  <sect1 xml:id="sec-boot-systemd-timer-units">
    <title>Unidades do temporizador do <systemitem class="daemon">systemd</systemitem></title>

    <para>
      Semelhante ao cron, as unidades do temporizador do <systemitem class="daemon">systemd</systemitem> oferecem um mecanismo para programar tarefas no Linux. Embora as unidades do temporizador do <systemitem class="daemon">systemd</systemitem> tenham a mesma finalidade que o cron, elas oferecem várias vantagens.
    </para>

    <itemizedlist>
      <listitem>
        <para>
          As tarefas programadas usando uma unidade do temporizador podem depender de outros serviços do <systemitem class="daemon">systemd</systemitem>.
        </para>
      </listitem>
      <listitem>
        <para>
          As unidades do temporizador são tratadas como serviços regulares do <systemitem class="daemon">systemd</systemitem>, portanto, podem ser gerenciadas com o <command>systemctl</command>.
        </para>
      </listitem>
      <listitem>
        <para>
          Os temporizadores podem ser em tempo real e monotônicos.
        </para>
      </listitem>
      <listitem>
        <para>
          As unidades de tempo são registradas no diário do <systemitem class="daemon">systemd</systemitem>, o que facilita o monitoramento e a solução de problemas delas.
        </para>
      </listitem>
    </itemizedlist>

    <para>
      As unidades do temporizador do <systemitem class="daemon">systemd</systemitem> são identificadas pela extensão de nome de arquivo <literal>.timer</literal>.
    </para>

    <sect2 xml:id="sec-boot-systemd-timer-types">
      <title>Tipos de temporizador do <systemitem class="daemon">systemd</systemitem></title>
      <para>
        As unidades do temporizador podem usar temporizadores monotônicos e em tempo real.
      </para>
      <itemizedlist>
        <listitem>
          <para>
            Semelhante ao cron, os temporizadores em tempo real são acionados com base em eventos do calendário. Os temporizadores em tempo real são definidos usando a opção <option>OnCalendar</option>.
          </para>
        </listitem>
        <listitem>
          <para>
            Os temporizadores monotônicos são acionados em um tempo especificado decorrido a partir de um determinado ponto inicial. O último pode ser um evento de boot do sistema ou de ativação da unidade do sistema. Há várias opções para definir temporizadores monotônicos, incluindo <option>OnBootSec</option>, <option>OnUnitActiveSec</option> e <option>OnTypeSec</option>. Os temporizadores monotônicos não são persistentes e são redefinidos após cada reinicialização.
          </para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-timer-service-units">
      <title>Temporizadores e unidades de serviço do <systemitem class="daemon">systemd</systemitem></title>
      <para>
        Cada unidade do temporizador deve ter um arquivo de unidade do <systemitem class="daemon">systemd</systemitem> correspondente que ela controla. Em outras palavras, um arquivo <filename>.timer</filename> ativa e gerencia o arquivo <filename>.service</filename> correspondente. Quando usado com um temporizador, o arquivo <filename>.service</filename> não requer uma seção <literal>[Install]</literal>, já que o serviço é gerenciado pelo temporizador.
      </para>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-timer-example">
      <title>Exemplo prático</title>
      <para>
        Para entender os conceitos básicos das unidades do temporizador do <systemitem class="daemon">systemd</systemitem>, configuramos um temporizador que aciona o script shell <filename>foo.sh</filename>.
      </para>
      <para>
        A primeira etapa é criar uma unidade de serviço do <systemitem class="daemon">systemd</systemitem> que controle o script shell. Para fazer isso, abra um novo arquivo de texto para edição e adicione a seguinte definição de unidade de serviço:
      </para>
<screen>[Unit]
Description="Foo shell script"

[Service]
ExecStart=/usr/local/bin/foo.sh</screen>
      <para>
        Grave o arquivo com o nome <filename>foo.service</filename> no diretório <filename>/etc/systemd/system/</filename>.
      </para>
      <para>
        Em seguida, abra um novo arquivo de texto para edição e adicione a seguinte definição do temporizador:
      </para>
<screen>[Unit]
Description="Run foo shell script"

[Timer]
OnBootSec=5min
OnUnitActiveSec=24h
Unit=foo.service

[Install]
WantedBy=multi-user.target</screen>
      <para>
        A seção <literal>[Timer]</literal> no exemplo acima especifica qual serviço acionar (<literal>foo.service</literal>) e quando acioná-lo. Nesse caso, a opção <option>OnBootSec</option> especifica um temporizador monotônico que aciona o serviço cinco minutos após o boot do sistema, enquanto a opção <option>OnUnitActiveSec</option> aciona o serviço 24 horas após a ativação do serviço (ou seja, o temporizador aciona o serviço uma vez por dia). Por fim, a opção <option>WantedBy</option> especifica que o temporizador deve ser iniciado quando o sistema atingiu o destino multiusuário.
      </para>
      <para>
        Em vez de um temporizador monotônico, você pode especificar um em tempo real usando a opção <option>OnCalendar</option>. A seguinte definição do temporizador em tempo real aciona a unidade de serviço relacionada uma vez por semana, começando na segunda-feira às 12:00.
      </para>
<screen>[Timer]
OnCalendar=weekly
Persistent=true</screen>
      <para>
        A opção <option>Persistent=true</option> indica que o serviço será acionado logo após a ativação do temporizador, se o temporizador tiver perdido o último horário de início (por exemplo, porque o sistema estava desligado).
      </para>
      <para>
        A opção <option>OnCalendar</option> também pode ser usada para definir horários e datas específicos para acionar um serviço usando o seguinte formato: <literal>DayOfWeek Year-Month-Day Hour:Minute:Second</literal>. O exemplo abaixo aciona um serviço às 5:00 todos os dias:
      </para>
<screen>OnCalendar=*-*-* 5:00:00</screen>
      <para>
        Você pode usar um asterisco para especificar qualquer valor e vírgulas para listar os valores possíveis. Use dois valores separados por .. para indicar uma faixa contígua. O exemplo a seguir aciona um serviço às 18:00 todas as sextas-feiras do mês:
      </para>
<screen>OnCalendar=Fri *-*-1..7 18:00:00</screen>
      <para>
        Para acionar um serviço em horários diferentes, você pode especificar várias entradas <option>OnCalendar</option>:
      </para>
<screen>OnCalendar=Mon..Fri 10:00
OnCalendar=Sat,Sun 22:00</screen>
      <para>
        No exemplo acima, um serviço é acionado às 10h nos dias de semana e às 22h nos fins de semana.
      </para>
      <para>
        Quando você terminar de editar o arquivo de unidade do temporizador, grave-o com o nome <filename>foo.timer</filename> no diretório <filename>/etc/systemd/system/</filename>. Para verificar se os arquivos de unidade criados estão corretos, execute o seguinte comando:
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command>  systemd-analyze verify /etc/systemd/system/foo.*</screen>
      <para>
        Se o comando não retornar nenhuma saída, os arquivos foram aprovados na verificação.
      </para>
      <para>
        Para iniciar o temporizador, use o comando <command>sudo systemctl start
        foo.timer</command>. Para habilitar o temporizador na inicialização, execute o comando <command>sudo systemctl enable foo.timer</command>.
      </para>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-timer-manage">
      <title>Gerenciando temporizadores do <systemitem class="daemon">systemd</systemitem></title>
      <para>
        Como os temporizadores são tratados como unidades regulares do <systemitem class="daemon">systemd</systemitem>, você pode gerenciá-los usando o <command>systemctl</command>. Você pode iniciar um temporizador com <command>systemctl start</command>, habilitá-lo com <command>systemctl enable</command> e assim por diante. Além disso, você pode listar todos os temporizadores ativos usando o comando <command>systemctl
        list-timers</command>. Para listar todos os temporizadores, incluindo os inativos, execute o comando <command>systemctl list-timers --all</command>.
      </para>
    </sect2>
  </sect1>
  <sect1 xml:id="sec-boot-systemd-info">
    <title>Mais informações</title>

    <para>
      Para obter mais informações sobre o <systemitem class="daemon">systemd</systemitem>, consulte os seguintes recursos online:
    </para>

    <variablelist>
      <varlistentry>
        <term>Home page</term>
        <listitem>
          <para>
            <link xlink:href="https://systemd.io/"/>
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><systemitem class="daemon">systemd</systemitem> para administradores</term>
        <listitem>
          <para>
            Lennart Pöttering, um dos criadores do <systemitem class="daemon">systemd</systemitem>, escreveu uma série de entradas de blog (13 até o fechamento deste capítulo). Encontre-os em <link xlink:href="https://0pointer.de/blog/projects/"/>.
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
  </sect1>
</chapter>
