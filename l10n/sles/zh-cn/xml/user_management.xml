<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="user_management.xml" version="5.0" role="General" xml:id="sec-sec-user-management"> <title>用户管理</title>
 <info>
      <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
        <dm:bugtracker/>
        <dm:translation>yes</dm:translation>
      </dm:docmanager>
    </info>
    <sect1 xml:id="sec-sec-prot-general-accounts">
   <title>各种帐户检查</title>

   <sect2 xml:id="sec-sec-prot-general-accounts-unlocked">
    <title>未锁定的帐户</title>
    <para>
     请务必锁定未用于登录的所有系统帐户和供应商帐户。要获取您系统中未锁定帐户的列表，您可以查找<emphasis>不含</emphasis>以 <literal>! </literal> 或 <literal>*</literal> 开头（在 <filename>/etc/shadow</filename> 文件中）的加密口令字符串的帐户。如果使用 <command>passwd</command> <option>-l</option> 锁定帐户，将会在加密口令之前添加 <literal>!! </literal>，以有效禁用该口令。如果使用 <command>usermod</command> <option>-L</option> 锁定帐户，将会在加密口令之前添加 <literal>! </literal>。默认情况下，许多系统和共享帐户通常都由口令字段中的 <literal>*</literal> 或 <literal>!! </literal> 进行锁定，这会让加密口令变为无效字符串。因此，要获取所有未锁定（可加密）帐户的列表，请运行以下命令：
    </para>
    <screen><prompt role="root">root # </prompt>egrep -v ':\*|:\!' /etc/shadow | awk -F: '{print $1}'</screen>
    <para>
     同时确保所有帐户在 <filename>/etc/passwd</filename> 中的口令字段中都有一个 <literal>x</literal>。以下命令列出口令字段中没有 <literal>x</literal> 的所有帐户：
    </para>
    <screen><prompt role="root">root # </prompt>grep -v ':x:' /etc/passwd</screen>
    <para>
     口令字段中的 <literal>x</literal> 表示该口令已阴影化，例如，需要在 <filename>/etc/shadow</filename> 文件中查找加密口令。如果 <filename>/etc/passwd</filename> 中的口令字段为空，则系统将不会查找阴影文件，并且不会在出现登录提示时提示用户提供口令。
    </para>
   </sect2>

   <sect2 xml:id="sec-sec-prot-general-accounts-unused">
    <title>未使用的帐户</title>
    <para>
     应从系统中去除未被用户、应用程序、系统或守护程序使用的所有系统帐户或供应商帐户。您可以使用以下命令，查找特定帐户是否拥有任何文件：
    </para>
    <screen><prompt role="root">root # </prompt>find / -path /proc -prune -o -user <replaceable>ACCOUNT</replaceable> -ls</screen>
    <para>
     在此示例中，<option>-prune</option> 选项用于跳过 /proc 文件系统。如果您确定可以删除某个帐户，可以使用以下命令去除该帐户：
    </para>
    <screen><prompt role="root">root # </prompt>userdel -r <replaceable>ACCOUNT</replaceable></screen>
    <para>
     如果没有 <option>-r</option> 选项，<command>userdel</command> 将不会删除用户的主目录和邮件假脱机目录 (<filename>/var/spool/mail/<replaceable>USER</replaceable></filename>)。请注意，许多系统帐户都没有主目录。
    </para>
   </sect2>
  </sect1>
  <sect1 xml:id="sec-sec-prot-general-pw-aging">
   <title>启用口令时效</title>

   <para>
    口令失效是一种普遍采用的最佳实践，但对于一些系统帐户和共享帐户（例如 Oracle）而言，可能需要将其排除。如果应用程序帐户失效，这些帐户的失效口令可能会导致系统服务中断。
   </para>

   <para>
    通常情况下，应针对系统帐户和共享帐户的口令更改规则/程序制定相应的公司政策。但常规用户帐户口令应该会自动失效。以下示例显示如何针对各个用户帐户设置口令失效。
   </para>

   <para>
    使用 <command>useradd</command> 命令创建新帐户时，可以使用下表中的文件和参数。将在 <filename>/etc/shadow</filename> 文件中为每个用户帐户储存此类设置。如果使用 YaST 工具（<guimenu>用户和组管理</guimenu>）添加用户，则会为每个用户提供该设置。下面是各种不同的设置，其中一些也可能是系统范围的设置（例如，<filename>/etc/login.defs</filename> 和 <filename>/etc/default/useradd</filename> 的修改）：
   </para>

   <informaltable>
    <tgroup cols="3">
     <tbody>
      <row>
       <entry>
        <para>
         <filename>/etc/login.defs</filename>
        </para>
       </entry>
       <entry>
        <para>
         <literal>PASS_MAX_DAYS</literal>
        </para>
       </entry>
       <entry>
        <para>
         口令保持有效的最大天数。
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>/etc/login.defs</filename>
        </para>
       </entry>
       <entry>
        <para>
         <literal>PASS_MIN_DAYS</literal>
        </para>
       </entry>
       <entry>
        <para>
         自上次更改到用户下次可更改口令之前的最小天数。
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>/etc/login.defs</filename>
        </para>
       </entry>
       <entry>
        <para>
         <literal>PASS_WARN_AGE</literal>
        </para>
       </entry>
       <entry>
        <para>
         从上次更改口令到下次提醒更改口令间隔的天数。
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>/etc/default/useradd</filename>
        </para>
       </entry>
       <entry>
        <para>
         <literal>INACTIVE</literal>
        </para>
       </entry>
       <entry>
        <para>
          口令失效后帐户处于禁用状态的天数。
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>/etc/default/useradd</filename>
        </para>
       </entry>
       <entry>
        <para>
         <literal>EXPIRE</literal>
        </para>
       </entry>
       <entry>
        <para>
         帐户失效日期（采用 YYYY-MM-DD 格式）。
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>

   <note>
    <para>
     在这些修改之前创建的用户不受影响。
    </para>
   </note>

   <para>
    请确保在 <filename>/etc/login.defs</filename> 和 <filename>/etc/default/useradd</filename> 文件中更改上述参数。审阅 <filename>/etc/shadow</filename> 文件将显示在添加用户之后如何储存这些设置。
   </para>

   <para>
    要创建新用户帐户，请执行以下命令：
   </para>

   <screen><prompt role="root">root # </prompt>useradd -c "<replaceable>TEST_USER</replaceable>" -g <replaceable>USERS</replaceable> <replaceable>TEST</replaceable></screen>

   <para>
    <option>-g</option> 选项指定此帐户的主组：
   </para>

<screen><prompt role="root">root # </prompt>id <replaceable>TEST</replaceable>
uid=509(test) gid=100(users) groups=100(users)</screen>

   <para>
    为 <filename>/etc/shadow</filename> 文件中的测试用户在 <filename>/etc/login.defs</filename> 和 <filename>/etc/default/useradd</filename> 中记录的设置如下所示：
   </para>

<screen><prompt role="root">root # </prompt>grep <replaceable>TEST</replaceable> /etc/shadow
test:!!:12742:7:60:7:14::</screen>

   <para>
    可使用 <command>chage</command> 命令随时修改口令时效。要禁用系统帐户和共享帐户的口令时效，您可以运行以下 <command>chage</command> 命令：
   </para>

   <screen><prompt role="root">root # </prompt>chage -M -1 <replaceable>SYSTEM_ACCOUNT_NAME</replaceable></screen>

   <para>
    要获取口令失效信息，请运行：
   </para>

   <screen><prompt role="root">root # </prompt>chage -l <replaceable>SYSTEM_ACCOUNT_NAME</replaceable></screen>

   <para>
    例如：
   </para>

<screen><prompt role="root">root # </prompt>chage -l <replaceable>TEST</replaceable>
Minimum: 7
Maximum: 60
Warning: 7
Inactive: 14
Last Change: Jan 11, 2015
Password Expires: Mar 12, 2015
Password Inactive: Mar 26, 2015
Account Expires: Never</screen>
  </sect1>
  <sect1 xml:id="sec-sec-prot-general-pw-strength">
   <title>实施更强的口令</title>

   <para>
    在经审计的系统上，请务必限制用户使用可被轻松破解的简单口令。可以将复杂的口令记下来，只要妥善保管即可。有些人主张通过强口令来保护您免受字典攻击，并可通过数次失败尝试之后锁定帐户来防御此类攻击。但此方法并非始终有效。如果进行此类设置，锁定系统帐户可能会使应用程序和系统服务中断，这会产生另一个同样棘手的问题 — 拒绝服务攻击。
   </para>

   <para>
    但无论怎样，实施有效的口令管理安全措施都很重要。大多数公司会要求口令至少包含一个数字、一个小写字母和一个大写字母。虽然政策各不相同，但要在口令强度/复杂性和管理难易度之间保持平衡可能并不容易。
   </para>
  </sect1>
  <xi:include href="hardening_pam_stack.xml"/>
  <sect1 xml:id="sec-sec-prot-restrict-root">
   <title>限制 <systemitem class="username">root</systemitem> 登录</title>

   <para>
    默认情况下，为 <systemitem class="username">root</systemitem> 用户分配了口令，并且该用户可以使用各种方法进行登录 — 例如，在本地终端上、在图形会话中，或者通过 SSH 远程登录。应尽可能限制使用这些方法登录。应避免共享使用 root 帐户。而是由各个管理员使用 <literal>su</literal> 或 <literal>sudo</literal> 等工具（有关详细信息，请键入 <command>man 1 su</command> 或 <command>man 8 sudo</command>）获取提升的特权。如此可将 <systemitem class="username">root</systemitem> 登录与特定用户相关联。同时还可增加了另一层安全保护；要获得完全的 root 访问权限，需要破解的不仅仅是 <systemitem class="username">root</systemitem> 口令，而是 <systemitem class="username">root</systemitem> <emphasis> 口令以及管理员普通帐户的</emphasis>口令。本节说明如何限制在不同级别系统上的直接 root 登录。
   </para>
   <sect2 xml:id="sec-sec-prot-restrict-root-tty">
    <title>限制本地文本控制台登录</title>

    <para>
     TTY 设备通过控制台提供文本模式的系统访问权限。对于桌面系统，通过本地键盘进行访问；如果是服务器系统，则通过连接到 KVM 交换机或远程管理卡（例如 ILO 和 DRAC）的输入设备进行访问。Linux 默认会提供 6 个不同的控制台，在文本模式下运行时，可通过组合键 <keycombo><keycap function="alt"/><keycap>F1</keycap></keycombo> 到 <keycombo><keycap function="alt"/><keycap>F6</keycap></keycombo> 切换它们；在图形会话中运行时，可通过组合键 <keycombo><keycap function="control"/><keycap function="alt"/><keycap>F1</keycap></keycombo> 到 <keycombo><keycap function="control"/><keycap function="alt"/><keycap>F6</keycap></keycombo> 进行切换。关联的终端设备命名为 <literal>tty1</literal> 至 <literal>tty6</literal>。
    </para>

    <para>
     下面的步骤限制对第一个 TTY 的 root 访问。此访问方法仅作为系统的紧急访问方式，绝不应将其用于日常系统管理任务。
    </para>

    <note>
     <para>
      此处显示的步骤根据 PC 体系结构（x86 和 AMD64/Intel 64）进行定制。在 POWER 等体系结构上，可以使用 <literal>tty1</literal> 以外的其他终端设备名称。请小心不要因为指定了错误的终端设备名称而将您自己完全锁定。您可以通过运行 <literal>tty</literal> 命令确定当前登录的终端的设备名称。请注意不要在虚拟终端（例如通过 SSH）或图形会话（设备名称 <filename>/dev/pts/<replaceable>N</replaceable></filename>）中执行此操作，而只通过实际登录终端（可通过 <keycombo><keycap function="alt"/><keycap>F<replaceable>N</replaceable></keycap></keycombo> 访问）进行操作。
     </para>
    </note>

    <procedure>
     <title>限制在本地 TTY 上进行 root 登录</title>
     <step>
      <para>
       请确保 PAM 堆栈配置文件 <filename>/etc/pam.d/login</filename> 包含 <literal>auth</literal> 块中的 <literal>pam_securetty</literal> 模块：
      </para>
      <screen>auth     requisite      pam_nologin.so
 auth     [user_unknown=ignore success=ok ignore=ignore auth_err=die default=bad] pam_securetty.so noconsole
 auth     include        common-auth</screen>
      <para>
        这样系统会在本地控制台处理身份验证期间包含 <literal>pam_securetty</literal> 模块，该模块会将 <systemitem class="username">root</systemitem> 限制为仅可在文件 <filename>/etc/securetty</filename> 中列出的 TTY 设备上登录。
      </para>
     </step>
     <step>
      <para>
       去除 <filename>/etc/securetty</filename> 中除这一项外的其他所有项。这将限制对 TTY 设备的 root 访问。
      </para>
     <screen>#
# This file contains the device names of tty lines (one per line,
# without leading /dev/) on which root is allowed to login.
#
tty1</screen>
     </step>
     <step>
      <para>
       检查是否会拒绝 <systemitem class="username">root</systemitem> 登录其他终端。应立即拒绝在 <literal>tty2</literal> 等终端上登录，甚至无需查询帐户口令。同时确保您仍可以成功登录 <literal>tty1</literal>，因而不会将 <systemitem class="username">root</systemitem> 完全锁定在系统之外。
      </para>
     </step>
    </procedure>

    <important>
     <para>
      请不要将 <literal>pam_securetty</literal> 模块添加到 <filename>/etc/pam.d/common-auth</filename> 文件中。这将破坏 <command>su</command> 和 <command>sudo</command> 命令，因为这些工具也会拒绝 <systemitem class="username">root</systemitem> 身份验证。
     </para>
    </important>

    <important>
     <para>
      这些配置更改还将导致拒绝在 <filename>/dev/ttyS0</filename> 等串行控制台上进行 root 登录。如果您需要此类用例，则需要在 <filename>/etc/securetty</filename> 文件中额外列出相应的 TTY 设备。
     </para>
    </important>
   </sect2>

   <sect2 xml:id="sec-sec-prot-retrict-root-graphical">
    <title>限制图形会话登录</title>

    <para>
     要提高您服务器的安全性，请完全避免使用图形环境。通常，图形程序不会设计为以 <systemitem class="username">root</systemitem> 身份运行，因此与控制台程序相比更可能包含安全问题。如果您需要图形登录，请使用非 <systemitem class="username">root</systemitem> 登录。配置您的系统，禁止通过 <systemitem class="username">root</systemitem> 登录图形会话。
    </para>

    <para>
     为了防止通过 <systemitem class="username">root</systemitem> 登录图形会话，您可以采用<xref linkend="sec-sec-prot-restrict-root-tty"/>中概述的相同基本步骤。只需将 <literal>pam_securetty</literal> 模块添加到属于显示管理器的 PAM 堆栈文件 — 例如，GDM 的 <filename>/etc/pam.d/gdm</filename>。图形会话还会在 TTY 设备上运行：默认为 <literal>tty7</literal>。因此，如果您限制 <systemitem class="username">root</systemitem> 登录到 <literal>tty1</literal>，将拒绝通过 <systemitem class="username">root</systemitem> 登录图形会话。
    </para>
   </sect2>

   <sect2 xml:id="sec-sec-prot-restrict-root-ssh">
    <title>限制 SSH 登录</title>
    <para>
     默认情况下，还允许 <systemitem class="username">root</systemitem> 用户通过 SSH 网络协议远程登录计算机（如果 SSH 端口未被防火墙阻止）。要限制此类登录，请对 OpenSSH 配置进行以下更改：
    </para>
    <procedure>
     <step>
      <para>编辑 <filename>/etc/ssh/sshd_config</filename> 并调整以下参数：</para>
      <screen>PermitRootLogin no</screen>
     </step>
     <step>
      <para>重启动 <systemitem class="service">sshd</systemitem> 服务以使更改生效：</para>
      <screen>systemctl restart sshd.service</screen>
     </step>
    </procedure>
    <note>
     <para>
      对于 OpenSSH，不适合使用 PAM <literal>pam_securetty</literal> 模块，因为在授权期间并非所有 SSH 登录都会通过 PAM 堆栈进行（例如使用 SSH 公共密钥身份验证时）。此外，攻击者能够区分错误口令和策略只能在稍后予以拒绝的成功登录。
     </para>
    </note>
   </sect2>

  </sect1>
  <sect1 xml:id="sec-sec-prot-inactivity-logout">
   <title>为交互式外壳会话设置无活动超时</title>
   <para>
    最好在一段无活动时间之后终止交互式外壳会话。例如，通过此方式可以阻止打开的无人监管会话或避免浪费系统资源。
   </para>
   <para>
    默认情况下，外壳没有无活动超时。如此当外壳处于打开状态且在几天甚至几年内未被使用时，也不会有任何反应。不过，您可以将大多数外壳配置为在一段时间后自动终止空闲会话。以下示例显示如何为一些常见类型的外壳设置无活动超时。
   </para>
   <para>
    可仅为登录外壳配置无活动超时，也可以为所有交互式外壳配置无活动超时。在后一种情况下，将针对每个外壳实例单独运行无活动超时。这意味着超时将会累积。当启动子外壳时，会为子外壳开始新的超时，并且仅在此超时过后，才会继续运行父外壳的超时。
   </para>
   <para>
    下表包含 <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 随附的常见外壳选集的配置详细信息：
   </para>
   <informaltable frame="all" rowsep="1" colsep="1">
    <tgroup cols="7">
     <colspec colname="col_1" colwidth="14.2857*"/>
     <colspec colname="col_2" colwidth="14.2857*"/>
     <colspec colname="col_3" colwidth="14.2857*"/>
     <colspec colname="col_4" colwidth="14.2857*"/>
     <colspec colname="col_5" colwidth="14.2857*"/>
     <colspec colname="col_6" colwidth="14.2857*"/>
     <colspec colname="col_7" colwidth="14.2858*"/>
     <thead>
      <row>
       <entry>软件包</entry>
       <entry>外壳特点</entry>
       <entry align="center">外壳变量</entry>
       <entry align="center">时间单位</entry>
       <entry>只读设置</entry>
       <entry align="center">配置路径（仅登录外壳）</entry>
       <entry align="center">配置路径（所有外壳）</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><para><literal>bash</literal></para></entry>
       <entry><para><literal>bash、sh</literal></para></entry>
       <entry align="center"><para><literal>TMOUT</literal></para></entry>
       <entry align="center"><para>秒</para></entry>
       <entry><para><literal>read-only TMOUT=</literal></para></entry>
       <entry><para><filename>/etc/profile.local</filename>、<filename>/etc/profile.d/</filename></para></entry>
       <entry><para><filename>/etc/bash.bashrc</filename></para></entry>
      </row>
      <row>
       <entry><para><literal>mksh</literal></para></entry>
       <entry><para><literal>ksh、lksh、mksh、pdksh</literal></para></entry>
       <entry align="center"><para><literal>TMOUT</literal></para></entry>
       <entry align="center"><para>秒</para></entry>
       <entry><para><literal>read-only TMOUT=</literal></para></entry>
       <entry><para><filename>/etc/profile.local</filename>、<filename>/etc/profile.d/</filename></para></entry>
       <entry><para><filename>/etc/ksh.kshrc.local</filename></para></entry>
      </row>
      <row>
       <entry><para><literal>tcsh</literal></para></entry>
       <entry><para><literal>csh、tcsh</literal></para></entry>
       <entry align="center"><para><literal>autologout</literal></para></entry>
       <entry align="center"><para>分钟</para></entry>
       <entry><para><literal>set -r autologout=</literal></para></entry>
       <entry><para><filename>/etc/csh.login.local</filename></para></entry>
       <entry><para><filename>/etc/csh.cshrc.local</filename></para></entry>
      </row>
      <row>
       <entry><para><literal>zsh</literal></para></entry>
       <entry><para><literal>zsh</literal></para></entry>
       <entry align="center"><para><literal>TMOUT</literal></para></entry>
       <entry align="center"><para>秒</para></entry>
       <entry><para><literal>readonly TMOUT=</literal></para></entry>
       <entry><para><filename>/etc/profile.local</filename>、<filename>/etc/profile.d/</filename></para></entry>
       <entry><para><filename>/etc/zsh.zshrc.local</filename></para></entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
   <para>
    每个列出的外壳支持使用一个内部超时外壳变量，可将该变量设置为某个特定时间值以触发无活动超时。如果您要防止用户覆盖超时设置，可以将相应的外壳超时变量标记为只读。上表中还提供了相应的变量声明语法。
   </para>

   <note>
    <para>
     此功能仅有助于避免因用户疏忽或遵循不安全做法而导致的风险。而无法防范恶意用户。超时只适用于外壳的交互式等待状态。恶意用户总是能找到绕过超时的方法，使得无论在任何情况下，都可以让其会话保持打开状态。
    </para>
   </note>

   <para>
    要配置无活动超时，需要为每个外壳的启动脚本都添加匹配的超时变量声明。可仅为登录外壳使用一种路径，或为所有外壳使用一种路径，如表中所列。以下示例使用适合 <command>bash</command> 和 <command>ksh</command> 的路径和设置，设置了无法被用户覆盖的只读登录外壳超时。使用以下内容创建文件 <filename>/etc/profile.d/timeout.sh</filename>：
   </para>
   <screen># /etc/profile.d/timeout.sh for SUSE Linux
#
# Timeout in seconds until the bash/ksh session is terminated
# in case of inactivity.
# 24h = 86400 sec
readonly TMOUT=86400</screen>

   <tip>
    <para>
     建议使用 <command>screen</command> 工具在注销前分离会话。<command>screen</command> 会话不会终止，一旦有需要便可重新挂接。可以在未注销的情况下锁定活动会话（有关细节，请阅读 <command>man screen</command> 中的 <keycombo>
      <keycombo><keycap function="control"/><keycap>a</keycap></keycombo>
      <keycap>x</keycap></keycombo> / <command>lockscreen</command>）。
    </para>
   </tip>

  </sect1>
  <sect1 xml:id="sec-sec-prot-dos">
   <title>防止意外拒绝服务</title>

   <para>
    Linux 允许您对用户和组可以使用的系统资源量设置限制。如果因为程序中的 bug 导致用户和组耗尽太多资源（例如内存泄漏）、降低计算机速度，甚至使系统无法使用，此项设置也非常有用。错误的设置可能会允许程序使用过多资源，这可能会导致服务器无法响应新连接，甚至无法响应本地登录请求（例如，如果某个程序用掉主机上的所有可用文件句柄）。这也会成为一个安全问题，例如，如果允许某人用掉所有系统资源，将会导致拒绝服务攻击（无论是无意的还是更糟的恶意攻击）。设置用户和组的资源限制可能是一种有效的系统保护方法，具体视环境而定。
   </para>

   <sect2 xml:id="sec-sec-prot-dos-restrict-ressources">
    <title>限制系统资源示例</title>
    <para>
     以下示例演示了设置或限制 Oracle 用户帐户的系统资源使用的实际用法。有关系统资源设置列表，请参见 <filename>/etc/security/limits.conf</filename> 或 <command>man limits.conf</command>。
    </para>
    <para>
     Bash 等大多数外壳都会提供基于用户的各种资源控制（例如允许的打开文件描述符数量上限或最大进程数）。要检查外壳中的所有当前限制，请执行以下命令：
    </para>
    <screen><prompt role="root">root # </prompt>ulimit -a</screen>
    <para>
     有关 Bash 外壳的 <command>ulimit</command> 的详细信息，请查看 Bash 手册页。
    </para>
    <important>
     <title>设置 SSH 会话的限制</title>
     <para>
      使用 SSH 会话时，设置<quote>硬</quote>限制和<quote>软</quote>限制可能不会起到预期的效果。要查看有效行为，可能需要以 root 身份登录，然后使用 <command>su</command> 命令切换到权限受限的身份（例如，在这些示例中为 <literal>Oracle</literal>）。假设应用程序在引导过程中已自动启动，资源限制也应生效。如果通过 SSH 对资源限制进行的更改似乎未生效，可能需要将 <filename>/etc/ssh/sshd_config</filename> 中的 <option>UsePrivilegeSeparation</option> 设置为 <literal>no</literal>，并重启动 SSH 守护程序 (<command>systemctl restart sshd</command>)。但一般不建议这样做，因为这会降低系统安全性。
     </para>
    </important>
    <tip>
     <title>禁用通过 <command>ssh</command> 进行口令登录功能</title>
     <para>
      您可以通过禁用 SSH 的口令身份验证来为服务器增加一定程度的安全性。请记住，您需要配置 SSH 密钥，否则无法访问服务器。要禁用口令登录，请在 <filename>/etc/ssh/sshd_config</filename> 中添加下面几行：
     </para>
<screen>UseLogin no
UsePAM no
PasswordAuthentication no
PubkeyAuthentication yes</screen>
    </tip>
    <para>
     在此示例中，可通过以 <systemitem class="username">root</systemitem> 身份编辑 <filename>/etc/security/limits.conf</filename> 并进行以下更改，来更改用户 <literal>oracle</literal> 可使用的文件句柄数或打开的文件数：
    </para>
<screen>oracle           soft    nofile          4096
oracle           hard    nofile          63536</screen>
    <para>
     第一行中的软限制定义了登录后 <systemitem class="username">oracle</systemitem> 用户将拥有的文件句柄（打开的文件）数目限制。如果用户看到有关文件句柄用尽的错误消息，则可以执行以下命令，将此示例中所示的文件句柄数增加到硬限制（在此示例中为 63536）：
    </para>
    <screen><prompt role="root">root # </prompt>ulimit -n 63536</screen>
    <para>
     必要时，您可以设置更高的软限制和硬限制。
    </para>
    <note>
     <para>
      请务必合理利用 ulimit。允许用户的 <literal>nofile</literal> 的<quote>硬</quote>限制（相当于内核限制 (<filename>/proc/sys/fs/file-max</filename>)）是非常糟糕的设置！如果用户占用了所有可用文件句柄，系统将无法启动新的登录，因为它无法访问执行登录所需的 PAM 模块。
     </para>
    </note>
    <para>
     您还需要确保在 <filename>/etc/pam.d/common-auth</filename> 中全局配置 <literal>pam_limits</literal>，或者针对以下文件中的 SSH、su、login 和 telnet 等个别服务进行配置：
    </para>
    <simplelist>
     <member><filename>/etc/pam.d/sshd</filename>（用于 SSH）</member>
     <member><filename>/etc/pam.d/su</filename>（用于 su）</member>
     <member><filename>/etc/pam.d/login</filename>（本地登录和 telnet）</member>
    </simplelist>
    <para>
     如果您不想为所有登录启用该配置，会有一个特定 PAM 模块读取 <filename>/etc/security/limits.conf</filename> 文件。PAM 配置指令中的项将如下所示：
    </para>
<screen>session     required      /lib/security/pam_limits.so
session     required      /lib/security/pam_unix.so</screen>
    <para>
     请务必注意，更改不会立即生效，需要新的登录会话：
    </para>
<screen><prompt role="root">root # </prompt>su - oracle
<prompt>tux &gt; </prompt>ulimit -n
4096</screen>
    <para>
     请注意，这些示例特定于 Bash 外壳；其他外壳的 <command>ulimit</command> 选项会有所不同。用户 <literal>oracle</literal> 的默认限制为 <literal>4096</literal>。要将用户 <literal>oracle</literal> 可使用的文件句柄数增加至 <literal>63536</literal>，请执行以下命令：
    </para>
<screen><prompt role="root">root # </prompt>su - oracle
<prompt>tux &gt; </prompt>ulimit -n
4096
<prompt>tux &gt; </prompt>ulimit -n 63536
<prompt>tux &gt; </prompt>ulimit -n
63536</screen>
    <para>
     要使其成为永久设置，需要向用户配置文件（<filename>~/.bashrc</filename> 或 <filename>~/.profile</filename> 文件）添加设置 <command>ulimit -n 63536</command>（仍是适用于 Bash），该配置文件为 <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 上的 Bash 外壳的用户启动文件（要校验外壳，请运行 <command>echo $SHELL</command>）。为此，可以针对用户 <literal>oracle</literal> 的 Bash 外壳运行以下命令：
    </para>
<screen><prompt role="root">root # </prompt>su - oracle
<prompt>tux &gt; </prompt>cat &gt;&gt; ~oracle/.bash_profile &lt;&lt; EOF
ulimit -n 63536
EOF</screen>
   </sect2>
  </sect1>
  
  <sect1 xml:id="sec-sec-prot-banners">
   <title>显示登录标题</title>

   <para>
    出于法律/审计政策原因，或者为了向用户提供安全说明，通常有必要在所有服务器上的登录屏幕上设置一个标题。
   </para>

   <para>
    如果您想在用户登录文本型终端（例如，使用 SSH 或在本地控制台上）<emphasis>后</emphasis>列显登录标题，可以使用 <filename>/etc/motd</filename> 文件（motd = 当天的消息）。默认情况下，该文件存在于 <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 上，但是空文件。只需向适用的/组织所需的文件中添加内容。
   </para>

   <note>
    <title>标题长度</title>
    <para>
     请尽量将登录标题内容放在一个终端页面（或更少）中，如果一页容纳不下而需要滚动屏幕，会使阅读变得更加困难。
    </para>
   </note>

   <para>
    您也可以在用户登录文本型终端<emphasis>前</emphasis>列显登录标题。如果是本地控制台登录，您可以编辑 <filename>/etc/issue</filename> 文件，这会使标题在出现登录提示前显示。如果是通过 SSH 进行登录，您可以编辑 <filename>/etc/ssh/sshd_config</filename> 文件中的<quote>Banner</quote>参数，这会在出现 SSH 登录提示前相应地显示标题文本。
   </para>

   <para>
    如果是通过 GDM 进行的图形登录，您可以遵循 <link xlink:href="https://help.gnome.org/admin/system-admin-guide/stable/login-banner.html.en">GNOME 管理员指南</link>设置登录标题。此外，您可以进行以下更改，以要求用户通过选择<guimenu>是</guimenu>或<guimenu>否</guimenu>来对法律标题进行确认。编辑 <filename>/etc/gdm/Xsession</filename> 文件，并在脚本<emphasis>开头</emphasis>添加下面几行：
   </para>

<screen>if ! /usr/bin/gdialog --yesno '\n<replaceable>This system is classified...</replaceable>\n' 10 10; then
    /usr/bin/gdialog --infobox 'Aborting login'
    exit 1;
fi</screen>

   <para>
    需要将文本 <replaceable>This system is classified...</replaceable> 替换为所需的标题文本。请务必注意，此对话框不会阻止登录进行。有关 GDM 脚本的详细信息，请参见 <link xlink:href="https://help.gnome.org/admin/gdm/stable/configuration.html.en#scripting">GDM 管理员手册</link>。
   </para>
  </sect1>
     <sect1 xml:id="sec-sec-prot-misc-account-utils">
    <title>连接统计实用程序</title>
    <para>
     下面是您可以用于获取有关用户登录的数据的命令列表：
    </para>
    <formalpara>
     <title><command>who</command></title>
     <para>
      列出当前登录的用户。
     </para>
    </formalpara>
    <formalpara>
     <title><command>w</command></title>
     <para>
      显示登录者及其执行的操作。
     </para>
    </formalpara>
    <formalpara>
     <title><command>last</command></title>
     <para>
      显示最近登录的用户列表，包括登录时间、注销时间、登录 IP 地址等。
     </para>
    </formalpara>
    <formalpara>
     <title><command>lastb</command></title>
     <para>
      与 <command>last</command> 相同（除了默认显示 <filename>/var/log/btmp</filename>），包含所有无效登录尝试。
     </para>
    </formalpara>
    <formalpara>
     <title><command>lastlog</command></title>
     <para>
      此命令报告 <filename>/var/log/lastlog</filename> 中维护的数据，该文件是用户上次登录的记录。
     </para>
    </formalpara>
    <formalpara>
     <title><command>ac</command></title>
     <para>
      安装 <systemitem>acct</systemitem> 软件包之后提供。按每个用户或每天等条件列显连接时间（以小时为单位）。此命令读取 <filename>/var/log/wtmp</filename>。
     </para>
    </formalpara>
    <formalpara>
     <title><command>dump-utmp</command></title>
     <para>
      将原始数据从 /var/run/utmp 或 <filename>/var/log/wtmp</filename> 转换为 ASCII 可分析格式。
     </para>
    </formalpara>
    <para>
     此外，如果未运行任何日志记录工具，请检查 <filename>/var/log/messages</filename> 文件或 <command>journalctl</command> 的输出。有关 <systemitem class="daemon">systemd</systemitem> 日记的详细信息，请参见<xref linkend="cha-journalctl"/>。
    </para>
   </sect1>
  </chapter>
