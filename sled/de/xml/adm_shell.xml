<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="adm_shell.xml" version="5.0" xml:id="cha.adm.shell">

 <title>Bash-Shell und Bash-Skripte</title>
 <info>
  <abstract>
   <para>
    Heutzutage werden zunehmend Computer mit einer grafischen Benutzeroberfläche (GUI) wie GNOME verwendet. Diese bieten zwar viele Funktionen, jedoch ist ihre Verwendung beschränkt, was automatisierte Aufgaben angeht. Shells sind eine gute Ergänzung für GUIs, und dieses Kapitel gibt Ihnen einen Überblick über einige Aspekte von Shells, in diesem Fall die Bash-Shell.
   </para>
  </abstract>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>Ja</dm:translation>
  </dm:docmanager>
 </info>
<indexterm> <primary>Shell</primary> </indexterm> <indexterm> <primary>Bash</primary> <see>Shell</see> </indexterm>
 <sect1 xml:id="sec.adm.whatistheshell">
  <title>Was ist <quote>die Shell</quote>?</title>



  <para>
   Traditionell handelt es sich bei <emphasis>der</emphasis> Shell um Bash (Bourne again Shell). Wenn in diesem Kapitel die Rede von <quote>der Shell</quote> ist, ist die Bash-Shell gemeint. Außer Bash sind noch weitere Shells verfügbar (ash, csh, ksh, zsh und viele mehr), von denen jede unterschiedliche Funktionen und Merkmale aufweist. Wenn Sie weitere Informationen über andere Shells wünschen, suchen Sie in YaST nach <emphasis>shell</emphasis>.
  </para>

  <sect2 xml:id="sec.adm.configfiles">
   <title>Die Bash-Konfigurationsdateien</title><indexterm> <primary>Konfigurationsdateien</primary> <see>Bash</see> </indexterm>
   <para>
    Eine Shell lässt sich aufrufen als:
   </para>
   <orderedlist spacing="normal">
    <listitem>
     <formalpara>
      <title>Interaktive Login-Shell</title>
      <para>
       Diese wird zum Anmelden bei einem Computer durch den Aufruf von Bash mit der Option <option>--login</option> verwendet oder beim Anmelden an einem entfernten Computer mit SSH.
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title><quote>Gewöhnliche</quote> interaktive Shell</title>
      <para>
       Dies ist normalerweise beim Starten von xterm, konsole, gnome-terminal oder ähnlichen Tools der Fall.
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Nicht interaktive Shell</title>
      <para>
       Dies wird beim Aufrufen eines Shell-Skripts in der Kommandozeile verwendet.
      </para>
     </formalpara>
    </listitem>
   </orderedlist>
   <para>
    Abhängig vom verwendeten Shell-Typ werden unterschiedliche Konfigurationsdateien gelesen. Die folgenden Tabellen zeigen die Login- und Nicht-Login-Shell-Konfigurationsdateien.
   </para>
   <table xml:id="tab.adm.shell.config.loginshells">
    <title>Bash-Konfigurationsdateien für Login-Shells</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>
        <para>
         Datei
        </para>
       </entry>
       <entry>
        <para>
         Beschreibung
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         <filename>/etc/profile</filename>
        </para>
       </entry>
       <entry>
        <para>
         Bearbeiten Sie diese Datei nicht, andernfalls können Ihre Änderungen bei Ihrem nächsten Update zerstört werden.
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>/etc/profile.local</filename>
        </para>
       </entry>
       <entry>
        <para>
         Verwenden Sie diese Datei, wenn Sie <filename>/etc/profile</filename> erweitern.
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>/etc/profile.d/</filename>
        </para>
       </entry>
       <entry>
        <para>
         Enthält systemweite Konfigurationsdateien für bestimmte Programme
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>~/.profile</filename>
        </para>
       </entry>
       <entry>
        <para>
         Fügen Sie hier benutzerspezifische Konfigurationsdaten für Login-Shells ein.
        </para>
       </entry>
      </row>

     </tbody>
    </tgroup>
   </table>
   <table xml:id="tab.adm.shell.configs.nonloginshells">
    <title>Bash-Konfigurationsdateien für Nicht-Login-Shells</title>
    <tgroup cols="2">
     <tbody>
      <row>
       <entry>
        <para>
         <filename>/etc/bash.bashrc</filename>
        </para>
       </entry>
       <entry>
        <para>
         Bearbeiten Sie diese Datei nicht, andernfalls können Ihre Änderungen bei Ihrem nächsten Update zerstört werden.
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>/etc/bash.bashrc.local</filename>
        </para>
       </entry>
       <entry>
        <para>
         Verwenden Sie diese Datei, um Ihre systemweiten Änderungen nur für die Bash-Shell einzufügen.
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>~/.bashrc</filename>
        </para>
       </entry>
       <entry>
        <para>
         Fügen Sie hier benutzerspezifische Konfigurationsdaten ein.
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Daneben verwendet die Bash-Shell einige weitere Dateien:
   </para>
   <table>
    <title>Besondere Dateien für die Bash-Shell</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>
        <para>
         Datei
        </para>
       </entry>
       <entry>
        <para>
         Beschreibung
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         <filename>~/.bash_history</filename>
        </para>
       </entry>
       <entry>
        <para>
         Enthält eine Liste aller Kommandos, die Sie eingegeben haben.
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>~/.bash_logout</filename>
        </para>
       </entry>
       <entry>
        <para>
         Wird beim Abmelden ausgeführt.
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>

  <xi:include href="fs_structure_i.xml"/>
 </sect1>
 <sect1 xml:id="sec.adm.shellscripts">
  <title>Schreiben von Shell-Skripten</title><indexterm> <primary>Shell-Skripten</primary> </indexterm>

  <para>
   Shell-Skripte bieten eine bequeme Möglichkeit, alle möglichen Aufgaben zu erledigen: Erfassen von Daten, Suche nach einem Wort oder Begriff in einem Text und viele andere nützliche Dinge. Das folgende Beispiel zeigt ein kleines Shell-Skript, das einen Text druckt:
  </para>

  <example>
   <title>Ein Shell-Skript, das einen Text druckt</title>
<screen>#!/bin/sh <co xml:id="co.adm.shell.shebang"/>
# Output the following line: <co xml:id="co.adm.shell.comment"/>
echo "Hello World" <co xml:id="co.adm.shell.echo"/></screen>
   <calloutlist>
    <callout arearefs="co.adm.shell.shebang">
     <para>
      Die erste Zeile beginnt mit dem <emphasis>Shebang</emphasis> <indexterm> <primary>Shebang</primary> </indexterm>-Zeichen (<literal>#!</literal>), das darauf hinweist, dass es sich bei dieser Datei um ein Skript handelt. Das Skript wird mit dem Interpreter ausgeführt, der nach dem Shebang angegeben ist, in diesem Fall mit <command>/bin/sh</command>.
     </para>
    </callout>
    <callout arearefs="co.adm.shell.comment">
     <para>
      Die zweite Zeile ist ein Kommentar, der mit dem Hash-Zeichen beginnt. Es wird empfohlen, schwierige Zeilen zu kommentieren, damit ihre Bedeutung auch später klar ist.
     </para>
    </callout>
    <callout arearefs="co.adm.shell.echo">
     <para>
      Die dritte Zeile verwendet das integrierte Kommando <command>echo</command>, um den entsprechenden Text zu drucken.
     </para>
    </callout>
   </calloutlist>
  </example>

  <para>
   Bevor Sie dieses Skript ausführen können, müssen einige Voraussetzungen erfüllt sein:
  </para>

  <orderedlist spacing="normal">
   <listitem>
    <para>
     Jedes Skript muss eine Shebang-Zeile enthalten. (Dies ist im obigen Beispiel bereits der Fall.) Wenn ein Skript diese Zeile nicht enthält, müssen Sie den Interpreter manuell aufrufen.
    </para>
   </listitem>
   <listitem>
    <para>
     Sie können das Skript an beliebiger Stelle speichern. Jedoch empfiehlt es sich, es in einem Verzeichnis zu speichern, in dem die Shell es finden kann. Der Suchpfad in einer Shell wird durch die Umgebungsvariable <envar>PATH</envar> bestimmt. In der Regel verfügt ein normaler Benutzer über keinen Schreibzugriff auf <filename>/usr/bin</filename>. Daher sollten Sie Ihre Skripten im Benutzerverzeichnis <filename>~/bin/</filename> speichern. Das obige Beispiel erhält den Namen <filename>hello.sh</filename>.
    </para>
   </listitem>
   <listitem>
    <para>
     Das Skript muss zum Ausführen von Dateien berechtigt sein. Stellen Sie die Berechtigungen mit dem folgenden Kommando ein:
    </para>
<screen>chmod +x ~/bin/hello.sh</screen>
   </listitem>
  </orderedlist>

  <para>
   Wenn Sie alle oben genannten Voraussetzungen erfüllt haben, können Sie das Skript mithilfe der folgenden Methoden ausführen:
  </para>

  <orderedlist spacing="normal">
   <listitem>
    <formalpara>
     <title>Als absoluten Pfad</title>
     <para>
      Das Skript kann mit einem absoluten Pfad ausgeführt werden. In unserem Fall lautet er <command>~/bin/hello.sh</command>.
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>Überall</title>
     <para>
      Wenn die Umgebungsvariable <envar>PATH</envar> das Verzeichnis enthält, in dem sich das Skript befindet, können Sie das Skript mit <command>hello.sh</command> ausführen.
     </para>
    </formalpara>
   </listitem>
  </orderedlist>
 </sect1>
 <sect1 xml:id="sec.adm.shell.redirect">
  <title>Umlenken von Kommandoereignissen</title>

  <para>
   Jedes Kommando kann drei Kanäle für Eingabe oder Ausgabe verwenden:
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <formalpara>
     <title>Standardausgabe</title>
     <para>
      Dies ist der Standardausgabe-Kanal. Immer wenn ein Kommando eine Ausgabe erzeugt, verwendet es den Standardausgabe-Kanal.
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>Standardeingabe</title>
     <para>
      Wenn ein Kommando Eingaben von Benutzern oder anderen Kommandos benötigt, verwendet es diesen Kanal.
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>Standardfehler</title>
     <para>
      Kommandos verwenden diesen Kanal zum Melden von Fehlern.
     </para>
    </formalpara>
   </listitem>
  </itemizedlist>

  <para>
   Zum Umlenken dieser Kanäle bestehen folgende Möglichkeiten:
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>Kommando &gt; Datei</literal>
    </term>
    <listitem>
     <para>
      Speichert die Ausgabe des Kommandos in eine Datei; eine etwaige bestehende Datei wird gelöscht. Beispielsweise schreibt das Kommando <command>ls</command> seine Ausgabe in die Datei <filename>listing.txt</filename>:
     </para>
<screen>ls &gt; listing.txt</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>Kommando &gt;&gt; Datei</literal>
    </term>
    <listitem>
     <para>
      Hängt die Ausgabe des Kommandos an eine Datei an. Beispielsweise hängt das Kommando <command>ls</command> seine Ausgabe an die Datei <filename>listing.txt</filename> an:
     </para>
<screen>ls &gt;&gt; listing.txt</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>Kommando &lt; Datei</literal>
    </term>
    <listitem>
     <para>
      Liest die Datei als Eingabe für das angegebene Kommando. Beispielsweise liest das Kommando <command>read</command> den Inhalt der Datei in die Variable   ein:
     </para>
<screen>read a &lt; foo</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>Kommando1 | Kommando2</literal>
    </term>
    <listitem>
     <para>
      Leitet die Ausgabe des linken Kommandos als Eingabe für das rechte Kommando um. Beispiel: Das Kommando <command>cat</command> gibt den Inhalt der Datei <filename>/proc/cpuinfo</filename> aus. Diese Ausgabe wird von <command>grep</command> verwendet, um nur diejenigen Zeilen herauszufiltern, die <literal>cpu</literal> enthalten:
     </para>
<screen>cat /proc/cpuinfo | grep cpu</screen>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Jeder Kanal verfügt über einen <emphasis>Dateideskriptor</emphasis>: 0 (Null) für Standardeingabe, 1 für Standardausgabe und 2 für Standardfehler. Es ist zulässig, diesen Dateideskriptor vor einem <literal>&lt;</literal>- oder <literal>&gt;</literal>-Zeichen einzufügen. Beispielsweise sucht die folgende Zeile nach einer Datei, die mit <filename>foo</filename> beginnt, aber seine Fehlermeldungen durch Umlenkung zu <filename>/dev/null</filename> unterdrückt:
  </para>

<screen>find / -name "foo*" 2&gt;/dev/null</screen>
 </sect1>
 <sect1 xml:id="sec.adm.alias">
  <title>Verwenden von Aliassen</title><indexterm> <primary>aliases</primary> </indexterm>

  <para>
   Ein Alias ist ein Definitionskürzel für einen oder mehrere Kommandos. Die Syntax für einen Alias lautet:
  </para>

<screen>alias <replaceable>NAME</replaceable>=<replaceable>DEFINITION</replaceable></screen>

  <para>
   Beispielsweise definiert die folgende Zeile den Alias <command>lt</command>, der eine lange Liste ausgibt (Option <option>-l</option>), sie nach Änderungszeit sortiert (<option>-t</option>) und sie bei der Sortierung in umgekehrter Reihenfolge ausgibt (<option>-r</option>):
  </para>

<screen>alias lt='ls -ltr'</screen>

  <para>
   Zur Anzeige aller Aliasdefinitionen verwenden Sie <command>alias</command>. Entfernen Sie den Alias mit <command>Alias entfernen</command> und dem entsprechenden Aliasnamen.
  </para>
 </sect1>
 <sect1 xml:id="sec.adm.variables">
  <title>Verwenden von Variablen in der Bash-Shell</title>

  <para>
   Eine Shell-Variable kann global oder lokal sein. Auf globale Variablen, z. B. Umgebungsvariablen, kann in allen Shells zugegriffen werden. Lokale Variablen sind hingegen nur in der aktuellen Shell sichtbar.
  </para>

  <para>
   Verwenden Sie zur Anzeige von allen Umgebungsvariablen das Kommando <command>printenv</command>. Wenn Sie den Wert einer Variable kennen müssen, fügen Sie den Namen Ihrer Variablen als ein Argument ein:
  </para>

<screen>printenv PATH</screen>

  <para>
   Eine Variable (global oder lokal) kann auch mit <command>echo</command> angezeigt werden:
  </para>

<screen>echo $PATH</screen>

  <para>
   Verwenden Sie zum Festlegen einer lokalen Variablen einen Variablennamen, gefolgt vom Gleichheitszeichen und dem Wert für den Namen:
  </para>

<screen>PROJECT="SLED"</screen>

  <para>
   Geben Sie keine Leerzeichen um das Gleichheitszeichen ein, sonst erhalten Sie einen Fehler. Verwenden Sie zum Setzen einer Umgebungsvariablen <command>export</command>:
  </para>

<screen>export NAME="tux"</screen>

  <para>
   Zum Entfernen einer Variable verwenden Sie <command>unset</command>:
  </para>

<screen>unset NAME</screen>

  <para>
   Die folgende Tabelle enthält einige häufige Umgebungsvariablen, die Sie in Ihren Shell-Skripten verwenden können:
  </para>

  <table xml:id="tab.adm.envars">
   <title>Nützliche Umgebungsvariablen</title>
   <tgroup cols="2">
    <tbody>
     <row>
      <entry>
       <para>
        <envar>HOME</envar>
       </para>
      </entry>
      <entry>
       <para>
        Home-Verzeichnis des aktuellen Benutzers
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>HOST</envar>
       </para>
      </entry>
      <entry>
       <para>
        Aktueller Hostname
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>LANG</envar>
       </para>
      </entry>
      <entry>
       <para>
        Wenn ein Werkzeug lokalisiert wird, verwendet es die Sprache aus dieser Umgebungsvariablen. Englisch kann auch auf <literal>C</literal> gesetzt werden
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>PFAD</envar>
       </para>
      </entry>
      <entry>
       <para>
        Suchpfad der Shell, eine Liste von Verzeichnissen, die durch Doppelpunkte getrennt sind
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>PS1</envar>
       </para>
      </entry>
      <entry>
       <para>
        Gibt die normale Eingabeaufforderung an, die vor jedem Kommando angezeigt wird
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>PS2</envar>
       </para>
      </entry>
      <entry>
       <para>
        Gibt die sekundäre Eingabeaufforderung an, die beim Ausführen eines mehrzeiligen Kommandos angezeigt wird
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>PWD</envar>
       </para>
      </entry>
      <entry>
       <para>
        Aktuelles Arbeitsverzeichnis
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>USER</envar>
       </para>
      </entry>
      <entry>
       <para>
        Aktueller Benutzer
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <sect2 xml:id="sec.adm.variables.argument">
   <title>Verwenden von Argumentvariablen</title>

   <para>
    Wenn Sie beispielsweise über das Skript <command>foo.sh</command> verfügen, können Sie es wie folgt ausführen:
   </para>
<screen>foo.sh "Tux Penguin" 2000 </screen>
   <para>
    Für den Zugriff auf alle Argumente, die an Ihr Skript übergeben werden, benötigen Sie Positionsparameter. Diese sind <envar>$1</envar> für das erste Argument, <envar>$2</envar> für das zweite usw. Sie können bis zu neun Parameter verwenden. Verwenden Sie <envar>$0</envar> zum Abrufen des Skriptnamens.
   </para>
   <para>
    Das folgende Skript <command>foo.sh</command> gibt alle Argumente von 1 bis 4 aus:
   </para>
<screen>#!/bin/sh
echo \"$1\" \"$2\" \"$3\" \"$4\"</screen>
   <para>
    Wenn Sie das Skript mit den obigen Argumenten ausführen, erhalten Sie Folgendes:
   </para>
<screen>"Tux Penguin" "2000" "" ""</screen>

  </sect2>

  <sect2 xml:id="sec.adm.shell.varsubst">
   <title>Verwenden der Variablenersetzung</title>
   <para>
    Variablenersetzungen wenden beginnend von links oder rechts ein Schema auf den Inhalt einer Variable an. Die folgende Liste enthält die möglichen Syntaxformen:
   </para>
   <variablelist>
    <varlistentry>
     <term><literal>${VAR#schema}</literal>
     </term>
     <listitem>
      <para>
       entfernt die kürzeste mögliche Übereinstimmung von links:
      </para>
<screen>file=/home/tux/book/book.tar.bz2
echo ${file#*/}
home/tux/book/book.tar.bz2</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>${VAR##schema}</literal>
     </term>
     <listitem>
      <para>
       entfernt die längste mögliche Übereinstimmung von links:
      </para>
<screen>file=/home/tux/book/book.tar.bz2
echo ${file##*/}
book.tar.bz2</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>${VAR%schema}</literal>
     </term>
     <listitem>
      <para>
       entfernt die kürzeste mögliche Übereinstimmung von rechts:
      </para>
<screen>file=/home/tux/book/book.tar.bz2
echo ${file%.*}
/home/tux/book/book.tar</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>${VAR%%schema}</literal>
     </term>
     <listitem>
      <para>
       entfernt die längste mögliche Übereinstimmung von rechts:
      </para>
<screen>file=/home/tux/book/book.tar.bz2
echo ${file%%.*}
/home/tux/book/book</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>${VAR/pattern_1/pattern_2}</literal>
     </term>
     <listitem>
      <para>
       ersetzt den Inhalt von <replaceable>VAR</replaceable> von <replaceable>pattern_1</replaceable> durch <replaceable>pattern_2</replaceable>:
      </para>
<screen>file=/home/tux/book/book.tar.bz2
echo ${file/tux/wilber}
/home/wilber/book/book.tar.bz2</screen>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>
 </sect1>
 <sect1 xml:id="sec.adm.shell.grouping">
  <title>Gruppieren und Kombinieren von Kommandos</title>

  <para>
   In Shells können Sie Kommandos für die bedingte Ausführung verketten und gruppieren. Jedes Kommando übergibt einen Endcode, der den Erfolg oder Misserfolg seiner Ausführung bestimmt. Wenn er 0 (Null) lautet, war das Kommando erfolgreich, alle anderen Codes bezeichnen einen Fehler, der spezifisch für das Kommando ist.
  </para>

  <para>
   Die folgende Liste zeigt, wie sich Kommandos gruppieren lassen:
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>Kommando1 ; Kommando2</literal>
    </term>
    <listitem>
     <para>
      führt die Kommandos in sequenzieller Reihenfolge aus. Der Endcode wird nicht geprüft. Die folgende Zeile zeigt den Inhalt der Datei mit <command>cat</command> an und gibt deren Dateieigenschaften unabhängig von deren Endcodes mit <command>ls</command> aus:
     </para>
<screen>cat filelist.txt ; ls -l filelist.txt</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>Kommando1 &amp;&amp; Kommando2</literal>
    </term>
    <listitem>
     <para>
      führt das rechte Kommando aus, wenn das linke Kommando erfolgreich war (logisches UND). Die folgende Zeile zeigt den Inahlt der Datei an und gibt deren Dateieigenschaften nur aus, wenn das vorherige Kommando erfolgreich war (vgl. mit dem vorherigen Eintrag in dieser Liste):
     </para>
<screen>cat filelist.txt &amp;&amp; ls -l filelist.txt</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>Kommando1 || Kommando2</literal>
    </term>
    <listitem>
     <para>
      führt das rechte Kommando aus, wenn das linke Kommando fehlgeschlagen ist (logisches ODER). Die folgende Zeile legt nur ein Verzeichnis in <filename>/home/wilber/bar</filename> an, wenn die Erstellung des Verzeichnisses in <filename>/home/tux/foo</filename> fehlgeschlagen ist:
     </para>
<screen>mkdir /home/tux/foo || mkdir /home/wilber/bar</screen>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>funcname(){ ... }</literal>
    </term>
    <listitem>
     <para>
      erstellt eine Shell-Funktion. Sie können mithilfe der Positionsparameter auf ihre Argumente zugreifen. Die folgende Zeile definiert die Funktion <literal>hello</literal> für die Ausgabe einer kurzen Meldung:
     </para>
<screen>hello() { echo "Hello $1"; }</screen>
     <para>
      Sie können diese Funktion wie folgt aufrufen:
     </para>
<screen>hello Tux</screen>
     <para>
      Die Ausgabe sieht wie folgt aus:
     </para>
<screen>Hello Tux</screen>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 xml:id="sec.adm.shell.commonconstructs">
  <title>Arbeiten mit häufigen Ablaufkonstrukten</title>

  <para>
   Zur Steuerung des Ablaufs Ihres Skripts verfügt eine Shell über <command>while</command>-, <command>if</command>-, <command>for</command>- und <command>case</command>-Konstrukte.
  </para>



  <sect2 xml:id="sec.adm.shell.if">
   <title>Das Steuerungskommando „if“</title>
   <para>
    Das Kommando <command>if</command> wird verwendet, um Ausdrücke zu prüfen. Beispielsweise testet der folgende Code, ob es sich beim aktuellen Benutzer um Tux handelt:
   </para>
<screen>if test $USER = "tux"; then
  echo "Hello Tux."
else
  echo "You are not Tux."
fi</screen>
   <para>
    Der Testausdruck kann so komplex oder einfach wie möglich sein. Der folgende Ausdruck prüft, ob die Datei <filename>foo.txt</filename> existiert:
   </para>
<screen>if test -e /tmp/foo.txt ; then
  echo "Found foo.txt"
fi</screen>
   <para>
    Der Testausdruck kann auch in eckigen Klammern abgekürzt werden:
   </para>
<screen>if [ -e /tmp/foo.txt ] ; then
  echo "Found foo.txt"
fi</screen>
   <para>
    Weitere nützliche Ausdrücke finden Sie unter <link xlink:href="http://www.cyberciti.biz/nixcraft/linux/docs/uniqlinuxfeatures/lsst/ch03sec02.html"/>.
   </para>
  </sect2>

  <sect2 xml:id="sec.adm.shell.for">
   <title>Erstellen von Schleifen mit dem Kommando <command>for</command></title>
   <para>
    Mithilfe der <command>for</command>-Schleife können Sie Kommandos an einer Liste von Einträgen ausführen. Beispielsweise gibt der folgende Code einige Informationen über PNG-Dateien im aktuellen Verzeichnis aus:
   </para>
<screen>for i in *.png; do
 ls -l $i
done</screen>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.adm.shell.moreinfo">
  <title>Weiterführende Informationen</title>

  <para>
   Wichtige Informationen über die Bash-Shell finden Sie auf den man-Seiten zu <command>man bash</command>. Für weitere Informationen zu diesem Thema siehe die folgende Liste:
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     <link xlink:href="http://tldp.org/LDP/Bash-Beginners-Guide/html/index.html"/> – Bash Guide for Beginners (Bash-Anleitungen für Anfänger)
    </para>
   </listitem>
   <listitem>
    <para>
     <link xlink:href="http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html"/> – BASH Programming - Introduction HOW-TO (BASH-Programmierung – Einführende schrittweise Anleitungen)
    </para>
   </listitem>
   <listitem>
    <para>
     <link xlink:href="http://tldp.org/LDP/abs/html/index.html"/> – Advanced Bash-Scripting Guide (Anleitung für erweiterte Bash-Skripts)
    </para>
   </listitem>
   <listitem>
    <para>
     <link xlink:href="http://www.grymoire.com/Unix/Sh.html"/> – Sh - the Bourne Shell (Sh – die Bourne-Shell)
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
</chapter>
