<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="tuning_systemd_coredump.xml" version="5.0" xml:id="cha-tuning-systemd-coredump">
 <title>使用 <systemitem class="daemon">systemd-coredump</systemitem> 针对应用程序崩溃进行调试</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>
 <para>
  <systemitem class="daemon">systemd-coredump</systemitem> 可收集并显示核心转储，用于分析应用程序崩溃问题。核心转储包含进程内存在终止时的映像。当某个进程（或属于应用程序的所有进程）崩溃时，此工具默认会将核心转储记录到 <systemitem class="daemon">systemd</systemitem> 日志（如有可能还包括回溯），并将核心转储存储在 <filename>/var/lib/systemd/coredump</filename> 中的某个文件内。您还可以选择使用 <command>gdb</command> 或 <command>crash</command> 等其他工具检查转储文件（请参见<xref linkend="cha-tuning-kdump-analyze"/>）。
 </para>
 <para>
  存储在 <filename>/var/lib/systemd/coredump</filename> 中的核心转储在三天后将被删除（请参见 <filename>/usr/lib/tmpfiles.d/systemd.conf</filename> 中的 <literal>d /var/lib/systemd/coredump</literal> 行）。
 </para>
 <para>
  有一个选项不会储存核心转储，而是仅将其记录到日志，这样做有助于尽量减少敏感信息的收集与储存。
  </para>
 <sect1 xml:id="sect-sys-coredump-default">
  <title>用法和配置</title>

  <para>
   <systemitem class="daemon">systemd-coredump</systemitem> 默认已启用，随时可供运行。默认配置位于 <filename>/etc/systemd/coredump.conf</filename> 中：
  </para>

<screen>[Coredump]
#Storage=external
#Compress=yes
#ProcessSizeMax=2G
#ExternalSizeMax=2G
#JournalSizeMax=767M
#MaxUse=
#KeepFree=
</screen>

  <para>
   大小单位为 B、K、M、G、T、P 和 E。<literal>ExternalSizeMax</literal> 还支持 <literal>infinity</literal> 值。
   
  </para>

  <para>
   以下示例显示如何使用 Vim 进行简单的测试，方法是创建一个 segfault 来生成日志项和核心转储。
  </para>

  <procedure xml:id="pro-test-coredump">
   <title>使用 Vim 创建核心转储</title>
    <step>
   <para>
     启用 <systemitem>debuginfo-pool</systemitem> 和 <systemitem>debuginfo-update</systemitem> 软件源
    </para>
   </step>
   <step>
    <para>
     安装 <package>vim-debuginfo</package>
    </para>
   </step>
   <step>
    <para>
     启动 <command>vim testfile</command> 并键入几个字符
    </para>
   </step>
   <step>
    <para>
     获取 PID 并生成 segfault：
    </para>
<screen><prompt>&gt; </prompt>ps ax | grep vim
2345 pts/3    S+     0:00 vim testfile

<prompt role="root"># </prompt>kill -s SIGSEGV 2345</screen>
<para>
    Vim 将发出错误消息：
</para>
<screen>Vim: Caught deadly signal SEGV
Vim: Finished.
Segmentation fault (core dumped)</screen>
   </step>
   <step>
    <para>
     列出您的核心转储，然后对其进行检查：
    </para>
<screen><prompt role="root"># </prompt>coredumpctl
TIME                        PID  UID  GID SIG PRESENT EXE
Wed 2019-11-12 11:56:47 PST 2345 1000 100 11  *       /bin/vim

<prompt role="root"># </prompt>coredumpctl info
PID: 2345 (vim)
UID: 0 (root)
GID: 0 (root)
Signal: 11 (SEGV)
Timestamp: Wed 2019-11-12 11:58:05 PST
Command Line: vim testfile
Executable: /bin/vim
Control Group: /user.slice/user-1000.slice/session-1.scope
    Unit: session-1.scope
    Slice: user-1000.slice
    Session: 1
    Owner UID: 1000 (tux)
    Boot ID: b5c251b86ab34674a2222cef102c0c88
    Machine ID: b43c44a64696799b985cafd95dc1b698
    Hostname: linux-uoch
    Coredump: /var/lib/systemd/coredump/core.vim.0.b5c251b86ab34674a2222cef102
    Message: Process 2345 (vim) of user 0 dumped core.

         Stack trace of thread 2345:
         #0  0x00007f21dd87e2a7 kill (libc.so.6)
         #1  0x000000000050cb35 may_core_dump (vim)
         #2  0x00007f21ddbfec70 __restore_rt (libpthread.so.0)
         #3  0x00007f21dd92ea33 __select (libc.so.6)
         #4  0x000000000050b4e3 RealWaitForChar (vim)
         #5  0x000000000050b86b mch_inchar (vim)
[...]
</screen>
   </step>
  </procedure>

  <para>
   如果您有多个核心转储，<command>coredumpctl info</command> 会显示所有这些核心转储。可按 <literal>PID</literal>、<literal>COMM</literal>（命令）或 <literal>EXE</literal>（可执行文件的完整路径）过滤核心转储，例如，查看 Vim 的所有核心转储：
  </para>

<screen><prompt role="root"># </prompt>coredumpctl info /bin/vim</screen>

  <para>
   按 <literal>PID</literal> 查看单个核心转储：
  </para>

<screen>
<prompt role="root"># </prompt>coredumpctl info 2345</screen>

  <para>
      将选定的核心输出到 <command>gdb</command>：
  </para>

<screen>
<prompt role="root"># </prompt>coredumpctl gdb 2345</screen>

  <para>
   <literal>PRESENT</literal> 列中的星号表示存在已存储的核心转储。如果该字段为空，则表示没有已存储的核心转储，<command>coredumpctl</command> 将从日志中检索崩溃信息。可以在 <filename>/etc/systemd/coredump.conf</filename> 中使用 <literal>Storage</literal> 选项控制此行为：
  </para>

  <itemizedlist>
   <listitem>
    <para>
     <literal>Storage=none</literal> — 在日志中记录核心转储，但不存储。这样做有助于尽量减少敏感信息的收集与储存，例如，出于符合一般数据保护条例 (GDPR) 的目的。
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>Storage=external</literal> — 将核心存储在 <filename>/var/lib/systemd/coredump</filename> 中
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>Storage=journal</literal> — 将核心存储在 <systemitem class="daemon">systemd</systemitem> 日志中
    </para>
   </listitem>
  </itemizedlist>

  <para>
   将为每个核心转储调用 <systemitem class="daemon">systemd-coredump</systemitem> 的新实例，因此，下一次核心转储时会应用配置更改，而无需重启动任何服务。
  </para>

  <para>
   重启动系统后核心转储不会保留。可以使用 <command>coredumpctl</command> 永久保存核心转储。以下示例按 <literal>PID</literal> 过滤核心转储，并将核心存储在 <filename>vim.dump</filename> 中：
  </para>

<screen><prompt role="root"># </prompt>coredumpctl -o vim.dump dump 2345</screen>

  <para>
   有关完整的命令和选项列表，请参见 <command>man systemd-coredump</command>、<command>man
   coredumpctl</command>、<command>man core</command> 和 <command>man coredump.conf</command>。
  </para>
 </sect1>
</chapter>
