<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//Novell//DTD NovDoc XML V1.0//EN" "novdocx.dtd">
<!--
*********************************
Please see LICENSE.txt for this document's license.
*********************************
-->
<chapter xml:base="adm_shell.xml" id="cha.adm.shell">

 <title>Bash e scripts Bash</title><indexterm> <primary>Shell</primary></indexterm><indexterm> <primary>Bash</primary> <see>Shell</see></indexterm>
 <abstract>
  <para>
   Atualmente, muitas pessoas usam computadores com uma GUI (interface gráfica do usuário) como o GNOME. Embora ela ofereça muitos recursos, seu uso é limitado quando se trata de execução de tarefas automatizadas. Shells são bons aliados das interfaces gráficas, por isso este capítulo apresenta uma visão geral de alguns aspectos dos shells, neste caso, o Bash.
  </para>
 </abstract>
 <sect1 id="sec.adm.whatistheshell">
  <title>O que é <quote>o shell</quote>?</title>



  <para>
   Tradicionalmente, <emphasis>o</emphasis> shell é o Bash (Bourne again Shell). Quando este capítulo menciona <quote>o shell</quote>, ele se refere ao Bash. Na verdade, há mais shells disponíveis além do Bash (ash, csh, ksh, zsh, etc.), cada um deles empregando recursos e características diferentes. Se você precisar de mais informações sobre outros shells, pesquise por <emphasis>shell</emphasis> no YaST.
  </para>

  <sect2 id="sec.adm.configfiles">
   <title>Conhecendo os arquivos de configuração do Bash</title><indexterm> <primary>arquivos de configuração</primary> <see>Bash</see></indexterm>
   <para>
    Um shell pode ser acionado como:
   </para>
   <orderedlist spacing="normal">
    <listitem>
     <formalpara>
      <title>Shell de login interativo</title>
      <para>
       Esse tipo é usado para efetuar login em uma máquina, chamando o Bash com a opção <option>--login</option>, ou para efetuar login em uma máquina remota com SSH.
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Shell interativo <quote>comum</quote></title>
      <para>
       Normalmente esse é o caso quando se inicia o xterm, o konsole, o gnome-terminal ou ferramentas semelhantes.
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Shell não interativo</title>
      <para>
       Usado para chamar um script de shell na linha de comando.
      </para>
     </formalpara>
    </listitem>
   </orderedlist>
   <para>
    Dependendo do tipo de shell usado, variam os arquivos de configuração lidos. As tabelas seguintes mostram os arquivos de configuração de shell de login e sem login.
   </para>
   <table id="tab.adm.shell.config.loginshells">
    <title>Arquivos de configuração do Bash para shells de login</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>
        <para>
         Arquivo
        </para>
       </entry>
       <entry>
        <para>
         Descrição
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         <filename>/etc/profile</filename>
        </para>
       </entry>
       <entry>
        <para>
         Não modifique esse arquivo, senão as suas modificações poderão ser destruídas durante a próxima atualização!
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>/etc/profile.local</filename>
        </para>
       </entry>
       <entry>
        <para>
         Use esse arquivos se for estender <filename>/etc/profile</filename>
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>/etc/profile.d/</filename>
        </para>
       </entry>
       <entry>
        <para>
         Contém arquivos de configuração de programas específicos para todo o sistema 
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>~/.profile</filename>
        </para>
       </entry>
       <entry>
        <para>
         Insira aqui a configuração específica de usuário para os shells de login
        </para>
       </entry>
      </row>

     </tbody>
    </tgroup>
   </table>
   <table id="tab.adm.shell.configs.nonloginshells">
    <title>Arquivos de configuração do Bash para shells sem login</title>
    <tgroup cols="2">
     <tbody>
      <row>
       <entry>
        <para>
         <filename>/etc/bash.bashrc</filename>
        </para>
       </entry>
       <entry>
        <para>
         Não modifique esse arquivo, senão as suas modificações poderão ser destruídas durante a próxima atualização!
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>/etc/bash.bashrc.local</filename>
        </para>
       </entry>
       <entry>
        <para>
         Use esse arquivo para inserir suas modificações apenas do Bash em todo o sistema
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>~/.bashrc</filename>
        </para>
       </entry>
       <entry>
        <para>
         Insira aqui a configuração específica de usuário
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Além desses, o Bash usa mais outros arquivos:
   </para>
   <table>
    <title>Arquivos especiais do Bash</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>
        <para>
         Arquivo
        </para>
       </entry>
       <entry>
        <para>
         Descrição
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         <filename>~/.bash_history</filename>
        </para>
       </entry>
       <entry>
        <para>
         Contém uma lista de todos os comandos que você digitou
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>~/.bash_logout</filename>
        </para>
       </entry>
       <entry>
        <para>
         Executado durante o logout
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>

  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="fs_structure_i.xml" parse="xml"/>
 </sect1>
 <sect1 id="sec.adm.shellscripts">
  <title>Gravando scripts shell</title><indexterm> <primary>Scripts shell</primary></indexterm>

  <para>
   Scripts shell são convenientes para todos os tipos de tarefas: coleta de dados, pesquisa por uma palavra ou frase em um texto e muitas outras coisas úteis. O exemplo seguinte mostra um pequeno script shell que imprime um texto:
  </para>

  <example>
   <title>Um script shell que imprime um texto</title>
<screen>#!/bin/sh <co id="co.adm.shell.shebang"/>
# Output the following line: <co id="co.adm.shell.comment"/>
echo "Hello World" <co id="co.adm.shell.echo"/></screen>
   <calloutlist>
    <callout arearefs="co.adm.shell.shebang">
     <para>
      A primeira linha começa com os caracteres <emphasis>Shebang</emphasis> <indexterm> <primary>Shebang</primary> </indexterm> (<literal>#!</literal>), indicando que o arquivo é um script. O script é executado pelo interpretador especificado após o Shebang, neste caso, <command>/bin/sh</command>.
     </para>
    </callout>
    <callout arearefs="co.adm.shell.comment">
     <para>
      A segunda linha é um comentário que começa com o sinal de hash. Ele é recomendado para inserir comentário em linhas cuja função é difícil de lembrar.
     </para>
    </callout>
    <callout arearefs="co.adm.shell.echo">
     <para>
      A terceira linha usa o comando interno <command>echo</command> para imprimir o texto correspondente.
     </para>
    </callout>
   </calloutlist>
  </example>

  <para>
   Antes de executar esse script, você precisa de alguns pré-requisitos:
  </para>

  <orderedlist spacing="normal">
   <listitem>
    <para>
     Todo script deve conter uma linha Shebang (como foi o caso do nosso exemplo acima). Se um script não tiver essa linha, você deverá chamar o interpretador manualmente.
    </para>
   </listitem>
   <listitem>
    <para>
     Grave o script no lugar desejado. Contudo, convém gravá-lo em um diretório onde o shell possa encontrá-lo. O caminho de pesquisa em um shell é determinado pela variável de ambiente <envar>PATH</envar>. Um usuário normal geralmente não tem acesso de gravação em <filename>/usr/bin</filename>. Por essa razão, recomenda-se gravar seus scripts no diretório <filename>~/bin/</filename> dos usuários. O exemplo acima leva o nome <filename>hello.sh</filename>.
    </para>
   </listitem>
   <listitem>
    <para>
     O script requer permissões de executável. Defina as permissões com o seguinte comando:
    </para>
<screen>chmod +x ~/bin/hello.sh</screen>
   </listitem>
  </orderedlist>

  <para>
   Se você atendeu a todos os pré-requisitos acima, poderá executar o script das seguintes maneiras:
  </para>

  <orderedlist spacing="normal">
   <listitem>
    <formalpara>
     <title>Como caminho absoluto</title>
     <para>
      O script pode ser executado em um caminho absoluto. No nosso caso, ele é <command>~/bin/hello.sh</command>.
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>Em todos os lugares</title>
     <para>
      Se a variável de ambiente <envar>PATH</envar> incluir o diretório no qual o script está localizado, você poderá executar o script usando o comando <command>hello.sh</command>.
     </para>
    </formalpara>
   </listitem>
  </orderedlist>
 </sect1>
 <sect1 id="sec.adm.shell.redirect">
  <title>Redirecionando eventos de comando</title>

  <para>
   Cada comando pode usar três canais, seja para entrada ou para saída:
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <formalpara>
     <title>Saída padrão</title>
     <para>
      Esse é o canal de saída padrão. Sempre que um comando imprime algo, ele usa o canal de saída padrão.
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>Entrada padrão</title>
     <para>
      Se um comando precisar da entrada dos usuários ou de outros comandos, ele usará esse canal.
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>Erro padrão</title>
     <para>
      Os comandos usam esse canal para gerar relatórios de erros.
     </para>
    </formalpara>
   </listitem>
  </itemizedlist>

  <para>
   Para redirecionar os canais, as possibilidades são as seguintes:
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>Comando &gt; Arquivo</literal>
    </term>
    <listitem>
     <para>
      Grava a saída do comando em um arquivo, apagando um arquivo existente. Por exemplo, o comando <command>ls</command> grava sua saída no arquivo <filename>listing.txt</filename>:
     </para>
<screen>ls &gt; listing.txt</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>Comando &gt;&gt; Arquivo</literal>
    </term>
    <listitem>
     <para>
      Anexa a saída do comando a um arquivo. Por exemplo, o comando <command>ls</command> anexa sua saída ao arquivo <filename>listing.txt</filename>:
     </para>
<screen>ls &gt;&gt; listing.txt</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>Comando &lt; Arquivo</literal>
    </term>
    <listitem>
     <para>
      Lê o arquivo como entrada do comando em questão. Por exemplo, o comando <command>read</command> extrai o conteúdo do arquivo para a variável:
     </para>
<screen>read a &lt; foo</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>Comando1 | Comando2</literal>
    </term>
    <listitem>
     <para>
      Redireciona a saída do comando à esquerda como entrada para o comando à direita. Por exemplo, o comando <command>cat</command> gera a saída do conteúdo do arquivo <filename>/proc/cpuinfo</filename>. Essa saída é usada por <command>grep</command> para filtrar apenas as linhas que contêm <literal>cpu</literal>:
     </para>
<screen>cat /proc/cpuinfo | grep cpu</screen>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Cada canal possui um <emphasis>descritor de arquivo</emphasis>: 0 (zero) para entrada padrão, 1 para saída padrão e 2 para erro padrão. É permitido inserir esse descritor de arquivo antes de um caractere <literal>&lt;</literal> ou <literal>&gt;</literal>. Por exemplo, a linha a seguir procura por um arquivo que começa com <filename>foo</filename>, mas suprime seus erros redirecionando-o para <filename>/dev/null</filename>:
  </para>

<screen>find / -name "foo*" 2&gt;/dev/null</screen>
 </sect1>
 <sect1 id="sec.adm.alias">
  <title>Usando álias</title><indexterm> <primary>aliases</primary></indexterm>

  <para>
   Um álias é uma definição de atalho de um ou mais comandos. A sintaxe de um álias é a seguinte:
  </para>

<screen>alias <replaceable>NAME</replaceable>=<replaceable>DEFINITION</replaceable></screen>

  <para>
   Por exemplo, a linha a seguir define um álias <command>lt</command> que gera uma listagem extensa (opção <option>-l</option>), classifica-a por horário de modificação (<option>-t</option>) e imprime-a em ordem inversa ao classificar (<option>-r</option>):
  </para>

<screen>alias lt='ls -ltr'</screen>

  <para>
   Para ver todas as definições de álias, use <command>alias</command> Remova o seu álias com <command>unalias</command> e o nome de álias correspondente.
  </para>
 </sect1>
 <sect1 id="sec.adm.variables">
  <title>Usando variáveis no Bash</title>

  <para>
   Uma variável de shell pode ser global ou local. Variáveis globais, ou de ambiente, podem ser acessadas em todos os shells. As variáveis locais, ao contrário, são visíveis apenas no shell atual.
  </para>

  <para>
   Para ver todas as variáveis de ambiente, use o comando <command>printenv</command>. Se for preciso saber o valor de uma variável, insira o nome da variável como argumento:
  </para>

<screen>printenv PATH</screen>

  <para>
   Uma variável, seja ela global ou local, também pode ser visualizada com <command>echo</command>:
  </para>

<screen>echo $PATH</screen>

  <para>
   Para definir uma variável local, use um nome de variável, seguido pelo sinal de igual, seguido pelo valor:
  </para>

<screen>PROJECT="SLED"</screen>

  <para>
   Não insira espaços antes e depois do sinal de igual, senão você obterá um erro. Para definir uma variável de ambiente, use <command>export</command>:
  </para>

<screen>export NAME="tux"</screen>

  <para>
   Para remover uma variável, use <command>unset</command>:
  </para>

<screen>unset NAME</screen>

  <para>
   A tabela a seguir contém algumas variáveis de ambiente comuns que podem ser usadas nos seus scripts shell:
  </para>

  <table id="tab.adm.envars">
   <title>Variáveis de ambiente úteis</title>
   <tgroup cols="2">
    <tbody>
     <row>
      <entry>
       <para>
        <envar>HOME</envar>
       </para>
      </entry>
      <entry>
       <para>
        diretório pessoal do usuário atual
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>HOST</envar>
       </para>
      </entry>
      <entry>
       <para>
        nome do host atual
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>LANG</envar>
       </para>
      </entry>
      <entry>
       <para>
        quando uma ferramenta é localizada, ela usa o idioma dessa variável de ambiente. Também é possível definir o idioma inglês como <literal>C</literal>
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>PATH</envar>
       </para>
      </entry>
      <entry>
       <para>
        caminho de pesquisa do shell, uma lista de diretórios separados por dois-pontos
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>PS1</envar>
       </para>
      </entry>
      <entry>
       <para>
        especifica o prompt normal impresso antes de cada comando
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>PS2</envar>
       </para>
      </entry>
      <entry>
       <para>
        especifica o prompt secundário impresso quando você executa um comando em várias linhas
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>PWD</envar>
       </para>
      </entry>
      <entry>
       <para>
        diretório de trabalho atual
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>USER</envar>
       </para>
      </entry>
      <entry>
       <para>
        usuário atual
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <sect2 id="sec.adm.variables.argument">
   <title>Usando variáveis de argumento</title>

   <para>
    Por exemplo, se você tiver o script <command>foo.sh</command>, poderá executá-lo desta maneira:
   </para>
<screen>foo.sh "Tux Penguin" 2000 </screen>
   <para>
    Para acessar todos os argumentos que são passados ao seu script, você precisa de parâmetros de posição. Isto é, <envar>$1</envar> para o primeiro argumento, <envar>$2</envar> para o segundo e assim sucessivamente. É possível usar até nove parâmetros. Para obter o nome do script, use <envar>$0</envar>.
   </para>
   <para>
    O script <command>foo.sh</command> a seguir imprime todos os argumentos de 1 a 4:
   </para>
<screen>#!/bin/sh
echo \"$1\" \"$2\" \"$3\" \"$4\"</screen>
   <para>
    Se você executar esse script com os argumentos acima, obterá:
   </para>
<screen>"Tux Penguin" "2000" "" ""</screen>

  </sect2>

  <sect2 id="sec.adm.shell.varsubst">
   <title>Usando substituição de variável</title>
   <para>
    As substituições de variáveis aplicam um padrão ao conteúdo de uma variável, seja da esquerda ou da esquerda. A lista a seguir contém as formas de sintaxe possíveis:
   </para>
   <variablelist>
    <varlistentry>
     <term><literal>${VAR#padrão}</literal>
     </term>
     <listitem>
      <para>
       remove a correspondência mais curta possível da esquerda:
      </para>
<screen>file=/home/tux/book/book.tar.bz2
echo ${file#*/}
home/tux/book/book.tar.bz2</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>${VAR##padrão}</literal>
     </term>
     <listitem>
      <para>
       remove a correspondência mais longa possível da esquerda:
      </para>
<screen>file=/home/tux/book/book.tar.bz2
echo ${file##*/}
book.tar.bz2</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>${VAR%padrão}</literal>
     </term>
     <listitem>
      <para>
       remove a correspondência mais curta possível da direita:
      </para>
<screen>file=/home/tux/book/book.tar.bz2
echo ${file%.*}
/home/tux/book/book.tar</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>${VAR%%padrão}</literal>
     </term>
     <listitem>
      <para>
       remove a correspondência mais longa possível da direita:
      </para>
<screen>file=/home/tux/book/book.tar.bz2
echo ${file%%.*}
/home/tux/book/book</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>${VAR/padrão_1/padrão_2}</literal>
     </term>
     <listitem>
      <para>
       substitui o conteúdo de <replaceable>VAR</replaceable> do <replaceable>padrão_1</replaceable> pelo do <replaceable>padrão_2</replaceable>:
      </para>
<screen>file=/home/tux/book/book.tar.bz2
echo ${file/tux/wilber}
/home/wilber/book/book.tar.bz2</screen>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>
 </sect1>
 <sect1 id="sec.adm.shell.grouping">
  <title>Agrupando e combinando comandos</title>

  <para>
   Os shells permitem concatenar e agrupar comandos para uma execução condicional. Cada comando retorna um código de saída que determina o sucesso ou a falha de sua operação. Se o código for 0 (zero), significa que o comando obteve sucesso. Todos os outros códigos significam erro específico do comando.
  </para>

  <para>
   A lista a seguir mostra como os comandos podem ser agrupados:
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>Comando1 ; Comando2</literal>
    </term>
    <listitem>
     <para>
      executa os comandos em sequência. O código de saída não é verificado. A linha a seguir exibe o conteúdo do arquivo com <command>cat</command> e depois imprime suas propriedades com <command>ls</command>, independentemente dos códigos de erro:
     </para>
<screen>cat filelist.txt ; ls -l filelist.txt</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>Comando1 &amp;&amp; Comando2</literal>
    </term>
    <listitem>
     <para>
      executa o comando à direita quando o comando à esquerda for bem-sucedido (E lógico). A linha a seguir exibe o conteúdo do arquivo e imprime suas propriedades apenas quando o comando anterior obtiver sucesso (compare com a entrada anterior nesta lista):
     </para>
<screen>cat filelist.txt &amp;&amp; ls -l filelist.txt</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>Comando1 || Comando2</literal>
    </term>
    <listitem>
     <para>
      executa o comando à direita quando o comando da esquerda falhar (OU lógico). A linha a seguir cria um diretório em <filename>/home/wilber/bar</filename> apenas quando a criação do diretório em <filename>/home/tux/foo</filename> falhar:
     </para>
<screen>mkdir /home/tux/foo || mkdir /home/wilber/bar</screen>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>nome_da_função(){ ... }</literal>
    </term>
    <listitem>
     <para>
      cria uma função shell. Você pode usar os parâmetros de posição para acessar seus argumentos. A linha a seguir define a função <literal>hello</literal> para imprimir uma mensagem curta:
     </para>
<screen>hello() { echo "Hello $1"; }</screen>
     <para>
      Você pode chamar essa função assim:
     </para>
<screen>hello Tux</screen>
     <para>
      que imprimirá:
     </para>
<screen>Hello Tux</screen>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 id="sec.adm.shell.commonconstructs">
  <title>Trabalhando com construções de fluxo comuns</title>

  <para>
   Para controlar o fluxo do seu script, um shell possui as construções <command>while</command>, <command>if</command>, <command>for</command> e <command>case</command>.
  </para>



  <sect2 id="sec.adm.shell.if">
   <title>Comando de controle if</title>
   <para>
    O comando <command>if</command> é usado para verificar expressões. Por exemplo, o código a seguir testa se o usuário atual é Tux:
   </para>
<screen>if test $USER = "tux"; then
  echo "Hello Tux."
else
  echo "You are not Tux."
fi</screen>
   <para>
    A expressão de teste pode ser tão complexa ou simples quanto possível. a expressão a seguir verifica se o arquivo <filename>foo.txt</filename> existe:
   </para>
<screen>if test -e /tmp/foo.txt ; then
  echo "Found foo.txt"
fi</screen>
   <para>
    A expressão de teste também pode ser abreviada entre colchetes:
   </para>
<screen>if [ -e /tmp/foo.txt ] ; then
  echo "Found foo.txt"
fi</screen>
   <para>
    Outras expressões úteis estão disponíveis em <ulink url="http://www.cyberciti.biz/nixcraft/linux/docs/uniqlinuxfeatures/lsst/ch03sec02.html"/>.
   </para>
  </sect2>

  <sect2 id="sec.adm.shell.for">
   <title>Criando loops com o comando for</title>
   <para>
    O loop <command>for</command> permite executar comandos para uma lista de entradas. Por exemplo, o código a seguir imprime algumas informações sobre arquivos PNG no diretório atual:
   </para>
<screen>for i in *.png; do
 ls -l $i
done</screen>
  </sect2>
 </sect1>
 <sect1 id="sec.adm.shell.moreinfo">
  <title>Para obter mais informações</title>

  <para>
   Informações importantes sobre o Bash são fornecidas nas páginas de manual <command>man bash</command>. Mais informações sobre este tópico estão disponíveis na lista a seguir:
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     <ulink url="http://tldp.org/LDP/Bash-Beginners-Guide/html/index.html"/>— Bash Guide for Beginners (Guia do Bash para Iniciantes)
    </para>
   </listitem>
   <listitem>
    <para>
     <ulink url="http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html"/>— BASH Programming - Introduction HOW-TO (COMO FAZER Programação de Bash: Introdução)
    </para>
   </listitem>
   <listitem>
    <para>
     <ulink url="http://tldp.org/LDP/abs/html/index.html"/>— Advanced Bash-Scripting Guide (Guia Avançado de Criação de Scripts Bash)
    </para>
   </listitem>
   <listitem>
    <para>
     <ulink url="http://www.grymoire.com/Unix/Sh.html"/>— Sh - the Bourne Shell (Sh: o Bourne Shell)
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
</chapter>
