<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="storage_filesystems.xml" version="5.0" xml:id="cha.filesystems" xml:lang="en">
 <title>Linux 中的文件系统的概述</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
  <abstract>
   <para>
    <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 随附了不同的文件系统供您选择，包括 Btrfs、Ext4、Ext3、Ext2、ReiserFS 和 XFS。每个文件系统都有各自的优点和缺点。有关 <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 中主要操作系统的并排功能比较，请参见 <link xlink:href="http://www.suse.com/products/server/technical-information/#FileSystem"/>（文件系统支持和大小）。本章概述了这些文件系统的工作原理以及它们的优点。
   </para>
  </abstract>
 </info>
 <para>
  在 SUSE Linux Enterprise 12 中，Btrfs 是操作系统的默认文件系统，XFS 是所有其他使用案例的默认文件系统。此外，SUSE 仍继续支持 Ext 系列的文件系统、ReiserFS 和 OCFS2。根据默认设置，Btrfs 文件系统将设置为使用子卷。对于使用 snapper 基础结构的根文件系统，将会自动启用快照。有关 snapper 的详细信息，请参见<xref linkend="cha.snapper"/>。
 </para>
 <para>
  专业的高性能设置可能需要高可用性的储存系统。为符合高性能群集案例的要求，<phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 在 High Availability Extension 附加产品中加入了 OCFS2（Oracle Cluster File System 2) 与 Distributed Replicated Block Device (DRBD)。本指南中不涉及这些高级储存系统的内容。有关详细信息，请参见《<citetitle>SUSE Linux Enterprise High Availability Extension <citetitle>管理指南</citetitle></citetitle>》，网址为：<link xlink:href="http://www.suse.com/doc"/>。
 </para>
 <para>
  记住一点很重要：没有任何一种文件系统适合所有种类的应用。每个文件系统都有各自的特定优点和缺点，必须将这些因素考虑在内。此外，即使是最复杂的文件系统也不能替代合理的备份策略。
 </para>
 <para>
  本节中使用的术语<emphasis>数据完整性</emphasis>和<emphasis>数据一致性</emphasis>并不是指用户空间数据（您的应用程序写入其文件的数据）的一致性。此数据是否一致必须由应用程序本身控制。
 </para>
 <para>
  除非本节特别指明，否则设置或更改分区以及文件系统所需的一切步骤，都可以使用 YaST 分区程序（强烈推荐使用）来执行。有关信息，请参见<xref linkend="cha.advdisk"/>。
 </para>
 <sect1 xml:id="sec.filesystems.glossary">
  <title>术语</title>

  <variablelist>
   <varlistentry>
    <term>元数据</term>
    <listitem>
     <para>
      文件系统内部的一种数据结构。它可确保磁盘上的所有数据都有条不紊，并且可供访问。从本质上讲，它是<quote>有关数据的数据</quote>。几乎每一种文件系统都有自己的元数据结构，这也是文件系统展现出不同性能特性的原因所在。维护元数据的完整性非常重要，因为如果不这样，则可能无法访问文件系统中的所有数据。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>inode</term>
    <listitem>
     <para>
      文件系统的数据结构包含文件的各种信息，包括大小、链接数量、实际储存文件内容的磁盘块的指针、创建、修改和访问的日期与时间。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>日记</term>
    <listitem>
     <para>
      在提及文件系统时，日记是包含某种日志的磁盘上结构，文件系统将要对文件系统的元数据进行的更改储存在此日志中。日记可大大降低文件系统的恢复时间，因为有了它就不需要在系统启动时执行文件系统全面检查这一冗长的搜索程序。而只是重放日记。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 xml:id="sec.filesystems.major.btrfs">
  <title>Btrfs</title>

  <para>
   Brtfs 是由 Chris Mason 开发的一种写时复制 (COW) 文件系统。它基于 Ohad Rodeh 开发的适用于 COW 的 B 树。Btrfs 是日志记录样式的文件系统。它不记录块更改，而是将块更改写入新位置，然后链接上更改。新更改在上一次写后才提交。
  </para>

  <sect2 xml:id="sec.filesystems.major.btrfs.features">
   <title>主要特征</title>
   <para>
    Btrfs 提供容错、修复和易于管理的功能，比如：
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>
      可写快照，允许应用更新后按需轻松回滚系统或允许备份文件。
     </para>
    </listitem>
    <listitem>
     <para>
      子卷支持：Btrfs 会在为其指派的空间池中创建默认子卷。它允许您在相同空间池中创建更多的子卷，作为不同的文件系统。子卷的数目仅受分配给池的空间所限。
     </para>
    </listitem>
    <listitem>
     <para>
      Btrfs 命令行工具中提供了在线检查和修复功能 <command>scrub</command>。它会在假设树状结构没有问题的前提下，验证数据和元数据的完整性。您可以在安装的文件系统上定期运行 scrub；正常操作期间，它将在后台运行。
     </para>
    </listitem>
    <listitem>
     <para>
      不同 RAID 级别，适用于元数据和用户数据。
     </para>
    </listitem>
    <listitem>
     <para>
      用于元数据和用户数据的不同校验和，可改进错误检测。
     </para>
    </listitem>
    <listitem>
     <para>
      与 Linux 逻辑卷管理器 (LVM) 储存对象集成。
     </para>
    </listitem>
    <listitem>
     <para>
      与 <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 上的 YaST 分区程序及 AutoYaST 整合。这还包括在多个设备 (MD) 和设备映射程序 (DM) 储存配置上创建 Btrfs 文件系统。
     </para>
    </listitem>
    <listitem>
     <para>
      从现有的 Ext2、Ext3 以及 Ext4 文件系统进行脱机迁移。
     </para>
    </listitem>
    <listitem>
     <para>
      <filename>/boot</filename> 的引导加载程序支持，允许从 Btrfs 分区引导。
     </para>
    </listitem>
    <listitem>

     <para>
      <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> <phrase role="productnumber"><phrase os="sles;sled;slerte"> }12 SP3</phrase></phrase> 中的 RAID0、RAID1 和 RAID10 配置文件支持多卷 Btrfs。更高的 RAID 级别尚不受支持，但安装将来发布的服务包后可能会支持。
     </para>
    </listitem>
    <listitem>
     <para>
      使用 Btrfs 命令设置透明压缩。
     </para>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 xml:id="sec.filesystems.major.btrfs.suse">
   <title><phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 上的根文件系统设置</title>
   <para>
    <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase>  默认设置为对根分区使用 Btrfs 和快照。快照可让您在应用更新之后有需要时轻松地回滚系统，也可让您备份文件。快照可通过 SUSE Snapper 基础结构轻松管理，如<xref linkend="cha.snapper"/>所述。有关 SUSE Snapper 项目的一般信息，请参见 OpenSUSE.org (<link xlink:href="http://snapper.io"/>) 上的 Snapper 门户网站 Wiki。
   </para>
   <para>
    使用快照回滚系统时，必须确保在回滚期间，数据（例如用户的主目录、Web 和 FTP 服务器内容或日志文件）不会遗失或被重写。这一点通过使用根文件系统上的 Btrfs 子卷实现。子卷可从快照中排除。安装期间，根据 YaST 建议，<phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 上的默认根文件系统设置包含下列子卷。由于以下原因，它们会从快照中排除。
   </para>
   <xi:include href="snapshot_excludes_i.xml"/>
   <warning>
    <title>回滚支持</title>
    <para>
     仅当您未去除任何预先设置的子卷时，SUSE 支持才支持回滚。不过，您可以使用 YaST 分区程序添加其他子卷。
    </para>
   </warning>
   <sect3 xml:id="sec.filesystems.major.btrfs.compress">
    <title>装入压缩的 Btrfs 文件系统</title>
    <remark>toms 2015-09-16: FATE#316463</remark>
    <note>
     <title>GRUB 2 和 LZO 压缩根目录</title>
     <para>
      GRUB 2 无法读取 lzo 压缩根目录。如果要使用压缩，您需要创建单独的 <filename>/boot</filename> 分区。
     </para>
    </note>
    <para>
     从 SLE12 SP1 开始，支持压缩 Btrfs 文件系统。使用 <option>compress</option> 或 <option>compress-force</option> 选项，并选择压缩算法 <literal>lzo</literal> 或 <literal>zlib</literal>（默认）。zlib 压缩的压缩率更高，而 lzo 的压缩速度更快，并且所需的 CPU 负载更小。
    </para>
    <para>
     例如：
    </para>
<screen><prompt role="root">root # </prompt>mount -o compress /dev/sdx /mnt</screen>
    <para>
     如果您创建了一个文件并在其中写入数据，而压缩后的结果大于或等于未压缩时的大小，则将来针对此文件执行写入操作后，Btrfs 会始终跳过压缩。如果您不希望有这种行为，请使用 <option>compress-force</option> 选项。对于包含一些初始未压缩数据的文件而言，此选项可能很有用。
    </para>
    <para>
     请注意，压缩只会作用于新文件。如果使用 <option>compress</option> 或 <option>compress-force</option> 选项装入文件系统，则在未压缩的情况下写入的文件将不会压缩。此外，包含 <option>nodatacow</option> 属性的文件的内容永远不会压缩：
    </para>
<screen><prompt role="root">root # </prompt><command>chattr</command> +C <replaceable>FILE</replaceable>
<prompt role="root">root # </prompt><command>mount</command> -o nodatacow  /dev/sdx /mnt</screen>
    <para>
     加密与任何压缩操作均无关。在此分区中写入一些数据后，请打印细节：
    </para>
<screen><prompt role="root">root # </prompt>btrfs filesystem show /mnt
btrfs filesystem show /mnt
Label: 'Test-Btrfs'  uuid: 62f0c378-e93e-4aa1-9532-93c6b780749d
        Total devices 1 FS bytes used 3.22MiB
      devid    1 size 2.00GiB used 240.62MiB path /dev/sdb1</screen>
    <para>
     如果您希望此设置是永久性的，请在 <filename>/etc/fstab</filename> 配置文件中添加 <option>compress</option> 或 <option>compress-force</option> 选项。例如：
    </para>
<screen>UUID=1a2b3c4d /home btrfs subvol=@/home,<emphasis role="strong">compress</emphasis> 0 0</screen>
   </sect3>
   <sect3 xml:id="sec.filesystems.major.btrfs.suse.mount">
    <title>装入子卷</title>
    <para>
     在 <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 上，从快照进行系统回滚的程序通过先从快照引导来执行。这样一来，您便可以在运行回滚之前，在运行的同时检查快照。只要装入子卷，就可以实现从快照引导（通常没必要）。
    </para>
    <para>
     除了<xref linkend="sec.filesystems.major.btrfs.suse"/>中列出的子卷之外，系统中还存在一个名为 <literal>@</literal> 的卷。这是默认的子卷，将作为根分区 (<filename>/</filename>) 装入。其他子卷将装入到此卷中。
    </para>
    <para>
     从快照引导时，使用的不是 <literal>@</literal> 子卷，而是快照。快照中包括的文件系统部分将以只读方式装入为 <filename>/</filename>。其他子卷将以可写入方式装入到快照中。此状态默认为临时状态，下次重引导时将还原先前的配置。若要使它成为永久状态，请执行 <command>snapper rollback</command> 命令。这将使目前引导的快照成为新的<emphasis>默认</emphasis>子卷，在重引导之后将会使用它。
    </para>
   </sect3>
   <sect3 xml:id="sec.filesystems.major.btrfs.suse.space">
    <title>检查可用空间</title>
    <para>
     通常可通过运行 <command>df</command> 命令来检查文件系统的用量。在 Btrfs 文件系统上，<command>df</command> 的输出可能有误导性，因为除了原始数据分配的空间以外，Btrfs 文件系统还会为元数据分配并使用空间。
    </para>
    <para>
     因此，即使看上去仍有大量的可用空间，Btrfs 文件系统也可能会报告空间不足。发生这种情况时，为元数据分配的全部空间都已用尽。使用以下命令可检查 Btrfs 文件系统上已用和可用的空间：
    </para>
    <variablelist>
     <varlistentry>
      <term><command>btrfs filesystem show</command>
      </term>
      <listitem>
<screen><prompt>tux &gt; </prompt>sudo btrfs filesystem show /
Label: 'ROOT'  uuid: 52011c5e-5711-42d8-8c50-718a005ec4b3
        Total devices 1 FS bytes used 10.02GiB
        devid    1 size 20.02GiB used 13.78GiB path /dev/sda3</screen>
       <para>
        显示文件系统的总大小及其用量。如果最后一行中的这两个值匹配，则表示文件系统上的全部空间都已分配出去。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><command>btrfs filesystem df</command>
      </term>
      <listitem>
<screen><prompt>tux &gt; </prompt>sudo btrfs filesystem df /
Data, single: total=13.00GiB, used=9.61GiB
System, single: total=32.00MiB, used=16.00KiB
Metadata, single: total=768.00MiB, used=421.36MiB
GlobalReserve, single: total=144.00MiB, used=0.00B</screen>
       <para>
        显示文件系统的已分配 (<literal>total</literal>) 空间和已用空间值。如果元数据的 <literal>total</literal> 和 <literal>used</literal> 值基本上相等，则表示元数据的全部空间都已分配出去。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><command>btrfs filesystem usage</command>
      </term>
      <listitem>
<screen><prompt>tux &gt; </prompt>sudo btrfs filesystem usage /
Overall:
    Device size:                  20.02GiB
    Device allocated:             13.78GiB
    Device unallocated:            6.24GiB
    Device missing:                  0.00B
    Used:                         10.02GiB
    Free (estimated):              9.63GiB      (min: 9.63GiB)
    Data ratio:                       1.00
    Metadata ratio:                   1.00
    Global reserve:              144.00MiB      (used: 0.00B)

             Data     Metadata  System
Id Path      single   single    single   Unallocated
-- --------- -------- --------- -------- -----------
 1 /dev/sda3 13.00GiB 768.00MiB 32.00MiB     6.24GiB
-- --------- -------- --------- -------- -----------
   Total     13.00GiB 768.00MiB 32.00MiB     6.24GiB
   Used       9.61GiB 421.36MiB 16.00KiB</screen>
       <para>
        显示类似于前两个命令输出合并所得的数据。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     有关详细信息，请参见 <command>man 8 btrfs-filesystem</command> 和 <link xlink:href="https://btrfs.wiki.kernel.org/index.php/FAQ"/>。
    </para>
   </sect3>
  </sect2>

  <sect2 xml:id="sec.filesystems.major.btrfs.migrate">
   <title>从 Ext 和 ReiserFS 文件系统迁移至 Btrfs</title>
   <para>
    您可以将数据卷从现有 Ext（Ext2、Ext3 或 Ext4）或 ReiserFS 文件系统迁移至 Btrfs 文件系统。转换过程将在该设备的适当位置以脱机方式进行。文件系统至少需要使用设备上 15% 的可用空间。
   </para>
   <para>
    要将 文件系统转换为 Btrfs 文件系统，请将文件系统脱机，然后输入：
   </para>
<screen>sudo btrfs-convert <replaceable>DEVICE</replaceable></screen>
   <para>
    要将迁移回滚到原先的 文件系统，请将文件系统脱机，然后输入：
   </para>
<screen>sudo btrfs-convert -r <replaceable>DEVICE</replaceable></screen>
   <warning>
    <title>不支持根文件系统转换</title>
    <para>
     不支持将根文件系统转换为 Btrfs。请保留现有的文件系统，或者从头开始重新安装整个系统。
    </para>
   </warning>
   <important>
    <title>可能的数据丢失</title>
    <para>
     回滚到原先的 文件系统时，将丢失所有在转换为 Btrfs 文件系统后添加的数据。也就是说，只有原始数据会重新转换为先前的文件系统。
    </para>
   </important>
  </sect2>

  <sect2 xml:id="sec.filesystems.major.btrfs.admin">
   <title>Btrfs 管理</title>
   <para>
    Btrfs 与 YaST 分区程序和 AutoYaST 集成。您可以在安装期间使用它来为根文件系统建立解决方案。安装之后，您可以使用 YaST 分区程序来查看和管理 Btrfs 卷。
   </para>
   <para>
    <filename>btrfsprogs</filename> 包中提供了 Btrfs 管理工具。有关使用 Btrfs 命令的信息，请参见 <command>man 8 btrfs</command>、<command>man 8 btrfsck</command> 和 <command>man 8 mkfs.btrfs</command> 命令。有关 Btrfs 功能的信息，请参见 <citetitle>Btrfs Wiki</citetitle>，网址为 <link xlink:href="http://btrfs.wiki.kernel.org"/>。
   </para>
  </sect2>

  <sect2 xml:id="sec.filesystems.major.btrfs.quota">
   <title>Btrfs 子卷定额支持</title>
   <para>
    Btrfs 根文件系统子卷 <filename>/var/log</filename>、<filename>/var/crash</filename> 和 <filename>/var/cache</filename> 在正常运作情况下可能会使用所有可用的磁盘空间，此时将导致系统故障。为避免出现此状况，<phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 现在提供了 Btrfs 子卷配额支持。如果您按照相应的 YaST 建议设置根文件系统，系统会为根文件系统进行相应的准备：所有子卷的配额组 (<literal>qgroup</literal>) 均已设置。若要设置根文件系统中子卷的配额，请执行下列步骤：
   </para>
   <procedure>
    <step>
     <para>
      启用配额支持：
     </para>
<screen>sudo btrfs quota enable /</screen>
    </step>
    <step>
     <para>
      取得子卷列表：
     </para>
<screen>sudo btrfs subvolume list /</screen>
     <para>
      只能为现有子卷设置配额。
     </para>
    </step>
    <step>
     <para>
      为上一步中所列的其中一个子卷设置配额。子卷可以用路径识别（例如 <filename>/var/tmp</filename>），也可以用 <literal>0/<replaceable>子卷 ID</replaceable></literal> 识别（例如 <literal>0/272</literal>）。下面的范围为 <filename>/var/tmp</filename> 设置了 5 GB 的配额。
     </para>
<screen>sudo btrfs qgroup limit 5G /var/tmp</screen>
     <para>
      大小单位可以是字节 (5000000000)、KB (5000000K)、MB (5000M) 或 GB (5G)。以字节为单位产生的值略有不同，因为 1024 字节 = 1 KB，1024 KB = 1 MB 等。
     </para>
    </step>
    <step>
     <para>
      若要列出现有配额，请使用以下命令。<literal>max_rfer</literal> 列以字节为单位显示配额。
     </para>
<screen>sudo btrfs qgroup show -r /</screen>
    </step>
   </procedure>
   <tip>
    <title>取消配额</title>
    <para>
     如果您要取消现有定额，请将定额大小设置为 <literal>none</literal>：
    </para>
<screen>sudo btrfs qgroup limit none /var/tmp</screen>
    <para>
     若要禁用某个分区及其所有子卷的配额支持，请使用 <command>btrfs quota disable</command>：
    </para>
<screen>sudo btrfs quota disable /</screen>
   </tip>
   <para>
    有关细节，请参见 <command>man 8 btrfs-qgroup</command> 和 <command>man 8 btrfs-quota</command>。Btrfs Wiki (<link xlink:href="https://btrfs.wiki.kernel.org/index.php/UseCases"/>) 上的 <citetitle>UseCases</citetitle> 页面也提供了更多信息。
   </para>
  </sect2>

  <sect2 xml:id="sec.filesystems.major.btrfs.s-r">
   <title>Btrfs 发送/接收</title>
   <para>
    Btrfs 允许生成快照来捕获文件系统的状态。例如，Snapper 可使用此功能在系统更改之前及之后创建快照，以便允许回滚。不过，将快照与发送/接收功能结合使用还可以在远程位置创建和维护文件系统的副本。例如，此功能可用于执行增量备份。
   </para>
   <para>
    <command>btrfs send</command> 操作可计算同一子卷中两个只读快照之间的差异，并将差异发送到某个文件或 STDOUT。<command>Btrfs receive</command> 操作接收发送命令的结果，并将其应用到快照。
   </para>
   <sect3 xml:id="sec.filesystems.major.btrfs.s-r.requires">
    <title>先决条件</title>
    <para>
     要使用 Btrfs 的发送/接收功能，需要满足以下要求：
    </para>
    <itemizedlist>
     <listitem>
      <para>
       源端（<literal>发送</literal>）和目标端（<literal>接收</literal>）各有一个 Btrfs 文件系统。
      </para>
     </listitem>
     <listitem>
      <para>
       Btrfs 发送/接收是对快照执行的，因此，相应的数据需要驻留在 Btrfs 子卷中。
      </para>
     </listitem>
     <listitem>
      <para>
       源端中的快照必须为只读模式。
      </para>
     </listitem>
     <listitem>
      <para>
       SUSE Linux Enterprise 12 SP2 或更高版本。早期版本的 SUSE Linux Enterprise 不支持发送/接收。
      </para>
     </listitem>
    </itemizedlist>
   </sect3>
   <sect3 xml:id="sec.filesystems.major.btrfs.s-r.backup">
    <title>增量备份</title>
    <para>
     以下过程展示了 Btrfs 发送/接收操作的基本用法，其中示范了如何在 <filename>/backup/data</filename>（目标端）中创建 <filename>/data</filename>（源端）的增量备份。<filename>/data</filename> 必须是一个子卷。
    </para>
    <procedure>
     <title>初始设置</title>
     <step>
      <para>
       在源端创建初始快照（在本示例中名为 <literal>snapshot_0</literal>），并确保将它写入该磁盘：
      </para>
<screen>sudo btrfs subvolume snapshot -r /data /data/bkp_data
sync</screen>
      <para>
       即会创建一个新子卷 <filename>/data/bkp_data</filename>。该子卷将用作后续增量备份的基础，应将它保留为参照。
      </para>
     </step>
     <step>
      <para>
       将初始快照发送到目标端。由于这是初始的发送/接收操作，因此需要发送整个快照：
      </para>
<screen>sudo bash -c 'btrfs send /data/bkp_data | btrfs receive /backup'</screen>
      <para>
       目标端上即会创建一个新子卷 <filename>/backup/bkp_data</filename>。
      </para>
     </step>
    </procedure>
    <para>
     完成初始设置后，可以创建增量备份，并将当前快照与先前快照之间的差异发送到目标端。操作过程始终是相同的：
    </para>
    <orderedlist>
     <listitem>
      <para>
       在源端创建新快照。
      </para>
     </listitem>
     <listitem>
      <para>
       将差异发送到目标端。
      </para>
     </listitem>
     <listitem>
      <para>
       可选：重命名和/或清理两端中的快照。
      </para>
     </listitem>
    </orderedlist>
    <procedure>
     <title>执行增量备份</title>
     <step>
      <para>
       在源端创建新快照，并确保将它写入该磁盘。在下面的示例中，快照命名为 bkp_data_<replaceable>当前日期</replaceable>：
      </para>
<screen>sudo btrfs subvolume snapshot -r /data /data/bkp_data_$(date +%F)
sync</screen>
      <para>
       创建新子卷，例如 <filename>/data/bkp_data_2016-07-07</filename>。
      </para>
     </step>
     <step>
      <para>
       将先前快照与刚创建的快照之间的差异发送到目标端。为此，可以使用选项 <option>-p <replaceable>SNAPSHOT</replaceable></option> 指定先前的快照。
      </para>
<screen>sudo bash -c 'btrfs send -p /data/bkp_data /data/bkp_data_2016-07-07 \
| btrfs receive /backup'</screen>
      <para>
       即会创建一个新子卷 <filename>/backup/bkp_data_2016-07-07</filename>。
      </para>
     </step>
     <step>
      <para>
       如此我们有了四个快照，每端各有两个：
      </para>
      <simplelist>
       <member><filename>/data/bkp_data</filename>
       </member>
       <member><filename>  /data/bkp_data_2016-07-07</filename>
       </member>
       <member><filename>  /backup/bkp_data</filename>
       </member>
       <member><filename>  /backup/bkp_data_2016-07-07</filename>
       </member>
      </simplelist>
      <para>
       现在，关于如何继续，您有三种选择：
      </para>
      <itemizedlist>
       <listitem>
        <para>
         保留两端中的所有快照。如果采用这种选择，您可以回滚到两端中的任一快照，同时会复制所有数据。不需要执行额外操作。执行后续增量备份时，请记得使用倒数第二个快照作为发送操作的父项。
        </para>
       </listitem>
       <listitem>
        <para>
         仅保留源端中的最后一个快照，保留目标端中的所有快照。此外，允许回滚到两端中的任一快照 - 要回滚到源端中的特定快照，请对整个快照执行从目标端到源端的发送/接收操作。在源端执行删除/移动操作。
        </para>
       </listitem>
       <listitem>
        <para>
         仅保留两端中的最后一个快照。采用这种方法，您会在目标端创建一个备份，该备份代表源端中生成的最后一个快照的状态。系统无法回滚到其他快照。在源端和目标端执行删除/移动操作。
        </para>
       </listitem>
      </itemizedlist>
      <substeps>
       <step>
        <para>
         如果只想保留源端中的最后一个快照，请执行以下命令：
        </para>
<screen>sudo btrfs subvolume delete /data/bkp_data
sudo mv /data/bkp_data_2016-07-07 /data/bkp_data</screen>
        <para>
         第一条命令将删除先前的快照，第二条命令将当前快照重命名为 <filename>/data/bkp_data</filename>。这可确保备份的最后一个快照始终命名为 <filename>/data/bkp_data</filename>。因此，您也可以始终使用此子卷名称作为增量发送操作的父项。
        </para>
       </step>
       <step>
        <para>
         如果只想保留目标端中的最后一个快照，请执行以下命令：
        </para>
<screen>sudo btrfs subvolume delete /backup/bkp_data
sudo mv /backup/bkp_data_2016-07-07 /backup/bkp_data</screen>
        <para>
         第一条命令将删除先前的备份快照，第二条命令将当前备份快照重命名为 <filename>/backup/bkp_data</filename>。这可确保最新的备份快照始终命名为 <filename>/backup/bkp_data</filename>。
        </para>
       </step>
      </substeps>
     </step>
    </procedure>
    <tip>
     <title>发送到远程目标端</title>
     <para>
      要将快照发送到远程计算机，请使用 SSH：
     </para>
<screen>btrfs send /data/bkp_data | ssh root@jupiter.example.com 'btrfs receive /backup'</screen>
    </tip>
   </sect3>
  </sect2>

  <sect2 xml:id="sec.filesystems.major.btrfs.deduplication">
   <title>重复数据删除支持</title>
   <para>
    Btrfs 支持重复数据删除功能，具体办法是以指向通用储存位置中的块单一副本的逻辑链接替换文件系统中完全相同的块。<phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 提供 <command>duperemove</command> 工具来扫描文件系统中有没有完全相同的块。在 Btrfs 文件系统上使用时，它也可以用来对这些块执行重复数据删除。系统上默认不会安装 <command>duperemove</command>。要使此功能可用，请安装包
    <package>duperemove</package>
    。
   </para>
   <note>
    <title>使用案例</title>
    <para>
     从 <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> <phrase role="productnumber"><phrase os="sles;sled;slerte"> 12 SP3</phrase></phrase> 开始，duperemove 不再适用于对整个文件系统执行重复数据删除。它主要用于对 10 到 50 个为一组的大型文件执行重复数据删除操作（这些文件可能具有许多通用块，例如虚拟机映像）。
    </para>
   </note>
   <para>
    <command>duperemove</command> 可以针对一系列文件操作，也可以以递归方式扫描某个目录：
   </para>
<screen>sudo duperemove <replaceable>OPTIONS</replaceable> file1 file2 file3
sudo duperemove -r <replaceable>OPTIONS</replaceable> directory</screen>
   <para>
    它有两种操作模式：只读和重复数据删除。以只读模式运行时（即不使用 <option>-d</option> 切换），它会扫描给定文件或目录中有无重复的块，并将它们打印出来。此模式适用于所有文件系统。
   </para>
   <para>
    以重复数据删除模式执行 <command>duperemove</command> 仅在 Btrfs 文件系统上受支持。扫描给定文件或目录之后，将会提交重复的块以进行重复数据删除。
   </para>
   <para>
    有关详细信息，请参见 <command>man 8 duperemove</command>。
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.filesystems.major.xfs">
  <title>XFS</title>

  <para>
   SGI 在 20 世纪 90 年代初开始开发 XFS，最初计划将 XFS 作为 IRIX OS 的文件系统。开发 XFS 的目的是创建一个高性能的 64 位日记文件系统来满足对计算能力的极高要求。XFS 适合操纵大型文件，在高端硬件上表现优异。XFS 是 <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 中数据分区的默认文件系统。
  </para>

  <para>
   快速回顾 XFS 的关键功能可解释为什么此文件系统经证明在高端计算方面是其他日记文件系统的强大竞争对手。
  </para>

  <sect2 xml:id="sec.filesystems.major.xfs.scalability">
   <title>使用分配组实现高可伸缩性</title>
   <para>
    在创建 XFS 文件系统时，文件系统底层的块设备被分成 8 个或 8 个以上相同大小的线性区域。这些区域称为<emphasis>分配组</emphasis>。每个分配组管理自己的 inode 和可用空间。实际上，可以将分配组看作文件系统中的文件系统。因为分配组相互独立，所以内核可同时对多个分配组进行寻址。此功能是 XFS 优异的可伸缩性关键之所在。独立分配组的概念自然适合多处理器系统的需要。
   </para>
  </sect2>

  <sect2 xml:id="sec.filesystems.major.xfs.mgmt">
   <title>通过有效管理磁盘空间获得高性能</title>
   <para>
    可用空间和 inode 是由分配组内的 B<superscript>+</superscript> 树处理的。使用 B<superscript>+</superscript> 树将大大增强 XFS 的性能和可伸缩性。XFS 使用<emphasis>延迟分配</emphasis>，它可以通过将进程分为两部分而处理分配。将挂起事务储存在 RAM 中并保留适当数量的空间。XFS 仍不决定应储存数据的准确位置（即不指出文件系统块）。此决定将被延迟到最后的时刻。某些生存期很短的临时数据可能永远不会被储存到磁盘上，这是因为在 XFS 决定保存它们的实际位置时，这些数据可能已经过时了。以这种方式，XFS 增强了写性能并减少了文件系统分段。因为延迟分配引起写事件的频率比其他文件系统引起写事件的频率要低，所以如果写操作期间发生系统崩溃，则数据丢失可能会更加严重。
   </para>
  </sect2>

  <sect2 xml:id="sec.filesystems.major.prealloc">
   <title>进行预分配以避免文件系统碎片</title>
   <para>
    在将数据写入文件系统前，XFS <emphasis>保留</emphasis>（预分配）文件所需的可用空间。这样会大大减少文件系统碎片的数目。因为文件的内容不会分散在整个文件系统中，所以性能得以提高。
   </para>
   <note>
    <title>新的 XFS 磁盘格式</title>
    <para>
     从 12 版开始，<phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 支持 XFS 文件系统的新<quote>磁盘格式</quote> (v5)。由 YaST 创建的 XFS 文件系统将使用这种新格式。这种格式的主要优点包括，所有 XFS 元数据的自动检查总数、文件类型支持以及支持文件更多数量的访问控制列表。
    </para>
    <para>
     请注意，低于 3.12 版的 SUSE Linux Enterprise 内核、低于 3.2.0 版的 xfsprogs，以及在 SUSE Linux Enterprise 12 之前发布的 GRUB 2 版本均<emphasis>不</emphasis>支持这种格式。如果同时还要从不符合上述先决条件的系统中使用该文件系统，就会出现问题。
    </para>
    <para>
     如果您需要在较旧 SUSE 系统或其他 Linux 发行套件与 XFS 文件系统之间实现互操作性，请使用 <command>mkfs.xfs</command> 命令手动格式化文件系统。这将创建一个采用旧格式的 XFS 文件系统（除非您使用 <option>-m crc=1</option> 选项）。
    </para>
   </note>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.filesystems.major.ext2">
  <title>Ext2</title>

  <para>
   Ext2 的原身可以追溯到 Linux 历史的早期。其前身是“扩展文件系统”，于 1992 年 4 月实施，集成在 Linux 0.96c 中。扩展文件系统经历了数次修改，后来才称为 Ext2，曾经是多年来最受欢迎的 Linux 文件系统。但随着日记文件系统的创建以及其恢复时间的缩短，Ext2 的重要性逐渐降低。
  </para>

  <para>
   简要总结 Ext2 的优点有助于您了解为什么它以前是（在某些领域现在仍是）许多 Linux 用户最喜欢使用的 Linux 文件系统。
  </para>

  <variablelist>
   <varlistentry>
    <term>可靠性和速度</term>
    <listitem>
     <para>
      Ext2 是一个<quote>老古董</quote>，它经历了许多改进和频繁的测试。这可能是人们经常称之为坚如磐石的文件系统的原因。在系统中断后，如果无法彻底卸装文件系统，则 e2fsck 将开始分析文件系统数据。系统使元数据恢复一致的状态，并将挂起的文件或数据块写入指定的目录（名为 <filename>lost+found</filename>）。与日记文件系统相比，e2fsck 会分析整个文件系统，而不仅仅是元数据中最近修改的位。这种操作所花的时间要远远超过检查日记文件系统的日志数据所花的时间。根据文件系统的大小，此过程可能需要半小时或更长时间。因此，对于任何要求高可用性的服务器，不要选择 Ext2。但是，因为 Ext2 不维护日记且使用的内存也更少，所以其速度往往快于其他文件系统。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>可方便地升级</term>
    <listitem>
     <para>
      因为 Ext3 以 Ext2 代码为基础并且共享 Ext2 的磁盘上格式和元数据格式，所以从 Ext2 升级到 Ext3 非常容易。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 xml:id="sec.filesystems.major.ext3">
  <title>Ext3</title>

  <para>
   Ext3 由 Stephen Tweedie 设计。与所有其他下一代文件系统不同，Ext3 并没有采用全新的设计原则。它是在 Ext2 的基础上设计的。这两个文件系统密切关联。可以方便地在 Ext2 文件系统上建立 Ext3 文件系统。Ext2 和 Ext3 最重要的区别是 Ext3 支持日记。总之，Ext3 有三个主要优点：
  </para>

  <sect2 xml:id="sec.filesystems.major.ext3.upgrade">
   <title>方便并高度可靠地从 Ext2 升级</title>
   <para>
    Ext2 的代码为 Ext3 奠定了坚实的基础，使后者成为受到高度评价的下一代文件系统。在 Ext3 中，它的可靠性和稳定性与日记文件系统的优点完美地结合在一起。不像转换至其他日记文件系统（例如 ReiserFS 或 XFS）那么冗长乏味（备份整个文件系统，然后从头开始重新创建），转换至 Ext3 只是数分钟的事。升级到 Ext3 还很安全，因为从头重新创建整个文件系统可能会出现问题。考虑到等待升级到日记文件系统的现有 Ext2 系统的数量，就很容易明白为什么 Ext3 对许多系统管理员来说如此重要。从 Ext3 降级到 Ext2 与升级一样简单。将 Ext3 文件系统完全卸载，然后重新装入成 Ext2 文件系统即可。
   </para>
  </sect2>

  <sect2 xml:id="sec.filesystems.major.ext3.performance">
   <title>可靠性和性能</title>
   <para>
    某些其他日记文件系统采用<quote>仅元数据</quote>的日记方法。这意味着元数据始终保持一致的状态，但无法自动保证文件系统数据本身一致。Ext3 的设计既可以照顾到元数据，又可以照顾到数据。<quote>照顾</quote>的程度可以自定义。在 <option>data=journal</option> 方式中启用 Ext3 可以提供最大的安全性（数据完整性），但因为要将元数据和数据都记入日记，所以可能会降低系统的速度。一个相对较新的方法是采用 <option>data=ordered</option> 方式，这种方式确保了数据和元数据的完整性，但只对元数据使用日记。文件系统驱动程序收集与一次元数据更新对应的所有数据块。这些数据块在更新元数据之前被写入磁盘中。这样，在不牺牲性能的情况下，元数据和数据的一致性得以实现。第三个要使用的选项是 <option>data=writeback</option>，允许数据在其元数据已经提交至日记后再写入主要文件系统。在性能方面，此选项常被认为是最佳选项。但它在维护内部文件系统完整性的同时，允许以前的数据在系统崩溃并恢复后再次出现在文件中。Ext3 使用 <option>data=ordered</option> 选项作为默认值。
   </para>
  </sect2>

  <sect2 xml:id="sec.filesystems.major.ext3.ext22ext3a">
   <title>将 Ext2 文件系统转换为 Ext3</title>
   <para>
    要将 Ext2 文件系统转换为 Ext3：
   </para>
   <procedure>
    <step>
     <para>
      作为 <systemitem class="username">root</systemitem> 用户运行 <command>tune2fs -j</command> 来创建 Ext3 日记。
     </para>
     <para>
      此命令将用默认参数创建 Ext3 日记。
     </para>
     <para>
      要指定日记的大小和所驻留的设备，请改为运行 <command>tune2fs </command> <option>-J</option>，同时使用所需的日记选项 <option>size=</option> 和 <option>device=</option>。<command>tune2fs</command> 手册页中有关于 <command>tune2fs</command> 程序的更多信息。
     </para>
    </step>
    <step>
     <para>
      作为 <systemitem class="username">root</systemitem> 用户编辑文件 <filename>/etc/fstab</filename>，以将为相应分区指定的文件系统类型从 <literal>ext2</literal> 更改为 <literal>ext3</literal>，然后保存更改。
     </para>
     <para>
      这确保可以正确识别出 Ext3 文件系统。此更改将在下次重引导后生效。
     </para>
    </step>
    <step>
     <para>
      若引导已设置为 Ext3 分区的根文件系统，请在 <literal>initrd</literal> 中添加模块 <literal>ext3</literal> 和 <filename>jbd</filename>。操作步骤如下：
     </para>
     <substeps performance="required">
      <step>
       <para>
        将下面一行添加至 <filename>/etc/dracut.conf.d/01-dist.conf</filename>：
       </para>
<screen>force_drivers+="ext3 jbd"</screen>
      </step>
      <step>
       <para>
        然后运行 <command>dracut </command> <option>-f</option> 命令。
       </para>
      </step>
     </substeps>
    </step>
    <step>
     <para>
      重引导系统。
     </para>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="sec.filesystems.major.ext3.inodesize">
   <title>Ext3 文件系统 inode 大小及 inode 数量</title>
   <para>
    inode 用于存储文件的相关信息及其在文件系统中的块位置。为了让 inode 有空间可以容纳扩展属性以及 ACL，Ext3 的默认 inode 大小从 SLES 10 上的 128 字节增加到了 SLES 11 上的 256 字节。与 SLES 10 相比，当您在 SLES 11 上创建新的 Ext3 文件系统时，为相同数量的 Inode 预先分配的默认空间容量会增加一倍，文件系统中文件的可用空间则会减少相应的容量。因此，要容纳与 SLES 10 上的 Ext3 文件系统中数量相同的 inode 和文件，您必须使用更大的分区。
   </para>
   <para>
    当您创建新的 Ext3 文件系统时，系统将根据可创建的 Inode 总数预先分配 Inode 表格中的空间。每 inode 的字节数比率以及文件系统的大小决定了可以创建的 inode 数量。建立文件系统时，将根据每 inode 字节数的单位空间创建 inode：
   </para>
<screen>number of inodes = total size of the file system divided by the number of bytes per inode</screen>
   <para>
    inode 的数量控制着文件系统中可容纳的文件数：一个文件对应一个 inode。为解决 inode 大小增加而使可用空间变少的问题，每 inode 的字节数比率的默认值由 SLES 10 上的 8192 字节增加到了 SLES 11 上的 16384 字节。比率翻倍意味着可以创建的文件数量将只有 SLES 10 上 Ext3 文件系统中可容纳文件数量的一半。
   </para>
   <important>
    <title>更改现有 Ext3 文件系统的 Inode 大小。</title>
    <para>
     inode 分配完毕后，将无法更改 inode 大小的设置或每 inode 的字节数比率。如果不使用其他设置重新创建文件系统，或不扩展文件系统，则无法添加 Inode。超过 inode 最大数量时，只有删除部分文件才能在文件系统上创建新文件。
    </para>
   </important>
   <para>
    新建 Ext3 文件系统时，您可以指定 inode 大小和每 inode 的字节数比率，以控制文件系统上可容纳 inode 空间占用量以及文件数量。如果未指定块大小、inode 大小以及每 inode 的字节数比率值，则将应用 <filename>/etc/mked2fs.conf</filename> 中的默认值。有关信息，请参见 <filename>mke2fs.conf(5)</filename> 手册页。
   </para>
   <para>
    使用以下指标：
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <formalpara>
      <title>inode 大小：</title>
      <para>
       默认的 inode 大小为 256 字节。指定字节值，即介于 128 字节（含）到块大小（含）之间的 2 的乘方值，如 128、256、512，以此类推。只有当 Ext3 文件系统上不使用扩展属性或 ACL 时才可使用 128 字节。
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>每 inode 的字节数比率：</title>
      <para>
       默认的每 inode 的字节数比率为 16384 字节。有效的每 inode 的字节数比率值必须是大于等于 1024 字节的 2 的乘方值，如 1024、2048、4096、8192、16384、32768，以此类推。该值不应小于文件系统的块大小，因为块大小是用于存储数据的最小空间大块。Ext3 文件系统默认的块大小为 4 KB。
      </para>
     </formalpara>
     <para>
      此外，您还应考虑文件的数量以及需要存储的文件大小。例如，如果您的文件系统上将会有许多小文件，则可以指定一个较小的每 inode 的字节数比率，这样会增加 inode 的数量。如果文件系统将储存超大型文件，您可以指定一个较大的每 Inode 的字节数比率，这样可减少可能的 Inode 数。
     </para>
     <para>
      通常情况下，最好要保证有足够多的 inode 可供使用。如果 inode 数量过少且文件很小，则可能当磁盘上的文件数量已达最大值时实际上磁盘却还很空。如果 inode 过多且文件很大，则可能虽然报告仍有可用空间，但却无法使用，这是因为您无法在为 inode 预留的空间中新建文件。
     </para>
    </listitem>
   </itemizedlist>
   <para>
    如果您在 Ext3 文件系统上不使用扩展属性或 ACL，则在创建文件系统时可通过将 inode 大小指定为 128 字节，并将每 inode 的字节数比率指定为 8192 字节，来恢复到 SLES 10 行为。使用以下任何一种方法设置 inode 大小以及每 inode 的字节数比率：
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <formalpara>
      <title>更改所有新的 Ext3 文件的默认设置：</title>
      <para>
       在文本编辑器中，修改 <filename>/etc/mke2fs.conf</filename> 文件的 <literal>defaults</literal> 部分，以为 <literal>inode_size</literal> 和 <literal>inode_ratio</literal> 设置所需的默认值。这些值将应用到所有新的 Ext3 文件系统。例如：
      </para>
     </formalpara>
<screen>blocksize = 4096
inode_size = 128
inode_ratio = 8192</screen>
    </listitem>
    <listitem>
     <formalpara>
      <title>在命令行处：</title>
      <para>
       新建 Ext3 文件系统时，将 inode 大小 (<literal>-I 128</literal>) 以及每 inode 的字节数比率 (<literal>-i 8192</literal>) 传递给 <command>mkfs.ext3(8)</command> 命令或 <command>mke2fs(8)</command> 命令。例如，使用以下任一命令：
      </para>
     </formalpara>
<screen>sudo mkfs.ext3 -b 4096 -i 8092 -I 128 /dev/sda2
sudo mke2fs -t ext3 -b 4096 -i 8192 -I 128 /dev/sda2</screen>
    </listitem>
    <listitem>
     <formalpara>
      <title>在使用 YaST 安装期间：</title>
      <para>
       在安装期间，新建 Ext3 文件系统时要传递 inode 大小和每 inode 的字节数比率值。在<guimenu>格式化选项</guimenu>下的<guimenu>编辑分区</guimenu>页面的 YaST 分区程序中，选择<guimenu>格式化分区</guimenu><guimenu>Ext3</guimenu>，然后单击<guimenu>选项</guimenu>。从<guimenu>文件系统选项</guimenu>对话框中的<guimenu>块大小 (B)</guimenu>、<guimenu>每 inode 的字节数</guimenu>以及 <guimenu>Inode 大小</guimenu>下拉框中，选择所需的值。
      </para>
     </formalpara>
     <para>
      例如，在<guimenu>块大小 (B)</guimenu> 下拉框中选择 4096、在<guimenu>每 inode 的字节数</guimenu>下拉框中选择 8192、在 <guimenu>Inode 大小</guimenu>下拉框中选择 128，然后单击<guimenu>确定</guimenu>。
     </para>
     <informalfigure>
      <mediaobject>
       <imageobject role="fo">
        <imagedata fileref="ext3_inode_yast_a.png" width="80%" format="PNG"/>
       </imageobject>
       <imageobject role="html">
        <imagedata fileref="ext3_inode_yast_a.png" width="100%" format="PNG"/>
       </imageobject>
      </mediaobject>
     </informalfigure>
    </listitem>
    <listitem>
     <formalpara>
      <title>在使用 AutoYaST 安装期间：</title>
      <para>
       在 AutoYaST 配置文件中，您可以使用 <literal>fs_options</literal> 标记来设置 <literal>opt_bytes_per_inode</literal> 比率值（-i 为 8192）以及 <literal>opt_inode_density</literal> 值（-I 为 128）：
      </para>
     </formalpara>
<screen>
&lt;partitioning config:type="list"&gt;
  &lt;drive&gt;
    &lt;device&gt;/dev/sda&lt;/device&gt;
    &lt;initialize config:type="boolean"&gt;true&lt;/initialize&gt;
    &lt;partitions config:type="list"&gt;
      &lt;partition&gt;
        &lt;filesystem config:type="symbol"&gt;ext3&lt;/filesystem&gt;
        &lt;format config:type="boolean"&gt;true&lt;/format&gt;
        &lt;fs_options&gt;
          &lt;opt_bytes_per_inode&gt;
            &lt;option_str&gt;-i&lt;/option_str&gt;
            &lt;option_value&gt;8192&lt;/option_value&gt;
          &lt;/opt_bytes_per_inode&gt;
          &lt;opt_inode_density&gt;
            &lt;option_str&gt;-I&lt;/option_str&gt;
            &lt;option_value&gt;128&lt;/option_value&gt;
          &lt;/opt_inode_density&gt;
        &lt;/fs_options&gt;
        &lt;mount&gt;/&lt;/mount&gt;
        &lt;partition_id config:type="integer"&gt;131&lt;/partition_id&gt;
        &lt;partition_type&gt;primary&lt;/partition_type&gt;
        &lt;size&gt;25G&lt;/size&gt;
      &lt;/partition&gt;
    &lt;/partitions&gt;
  &lt;/drive&gt;
&lt;partitioning&gt;</screen>
    </listitem>
   </itemizedlist>
   <para>
    有关相关信息，请参见 <link xlink:href="http://www.suse.com/support/kb/doc.php?id=7009075"/>（<citetitle>SLES11 ext3 分区只能储存 SLES10 上可储存的文件数的  50%</citetitle> [技术信息文档 7009075]）。
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.filesystems.major.ext4">
  <title>Ext4</title>

  <para>
   2006 年，Ext4 做为 Ext3 的传承面市。它支持最大大小为 1 EiB 的卷、最大大小为 16 TiB 的文件和无限个子目录，消除了 Ext3 在储存上的一些局限。它还引入了多项性能增强功能，例如延迟块分配和速度大幅加快的文件系统检查例程。Ext4 还支持日记校验和，并可提供以纳秒度量的时间戳，因而更加可靠。Ext4 完全反向兼容于 Ext2 和 Ext3，后两个文件系统都可以作为 Ext4 装入。
  </para>
 </sect1>
 <sect1 xml:id="sec.filesystems.major.reiser">
  <title>ReiserFS</title>

  <para>
   作为 2.4 内核版本的正式的重要功能之一，ReiserFS 作为 2.2.x SUSE 内核的内核增补程序提供，因为版本 6.4 的 ReiserFS 是由 Hans Reiser 和 Namesys 开发团队设计的。ReiserFS 已证明它自己是 Ext2 功能强大的替代系统。其重要优点是通过数据日记实现的更合理的磁盘空间使用、更佳的磁盘访问性能、更快的崩溃恢复能力以及可靠性。
  </para>

  <important>
   <title><phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 12 中支持的 ReiserFS</title>
   <para>
    现有 ReiserFS 分区在 <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 12 的有效期间均受支持，专用于迁移。从 <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 12 开始，去除了创建新 ReiserFS 文件系统的支持。
   </para>
  </important>
 </sect1>
 <sect1 xml:id="sec.filesystems.other">
  <title>支持的其他文件系统</title>

  <para role="intro">
   <xref linkend="tab.filesystems.other" xrefstyle="TableXRef"/>对 linux 支持的其他一些文件系统进行了总结。支持这些文件系统主要是为了确保与不同类型的媒体或异操作系统实现兼容和数据交换。
  </para>

  <table xml:id="tab.filesystems.other">
   <title>Linux 中的文件系统类型</title>
   <tgroup cols="2">
    <colspec colnum="1" colname="1" colwidth="2381*"/>
    <colspec colnum="2" colname="2" colwidth="7620*"/>
    <thead>
     <row>
      <entry>
       <para>
        文件系统类型
       </para>
      </entry>
      <entry>
       <para>
        描述
       </para>
      </entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <para>
        <systemitem>cramfs</systemitem>
       </para>
      </entry>
      <entry>
       <para>
        压缩的 ROM 文件系统：一种经压缩的只读 ROM 文件系统。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <systemitem>hpfs</systemitem>
       </para>
      </entry>
      <entry>
       <para>
        高性能文件系统：IBM OS/2 标准文件系统。只在只读模式下支持。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <systemitem>iso9660</systemitem>
       </para>
      </entry>
      <entry>
       <para>
        CD-ROM 上的标准文件系统。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <systemitem>minix</systemitem>
       </para>
      </entry>
      <entry>
       <para>
        此文件系统源自有关操作系统的学术项目，是在 Linux 中使用的第一个文件系统。目前，它被用作软盘的文件系统。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <systemitem>msdos</systemitem>
       </para>
      </entry>
      <entry>
       <para>
        <filename>fat</filename>（最初由 DOS 使用的文件系统）现在已被多种操作系统采用。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <systemitem>nfs</systemitem>
       </para>
      </entry>
      <entry>
       <para>
        网络文件系统：在此文件系统中，可以将数据储存在网络中的任何计算机上，并可以通过网络授予访问权限。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <systemitem>ntfs</systemitem>
       </para>
      </entry>
      <entry>
       <para>
        Windows NT 文件系统；只读。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <systemitem>smbfs</systemitem>
       </para>
      </entry>
      <entry>
       <para>
        Windows 等产品使用服务器消息块来支持通过网络启用文件访问。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <systemitem>sysv</systemitem>
       </para>
      </entry>
      <entry>
       <para>
        在 SCO Unix、Xenix 和 Coherent（用于 PC 的商用 Unix 系统）上使用。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <systemitem>ufs</systemitem>
       </para>
      </entry>
      <entry>
       <para>
        供 BSD、SunOS 和 NextStep 使用。只在只读方式下支持此文件系统。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <systemitem>umsdos</systemitem>
       </para>
      </entry>
      <entry>
       <para>
        MS-DOS 上的 Unix：在标准 <filename>fat</filename> 文件系统之上应用，通过创建特殊文件获得 Unix 功能（权限、链接和长文件名）。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <systemitem>vfat</systemitem>
       </para>
      </entry>
      <entry>
       <para>
        虚拟 FAT：<literal>fat</literal> 文件系统的扩展（支持长文件名）。
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>
 <sect1 xml:id="sec.filesystems.lfs">
  <title>Linux 中对大型文件的支持</title>

  <para>
   最初，Linux 支持的最大文件大小为 2 GiB（2<superscript>31</superscript> 字节）。除非文件系统支持大型文件，否则 32 位系统上的最大文件大小为 2 GiB。
  </para>

  <para>
   目前，所有标准文件系统都具有 LFS（大型文件支持）功能，理论上可支持的最大文件大小为 2<superscript>63</superscript> 字节。<xref linkend="tab.filesystems.maxsize" xrefstyle="TableXRef"/>概述了 Linux 文件和文件系统的当前磁盘上格式的限制。表中的数字基于文件系统使用 4 KiB 块大小的假设得出，这是通用的标准。使用不同的块大小，结果也就不同。使用较稀疏的块时，<xref linkend="tab.filesystems.maxsize" xrefstyle="TableXRef"/>中的最大文件大小可能会大于文件系统的实际大小。
  </para>

  <note>
   <title>二进制倍数</title>
   <para>
    在此文档中：1024 字节 = 1 KiB；1024 KiB = 1 MiB；1024 MiB = 1 GiB；1024 GiB = 1 TiB；1024 TiB = 1 PiB；1024 PiB = 1 EiB（另请参见 <link xlink:href="http://physics.nist.gov/cuu/Units/binary.html"><citetitle>NIST：二进制倍数的前缀</citetitle></link>）。
   </para>
  </note>

  <table xml:id="tab.filesystems.maxsize">
   <title>文件和文件系统的最大大小（磁盘格式，4 KiB 块大小)</title>
   <tgroup cols="3">
    <colspec colnum="1" colname="1" colwidth="3334*"/>
    <colspec colnum="2" colname="2" colwidth="3334*"/>
    <colspec colnum="3" colname="3" colwidth="3334*"/>
    <thead>
     <row>
      <entry>
       <para>
        文件系统（4 KiB 块大小）
       </para>
      </entry>
      <entry>
       <para>
        最大文件系统大小
       </para>
      </entry>
      <entry>
       <para>
        最大文件大小
       </para>
      </entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <para>
        Btrfs
       </para>
      </entry>
      <entry>
       <para>
        16 EiB
       </para>
      </entry>
      <entry>
       <para>
        16 EiB
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        Ext3
       </para>
      </entry>
      <entry>
       <para>
        16 TiB
       </para>
      </entry>
      <entry>
       <para>
        2 TiB
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        Ext4
       </para>
      </entry>
      <entry>
       <para>
        1 EiB
       </para>
      </entry>
      <entry>
       <para>
        16 TiB
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        OCFS2（高可用性扩展中可使用的集群感知文件系统）
       </para>
      </entry>
      <entry>
       <para>
        16 TiB
       </para>
      </entry>
      <entry>
       <para>
        1 EiB
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        ReiserFS v3.6
       </para>
      </entry>
      <entry>
       <para>
        16 TiB
       </para>
      </entry>
      <entry>
       <para>
        1 EiB
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        XFS
       </para>
      </entry>
      <entry>
       <para>
        8 EiB
       </para>
      </entry>
      <entry>
       <para>
        8 EiB
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        NFSv2（客户端）
       </para>
      </entry>
      <entry>
       <para>
        8 EiB
       </para>
      </entry>
      <entry>
       <para>
        2 GiB
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        NFSv3/NFSv4（客户端）
       </para>
      </entry>
      <entry>
       <para>
        8 EiB
       </para>
      </entry>
      <entry>
       <para>
        8 EiB
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <important>
   <title>限制</title>
   <para>
    <xref linkend="tab.filesystems.maxsize" xrefstyle="TableXRef"/>介绍了有关磁盘上格式的限制。 Linux 内核自身的大小限制同样适用于其处理的文件和文件系统大小。下面介绍了这些限制：
   </para>
   <variablelist>
    <varlistentry>
     <term>文件大小</term>
     <listitem>
      <para>
       在 32 位系统上，文件不能超过 2 TiB（2<superscript>41</superscript> 字节）。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>文件系统大小</term>
     <listitem>
      <para>
       文件系统最大可以为 2<superscript>73</superscript> 个字节。但是，目前可用的硬件尚不会超出这一限制。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </important>
 </sect1>
 <sect1 xml:id="sect.filesystems.stor_limits">
  <title>Linux 内核储存的限制</title>

  <para>
   <xref linkend="tab.filesystems.stor_limits" xrefstyle="TableXRef"/> 总结了与 <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 相关联的储存的内核限制。
  </para>

  <table xml:id="tab.filesystems.stor_limits">
   <title>储存限制</title>
   <tgroup cols="2">
    <colspec colnum="1" colname="1" colwidth="5001*"/>
    <colspec colnum="2" colname="2" colwidth="5001*"/>
    <thead>
     <row>
      <entry>
       <para>
        储存功能
       </para>
      </entry>
      <entry>
       <para>
        限制
       </para>
      </entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <para>
        支持的 LUN 最大数量
       </para>
      </entry>
      <entry>
       <para>
        每个目标 16384 个 LUN。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        每一个单独 LUN 的最大路径数量
       </para>
      </entry>
      <entry>
       <para>
        默认情况下没有限制。每个路径视作一个常规 LUN。
       </para>
       <para>
        每个目标的 LUN 数量以及每个 HBA 的目标数量决定了实际的限制（光纤通道 HBA 为 16777215）。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        HBA 的最大数量
       </para>
      </entry>
      <entry>
       <para>
        不限。实际限制取决于系统的 PCI 槽的数量。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        每个操作系统使用 device-mapper-multipath 的最大路径数量（总计）
       </para>
      </entry>
      <entry>
       <para>
        大约为 1024。实际数量取决于设备号字符串的长度。它是 multipath-tools 中的一个编译时间变量，如果此限制会导致问题，则可提高其值。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        每一个块设备的最大大小
       </para>
      </entry>
      <entry>
       <para>
        最多 8 EiB。
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>
 <sect1 xml:id="sect.filesystems.trouble">
  <title>文件系统疑难解答</title>

  <para>
   本节说明文件系统的一些已知问题和可能的解决方案。
  </para>

  <sect2 xml:id="sect.filesystems.trouble.btrfs_volfull">
   <title>Btrfs 错误：设备上没有剩余空间</title>
   <para>
    使用 Btrfs 文件系统的根 (<filename>/</filename>) 分区停止接受数据。您收到错误<quote><literal>设备上没有剩余空间</literal></quote>。
   </para>
   <para>
    请参见下列各部分，了解有关此问题的可能原因和预防措施的信息。
   </para>
   <sect3 xml:id="sect.filesystems.trouble.btrfs_volfull.snapshots">
    <title>Snapper 快照使用的磁盘空间</title>
    <para>
     如果 Snapper 是针对 Btrfs 文件系统运行的，则<quote><literal>设备上没有剩余空间</literal></quote>问题通常是由于系统上做为快照储存的数据过多所致。
    </para>
    <para>
     您可以从 Snapper 中去除一些快照，不过，快照不会立即删除，可能不能释放您需要的空间容量。
    </para>
    <para>
     若要从 Snapper 中删除文件：
    </para>
    <procedure>
     <step>
      <para>
       打开一个终端控制台。
      </para>
     </step>
     <step>
      <para>
       在命令提示符处，输入 <command>btrfs filesystem show</command>，例如：
      </para>
<screen><prompt>tux &gt; </prompt>sudo btrfs filesystem show
Label: none uuid: 40123456-cb2c-4678-8b3d-d014d1c78c78
 Total devices 1 FS bytes used 20.00GB
 devid 1 size 20.00GB used 20.00GB path /dev/sda3</screen>
     </step>
     <step>
      <para>
       输入
      </para>
<screen>sudo btrfs fi balance start <replaceable>MOUNTPOINT</replaceable> -dusage=5</screen>
      <para>
       此命令会尝试将数据重新放置在空的或接近空的数据块中，从而允许收回空间并将其重新指派给元数据。此操作可能需要一些时间（1 TB 数据可能需要很多小时），不过，在此期间系统仍可以使用。
      </para>
     </step>
     <step>
      <para>
       列出 Snapper 中的快照。输入
      </para>
<screen>sudo snapper -c root list</screen>
     </step>
     <step>
      <para>
       从 Snapper 中删除一或多个快照。输入
      </para>
<screen>sudo snapper -c root delete <replaceable>SNAPSHOT_NUMBER(S)</replaceable></screen>
      <para>
       务必先删除最旧的快照。快照生成的时间越长，其占用的空间就越大。
      </para>
     </step>
    </procedure>
    <para>
     为了避免此问题发生，您可以更改 Snapper 清理算法。有关细节，请参见<xref linkend="sec.snapper.manage.metadata.cleanup"/>。控制快照清理的配置值为 <envar>EMPTY_*</envar>、<envar>NUMBER_*</envar> 和 <envar>TIMELINE_*</envar>。
    </para>
    <para>
     如果在文件系统磁盘上搭配使用 Snapper 和 Btrfs，建议您保留两倍于标准储存建议的磁盘空间容量。YaST 分区程序会自动在 Btrfs 储存建议中为根文件系统建议标准磁盘空间的两倍容量。
    </para>
   </sect3>
   <sect3 xml:id="sect.filesystems.trouble.btrfs_volfull.var">
    <title>日志、崩溃和缓存文件使用的磁盘空间</title>
    <para>
     如果系统磁盘填满了数据，您可以尝试从 <filename>/var/log</filename>、<filename>/var/crash</filename>、<filename>/var/lib/systemd/coredump</filename> 和 <filename>/var/cache</filename> 中删除文件。
    </para>
    <para>
     Btrfs <systemitem class="username">根</systemitem>文件系统子卷 <filename>/var/log</filename>、<filename>/var/crash</filename> 和 <filename>/var/cache</filename> 在正常运作情况下可能会使用所有可用的磁盘空间，此时将导致系统故障。为避免出现此状况，<phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 提供了 Btrfs 子卷配额支持。有关详细信息，请参见<xref linkend="sec.filesystems.major.btrfs.quota"/>。
    </para>
    <para>
     在测试和开发计算机上，尤其是当应用程序频繁崩溃时，您也可能想查看 <filename>/var/lib/systemd/coredump</filename>，内核转储就储存在其中。 
    </para>
   </sect3>
  </sect2>

  <sect2 xml:id="sect.filesystems.trouble.trim">
   <title>释放未使用的文件系统块</title>
   <para>
    在固态硬盘 (SSD) 和精简配置的卷中，释放未被文件系统使用的块会很有用。<phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 完全支持在支持<literal>取消映射</literal>或<literal>释放</literal>方法的所有文件系统上执行这些操作。
   </para>
   <para>
    建议通过运行 <phrase role="productname"><phrase os="sles">/sbin/wiper.sh</phrase></phrase> 来在 <command>SUSE Linux Enterprise Server</command> 上释放受支持文件系统。在运行此脚本之前，请务必阅读 <filename>/usr/share/doc/packages/hdparm/README.wiper</filename>。对于大多数桌面和服务器系统，每周释放一次便已足够。使用 <option>-o discard</option> 装入文件系统会降低性能，并可能对 SSD 的寿命造成负面影响，因此不建议使用此选项。
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec_filesystems_info">
  <title>其他信息</title>

  <para>
   上面介绍的每个文件系统项目都有自己的主页，可以在其中找到邮件列表信息、更多文档和常见问题：
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     Kernel.org 上的 Btrfs Wiki：<link xlink:href="https://btrfs.wiki.kernel.org/"/>
    </para>
   </listitem>
   <listitem>
    <para>
     E2fsprogs: Ext2/3/4 File System Utilities: <link xlink:href="http://e2fsprogs.sourceforge.net/"/>
    </para>
   </listitem>
   <listitem>
    <para>
     Introducing Ext3: <link xlink:href="http://www.ibm.com/developerworks/linux/library/l-fs7/"/>
    </para>
   </listitem>
   <listitem>
    <para>
     XFS：高性能日记文件系统：<link xlink:href="http://oss.sgi.com/projects/xfs/"/>
    </para>
   </listitem>
   <listitem>
    <para>
     OCFS2 Project（OCFS2 项目）：<link xlink:href="http://oss.oracle.com/projects/ocfs2/"/>
    </para>
   </listitem>
  </itemizedlist>

  <para>
   有关 Linux 文件系统的多部份全面教学课程，请参见 IBM developerWork 中的《<citetitle>Advanced File System Implementor’s Guide</citetitle>》（高级文件系统实施指南）<link xlink:href="https://www.ibm.com/developerworks/linux/library/l-fs/"/>。
  </para>

  <para>
   Wikipedia 项目上的“Comparison of File Systems”（文件系统比较，网址：<link xlink:href="http://en.wikipedia.org/wiki/Comparison_of_file_systems#Comparison"/>）中提供了对各种文件系统（不仅仅是 Linux 文件系统）更深入的比较。
  </para>
 </sect1>
</chapter>
