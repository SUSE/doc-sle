<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="64bit_issues.xml" version="5.0" xml:id="cha.64bit">
 <title>64 位系统环境中的 32 位和 64 位应用程序</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info><indexterm>
 <primary> 64 位 Linux</primary></indexterm> 
 <para>
  <phrase role="productname"><phrase os="sled">SUSE® Linux Enterprise Desktop</phrase></phrase> 可用于 64 位平台。但是这并不表示内含的所有应用程序都已移植到 64 位平台上。<phrase role="productname"><phrase os="sled">SUSE Linux Enterprise Desktop</phrase></phrase> 支持在 64 位系统环境中使用 32 位应用程序。本章简单介绍了如何在 64 位<phrase role="productname"><phrase os="sled"> SUSE Linux Enterprise Desktop</phrase></phrase> 平台上实现这种支持。它解释了如何执行 32 位应用程序（运行时支持）以及应该如何编译 32 位应用程序以使它们既可以在 32 位系统环境中运行，又可以在 64 位系统环境中运行。另外，您还可以了解有关内核 API 的信息和 32 位应用程序如何在 64 位内核下运行的解释。
 </para>
 <para>
  <phrase os="sled;osuse"><phrase role="productname"><phrase os="sled">用于 64 位平台 amd64 和 Intel 64 的 SUSE Linux Enterprise Desktop</phrase></phrase></phrase> 可让现有的 32 位应用程序<quote>无需额外配置</quote>。这种支持意味着您可以继续使用所需的 32 位应用程序，而无需等待对应的 64 位端口可用。
 </para>
 <sect1 xml:id="sec.64bit.runt">
  <title>运行时支持</title><indexterm>

  <primary> 64 位 Linux</primary>

  <secondary> 运行时支持</secondary></indexterm> 

  <important>
   <title>应用程序版本之间的冲突</title>
   <para>
    如果某个应用程序在 32 位和 64 位环境中都可用，则两个版本的并行安装必定会导致出现问题。在这种情况下，在两个版本中选一个，然后安装并使用这一版本。
   </para>
   <para>
    此规则的一个例外是 PAM（可插入身份验证模块）。<phrase role="productname"><phrase os="sled">SUSE Linux Enterprise Desktop</phrase></phrase> 在身份验证过程中使用 PAM 充当用户和应用程序之间的中间层。在另外还运行 32 位应用程序的 64 位操作系统上，始终需要安装两个版本的 PAM 模块。
   </para>
  </important>

  <para>
   若要正确执行，每个应用程序都需要一系列库。不巧的是，这些库的 32 位和 64 位版本的名称是相同的。必须通过另一种方法对它们加以区分。
  </para>

  <para>
   为了保持与 32 位版本的兼容性，这些库在系统中的储存位置与在 32 位环境中相同。在 32 位和 64 位环境中，<filename>libc.so.6</filename> 的 32 位版本都位于 <filename>/lib/libc.so.6</filename> 下。
  </para>

  <para>
   所有 64 位库和对象文件都位于名为 <filename>lib64</filename> 的目录中。通常预计会在 <filename>/lib</filename> 和 <filename>/usr/lib</filename> 下找到的 64 位对象文件，现在可以在 <filename>/lib64</filename> 和 <filename>/usr/lib64</filename> 下找到。这意味着 <filename>/lib</filename> 和 <filename>/usr/lib</filename> 下有储存 32 位库的空间，因此两个版本的文件名都可以保持不变。
  </para>

  <para>
   如果 32 位 <filename>/lib</filename> 目录的子目录包含的数据内容不依赖于字大小，则不移动这些目录。此方案符合 LSB（Linux 标准库）和 FHS（文件系统层次标准）。
  </para>
 </sect1>
 <sect1 xml:id="sec.64bit.devel">
  <title>软件开发</title><indexterm>

  <primary> 64 位 Linux</primary>

  <secondary>软件开发</secondary></indexterm> 

  

  <para>
   使用 biarch 开发工具链既可以生成 32 位对象，也可以生成 64 位对象。Biarch 开发工具链允许生成 32 位和 64 位对象。在几乎所有平台上，默认设置都是编译 64 位对象。如果使用特殊的标志，则可以生成 32 位对象。特殊标志是 <option>-m32</option>（对于 GCC）。用于 binutils 的标志是依赖于体系结构的，但 GCC 将正确的标志传送到链接器和汇编器。Biarch 开发工具链当前可用于 amd64（支持 x86 和 amd64 指令的开发）、z Systems 和 POWER。32 位对象通常是在 POWER 平台上创建的。<literal>-m64</literal> 标志用于生成 64 位对象。
  </para>

  <para os="sled">
   Biarch 开发工具链允许生成 32 位和 64 位对象。默认为编译 64 位对象。通过使用特殊标志也可以生成 32 位对象。对于 GCC，此特殊标志是 <option>-m32</option>。
  </para>

  <para>
   必须以一种独立于体系结构的形式编写所有头文件。安装的 32 位和 64 位库必须具有与安装的头文件匹配的 API（应用程序编程接口）。普通 <phrase role="productname"><phrase os="sled">SUSE Linux Enterprise Desktop</phrase></phrase> 环境是根据此原则设计的。如果是手动更新的库，请自行解决此问题。
  </para>
 </sect1>
 <sect1 xml:id="sec.64bit.biarch">
  <title>Biarch 平台上的软件编译</title>

  <para>
   若要在 Biarch 体系结构上为其他体系结构开发二进制代码，则必须另外安装用于第二个体系结构的各个库。这些包称为 <systemitem class="resource">rpmname-32bit</systemitem>。您还需要 <systemitem class="resource">rpmname-devel</systemitem> 包中各自的标题和库以及 <systemitem class="resource">rpmname-devel-32bit</systemitem> 中用于第二个体系结构的开发库。
  </para>

  

  

  <para>
   大多数开放源代码程序使用基于 <command>autoconf</command> 的程序配置。若要使用 <command>autoconf</command> 配置第二个体系结构的程序，请通过运行带有附加环境变量的 <command>configure</command> 脚本覆盖 <command>autoconf</command> 的常规编译器和链接器设置。
  </para>

  <para>
   以下示例代表的是使用 x86 作为第二个体系结构的 x86_64 系统。 
  </para>

  <procedure>
   <step>
    <para>
     使用 32 位编译器：
    </para>
<screen>CC="gcc -m32"</screen>
   </step>
   <step>
    <para>
     指示链接器处理 32 位对象（始终使用 <command>gcc</command> 作为链接器前端）：
    </para>
<screen>LD="gcc -m32"</screen>
   </step>
   <step>
    <para>
     设置组装器生成 32 位对象：
    </para>
<screen>AS="gcc -c -m32"</screen>
   </step>
   <step>
    <para>
     指定链接器标志，如 32 位库的位置，例如：
    </para>
<screen>LDFLAGS="-L/usr/lib"</screen>
   </step>
   <step>
    <para>
     指定 32 位对象代码库的位置：
    </para>
<screen>--libdir=/usr/lib</screen>
   </step>
   <step>
    <para>
     指定 32 位 X 库的位置：
    </para>
<screen>--x-libraries=/usr/lib</screen>
   </step>
  </procedure>

  <para>
   并不是每个程序都需要这些变量。根据各个程序对这些变量进行调整。
  </para>

  <para>
   在 86_64 上编译本机 32 位应用程序的示例 <command>configure</command> 调用如下所示：
  </para>

<screen>CC="gcc -m32"
LDFLAGS="-L/usr/lib;"
./configure --prefix=/usr --libdir=/usr/lib --x-libraries=/usr/lib
make
make install</screen>
 </sect1>
 <sect1 xml:id="sec.64bit.kernel">
  <title>内核规范</title><indexterm>

  <primary> 64 位 Linux</primary>

  <secondary> 内核规范</secondary></indexterm> 

  <para>
   适用于 AMD 64/Intel 64 的 64 位内核提供了 64 位和 32 位两种内核 ABI（应用程序二进制接口）。后者与对应的 32 位内核的 ABI 相同。这意味着 32 位应用程序可以以与 32 位内核交流的相同方式与 64 位内核进行交流。
  </para>

  <para>
   64 位内核系统调用的 32 位仿真不支持系统程序使用的某些 API。这取决于平台。因此，必须对 <command>lspci</command> 之类的一些应用程序进行编译。￼
  </para>

  <para>
   64 位内核只能装载专门为此内核编译的 64 位内核模块。不能使用 32 位内核模块。
  </para>

  <tip>
   <title>内核可装载模块</title>
   <para>
    某些应用程序需要单独的内核可装载模块。如果要在 64 位系统环境中使用此类 32 位应用程序，请与此应用程序的提供商和 SUSE 联系以确保内核可装载模块的 64 位版本和内核 API 的 32 位编译版本可用于此模块。
   </para>
  </tip>
 </sect1>
</chapter>
