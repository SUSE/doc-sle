<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="systemd.xml" version="5.0" xml:id="cha.systemd">

 <title>Der Daemon <systemitem class="daemon">systemd</systemitem></title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>Ja</dm:translation>
  </dm:docmanager>
 </info>
 <para>
  Das Programm <systemitem class="daemon">systemd</systemitem> trägt die Prozess-ID 1. Hiermit wird das System in der erforderlichen Form initialisiert. <systemitem class="daemon">systemd</systemitem> wird direkt vom Kernel gestartet und widersteht dem Signal 9, das in der Regel Prozesse beendet. Alle anderen Programme werden entweder direkt von systemd oder von einem seiner untergeordneten Prozesse gestartet.
 </para>
 <para>
  Ab <phrase role="productname"><phrase os="sled">SUSE Linux Enterprise Desktop</phrase></phrase> 12 ersetzt systemd den beliebten System V-init-Daemon. <systemitem class="daemon">systemd</systemitem> ist mit System V init uneingeschränkt kompatibel (init-Skripten werden unterstützt). Einer der wichtigsten Vorteile von systemd ist die deutliche Beschleunigung des Bootvorgangs, da die Dienststarts konsequent parallel ausgeführt werden. Darüber hinaus startet systemd einen Dienst nur dann, wenn er tatsächlich benötigt wird. Deamons werden nicht in jedem Fall beim Booten gestartet, sondern erst dann, wenn sie erstmalig benötigt werden. systemd unterstützt außerdem Kernel-Steuergruppen (cgroups), das Erstellen von Snapshots, das Wiederherstellen des Systemstatus und vieles mehr. Weitere Informationen finden Sie in <link xlink:href="http://www.freedesktop.org/wiki/Software/systemd/"/>.
 </para>

 <sect1 xml:id="sec.boot.systemd.concept">
  <title>Das Konzept von &amp;systemd</title>

  <para>
   In diesem Abschnitt wird das Konzept von systemd eingehend beleuchtet.
  </para>

  <sect2 xml:id="sec.boot.systemd.whatissystemd">
   <title>Grundlagen von systemd</title>
   <para>
    systemd ist ein System- und Sitzungsmanager für Linux und ist mit System V- und LSB-init-Skripts kompatibel. Die wichtigsten Funktionen sind:
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>
      Konsequente Parallelisierung
     </para>
    </listitem>
    <listitem>
     <para>
      Starten von Diensten per Socket- und D-Bus-Aktivierung
     </para>
    </listitem>
    <listitem>
     <para>
      Starten der Daemons bei Bedarf
     </para>
    </listitem>
    <listitem>
     <para>
      Verfolgen der Prozesse, die Linux-cgroups nutzen
     </para>
    </listitem>
    <listitem>
     <para>
      Unterstützung für das Erstellen von Snapshots und Wiederherstellen des Systemstatus
     </para>
    </listitem>
    <listitem>
     <para>
      Einhängepunkte und Automount-Punkte
     </para>
    </listitem>
    <listitem>
     <para>
      Ausgereifte Dienststeuerlogik auf der Basis der Transaktionsabhängigkeiten
     </para>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 xml:id="sec.boot.systemd.unitfile">
   <title>Unit-Datei</title>
   <para>
    Eine Unit-Konfigurationsdatei enthält Informationen zu einem Dienst, Socket, Gerät, Einhängepunkt, Automount-Punkt, einer Auslagerungsdatei oder Partition, einem Startziel, einem überwachten Dateisystempfad, einem von systemd gesteuerten und überwachten Zeitgeber, einem Snapshot eines temporären Systemstatus, einem Ressourcenverwaltungs-Slice oder einer Gruppe extern erstellter Prozesse. <quote>Unit-Datei</quote> ist in systemd ein generischer Term für Folgendes:
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <formalpara>
      <title>Dienst</title>
      <para>
       Informationen zu einem Prozess (z. B. Ausführung eines Daemon); Datei endet auf .service
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Ziele</title>
      <para>
       Fassen Units zu Gruppen zusammen bzw. fungieren als Synchronisierungspunkte beim Starten; Datei endet auf .target
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Sockets</title>
      <para>
       Informationen zu einem IPC- oder Netzwerk-Socket oder einem Dateisystem-FIFO, für die socketbasierte Aktivierung (wie <systemitem class="daemon">inetd</systemitem>); Datei endet auf .socket
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Pfad</title>
      <para>
       Dient als Auslöser von anderen Units (z. B. Ausführen eines Dienstes, wenn Dateien geändert werden); Datei endet auf .path
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Zeitgeber</title>
      <para>
       Informationen zu einem gesteuerten Zeitgeber für die zeitgeberbasierte Aktivierung; Datei endet auf .timer
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Einhängepunkt</title>
      <para>
       In der Regel automatisch durch den fstab-Generator erzeugt; Datei endet auf .mount
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Automount-Punkt</title>
      <para>
       Informationen zu einem Dateisystem-Automount-Punkt; Datei endet auf .automount
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Swap</title>
      <para>
       Informationen zu einem Auslagerungsgerät oder einer Auslagerungsdatei für das Arbeitsspeicher-Paging; Datei endet auf .swap
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Gerät</title>
      <para>
       Informationen zu einer Geräte-Unit in der Geräte-Baumstruktur sysfs/udev(7); Datei endet auf .device
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Bereich/Slice</title>
      <para>
       Konzept für die hierarchische Verwaltung von Ressourcen einer Prozessgruppe; Datei endet auf .scope/.slice
      </para>
     </formalpara>
    </listitem>
   </itemizedlist>
   <para>
    Weitere Informationen zu systemd.unit finden Sie unter <link xlink:href="http://www.freedesktop.org/software/systemd/man/systemd.unit.html"/>.
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.boot.systemd.basics">
  <title>Grundlegende Verwendung</title>

  <para>
   Im System V-init-System werden Dienste mit mehreren Kommandos verarbeitet – mit init-Skripten, <command>insserv</command>, <command>telinit</command> und anderen. systemd erleichtert die Dienstverwaltung, da ein einziges Kommando die meisten Dienstverarbeitungsaufgaben abdeckt: <command>systemctl</command>. Hierbei gilt die Syntax <quote>Kommando plus Subkommando</quote> wie bei <command>git</command> oder <command>zypper</command>:
  </para>

<screen>systemctl <replaceable>[general OPTIONS]</replaceable> <replaceable>subcommand</replaceable> <replaceable>[subcommand OPTIONS]</replaceable></screen>

  <para>
   Vollständige Anweisungen finden Sie in <command>man 1 systemctl</command>.
  </para>

  <tip>
   <title>Terminalausgabe und Bash-Vervollständigung</title>
   <para>
    Wenn die Ausgabe an ein Terminal geht (und nicht an eine Pipe oder Datei usw.), senden die systemd-Kommandos standardmäßig eine ausführliche Ausgabe an einen Pager. Mit der Option <option>--no-pager</option> deaktivieren Sie den Paging-Modus.
   </para>
   <para>
    systemd unterstützt außerdem die Bash-Vervollständigung. Hierbei geben Sie die ersten Buchstaben eines Subkommandos ein und drücken dann <keycap function="tab"/>, um es automatisch zu vervollständigen. Diese Funktion ist nur in der <systemitem>Bash</systemitem>-Shell verfügbar und das Paket <systemitem class="resource">bash-completion</systemitem> muss installiert sein.
   </para>
  </tip>

  <sect2 xml:id="sec.boot.systemd.basics.services">
   <title>Verwalten von Diensten auf einem laufenden System</title>
   <para>
    Die Subkommandos zum Verwalten der Dienste sind mit den entsprechenden Kommandos in System V-init identisch (<command>start</command>, <command>stop</command> usw.). Die allgemeine Syntax für Dienstverwaltungskommandos lautet wie folgt:
   </para>
   <variablelist>
    <varlistentry>
     <term>systemd</term>
     <listitem>
<screen>systemctl reload|restart|start|status|stop|<replaceable>...</replaceable> <replaceable>&lt;my_service(s)&gt;</replaceable></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>System V-init</term>
     <listitem>
<screen>rc<replaceable>&lt;my_service(s)&gt;</replaceable> reload|restart|start|status|stop|<replaceable>...</replaceable></screen>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Mit systemd können Sie mehrere Dienste gleichzeitig verwalten. Im Gegensatz zu System V-init, bei dem die init-Skripts einzeln nacheinander ausgeführt werden, führen Sie ein einziges Kommando aus, beispielsweise:
   </para>
<screen>systemctl start <replaceable>&lt;my_1st_service&gt;</replaceable> <replaceable>&lt;my_2nd_service&gt;</replaceable></screen>
   <para>
    Wenn alle auf dem System verfügbaren Dienste aufgelistet werden sollen:
   </para>
<screen>systemctl list-unit-files --type=service</screen>
   <para>
    Die folgende Tabelle zeigt die wichtigsten Dienstverwaltungskommandos für systemd und System V-init:
   </para>
   <table rowsep="1">
    <title>Befehle zur Diensteverwaltung</title>
    <tgroup cols="3">
     <colspec colnum="1" colname="1" colwidth="50*"/>
     <colspec colnum="2" colname="2" colwidth="30*"/>
     <colspec colnum="3" colname="3" colwidth="20*"/>
     <thead>
      <row>
       <entry colname="1">
        <para>
         Aufgabe
        </para>
       </entry>
       <entry colname="2">
        <para>
         systemd-Kommando
        </para>
       </entry>
       <entry colname="3">
        <para>
         System V-init-Kommando
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Starten</title>
         <para/>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>start</screen>
       </entry>
       <entry colname="3">
<screen>start</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Stoppen</title>
         <para/>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>stop</screen>
       </entry>
       <entry colname="3">
<screen>stop</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Neu starten</title>
         <para>
          Fährt Dienste herunter und startet sie dann neu. Wenn ein Dienst noch nicht ausgeführt wird, wird er gestartet.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>restart</screen>
       </entry>
       <entry colname="3">
<screen>restart</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Bedingt neu starten</title>
         <para>
          Startet Dienste neu, wenn sie derzeit ausgeführt werden. Keine Auswirkung bei Diensten, die nicht ausgeführt werden.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>try-restart</screen>
       </entry>
       <entry colname="3">
<screen>try-restart</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Neu laden</title>
         <para>
          Weist die Dienste an, die Konfigurationsdateien neu zu laden ohne die laufenden Vorgänge zu unterbrechen. Anwendungsbeispiel: Weisen Sie Apache an, eine bearbeitete Konfigurationsdatei <filename>httpd.conf</filename> neu zu laden. Nicht alle Dienste unterstützen das Neuladen.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>reload</screen>
       </entry>
       <entry colname="3">
<screen>reload</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Neu laden oder neu starten</title>
         <para>
          Lädt Dienste neu, wenn das Neuladen unterstützt wird; ansonsten werden die Dienste neu gestartet. Wenn ein Dienst noch nicht ausgeführt wird, wird er gestartet.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>reload-or-restart</screen>
       </entry>
       <entry colname="3">
<screen>n/a</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Bedingt neu laden oder neu starten</title>
         <para>
          Lädt Dienste neu, wenn das Neuladen unterstützt wird; ansonsten werden die Dienste neu gestartet, wenn sie derzeit ausgeführt werden. Keine Auswirkung bei Diensten, die nicht ausgeführt werden.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>reload-or-try-restart</screen>
       </entry>
       <entry colname="3">
<screen>n/a</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Ausführliche Statusinformationen abrufen</title>
         <para>
          Zeigt Informationen zum Dienststatus. Das Kommando <systemitem class="daemon">systemd</systemitem> bietet Details wie Beschreibung, ausführbare Datei, Status, cgroup und zuletzt durch den Dienst ausgegebene Meldungen (siehe <xref linkend="sec.boot.systemd.basics.services_debugging"/>). Die Detailtiefe bei System V-init ist von Dienst zu Dienst unterschiedlich.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>status</screen>
       </entry>
       <entry colname="3">
<screen>status</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Kurze Statusinformationen abrufen</title>
         <para>
          Gibt an, ob Dienste aktiv sind oder nicht.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>is-active</screen>
       </entry>
       <entry colname="3">
<screen>status</screen>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>

  <sect2 xml:id="sec.boot.systemd.basics.services_enabling">
   <title>Dienste dauerhaft aktivieren/deaktivieren</title>
   <para>
    Mit den Dienstverwaltungskommandos im vorangegangenen Abschnitt können Sie die Dienste für die aktuelle Sitzung bearbeiten. Mit systemd können Sie Dienste außerdem dauerhaft aktivieren oder deaktivieren, so dass sie entweder automatisch bei Bedarf gestartet werden oder gar nicht verfügbar sind. Sie können dies mithilfe von YaST oder über die Kommandozeile tun.
   </para>
   <sect3 xml:id="sec.boot.systemd.basics.services_enabling.cmd">
    <title>Aktivieren/Deaktivieren von Diensten über die Kommandozeile</title>
    <para>
     Die folgende Tabelle zeigt die wichtigsten Aktivierungs- und Deaktivierungskommandos für systemd und System V-init:
    </para>
    <important>
     <title>Service starten</title>
     <para>
      Wenn ein Dienst über die Kommandozeile aktiviert wird, wird er nicht automatisch gestartet. Der Dienst wird beim nächsten Systemstart oder bei der nächsten Änderung des Runlevels/Ziels gestartet. Soll ein Dienst nach dem Aktivieren sofort gestartet werden, führen Sie explizit <command>systemctl start <replaceable>&lt;mein_Dienst&gt;</replaceable>.</command> oder <command>rc <replaceable>&lt;mein_Dienst&gt;</replaceable> start</command> aus.
     </para>
    </important>
    <table rowsep="1">
     <title>Kommandos zum Aktivieren und Deaktivieren von Diensten</title>
     <tgroup cols="3">
      <colspec colnum="1" colname="1" colwidth="32*"/>
      <colspec colnum="2" colname="2" colwidth="40*"/>
      <colspec colnum="3" colname="3" colwidth="28*"/>
      <thead>
       <row>
        <entry colname="1">
         <para>
          Aufgabe
         </para>
        </entry>
        <entry colname="2">
         <para>
          <systemitem class="daemon">systemd-Kommando</systemitem>
         </para>
        </entry>
        <entry colname="3">
         <para>
          System V-init-Kommando
         </para>
        </entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Aktivieren</title>
          <para/>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl enable <replaceable>&lt;mein(e)_Dienst(e)&gt;</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>insserv <replaceable>&lt;mein(e)_Dienst(e)&gt;</replaceable></command>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Deaktivieren</title>
          <para/>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl disable <replaceable>&lt;mein(e)_Dienst(e)&gt;</replaceable>.service</command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>insserv -r<replaceable> &lt;mein(e)_Dienst(e)&gt;</replaceable></command>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Überprüfen</title>
          <para>
           Zeigt an, ob ein Dienst aktiviert ist oder nicht.
          </para>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl is-enabled <replaceable>&lt;mein_Dienst&gt;</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/v
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Erneut aktivieren</title>
          <para>
           Ähnlich wie beim Neustarten eines Diensts, deaktiviert dieses Kommando einen Dienst und aktiviert ihn dann wieder. Nützlich, wenn ein Dienst mit den Standardeinstellungen erneut aktiviert werden soll.
          </para>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl reenable <replaceable>&lt;mein_Dienst&gt;</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/v
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Maskierung</title>
          <para>
           Nach dem <quote>Deaktivieren</quote> eines Dienstes kann er weiterhin manuell aktiviert werden. Soll ein Dienst vollständig deaktiviert werden, maskieren Sie ihn. Mit Vorsicht verwenden.
          </para>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl mask <replaceable>&lt;mein_Dienst&gt;</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/v
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Demaskieren</title>
          <para>
           Ein maskierter Dienst kann erst dann wieder genutzt werden, wenn er demaskiert wurde.
          </para>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl unmask <replaceable>&lt;mein_Dienst&gt;</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/v
         </para>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.boot.systemd.boot">
  <title>Systemstart und Zielverwaltung</title>

  <para>
   Der gesamte Vorgang des Startens und Herunterfahrens des Systems wird von systemd verwaltet. Vor diesem Hintergrund kann der Kernel als Hintergrundprozess betrachtet werden, der alle anderen Prozesse verwaltet und die CPU-Zeit sowie den Hardwarezugriff entsprechend den Anforderungen anderer Programme anpasst.
  </para>

  <sect2 xml:id="sec.boot.systemd.targets">
   <title>Ziele im Vergleich zu Runlevels</title>
   <para>
    Bei System V-init wurde das System in ein sogenanntes <quote>Runlevel</quote> gebootet. Ein Runlevel definiert, wie das System gestartet wird und welche Dienste im laufenden System verfügbar sind. Die Runlevels sind numeriert. Die bekanntesten Runlevels sind <literal>0</literal> (System herunterfahren), <literal>3</literal> (Mehrbenutzermodus mit Netzwerk) und <literal>5</literal> (Mehrbenutzermodus mit Netzwerk und Anzeigemanager).
   </para>
   <para>
    systemd führt mit den sogenannten <quote>Ziel-Units</quote> ein neues Konzept ein. Dennoch bleibt die Kompatibilität mit dem Runlevel-Konzept uneingeschränkt erhalten. Die Ziel-Units tragen Namen statt Zahlen und erfüllen bestimmte Zwecke. Mit den Zielen <systemitem>local-fs.target</systemitem> und <systemitem>swap.target</systemitem> werden beispielsweise lokale Dateisysteme und Auslagerungsbereiche eingehängt.
   </para>
   <para>
    Das Ziel <systemitem>graphical.target</systemitem> stellt ein Mehrbenutzersystem mit Netzwerk sowie Anzeigemanager-Funktionen bereit und entspricht Runlevel 5. Komplexe Ziele wie <systemitem>graphical.target</systemitem> fungieren als <quote>Metaziele</quote>, in denen eine Teilmenge anderer Ziele vereint ist. Mit systemd können Sie problemlos vorhandene Ziele kombinieren und so benutzerdefinierte Ziele bilden. Damit bietet dieses Kommando eine hohe Flexibilität.
   </para>
   <para>
    Die nachfolgende Liste zeigt die wichtigsten systemd-Ziel-Units. Eine vollständige Liste finden Sie in <command>man 7 systemd.special</command>.
   </para>
   <variablelist>
    <title>Ausgewählte systemd-Ziel-Units</title>
    <varlistentry>
     <term><systemitem>default.target</systemitem>
     </term>
     <listitem>
      <para>
       Das Ziel, das standardmäßig gebootet wird. Kein <quote>reales</quote> Ziel, sondern ein symbolischer Link zu einem anderen Ziel wie <systemitem>graphic.target</systemitem>. Kann über YaST dauerhaft geändert werden (siehe <xref linkend="sec.boot.runlevel.edit"/>). Soll das Ziel für eine einzige Sitzung geändert werden, geben Sie die Kernel-Kommandozeilenoption <literal>systemd.unit=<replaceable>&lt;mein_Ziel&gt;.target</replaceable></literal> an der Boot-Eingabeaufforderung ein.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>emergency.target</systemitem>
     </term>
     <listitem>
      <para>
       Startet eine Notfall-Shell über die Konsole. Dieses Kommando darf nur an der Boot-Eingabeaufforderung im Format <literal>systemd.unit=emergency.target</literal> verwendet werden.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>graphical.target</systemitem>
     </term>
     <listitem>
      <para>
       Startet ein System mit Netzwerk, Mehrbenutzerunterstützung und Anzeigemanager.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>halt.target</systemitem>
     </term>
     <listitem>
      <para>
       Fährt das System herunter.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mail-transfer-agent.target</systemitem>
     </term>
     <listitem>
      <para>
       Startet alle Dienste, die zum Senden und Empfangen von Mails erforderlich sind.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>multi-user.target</systemitem>
     </term>
     <listitem>
      <para>
       Startet ein Mehrbenutzersystem mit Netzwerk.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>reboot.target</systemitem>
     </term>
     <listitem>
      <para>
       Bootet das System neu.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>rescue.target</systemitem>
     </term>
     <listitem>
      <para>
       Startet ein Einzelbenutzersystem ohne Netzwerk.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Damit die Kompatibilität mit dem Runlevel-System von System V-init gewährleistet bleibt, bietet systemd besondere Ziele mit der Bezeichnung <literal>runlevel<replaceable>X</replaceable>.target</literal>, denen die entsprechenden, mit <replaceable>X</replaceable> numerierten Runlevels zugeordnet sind.
   </para>
   <para>
    Mit dem Kommando <command>systemctl get-default</command> ermitteln Sie das aktuelle Ziel.
   </para>
   <table rowsep="1">
    <title>System V-Runlevels und <systemitem class="daemon">systemd</systemitem>-Ziel-Units</title>
    <tgroup cols="3">
     <colspec colnum="1" colname="1" colwidth="20*"/>
     <colspec colnum="2" colname="2" colwidth="40*"/>
     <colspec colnum="3" colname="3" colwidth="40*"/>
     <thead>
      <row>
       <entry>
        <para>
         System V-Runlevel
        </para>
       </entry>
       <entry>
        <para>
         <systemitem class="daemon">systemd</systemitem>-Ziel
        </para>
       </entry>
       <entry>
        <para>
         Beschreibung
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         0
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel0.target</systemitem>, <systemitem>halt.target</systemitem>, <systemitem>poweroff.target</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         System herunterfahren
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         1, S
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel1.target</systemitem>, <systemitem>rescue.target</systemitem>,
        </para>
       </entry>
       <entry>
        <para>
         Einzelbenutzermodus
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         2
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel2.target</systemitem>, <systemitem>multi-user.target</systemitem>,
        </para>
       </entry>
       <entry>
        <para>
         Lokaler Mehrbenutzermodus ohne entferntes Netzwerk
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         3
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel3.target</systemitem>, <systemitem>multi-user.target</systemitem>,
        </para>
       </entry>
       <entry>
        <para>
         Mehrbenutzer-Vollmodus mit Netzwerk
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         4
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel4.target</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         Nicht verwendet/benutzerdefiniert
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         5
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel5.target</systemitem>, <systemitem>graphical.target</systemitem>,
        </para>
       </entry>
       <entry>
        <para>
         Mehrbenutzer-Vollmodus mit Netzwerk und Anzeige-Manager
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         6
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel6.target</systemitem>, <systemitem>reboot.target</systemitem>,
        </para>
       </entry>
       <entry>
        <para>
         Systemneustart
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <important>
    <title>systemd ignoriert <filename>/etc/inittab</filename></title>
    <para>
     Die Runlevels in einem System V-init-System werden in <filename>/etc/inittab</filename> konfiguriert. Bei systemd wird diese Konfiguration <emphasis>nicht</emphasis> verwendet. Weitere Anweisungen zum Erstellen eines bootfähigen Ziels finden Sie unter <xref linkend="sec.boot.systemd.custom.targets"/>.
    </para>
   </important>
   <sect3 xml:id="sec.boot.systemd.targets.commands">
    <title>Kommandos zum Ändern von Zielen</title>
    <para>
     Mit den folgenden Kommandos arbeiten Sie mit den Ziel-Units:
    </para>
    <informaltable rowsep="1">
     <tgroup cols="3">
      <colspec colnum="1" colname="1" colwidth="20*"/>
      <colspec colnum="2" colname="2" colwidth="50*"/>
      <colspec colnum="3" colname="3" colwidth="30*"/>
      <thead>
       <row>
        <entry colname="1">
         <para>
          Aufgabe
         </para>
        </entry>
        <entry colname="2">
         <para>
          systemd-Kommando
         </para>
        </entry>
        <entry colname="3">
         <para>
          System V-init-Kommando
         </para>
        </entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry colname="1">
         <para>
          Aktuelles Ziel/Runlevel ändern
         </para>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl isolate </command><replaceable>&lt;mein_Ziel&gt;</replaceable>.target
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>telinit</command> <replaceable>X</replaceable>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          Zum standardmäßigen Ziel/Runlevel wechseln
         </para>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl default</command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/v
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          Aktuelles Ziel/Runlevel abrufen
         </para>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl list-units --type=target</command>
         </para>
         <para>
          Bei systemd sind in der Regel mehrere Ziele aktiv. Mit diesem Kommando werden alle derzeit aktiven Ziele aufgelistet.
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>who -r</command>
         </para>
         <para>
          oder
         </para>
         <para>
          <command>runlevel</command>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          Standard-Runlevel dauerhaft ändern
         </para>
        </entry>
        <entry colname="2">
         <para>
          Verwenden Sie die Dienste-Verwaltung, oder führen Sie das folgende Kommando aus:
         </para>
         <para>
          <command>ln -sf /usr/lib/systemd/system/</command><replaceable>&lt;mein_Ziel&gt;</replaceable>.target /etc/systemd/system/default.target
         </para>
        </entry>
        <entry colname="3">
         <para>
          Verwenden Sie die Dienste-Verwaltung, oder ändern Sie die Zeile
         </para>
         <para>
          <command>id:</command><replaceable>X</replaceable>:initdefault:
         </para>
         <para>
          in <filename>/etc/inittab</filename>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          Standard-Runlevel für den aktuellen Bootprozess ändern
         </para>
        </entry>
        <entry colname="2">
         <para>
          Geben Sie an der Boot-Eingabeaufforderung die folgende Option ein:
         </para>
         <para>
          <command>systemd.unit=</command><replaceable>&lt;mein_Ziel&gt;</replaceable>.target
         </para>
        </entry>
        <entry colname="3">
         <para>
          Geben Sie an der Boot-Eingabeaufforderung die gewünschte Runlevel-Nummer ein.
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          Abhängigkeiten für ein Ziel/Runlevel anzeigen
         </para>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl show -p "Requires"</command> <replaceable>&lt;mein_Ziel&gt;</replaceable>.target
         </para>
         <para>
          <command>systemctl show -p "Wants" </command><replaceable>&lt;mein_Ziel&gt;</replaceable>.target
         </para>
         <para>
          <quote>Requires</quote> (Benötigt) zeigt eine Liste der harten Abhängigkeiten (die in jedem Fall aufgelöst werden müssen), <quote>Wants</quote> (Erwünscht) dagegen eine Liste der weichen Abhängigkeiten (die nach Möglichkeit aufgelöst werden).
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/v
         </para>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </sect3>
  </sect2>

  <sect2 xml:id="sec.boot.systemd.debug">
   <title>Fehlersuche beim Systemstart</title>
   <para>
    systemd bietet eine Möglichkeit, den Systemstartvorgang zu analysieren. Auf einen Blick können Sie die Liste der Dienste mit dem jeweiligen Status prüfen (ohne durch <filename>/varlog/</filename> blättern zu müssen). Mit systemd können Sie zudem den Startvorgang scannen und so ermitteln, wie lang das Starten der einzelnen Dienste dauert.
   </para>
   <sect3 xml:id="sec.boot.systemd.debug.review">
    <title>Prüfen des Startvorgangs der Dienste</title>
    <para>
     Mit dem Kommando <command>systemctl</command> erzeugen Sie eine Liste aller Dienste, die seit dem Booten des Systems gestartet wurden. Hier werden alle aktiven Dienste wie im nachstehenden (gekürzten) Beispiel aufgeführt. Mit <command>systemctl status <replaceable>&lt;mein_Dienst&gt;</replaceable></command> erhalten Sie weitere Informationen zu einem bestimmten Dienst.
    </para>
    <example>
     <title>Liste der aktiven Dienste</title>
<screen><prompt>root # </prompt>systemctl
UNIT                        LOAD   ACTIVE SUB       JOB DESCRIPTION
[...]
iscsi.service               loaded active exited    Login and scanning of iSC+
kmod-static-nodes.service   loaded active exited    Create list of required s+
libvirtd.service            loaded active running   Virtualization daemon
nscd.service                loaded active running   Name Service Cache Daemon
ntpd.service                loaded active running   NTP Server Daemon
polkit.service              loaded active running   Authorization Manager
postfix.service             loaded active running   Postfix Mail Transport Ag+
rc-local.service            loaded active exited    /etc/init.d/boot.local Co+
rsyslog.service             loaded active running   System Logging Service
[...]
LOAD   = Reflects whether the unit definition was properly loaded.
ACTIVE = The high-level unit activation state, i.e. generalization of SUB.
SUB    = The low-level unit activation state, values depend on unit type.

161 loaded units listed. Pass --all to see loaded but inactive units, too.
To show all installed unit files use 'systemctl list-unit-files'.</screen>
    </example>
    <para>
     Soll die Ausgabe auf Dienste beschränkt werden, die nicht gestartet werden konnten, geben Sie die Option <option>--failed</option> an:
    </para>
    <example>
     <title>Liste der fehlerhaften Dienste</title>
<screen><prompt>root # </prompt>systemctl --failed
UNIT                   LOAD   ACTIVE SUB    JOB DESCRIPTION
apache2.service        loaded failed failed     apache
NetworkManager.service loaded failed failed     Network Manager
plymouth-start.service loaded failed failed     Show Plymouth Boot Screen

[...]</screen>
    </example>
   </sect3>
   <sect3 xml:id="sec.boot.systemd.debug.time">
    <title>Fehlersuche für die Startzeit</title>
    <para>
     Mit dem Kommando <command>systemd-analyze</command> führen Sie die Fehlersuche für die Startzeit durch. Hiermit werden der Gesamtzeitaufwand für den Startvorgang sowie eine Liste der beim Starten angeforderten Dienste angezeigt. Auf Wunsch kann auch eine SVG-Grafik erstellt werden, aus der hervorgeht, wie lange der Start der Dienste im Vergleich zu den anderen Diensten dauerte.
    </para>
    <variablelist>
     <varlistentry>
      <term>Auflisten der Startzeit des Systems</term>
      <listitem>
<screen><prompt>root # </prompt>systemd-analyze
Startup finished in 2666ms (kernel) + 21961ms (userspace) = 24628ms</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Auflisten der Startzeit der Dienste</term>
      <listitem>
<screen><prompt>root # </prompt>systemd-analyze blame
  6472ms systemd-modules-load.service
  5833ms remount-rootfs.service
  4597ms network.service
  4254ms systemd-vconsole-setup.service
  4096ms postfix.service
  2998ms xdm.service
  2483ms localnet.service
  2470ms SuSEfirewall2_init.service
  2189ms avahi-daemon.service
  2120ms systemd-logind.service
  1210ms xinetd.service
  1080ms ntp.service
[...]
    75ms fbset.service
    72ms purge-kernels.service
    47ms dev-vda1.swap
    38ms bluez-coldplug.service
    35ms splash_early.service</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Grafische Darstellung der Startzeit der Dienste</term>
      <listitem>
<screen><prompt>root # </prompt>systemd-analyze plot &gt; jupiter.example.com-startup.svg</screen>
       <informalfigure>
        <mediaobject>
         <imageobject role="fo">
          <imagedata fileref="systemd_startup.svg" width="75%" format="SVG"/>
         </imageobject>
         <imageobject role="html">
          <imagedata fileref="systemd_startup.png" width="75%" format="PNG"/>
         </imageobject>
        </mediaobject>
       </informalfigure>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3 xml:id="sec.boot.systemd.debug.complete">
    <title>Prüfen des gesamten Startvorgangs</title>
    <para>
     Mit den obigen Kommandos prüfen Sie die gestarteten Dienste und den Zeitaufwand für den Start. Wenn Sie detailliertere Informationen benötigen, können Sie <systemitem class="daemon">systemd</systemitem> anweisen, den gesamten Startvorgang ausführlich zu protokollieren. Geben Sie hierzu die folgenden Parameter an der Boot-Eingabeaufforderung ein:
    </para>
<screen>systemd.log_level=debug systemd.log_target=kmsg</screen>
    <para>
     <systemitem class="daemon">systemd</systemitem> schreibt die Protokollmeldungen nunmehr in den Kernel-Ringpuffer. Diesen Puffer zeigen Sie mit <command>dmesg</command> an:
    </para>
<screen>dmesg -T | less</screen>
   </sect3>
  </sect2>

  <sect2 xml:id="sec.boot.systemd.sysv_compatibility">
   <title>System V-Kompatibilität</title>
   <para>
    systemd ist mit System V kompatibel, sodass Sie vorhandene System V-init-Skripte weiterhin nutzen können. Es gibt allerdings mindestens ein bekanntes Problem, bei dem ein System V-init-Skript nicht ohne Weiteres mit systemd zusammenarbeitet: Wenn Sie einen Dienst als ein anderer Benutzer über <command>su</command> oder <command>sudo</command> in init-Skripten starten, tritt der Fehler <quote>Access denied</quote> (Zugriff verweigert) auf.
   </para>
   <para>
    Wenn Sie den Benutzer mit <command>su</command> oder <command>sudo</command> ändern, wird eine PAM-Sitzung gestartet. Diese Sitzung wird beendet, sobald das init-Skript abgeschlossen ist. Als Folge wird auch der Service, der durch das init-Skript gestartet wurde, beendet. Als Workaround für diesen Fehler gehen Sie wie folgt vor:
   </para>
   <procedure>
    <step>
     <para>
      Erstellen Sie einen Service-Datei-Wrapper mit demselben Namen wie das init-Skript und der Dateinamenerweiterung <filename>.service</filename>:
     </para>
<screen>[Unit]
Description=<replaceable>DESCRIPTION</replaceable>
After=network.target

[Service]
User=<replaceable>USER</replaceable>
Type=forking<co xml:id="co.service_wrapper.type"/>
PIDFile=<replaceable>PATH TO PID FILE</replaceable><xref linkend="co.service_wrapper.type" xrefstyle="select:label nopage"/>
ExecStart=<replaceable>PATH TO INIT SCRIPT</replaceable> start
ExecStop=<replaceable>PATH TO INIT SCRIPT</replaceable> stop
ExecStopPost=/usr/bin/rm -f <replaceable>PATH TO PID FILE</replaceable><xref linkend="co.service_wrapper.type" xrefstyle="select:label nopage"/>

[Install]
WantedBy=multi-user.target<co xml:id="co.service_wrapper.target"/></screen>
     <para>
      Ersetzen Sie alle Werte in <replaceable>GROSSBUCHSTABEN</replaceable> durch die entsprechenden Werte.
     </para>
     <calloutlist>
      <callout arearefs="co.service_wrapper.type">
       <para>
        Optional; nur zu verwenden, wenn mit dem init-Skript ein Daemon gestartet wird.
       </para>
      </callout>
      <callout arearefs="co.service_wrapper.target">
       <para>
        <literal>multi-user.target</literal> startet ebenfalls das init-Skript, wenn Sie in <literal>graphical.target</literal> booten. Falls der Start nur beim Booten in den Display-Manager erfolgen soll, verwenden Sie hier <literal>graphical.target</literal>.
       </para>
      </callout>
     </calloutlist>
    </step>
    <step>
     <para>
      Starten Sie den Daemon mit <command>systemctl start <replaceable>ANWENDUNG</replaceable></command>.
     </para>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.boot.runlevel.edit">
  <title>Verwalten von Services mit YaST</title>

  <para>
   Grundlegende Aufgaben können auch mit dem YaST-Modul Dienste-Verwaltung ausgeführt werden. Hiermit werden das Starten, Stoppen, Aktivieren und Deaktivieren von Diensten unterstützt. Darüber hinaus können Sie den Status eines Dienstes abrufen und das Standardziel ändern. Starten Sie das YaST-Modul mit <menuchoice> <guimenu>YaST</guimenu> <guimenu>System</guimenu> <guimenu>Dienste-Verwaltung</guimenu> </menuchoice>.
  </para>

  <figure xml:id="fig.yast2.runlevel">
   <title>Services Manager</title>
   <mediaobject>
    <imageobject role="fo">
     <imagedata fileref="yast2_runlevel.png" width="75%" format="PNG"/>
    </imageobject>
    <imageobject role="html">
     <imagedata fileref="yast2_runlevel.png" width="75%" format="PNG"/>
    </imageobject>
   </mediaobject>
  </figure>

  <variablelist>
   <varlistentry>
    <term>Ändern des <guimenu>Standard-Systemziels</guimenu>
    </term>
    <listitem>
     <para>
      Zum Ändern des Ziels, in das das System gebootet wird, wählen Sie ein Ziel in der Dropdown-Liste <guimenu>Default System Target</guimenu> aus. Die häufigsten Ziele sind <guimenu>Graphical Interface</guimenu> (Grafische Oberfläche; öffnet einen grafischen Anmeldebildschirm) und <guimenu>Multi-User</guimenu> (Mehrbenutzer; startet das System im Kommandozeilenmodus).
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Starten und Stoppen eines Dienstes</term>
    <listitem>
     <para>
      Wählen Sie einen Dienst in der Tabelle aus. Die Spalte <guimenu>Aktiv</guimenu> zeigt, ob er derzeit ausgeführt wird (<guimenu>Aktiv</guimenu>) oder nicht (<guimenu>Inactive</guimenu>, Inaktiv). Mit <guimenu>Start/Stop</guimenu> (Starten/Stoppen) schalten Sie den Status um.
     </para>
     <para>
      Durch das Starten und Stoppen eines Dienstes wird sein Status für die aktuelle Sitzung geändert. Soll der Status beim Neubooten geändert werden, müssen Sie den Dienst aktivieren oder deaktivieren.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Aktivieren oder Deaktivieren eines Dienstes</term>
    <listitem>
     <para>
      Wählen Sie einen Dienst in der Tabelle aus. Die Spalte <guimenu>Aktiviert</guimenu> zeigt, ob er derzeit <guimenu>Aktiviert</guimenu> oder <guimenu>Deaktiviert</guimenu> ist. Mit <guimenu>Enable/Disable</guimenu> (Aktivieren/Deaktivieren) schalten Sie den Status um.
     </para>
     <para>
      Durch das Aktivieren bzw. Deaktivieren eines Dienstes legen Sie fest, ob er beim Booten gestartet werden soll (<guimenu>Aktiviert</guimenu>) oder nicht (<guimenu>Deaktiviert</guimenu>). Diese Einstellung wirkt sich nicht auf die aktuelle Sitzung aus. Soll der Status in der aktuellen Sitzung geändert werden, müssen Sie den Dienst starten oder stoppen.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Anzeigen von Statusmeldungen</term>
    <listitem>
     <para>
      Zum Anzeigen der Statusmeldungen für einen Dienst wählen Sie den gewünschten Dienst in der Liste aus und wählen Sie <guimenu>Details anzeigen</guimenu>. Die Ausgabe ist mit der Ausgabe des Kommandos <command>systemctl </command><option>-l</option> status <replaceable>&lt;mein_Dienst&gt;</replaceable> identisch.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <warning>
   <title>Fehlerhafte Runlevel-Einstellungen können das System beschädigen</title>
   <para>
    Fehlerhafte Runlevel-Einstellungen können ein System unbrauchbar machen. Stellen Sie vor dem Anwenden der Änderungen sicher, dass Sie deren Auswirkungen kennen.
   </para>
  </warning>
 </sect1>
 <sect1 xml:id="sec.boot.systemd.custom">
  <title>Anpassen von <systemitem>systemd</systemitem></title>

  <para>
   In den folgenden Abschnitten finden Sie einige Beispiele, wie Sie <systemitem>systemd</systemitem> individuell anpassen.
  </para>

  <warning>
   <title>Vermeiden der Überschreibung von Anpassungen</title>
   <para>
    Passen Sie systemd stets in <filename>/etc/systemd/</filename> an, <emphasis>nicht</emphasis> in <filename>/usr/lib/systemd/</filename>. Ansonsten werden Ihre Änderungen bei der nächsten Aktualisierung von systemd überschrieben.
   </para>
  </warning>

  <sect2 xml:id="sec.boot.systemd.custom.service">
   <title>Anpassen von Dienstdateien</title>
   <para>
    Die systemd-Dienstdateien befinden sich in<filename>/usr/lib/systemd/system</filename>. Zum Anpassen fahren Sie wie folgt fort:
   </para>
   <procedure>
    <step>
     <para>
      Kopieren Sie die zu bearbeitenden Dateien aus <filename>/usr/lib/systemd/system</filename> in <filename>/etc/systemd/system</filename>. Behalten Sie die ursprünglichen Dateinamen bei.
     </para>
    </step>
    <step>
     <para>
      Bearbeiten Sie die Kopien in <filename>/etc/systemd/system</filename>.
     </para>
    </step>
    <step>
     <para>
      Mit dem Kommando <command>systemd-delta</command> erhalten Sie einen Überblick über Ihre Konfigurationsänderungen. Hiermit werden Konfigurationsdateien verglichen und ermittelt, die andere Konfigurationsdateien überschreiben. Weitere Informationen finden Sie auf der man-Seite zu <command>systemd-delta</command>.
     </para>
    </step>
   </procedure>
   <para>
    Die geänderten Dateien in <filename>/etc/systemd</filename> haben Vorrang vor den Originaldateien in <filename>/usr/lib/systemd/system</filename>, sofern die Dateinamen identisch sind.
   </para>
  </sect2>

  <sect2 xml:id="sec.boot.systemd.custom.drop-in">
   <title>Erstellen von <quote>Drop-in-Dateien</quote></title>
   <para>
    Wenn eine Konfigurationsdatei nur um wenige Zeilen ergänzt oder nur ein kleiner Teil daraus geändert werden soll, können Sie sogenannte <quote>Drop-in-Dateien</quote> verwenden. Mit den Drop-in-Dateien erweitern Sie die Konfiguration von Unit-Dateien, ohne die Unit-Dateien selbst bearbeiten oder überschreiben zu müssen.
   </para>
   <para>
    Um beispielsweise einen einzigen Wert für den Dienst <replaceable>foobar</replaceable> in <filename>/usr/lib/systemd/system/ <replaceable>foobar.service</replaceable></filename> zu ändern, gehen Sie wie folgt vor:
   </para>
   <procedure>
    <step>
     <para>
      Erstellen Sie ein Verzeichnis mit dem Namen <filename>/etc/systemd/system/<replaceable>&lt;mein_Dienst&gt;</replaceable>.service.d/</filename>.
     </para>
     <para>
      Beachten Sie das Suffix <literal>.d</literal>. Ansonsten muss der Name des Verzeichnisses mit dem Namen des Dienstes übereinstimmen, der mit der Drop-in-Datei gepatcht werden soll.
     </para>
    </step>
    <step>
     <para>
      Erstellen Sie in diesem Verzeichnis eine Datei mit dem Namen <filename><replaceable>whatevermodification</replaceable>.conf</filename>.
     </para>
     <para>
      Diese Datei darf nur eine Zeile mit dem zu ändernden Wert enthalten.
     </para>
    </step>
    <step>
     <para>
      Speichern Sie Ihre Änderungen in die Datei. Die Datei wird als Erweiterung der Originaldatei verwendet.
     </para>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="sec.boot.systemd.custom.targets">
   <title>Erstellen von benutzerdefinierten Zielen</title>
   <para>
    Auf SUSE-Systemen mit System V-init wird Runlevel 4 nicht genutzt, so dass die Administratoren eine eigene Runlevel-Konfiguration erstellen können. Mit systemd können Sie beliebig viele benutzerdefinierte Ziele erstellen. Zum Einstieg sollten Sie ein vorhandenes Ziel anpassen, beispielsweise <systemitem>graphical.target</systemitem>.
   </para>
   <procedure>
    <step>
     <para>
      Kopieren Sie die Konfigurationsdatei <filename>/usr/lib/systemd/system/graphical.target</filename> in <filename>/etc/systemd/system/<replaceable>&lt;mein_Ziel&gt;</replaceable>.target</filename> und passen Sie sie nach Bedarf an.
     </para>
    </step>
    <step>
     <para>
      Die im vorangegangenen Schritt kopierte Konfigurationsdatei enthält bereits die erforderlichen (<quote>harten</quote>) Abhängigkeiten für das Ziel. Um auch die erwünschten (<quote>weichen</quote>) Abhängigkeiten abzudecken, erstellen Sie ein Verzeichnis mit dem Namen <filename>/etc/systemd/system/<replaceable>&lt;mein_Ziel&gt;</replaceable>.target.wants</filename>.
     </para>
    </step>
    <step>
     <para>
      Legen Sie für jeden erwünschten Dienst einen symbolischen Link von <filename>/usr/lib/systemd/system</filename> in <filename>/etc/systemd/system/<replaceable>&lt;mein_Ziel&gt;</replaceable>.target.wants</filename> an.
     </para>
    </step>
    <step>
     <para>
      Sobald Sie alle Einstellungen für das Ziel festgelegt haben, laden Sie die systemd-Konfiguration neu. Damit wird das neue Ziel verfügbar:
     </para>
<screen>systemctl daemon-reload</screen>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.boot.systemd.advanced">
  <title>Erweiterte Nutzung</title>

  <para>
   In den nachfolgenden Abschnitten finden Sie weiterführende Themen für Systemadministratoren. Eine noch eingehendere Dokumentation finden Sie in der Serie von Lennart Pöttering zu systemd für Administratoren unter <link xlink:href="http://0pointer.de/blog/projects"/>.
  </para>

  <sect2 xml:id="sec.boot.systemd.advanced.tmp">
   <title>Bereinigen von temporären Verzeichnissen</title>
   <para>
    <systemitem class="daemon">systemd</systemitem> unterstützt das regelmäßige Bereinigen der temporären Verzeichnisse. Die Konfiguration aus der bisherigen Systemversion wird automatisch migriert und ist aktiv. <literal>tmpfiles.d</literal> (verwaltet temporäre Dateien) liest die Konfiguration aus den Dateien <filename>/etc/tmpfiles.d/*.conf</filename> , <filename>/run/tmpfiles.d/*.conf</filename> und <filename>/usr/lib/tmpfiles.d/*.conf</filename> aus. Die Konfiguration in <filename>/etc/tmpfiles.d/*.conf</filename> hat Vorrang vor ähnlichen Konfigurationen in den anderen beiden Verzeichnissen. (In <filename>/usr/lib/tmpfiles.d/*.conf</filename> speichern die Pakete die Konfigurationsdateien.)
   </para>
   <para>
    Im Konfigurationsformat ist eine Zeile pro Pfad vorgeschrieben, wobei diese Zeile die Aktion und den Pfad enthalten muss und optional Felder für Modus, Eigentümer, Alter und Argument (je nach Aktion) enthalten kann. Im folgenden Beispiel wird die Verknüpfung der X11-Sperrdateien aufgehoben:
   </para>
<screen>Type Path               Mode UID  GID  Age Argument
r    /tmp/.X[0-9]*-lock</screen>
   <para>
    So rufen Sie den Status aus dem tmpfile-Zeitgeber ab:
   </para>
<screen>systemctl status systemd-tmpfiles-clean.timer
systemd-tmpfiles-clean.timer - Daily Cleanup of Temporary Directories
 Loaded: loaded (/usr/lib/systemd/system/systemd-tmpfiles-clean.timer; static)
 Active: active (waiting) since Tue 2014-09-09 15:30:36 CEST; 1 weeks 6 days ago
   Docs: man:tmpfiles.d(5)
         man:systemd-tmpfiles(8)

Sep 09 15:30:36 jupiter systemd[1]: Starting Daily Cleanup of Temporary Directories.
Sep 09 15:30:36 jupiter systemd[1]: Started Daily Cleanup of Temporary Directories.</screen>
   <para>
    Weitere Informationen zum Arbeiten mit temporären Dateien finden Sie unter <command>man 5 tmpfiles.d</command>.
   </para>
  </sect2>

  <sect2 xml:id="sec.boot.systemd.advanced.logging">
   <title>Systemprotokoll</title>
   <para>
    In <xref linkend="sec.boot.systemd.basics.services_debugging"/> wird erläutert, wie Sie Protokollmeldungen für einen bestimmten Dienst anzeigen. Die Anzeige von Protokollmeldungen ist allerdings nicht auf Dienstprotokolle beschränkt. Sie können auch auf das gesamte von <systemitem class="daemon">systemd</systemitem> geschriebene Protokoll (das sogenannte <quote>Journal</quote>) zugreifen und Abfragen darauf ausführen. Mit dem Kommando <command>systemd-journalctl</command> zeigen Sie das gesamte Protokoll an, beginnend mit den ältesten Einträgen. Informationen zu weiteren Optionen, beispielsweise zum Anwenden von Filtern oder zum Ändern des Ausgabeformats, finden Sie unter <command>man 1 systemd-journalctl</command>.
   </para>
  </sect2>

  <sect2 xml:id="sec.boot.systemd.advanced.snapshots">
   <title>Aufnahmen</title>
   <para>
    Mit dem Subkommando <systemitem class="daemon">isolate</systemitem> können Sie den aktuellen Status von <command>systemd</command> als benannten Snapshot speichern und später wiederherstellen. Dies ist beim Testen von Diensten oder benutzerdefinierten Zielen hilfreich, weil Sie jederzeit zu einem definierten Status zurückkehren können. Ein Snapshot ist nur in der aktuellen Sitzung verfügbar; beim Neubooten wird er automatisch gelöscht. Der Snapshot-Name muss auf <filename>.snapshot</filename> enden.
   </para>
   <variablelist>
    <varlistentry>
     <term>Erstellen eines Snapshots</term>
     <listitem>
<screen>systemctl snapshot <replaceable>&lt;my_snapshot&gt;</replaceable>.snapshot</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Löschen eines Snapshots</term>
     <listitem>
<screen>systemctl delete <replaceable>&lt;my_snapshot&gt;</replaceable>.snapshot</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Anzeigen eines Snapshots</term>
     <listitem>
<screen>systemctl show <replaceable>&lt;my_snapshot&gt;</replaceable>.snapshot</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Aktivieren eines Snapshots</term>
     <listitem>
<screen>systemctl isolate <replaceable>&lt;my_snapshot&gt;</replaceable>.snapshot</screen>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>





  <sect2 xml:id="sec.boot.systemd.advanced.kernel_modules">
   <title>Laden der Kernelmodule</title>
   <para>
    Mit <systemitem class="daemon">systemd</systemitem> können Kernel-Module automatisch zum Bootzeitpunkt geladen werden, und zwar über die Konfigurationsdatei in <filename>/etc/modules-load.d</filename>. Die Datei sollte den Namen <replaceable>Modul</replaceable>.conf haben und den folgenden Inhalt aufweisen:
   </para>
<screen># load module <replaceable>module</replaceable> at boot time
<replaceable>module</replaceable></screen>
   <para>
    Falls ein Paket eine Konfigurationsdatei zum Laden eines Kernel-Moduls installiert, wird diese Datei unter <filename>/usr/lib/modules-load.d</filename> installiert. Wenn zwei Konfigurationsdateien mit demselben Namen vorhanden sind, hat die Datei unter <filename>/etc/modules-load.d</filename> Vorrang.
   </para>
   <para>
    Weitere Informationen finden Sie auf der man-Seite <systemitem>modules-load.d(5)</systemitem>.
   </para>
  </sect2>



  <sect2 xml:id="sec.boot.systemd.advanced.before.local">
   <title>Ausführen von Aktionen vor dem Laden eines Diensts</title>
   <para>
    Bei System V mussten init-Aktionen, die vor dem Laden eines Diensts ausgeführt werden müssen, in <filename>/etc/init.d/before.local</filename> festgelegt werden. Dieses Verfahren wird in systemd nicht mehr unterstützt. Wenn Aktionen vor dem Starten von Diensten ausgeführt werden müssen, gehen Sie wie folgt vor:
   </para>
   <variablelist>
    <varlistentry>
     <term>Laden der Kernelmodule</term>
     <listitem>
      <para>
       Erstellen Sie eine Drop-in-Datei im Verzeichnis <filename>/etc/modules-load.d</filename> (Syntax siehe <command>man modules-load.d</command>).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
     Erstellen von Dateien oder Verzeichnissen, Bereinigen von Verzeichnissen, Ändern des Eigentümers
     </term>
     <listitem>
      <para>
       Erstellen Sie eine Drop-in-Datei in <filename>/etc/tmpfiles.d</filename> (Syntax siehe <command>man tmpfiles.d</command>).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Weitere Aufgaben</term>
     <listitem>
      <para>
       Erstellen Sie eine Systemdienstdatei (beispielsweise <filename>/etc/systemd/system/before.service</filename>) anhand der folgenden Schablone:
      </para>
<screen>[Unit]
Before=<replaceable>NAME OF THE SERVICE YOU WANT THIS SERVICE TO BE STARTED BEFORE</replaceable>
[Service]
Type=oneshot
RemainAfterExit=true
ExecStart=<replaceable>YOUR_COMMAND</replaceable>
# beware, executable is run directly, not through a shell, check the man pages
# systemd.service and systemd.unit for full syntax
[Install]
# target in which to start the service
WantedBy=multi-user.target
#WantedBy=graphical.target</screen>
      <para>
       Sobald die Dienstdatei erstellt ist, führen Sie die folgenden Kommandos aus (als <systemitem class="username">root</systemitem>):
      </para>
<screen>systemctl daemon-reload
systemctl enable before</screen>
      <para>
       Bei jedem Bearbeiten der Dienstdatei müssen Sie Folgendes ausführen:
      </para>
<screen>systemctl daemon-reload</screen>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>



  <sect2 xml:id="sec.boot.systemd.advanced.cgroups">
   <title>Kernel-Steuergruppen (cgroups)</title>
   <para>
    Auf einem traditionellen System-V-init-System kann ein Prozess nicht immer eindeutig dem Dienst zugeordnet werden, durch den er erzeugt wurde. Einige Dienste (z. B. Apache) erzeugen zahlreiche externe Prozesse (z. B. CGI- oder Java-Prozesse), die wiederum weitere Prozesse erzeugen. Eindeutige Zuweisungen sind damit schwierig oder völlig unmöglich. Wenn ein Dienst nicht ordnungsgemäß beendet wird, bleiben zudem ggf. einige untergeordnete Dienste weiterhin aktiv.
   </para>
   <para>
    Bei systemd wird jeder Dienst in eine eigene cgroup aufgenommen, womit dieses Problem gelöst ist. cgroups sind eine Kernel-Funktion, mit der die Prozesse mit allen ihren untergeordneten Prozessen in hierarchisch strukturierten Gruppen zusammengefasst werden. Die cgroups werden dabei nach dem jeweiligen Dienst benannt. Da ein nicht privilegierter Dienst seine cgroup nicht <quote>verlassen</quote> darf, ist es damit möglich, alle von einem Dienst erzeugten Prozesse mit dem Namen dieses Dienstes zu versehen.
   </para>
   <para>
    Mit dem Kommando <command>systemd-cgls</command> erhalten Sie eine Liste aller Prozesse, die zu einem Dienst gehören. (Gekürztes) Beispiel für die Ausgabe:
   </para>
   <example>
    <title>Auflisten aller Prozesse, die zu einem Dienst gehören</title>
<screen><prompt>root # </prompt>systemd-cgls --no-pager
├─1 /usr/lib/systemd/systemd --switched-root --system --deserialize 20
├─user.slice
│ └─user-1000.slice
│   ├─session-102.scope
│   │ ├─12426 gdm-session-worker [pam/gdm-password]
│   │ ├─15831 gdm-session-worker [pam/gdm-password]
│   │ ├─15839 gdm-session-worker [pam/gdm-password]
│   │ ├─15858 /usr/lib/gnome-terminal-server

[...]

└─system.slice
  ├─systemd-hostnamed.service
  │ └─17616 /usr/lib/systemd/systemd-hostnamed
  ├─cron.service
  │ └─1689 /usr/sbin/cron -n
  ├─ntpd.service
  │ └─1328 /usr/sbin/ntpd -p /var/run/ntp/ntpd.pid -g -u ntp:ntp -c /etc/ntp.conf
  ├─postfix.service
  │ ├─ 1676 /usr/lib/postfix/master -w
  │ ├─ 1679 qmgr -l -t fifo -u
  │ └─15590 pickup -l -t fifo -u
  ├─sshd.service
  │ └─1436 /usr/sbin/sshd -D

[...]</screen>
   </example>
   <para>
    Weitere Informationen zu cpgroups finden Sie in <xref linkend="cha.tuning.cgroups"/>.
   </para>
  </sect2>

  <sect2 xml:id="sec.boot.systemd.advanced.kill">
   <title>Beenden von Diensten (Senden von Signalen)</title>
   <para>
    Wie in <xref linkend="sec.boot.systemd.advanced.cgroups"/> erläutert, kann ein Prozess in einem System-V-init-System nicht immer eindeutig seinem übergeordneten Dienstprozess zugeordnet werden. Das erschwert das Beenden eines Dienstes und seiner untergeordneten Dienste. Untergeordnete Prozesse, die nicht ordnungsgemäß beendet wurden, bleiben als "Zombie-Prozess" zurück.
   </para>
   <para>
    Durch das Konzept von systemd, mit dem jeder Dienst in einer eigenen cgroup abgegrenzt wird, können alle untergeordneten Prozesse eines Dienstes eindeutig erkannt werden, so dass Sie ein Signal zu diesen Prozessen senden können. Mit Use <command>systemctl kill</command> senden Sie die Signale an die Dienste. Eine Liste der verfügbaren Signale finden Sie in <command>man 7 signals</command>.
   </para>
   <variablelist>
    <varlistentry>
     <term>Senden von <systemitem>SIGTERM</systemitem> an einen Dienst</term>
     <listitem>
      <para>
       <systemitem>SIGTERM</systemitem> ist das standardmäßig gesendete Signal.
      </para>
<screen>systemctl kill <replaceable>&lt;my_service&gt;</replaceable></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Senden von <replaceable>SIGNAL</replaceable> an einen Dienst</term>
     <listitem>
      <para>
       Mit der Option <option>-s</option> legen Sie das zu sendende Signal fest.
      </para>
<screen>systemctl kill -s <replaceable>SIGNAL</replaceable> <replaceable>&lt;my_service&gt;</replaceable></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Auswählen von Prozessen</term>
     <listitem>
      <para>
       Standardmäßig sendet das Kommando <command>kill</command> das Signal an <option>alle</option> Prozesse der angegebenen cgroup. Sie können dies jedoch auf den Prozess <option>control</option> oder <option>main</option> beschränken. Damit können Sie beispielsweise das Neuladen der Konfiguration eines Dienstes mit dem Signal <systemitem>SIGHUP</systemitem> erzwingen:
      </para>
<screen>systemctl kill -s SIGHUP --kill-who=main <replaceable>&lt;my_service&gt;</replaceable></screen>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>



  <sect2 xml:id="sec.boot.systemd.basics.services_debugging">
   <title>Fehlersuche für Dienste</title>
   <para>
    Standardmäßig ist die Ausgabe von systemd auf ein Minimum beschränkt. Wenn ein Dienst ordnungsgemäß gestartet wurde, erfolgt keine Ausgabe. Bei einem Fehler wird eine kurze Fehlermeldung angezeigt. Mit <command>systemctl status</command> können Sie jedoch die Fehlersuche für den Start und die Ausführung eines Dienstes vornehmen.
   </para>
   <para>
    systemd umfasst einen Protokollierungsmechanismus (<quote>Journal</quote>), mit dem die Systemmeldungen protokolliert werden. Auf diese Weise können Sie die Dienstmeldungen zusammen mit den Statusmeldungen abrufen. Das Kommando <command>status</command> hat eine ähnliche Funktion wie <command>tail</command> und kann zudem die Protokollmeldungen in verschiedenen Formaten anzeigen, ist also ein wirksames Hilfsmittel für die Fehlersuche.
   </para>
   <variablelist>
    <varlistentry>
     <term>Anzeigen von Fehlern beim Starten von Diensten</term>
     <listitem>
      <para>
       Wenn ein Dienst nicht gestartet wird, erhalten Sie mit <command>systemctl status <replaceable>&lt;mein_Dienst&gt;</replaceable></command> eine ausführliche Fehlermeldung:
      </para>
<screen><prompt>root # </prompt>systemctl start apache2
Job failed. See system journal and 'systemctl status' for details.
<prompt>root # </prompt>systemctl status apache2
   Loaded: loaded (/usr/lib/systemd/system/apache2.service; disabled)
   Active: failed (Result: exit-code) since Mon, 04 Jun 2012 16:52:26 +0200; 29s ago
   Process: 3088 ExecStart=/usr/sbin/start_apache2 -D SYSTEMD -k start (code=exited, status=1/FAILURE)
   CGroup: name=systemd:/system/apache2.service

Jun 04 16:52:26 g144 start_apache2[3088]: httpd2-prefork: Syntax error on line
205 of /etc/apache2/httpd.conf: Syntax error on li...alHost&gt;</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Anzeigen der letzten <replaceable>n</replaceable> Dienstmeldungen</term>
     <listitem>
      <para>
       Standardmäßig zeigt das Subkommando <command>status</command> die letzten zehn Meldungen an, die ein Dienst ausgegeben hat. Mit dem Parameter <option>--lines=<replaceable>n</replaceable></option> legen Sie eine andere Anzahl fest:
      </para>
<screen>systemctl status ntp
systemctl --lines=20 status ntp</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Anzeigen von Dienstmeldungen im Anhängemodus</term>
     <listitem>
      <para>
       Mit der Option <quote>--follow</quote> erhalten Sie einen <option>Live-Stream</option> mit Dienstmeldungen; diese Option entspricht <command>tail </command><option>-f</option>:
      </para>
<screen>systemctl --follow status ntp</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Ausgabeformat der Meldungen</term>
     <listitem>
      <para>
       Mit dem Parameter <option>--output=<replaceable>mode</replaceable></option> legen Sie das Ausgabeformat für die Dienstmeldungen fest. Die wichtigsten Modi sind:
      </para>
      <variablelist>
       <varlistentry>
        <term><option>short</option>
        </term>
        <listitem>
         <para>
          Das Standardformat. Zeigt die Protokollmeldungen mit einem Zeitstempel in Klartext an.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><option>verbose</option>
        </term>
        <listitem>
         <para>
          Vollständige Ausgabe mit sämtlichen Feldern.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><option>cat</option>
        </term>
        <listitem>
         <para>
          Kurze Ausgabe ohne Zeitstempel.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.boot.systemd.info">
  <title>Weitere Informationen</title>

  <para>
   Weitere Informationen zu systemd finden Sie in folgenden Online-Quellen:
  </para>

  <variablelist>
   <varlistentry>
    <term>Startseite</term>
    <listitem>
     <para>
      <link xlink:href="http://www.freedesktop.org/wiki/Software/systemd"/>
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>systemd für Administratoren</term>
    <listitem>
     <para>
      Lennart Pöttering, einer der systemd-Autoren, hat eine Serie von Blogeinträgen verfasst. (Zum Zeitpunkt, als dieses Kapitel verfasst wurde, standen bereits 13 Einträge zur Verfügung.) Diese sind unter <link xlink:href="http://0pointer.de/blog/projects"/> zu finden.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
</chapter>
