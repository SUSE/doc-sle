<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<chapter version="5.0" xml:lang="en" xml:id="cha.new.bash"
  xmlns="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2001/XInclude"
  xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Shell Basics</title><indexterm>
 <primary>shell</primary>
 <secondary>basics</secondary></indexterm>
 <para>
  When working with Linux these days, you can communicate with the system
  almost without ever requiring a command line interpreter (the shell).
  After booting your Linux system, you are usually directed to a graphical
  user interface that guides you through the login process and the following
  interactions with the operating system. The graphical user interface in
  Linux (the X Window System or X11) is initially configured during
  installation. Both KDE and GNOME desktop (and other window managers you
  can install) use it for interaction with the user.
 </para>
 <para>
  Nevertheless, it is useful to have some basic knowledge of working with a
  shell because you might encounter situations where the graphical user
  interface is not available. For example, if some problem with the X Window
  System occurs. If you are not familiar with a shell, you might feel a bit
  uncomfortable at first when entering commands, but the more you get used
  to it, the more you will realize that the command line is often the
  quickest and easiest way to perform some daily tasks.
 </para>
 <para>
  For UNIX or Linux several shells are available which differ slightly in
  behavior and in the commands they accept. The default shell in
  &productnamereg; is Bash (GNU Bourne-Again Shell).
 </para>
 <para>
  The following sections will guide you through your first steps with the
  Bash shell and will show you how to complete some basic tasks via the
  command line. If you are interested in learning more or rather feel like a
  shell <quote>power user</quote> already, refer to
  <xref
   linkend="cha.adm.shell"/>.
 </para>
 <sect1 xml:id="sec.new.bash.start">
  <title>Starting a Shell</title><indexterm>

  <primary>shell</primary>

  <secondary>starting</secondary></indexterm>

  <para>
   Basically, there are two different ways to start a shell from the
   graphical user interface which usually shows after you have booted your
   computer:
  </para>

  <itemizedlist>
   <listitem>
    <para>
     you can leave the graphical user interface or
    </para>
   </listitem>
   <listitem>
    <para>
     you can start a terminal window <emphasis>within</emphasis> the
     graphical user interface.
    </para>
   </listitem>
  </itemizedlist>

  <para>
   While the first option is always available, you can only make use of the
   second option when you are already logged in to a desktop such as KDE or
   GNOME. Whichever way you choose, there is always a way back and you can
   switch back and forth between the shell and the graphical user interface.
  </para>

  <para>
   If you want to give it a try, press <keycombo>
   <keycap function="control"/> <keycap function="alt"/> <keycap>F2</keycap>
   </keycombo> to leave the graphical user interface. The graphical user
   interface disappears and you are taken to a shell which prompts you to
   log in. Type your username and press <keycap
    function="enter"/>. Then
   type your password and press <keycap function="enter"/>. The prompt now
   changes and shows some useful information as in the following example:
  </para>

<screen> <co xml:id="co.prompt.user"/>&nbsp;&nbsp;&nbsp;<co xml:id="co.prompt.hostname"/>&nbsp;&nbsp;&nbsp;<co xml:id="co.prompt.path"/>
tux@linux:~&gt;</screen><indexterm>

  <primary>shell</primary>

  <secondary>prompt</secondary></indexterm>

  <calloutlist>
   <callout arearefs="co.prompt.user">
    <para>
     Your login.
    </para>
   </callout>
   <callout arearefs="co.prompt.hostname">
    <para>
     The hostname of your computer.
    </para>
   </callout>
   <callout arearefs="co.prompt.path">
    <para>
     Path to the current directory. Directly after login, the current
     directory usually is your home directory, indicated by the
     <literal>~</literal> symbol (tilde) .
    </para>
   </callout>
  </calloutlist>

  <para>
   When you are logged in at a remote computer the information provided by
   the prompt always shows you which system you are currently working on.
  </para>

  <para>
   <indexterm>
   <primary>ls</primary>
   </indexterm> When the cursor is located behind this prompt, you can pass
   commands directly to your computer system. For example, you can now enter
   <command>ls</command> <option>-l</option> to list the contents of the
   current directory in a detailed format. If this is enough for your first
   encounter with the shell and you want to go back to the graphical user
   interface, you should log out from your shell session first. To do so,
   type <command>exit</command> and press <keycap
    function="enter"/>.
   Then press <keycombo> <keycap function="alt"/> <keycap>F7</keycap>
   </keycombo> to switch back to the graphical user interface. You will find
   your desktop and the applications running on it unchanged.
  </para>

  <para>
   When you are already logged in to the GNOME or the KDE desktop and want
   to start a terminal window within the desktop, press <keycombo>
   <keycap function="alt"/> <keycap>F2</keycap> </keycombo> and enter
   <command>konsole</command> (for KDE) or <command>gnome-terminal</command>
   (for GNOME). This opens a terminal window on your desktop. As you are
   already logged in to your desktop, the prompt shows information about
   your system as described above. You can now enter commands and execute
   tasks just like in any shell which runs parallel to your desktop. To
   switch to another application on the desktop just click on the
   corresponding application window or select it from the taskbar of your
   panel. To close the terminal window press <keycombo>
   <keycap function="alt"/> <keycap>F4</keycap> </keycombo>.
  </para>
 </sect1>
 <sect1 xml:id="sec.new.bash.commands">
  <title>Entering Commands</title><indexterm>

  <primary>Bash</primary>

  <secondary>commands</secondary></indexterm>

  <para>
   As soon as the prompt appears on the shell it is ready to receive and
   execute commands. A command can consist of several elements. The first
   element is the actual command, followed by parameters or options. You can
   type a command and edit it by using the following keys:
   <keycap
    function="left"/>, <keycap function="right"/>,
   <keycap function="home"/>, <keycap function="end"
   />,
   <keycap function="backspace"/> (Backspace), <keycap function="delete"/>,
   and <keycap
    function="space"/>. You can correct typing errors or add
   options. The command is not executed until you press
   <keycap function="enter"/>.
  </para>

  <important>
   <title>No News Is Good News</title>
   <para>
    The shell is not verbose: in contrast to some graphical user interfaces,
    it usually does not provide confirmation messages when commands have
    been executed. Messages only appear in case of problems or errors
    &mdash;or if you explicitly ask for them by executing a command with a
    certain option.
   </para>
   <para>
    Also keep this in mind for commands to delete objects. Before entering a
    command like <command>rm</command> (without any option) for removing a
    file, you should know if you really want to get rid of the object: it
    will be deleted irretrievably, without confirmation.
   </para>
  </important>

  <sect2 xml:id="sec.new.bash.commands.simple">
   <title>Using Commands without Options</title>
   <para>
    In <xref linkend="sec.new.bash.accperm.ugo"/> you already got to know
    one of the most basic commands: <command>ls</command>, <indexterm>
    <primary>ls</primary>
    </indexterm> which used to list the contents of a directory. This
    command can be used with or without options. Entering the plain
    <command>ls</command> command shows the contents of the current
    directory:
   </para>
<screen>tux@knox:~&gt; ls
bin Desktop Documents public_html tux.txt
tux@knox:~&gt;</screen>
   <para>
    Files in Linux may have a file extension or a suffix, such as
    <literal>.txt</literal>, but do not need to have one. This makes it
    difficult to differentiate between files and folders in this output of
    the <command>ls</command>. By default, the colors in the Bash shell give
    you a hint: directories are usually shown in blue, files in black.
   </para>
  </sect2>

  <sect2 xml:id="sec.new.bash.commands.options">
   <title>Using Commands with Options</title>
   <para>
    <indexterm>
    <primary>ls</primary>
    <secondary>options</secondary>
    </indexterm> A better way to get more details about the contents of a
    directory is using the <command>ls</command> command with a string of
    options. Options modify the way a command works so that you can get it
    to carry out specific tasks. Options are separated from the command with
    a blank and are usually prefixed with a hyphen. The <command>ls</command>
    <option>-l</option> command shows the contents of the same
    directory in full detail (long listing format):
   </para>
<screen>tux@knox:~&gt; ls -l
drwxr-xr-x 1 tux users     48 2015-06-23 16:08 bin
drwx---r-- 1 tux users  53279 2015-06-21 13:16 Desktop
drwx------ 1 tux users    280 2015-06-23 16:08 Documents
drwxr-xr-x 1 tux users  70733 2015-06-21 09:35 public_html
-rw-r--r-- 1 tux users  47896 2015-06-21 09:46 tux.txt
tux@knox:~&gt;</screen>
   <para>
    This output shows the following information about each object:
   </para>
<screen>drwxr-xr-x<co xml:id="co.ls_l.perm"/> 1<co xml:id="co.ls_l.a"/> tux<co xml:id="co.ls_l.user"/> users<co xml:id="co.ls_l.group"/> 48<co xml:id="co.ls_l.size"/> 2006-06-23 16:08<co xml:id="co.ls_l.date"/> bin<co xml:id="co.ls_l.name"/> </screen>
   <calloutlist>
    <callout arearefs="co.ls_l.perm">
     <para>
      Type of object and access permissions. For further information, refer
      to <xref
       linkend="sec.new.bash.accperm.ugo"/>.
     </para>
    </callout>
    <callout arearefs="co.ls_l.a">
     <para>
      Number of hard links to this file.
     </para>
    </callout>
    <callout arearefs="co.ls_l.user">
     <para>
      Owner of the file or directory. For further information, refer to
      <xref
       linkend="sec.new.bash.accperm.ugo"/>.
     </para>
    </callout>
    <callout arearefs="co.ls_l.group">
     <para>
      Group assigned to the file or directory. For further information,
      refer to <xref
       linkend="sec.new.bash.accperm.ugo"/>.
     </para>
    </callout>
    <callout arearefs="co.ls_l.size">
     <para>
      File size in bytes.
     </para>
    </callout>
    <callout arearefs="co.ls_l.date">
     <para>
      Date and time of the last change.
     </para>
    </callout>
    <callout arearefs="co.ls_l.name">
     <para>
      Name of the object.
     </para>
    </callout>
   </calloutlist>
   <para>
    Usually, you can combine several options by prefixing only the first
    option with a hyphen and then write the others consecutively without a
    blank. For example, if you want to see all files in a directory in long
    listing format, you can combine the two options <option>-l</option> and
    <option>-a</option> (show all files) for the <command>ls</command>
    command. Executing <command>ls</command> <option>-la</option> shows also
    hidden files in the directory, indicated by a dot in front (for example,
    <literal>.hiddenfile</literal>).
   </para>
   <para>
    The list of contents you get with <command>ls</command> is sorted
    alphabetically by filenames. But like in a graphical file manager, you
    can also sort the output of <command>ls</command> <option>-l</option>
    according to various criteria such as date, file extension or file size:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      For date and time, use <command>ls</command> <option>-lt</option>
      (displays newest first).
     </para>
    </listitem>
    <listitem>
     <para>
      For extensions, use <command>ls</command> <option>-lx</option>
      (displays files with no extension first).
     </para>
    </listitem>
    <listitem>
     <para>
      For file size, use <command>ls</command> <option>-lS</option>
      (displays largest first).
     </para>
    </listitem>
   </itemizedlist>
   <para>
    To revert the order of sorting, add <option>-r</option> as an option to
    your <command>ls</command> command. For example, <command>ls</command>
    <option>-lr</option> gives you the contents list sorted in reverse
    alphabetical order, <command>ls</command> <option>-ltr</option> shows the
    oldest files first. There are lots of other useful options for
    <command>ls</command>. In the following section you will learn how to
    investigate them.
   </para>
  </sect2>

  <sect2 xml:id="sec.new.bash.commands.help">
   <title>Getting Help</title>
   <para>
    Nobody is expected to know all options of all commands by heart. If you
    remember the command name but are not sure about the options or the
    syntax of the command, choose one of the following possibilities:
   </para>
   <variablelist>
    <varlistentry>
     <term><option>--help</option> option <indexterm>
      <primary>options</primary>
      <secondary>--help</secondary></indexterm><indexterm>
      <primary>help</primary>
      <secondary>options</secondary></indexterm>
     </term>
     <listitem>
      <para>
       If you only want to look up the options of a certain command, try
       entering the command followed by a space and <option>--help</option>.
       This <option>--help</option> option exists for many commands. For
       example, <command>ls</command> <option>--help</option> displays all
       the options for the <command>ls</command> command. <indexterm>
       <primary>commands</primary>
       <secondary>help</secondary>
       </indexterm>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Manual Pages<indexterm>
      <primary>commands</primary>
      <secondary>man</secondary></indexterm><indexterm>
      <primary>help</primary>
      <secondary>man pages</secondary></indexterm><indexterm>
      <primary>man pages</primary></indexterm>
     </term>
     <listitem>
      <para>
       To learn more about the various commands, you can also use the manual
       pages. Manual pages also give a short description of what the command
       does. They can be accessed with <command>man</command> followed by
       the name of the command, for example, <command>man&nbsp;ls</command>.
      </para>
      <para>
       The man pages are displayed directly in the shell. To navigate them,
       move up and down with <keycap function="pageup"/> and
       <keycap function="pagedown"/>. Move between the beginning and the end
       of a document with <keycap function="home"/> and
       <keycap function="end"
       />. End this viewing mode by pressing
       <keycap>Q</keycap>. Learn more about the <command>man</command>
       command itself with <command>man man</command>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Info Pages<indexterm>
      <primary>commands</primary>
      <secondary>info</secondary></indexterm><indexterm>
      <primary>help</primary>
      <secondary>info pages</secondary></indexterm><indexterm>
      <primary>info pages</primary></indexterm>
     </term>
     <listitem>
      <para>
       Info pages usually provide even more information about commands. To
       view the info page for a certain command, enter
       <command>info</command> followed by the name of the command (for
       example, <command>info ls</command>). You can browse an info page
       with a viewer directly in the shell and display the different
       sections, called <quote>nodes.</quote> Use
       <keycap
        function="space"/> to move forward and
       <keycap function="backspace"/> to move backwards. Within a node, you
       can also browse with <keycap function="pageup"/> and
       <keycap
        function="pagedown"/> but only
       <keycap function="space"/> and <keycap function="backspace"/> will
       take you also to the previous or subsequent node. Like for the man
       pages, press <keycap>Q</keycap> to end the viewing mode.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Note that man pages and info pages do not exist for all commands.
    Sometimes both are available (usually for key commands), sometimes only
    a man page or an info page exists, and sometimes neither of them are
    available.
   </para>
  </sect2>

  <sect2 xml:id="sec.new.bash.commands.shortcuts">
   <title>Bash Shortcut Keys</title><indexterm>
   <primary>Bash</primary>
   <secondary>shortcut keys</secondary></indexterm>
   <para>
    After having entered several commands, your shell will begin to fill up
    with all sorts of commands and the corresponding outputs. In the
    following table, find some useful shortcut keys for navigating and
    editing in the shell.
   </para>
   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>
        <para>
         Shortcut Key
        </para>
       </entry>
       <entry>
        <para>
         Function
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         <keycombo> <keycap function="control"/> <keycap>L</keycap>
         </keycombo>
        </para>
       </entry>
       <entry>
        <para>
         Clears the screen and moves the current line to the top of the
         page.
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <keycombo> <keycap function="control"/> <keycap>C</keycap>
         </keycombo>
        </para>
       </entry>
       <entry>
        <para>
         Aborts the command which is currently being executed.
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <keycombo> <keycap function="shift"/> <keycap function="pageup"/>
         </keycombo>
        </para>
       </entry>
       <entry>
        <para>
         Scrolls upwards.
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <keycombo> <keycap function="shift"/> <keycap function="pagedown"/>
         </keycombo>
        </para>
       </entry>
       <entry>
        <para>
         Scrolls downwards.
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <keycombo> <keycap function="control"/> <keycap>U</keycap>
         </keycombo>
        </para>
       </entry>
       <entry>
        <para>
         Deletes from cursor position to start of line.
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <keycombo> <keycap function="control"/> <keycap>K</keycap>
         </keycombo>
        </para>
       </entry>
       <entry>
        <para>
         Deletes from cursor position to the end of line.
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <keycombo> <keycap function="control"/> <keycap>D</keycap>
         </keycombo>
        </para>
       </entry>
       <entry>
        <para>
         Closes the shell session.
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <keycap function="up"/>, <keycap function="down"/>
        </para>
       </entry>
       <entry>
        <para>
         Browses in the history of executed commands.
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.new.bash.fildir">
  <title>Working with Files and Directories</title><indexterm>

  <primary>files</primary>

  <secondary>paths</secondary></indexterm><indexterm>

  <primary>directories</primary>

  <secondary>paths</secondary></indexterm><indexterm>

  <primary>paths</primary></indexterm>

  <remark>taroth: 061013: proposal by toms: perhaps add graphic for next revision?</remark>

  <para>
   To address a certain file or directory, you must specify the path leading
   to that directory or file. As you may know from MS DOS or Mac OS already,
   there are two ways to specify a path:
  </para>

  <variablelist>
   <varlistentry>
    <term>Absolute Path<indexterm>
     <primary>paths</primary>
     <secondary>absolute</secondary></indexterm>
    </term>
    <listitem>
     <para>
      Enter the entire path from the root directory to the relevant file or
      directory.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Relative Path<indexterm>
     <primary>paths</primary>
     <secondary>relative</secondary></indexterm>
    </term>
    <listitem>
     <para>
      Enter a path to the relevant file or directory by using the current
      directory as a starting point. This implies to give the levels you
      have to move up or down in the file system tree to reach the target
      directory of file, starting from the current directory.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Paths contain filenames, directories or both, separated by slashes.
   Absolute paths always start with a slash. Relative paths do not have a
   slash at the beginning, but can have one or two dots.
  </para>

  <para>
   When entering commands, you can choose either way to specify a path,
   depending on your preferences or the amount of typing, both will lead to
   the same result. To change directories, use the <command>cd</command>
   command and specify the path to the directory.
  </para>

  <note>
   <title>Handling Blanks in Filenames or Directory Names</title>
   <para>
    If a filename or the name of a directory contains a space, either escape
    the space using a back slash (<literal>\</literal>) in front of the
    blank or enclose the filename in single
<!-- or double-->
    quotes. Otherwise Bash interprets a filename like <filename>My
    Documents</filename> as the names of two files or directories,
    <filename>My</filename> and <filename>Documents</filename> in this case.
<!--The difference between
    single and double quotes is that variable expansion takes place within
    double quotes. Single quotes ensure that the shell sees the quoted string
    literally.-->
   </para>
  </note>

  <para>
   When specifying paths, the following <quote>shortcuts</quote> can save
   you a lot of typing:
  </para>

  <itemizedlist>
   <listitem>
    <para>
     The tilde symbol (<literal>~</literal>) is a shortcut for home
     directories. For example, to list the contents of your home directory,
     use <command>ls</command> <option>~</option>. To list the contents of
     another user's home directory, enter <command>ls</command>
     <option>~<replaceable>username</replaceable> </option> (or
     course, this will only work if you have permission to view the
     contents, see <xref linkend="sec.new.bash.accperm"/>). For example,
     entering <command>ls ~&exampleuser_plain;</command> would list the
     contents of the home directory of a user named &exampleuser;. You can use the
     tilde symbol as shortcut for home directories also if you are working
     in a network environment where your home directory may not be called
     <filename>/home</filename> but can be mapped to any directory in the
     file system.
    </para>
    <para>
     From anywhere in the file system, you can reach your home directory by
     entering <command>cd ~</command> or by simply entering
     <command>cd</command> without any options.
    </para>
   </listitem>
   <listitem>
    <para>
     When using relative paths, refer to the current directory with a dot
     (<literal>.</literal>). This is mainly useful for commands such as
     <command>cp</command> or <command>mv</command> by which you can copy or
     move files and directories.
    </para>
   </listitem>
   <listitem>
    <para>
     The next higher level in the tree is represented by two dots
     (<literal>..</literal>). In order to switch to the parent directory of
     your current directory, enter <command>cd ..</command>, to go up two
     levels from the current directory enter <command>cd ../..</command>
     etc.
    </para>
   </listitem>
  </itemizedlist>

  <para>
   To apply your knowledge, find some examples below. They address basic
   tasks you may want to execute with files or folders using Bash.
  </para>

  <sect2
   xml:id="sec.new.bash.fildir.ex">
   <title>Examples for Working with Files and Directories</title>
   <para>
    Suppose you want to copy a file located somewhere in your home directory
    to a subdirectory of <filename>/tmp</filename> that you need to create
    first.
   </para>
   <procedure>
    <title>Creating and Changing Directories</title>
    <para>
     From your home directory create a subdirectory in
     <filename>/tmp</filename>:
    </para>
    <step>
     <para>
      Enter
     </para>
<screen>mkdir  /tmp/test</screen>
     <para>
      <command>mkdir</command> stands for <quote>make directory</quote>.
      This command creates a new directory named <filename>test</filename>
      in the <filename>/tmp</filename> directory. In this case, you are
      using an absolute path to create the <filename>test</filename>
      directory.
     </para>
    </step>
    <step>
     <para>
      To check what happened, now enter
     </para>
<screen>ls -l /tmp</screen>
     <para>
      The new directory <filename>test</filename> should appear in the list
      of contents of the <filename>/tmp</filename> directory.
     </para>
    </step>
    <step>
     <para>
      Switch to the newly created directory with
     </para>
<screen>cd /tmp/test</screen>
    </step>
   </procedure>
   <procedure>
    <title>Creating and Copying Files</title>
    <para>
     Now create a new file in a subdirectory of your home directory and copy
     it to <filename>/tmp/test</filename>. Use a relative path for this
     task.
    </para>
    <important>
     <title>Overwriting of Existing Files</title>
     <para>
      Before copying, moving or renaming a file, check if your target
      directory already contains a file with the same name. If yes, consider
      changing one of the filenames or use <command>cp</command> or
      <command>mv</command> with options like <option>-i</option>, which
      will prompt before overwriting an existing file. Otherwise Bash will
      overwrite the existing file without confirmation.
     </para>
    </important>
    <step>
     <para>
      To list the contents of your home directory, enter
     </para>
<screen>ls -l ~</screen>
     <para>
      It should contain a subdirectory called <filename>Documents</filename>
      by default. If not, create this subdirectory with the
      <command>mkdir</command> command you already know:
     </para>
<screen>mkdir ~/Documents</screen>
    </step>
    <step>
     <para>
      To create a new, empty file named <filename>myfile.txt</filename> in
      the <filename>Documents</filename> directory, enter
     </para>
<screen>touch ~/Documents/myfile.txt</screen>
     <para>
      Usually, the <command>touch</command> command updates the modification
      and access date for an existing file. If you use
      <command>touch</command> with a filename which does not exist in your
      target directory, it creates a new file.
     </para>
    </step>
    <step>
     <para>
      Enter
     </para>
<screen>ls -l ~/Documents</screen>
     <para>
      The new file should appear in the list of contents.
     </para>
    </step>
    <step>
     <para>
      To copy the newly created file, enter
     </para>
<screen>cp ~/Documents/myfile.txt .</screen>
     <para>
      Do not forget the dot at the end.
     </para>
     <para>
      This command tells Bash to go to your home directory and to copy
      <filename> myfile.txt</filename> from the
      <filename>Documents</filename> subdirectory to the current directory,
      <filename>/tmp/test</filename>, without changing the name of the file.
     </para>
    </step>
    <step>
     <para>
      Check the result by entering
     </para>
<screen>ls -l</screen>
     <para>
      The file <filename>myfile.txt </filename> should appear in the list of
      contents for <filename>/tmp/test</filename>.
     </para>
    </step>
   </procedure>
   <procedure>
    <title>Renaming and Removing Files or Directories</title>
    <para>
     Now suppose you want to rename <filename>myfile.txt </filename> into
     <filename>tuxfile.txt</filename>. Finally you decide to remove the
     renamed file and the <filename>test</filename> subdirectory.
    </para>
    <step>
     <para>
      To rename the file, enter
     </para>
<screen>mv myfile.txt tuxfile.txt</screen>
    </step>
    <step>
     <para>
      To check what happened, enter
     </para>
<screen>ls -l</screen>
     <para>
      Instead of <filename>myfile.txt</filename>,
      <filename>tuxfile.txt</filename> should appear in the list of
      contents.
     </para>
     <para>
      <command>mv</command> stands for <literal>move</literal> and is used
      with two options: the first option specifies the source, the second
      option specifies the target of the operation. You can use
      <command>mv</command> either
     </para>
     <itemizedlist>
      <listitem>
       <para>
        to rename a file or a directory,
       </para>
      </listitem>
      <listitem>
       <para>
        to move a file or directory to a new location or
       </para>
      </listitem>
      <listitem>
       <para>
        to do both in one step.
       </para>
      </listitem>
     </itemizedlist>
    </step>
    <step>
     <para>
      Coming to the conclusion that you do not need the file any longer, you
      can delete it by entering
     </para>
<screen>rm tuxfile.txt </screen>
     <para>
      Bash deletes the file without any confirmation.
     </para>
    </step>
    <step>
     <para>
      Move up one level with <command>cd ..</command> and check with
     </para>
<screen>ls -l test</screen>
     <para>
      if the <filename>test</filename> directory is empty now.
     </para>
    </step>
    <step>
     <para>
      If yes, you can remove the <filename>test</filename> directory by
      entering
     </para>
<screen>rmdir test</screen>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.new.bash.root">
  <title>Becoming Root</title><indexterm>

  <primary>shell</primary>

  <secondary>root</secondary></indexterm>

  <para>
   &rootuser;, also called the superuser, has privileges which authorize him
   to access all parts of the system and to execute administrative tasks. He
   or she has the unrestricted capacity to make changes to the system and
   has unlimited access to all files. Therefore performing some
   administrative tasks or running certain programs such as &yast; requires
   &rootuser; permissions.
  </para>

  <sect2 xml:id="sec.new.bash.root.su">
   <title>Using <command>su</command></title>
   <para>
    In order to temporarily become &rootuser; in a shell, proceed as
    follows:
   </para>
   <procedure>
    <step>
     <para>
      Enter <command>su</command>. You are prompted for the &rootuser;
      password.
     </para>
    </step>
    <step>
     <para>
      Enter the password. If you mistyped the &rootuser; password, the shell
      displays a message. In this case, you have to re-enter
      <command>su</command> before retyping the password. If your password
      is correct, a hash symbol <literal>#</literal> appears at the end of
      the prompt, signaling that you are acting as &rootuser; now.
     </para>
    </step>
    <step>
     <para>
      Execute your task. For example, transfer ownership of a file to a new
      user which only &rootuser; is allowed to do:
     </para>
<screen>chown &exampleuserII; kde_quick.xml</screen>
    </step>
    <step>
     <para>
      After having completed your tasks as &rootuser;, switch back to your
      normal user account. To do so, enter
     </para>
<screen>exit</screen>
     <para>
      The hash symbol disappears and you are acting as <quote>normal</quote>
      user again.
     </para>
     <remark condition="clarity"> 2007-07-17 - jjaeger: what about su-?
      taroth:
      left that out on purpose as this only makes sense if the user knows
      about environment variables that I didn't want to mention in this newbie
      chapter here... </remark>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="sec.new.bash.root.sudo">
   <title>Using <command>sudo</command></title>
   <para>
    Alternatively, you can also use <command>sudo</command> (superuser
    <quote>do</quote>) to execute some tasks which normally are for
    &rootuser;s only. With sudo, administrators can grant certain users
    &rootuser; privileges for some commands. Depending on the system
    configuration, users can then run &rootuser; commands by entering their
    normal password only. Due to a timestamp function, users are only
    granted a <quote>ticket</quote> for a restricted period of time after
    having entered their password. The ticket usually expires after a few
    minutes. In &opensuse;, sudo requires the &rootuser; password by default
    (if not configured otherwise by your system administrator).
   </para>
   <para>
    For users, sudo is convenient as it prevents you from switching accounts
    twice (to &rootuser; and back again). To change the ownership of a file
    using sudo, only one command is necessary instead of three:
   </para>
<screen>sudo chown &exampleuserII; kde_quick.xml</screen>
   <para>
    After you have entered the password which you are prompted for, the
    command is executed. If you enter a second &rootuser; command shortly
    after that, you are not prompted for the password again, because your
    ticket is still valid. After a certain amount of time, the ticket
    automatically expires and the password is required again. This also
    prevents unauthorized persons from gaining &rootuser; privileges in case
    a user forgets to switch back to his normal user account again and
    leaves a &rootuser; shell open.
   </para>
  </sect2>
 </sect1>
 <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="newbie_perm_i.xml"/>
 <sect1 xml:id="sec.new.bash.feat">
  <title>Useful Features of the Shell</title><indexterm>

  <primary>Bash</primary>

  <secondary>features</secondary></indexterm>

  <para>
   As you probably noticed in the examples above, entering commands in Bash
   can include a lot of typing. In the following, get to know some features
   of the Bash that can make your work a lot easier and save a lot of
   typing.
  </para>

  <variablelist>
   <varlistentry>
    <term>History <indexterm>
     <primary>Bash</primary>
     <secondary>history</secondary></indexterm><indexterm>
     <primary>History</primary>
     <secondary>Bash</secondary></indexterm>
    </term>
    <listitem>
     <para>
      By default, Bash <quote>remembers</quote> commands you have entered.
      This feature is called <emphasis>history</emphasis>. You can browse
      through commands that have been entered before, select one you want to
      repeat and then execute it again. To do so, press
      <keycap
       function="up"/> repeatedly until the desired command
      appears at the prompt. To move forward through the list of previously
      entered commands, press <keycap function="down"/>. For easier
      repetition of a certain command from Bash history, just type the first
      letter of the command you want to repeat and press
      <keycap function="pageup"/>.
     </para>
     <para>
      You can now edit the selected command (for example, change the name of
      a file or a path), before you execute the command by pressing
      <keycap function="enter"/>. To edit the command line, just move the
      cursor to the desired position using the arrow keys and start typing.
     </para>
     <para>
      You can also search for a certain command in the history. Press
      <keycombo> <keycap function="control"/> <keycap>R</keycap> </keycombo>
      to start an incremental search function. showing the following prompt:
     </para>
<screen> (reverse-i-search)`': </screen>
     <para>
      Just type one or several letters from the command you are searching
      for. Each character you enter narrows down the search. The
      corresponding search result is shown on the right side of the colon
      whereas your input appears on the left of the colon. To accept a
      search result, press <keycap function="escape"/>. The prompt now
      changes to its normal appearance and shows the command you chose. You
      can now edit the command or directly execute it by pressing
      <keycap
       function="enter"/>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Completion<indexterm>
     <primary>Bash</primary>
     <secondary>completion</secondary></indexterm><indexterm>
     <primary>Completion</primary>
     <secondary>Bash</secondary></indexterm>
    </term>
    <listitem>
     <para>
      Completing a filename or directory name to its full length after
      typing its first letters is another helpful feature of Bash. To do so,
      type the first letters then press <keycap function="tab"/>
      (Tabulator). If the filename or path can be uniquely identified, it is
      completed at once and the cursor moves to the end of the filename. You
      can then enter the next option of the command, if necessary. If the
      filename or path cannot be uniquely identified (because there are
      several filenames starting with the same letters), the filename or
      path is only completed up to the point where it becomes ambiguous
      again. You can then obtain a list of them by pressing
      <keycap function="tab"/> a second time. After this, you can enter the
      next letters of the file or path then try completion again by pressing
      <keycap
       function="tab"/>. When completing filenames and paths
      with the help of <keycap function="tab"
      />, you can
      simultaneously check whether the file or path you want to enter really
      exists (and you can be sure of getting the spelling right).
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Wild Cards <indexterm>
     <primary>Bash</primary>
     <secondary>wild cards</secondary></indexterm><indexterm>
     <primary>Wild Cards</primary>
     <secondary>Bash</secondary></indexterm>
    </term>
    <listitem>
     <para>
      You can replace one or more characters in a filename with a wild card
      for pathname expansion. Wild cards are characters that can stand for
      other characters. There are three different types of these in Bash:
     </para>
     <informaltable>
      <tgroup cols="2">
       <tbody>
        <row>
         <entry>
          <para>
           Wild Card
          </para>
         </entry>
         <entry>
          <para>
           Function
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
           <literal>?</literal>
          </para>
         </entry>
         <entry>
          <para>
           Matches exactly one arbitrary character
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
           <literal>*</literal>
          </para>
         </entry>
         <entry>
          <para>
           Matches any number of characters
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
           <literal>[<replaceable>set</replaceable>]</literal>
          </para>
         </entry>
         <entry>
          <para>
           Matches one of the characters from the group specified inside the
           square brackets, which is represented here by the string
           <replaceable>set</replaceable>.
          </para>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </listitem>
   </varlistentry>
  </variablelist>

  <sect2 xml:id="sec.new.bash.feat.ex">
   <title>Examples For Using History, Completion and Wildcards</title>
   <para>
    The following examples illustrate how to make use of these convenient
    features of Bash.
   </para>
   <procedure>
    <title>Using History and Completion</title>
    <para>
     If you already did the example <xref linkend="sec.new.bash.fildir.ex"/>
     your shell buffer should be filled with commands which you can retrieve
     using the history function.
    </para>
    <step>
     <para>
      Press <keycap function="up"/> repeatedly until <command>cd ~</command>
      appears.
     </para>
    </step>
    <step>
     <para>
      Press <keycap function="enter"/> to execute the command and to switch
      to your home directory.
     </para>
     <para>
      By default, your home directory contains two subdirectories starting
      with the same letter, <filename>Documents</filename> and
      <filename>Desktop</filename>.
     </para>
    </step>
    <step>
     <para>
      Enter <command>cd D</command> and press <keycap function="tab"/>.
     </para>
     <para>
      Nothing happens since Bash cannot identify to which one of the
      subdirectories you want to change.
     </para>
    </step>
    <step>
     <para>
      Press <keycap function="tab"/> again to see the list of possible
      choices:
     </para>
<screen>tux@knox:~> cd D Desktop/   Documents/ tux@knox:~> cd D</screen>
    </step>
    <step>
     <para>
      The prompt still shows your initial input. Type the next character of
      the subdirectory you want to go to and press <keycap function="tab"/>
      again.
     </para>
     <para>
      Bash now completes the path.
     </para>
    </step>
    <step>
     <para>
      You can now execute the command with <keycap function="enter"/>.
     </para>
    </step>
   </procedure>
   <procedure>
    <title>Using Wildcards</title>
    <para>
     Now suppose that your home directory contains a number of files with
     various file extensions. It also holds several versions of one file
     which you saved under different filenames
     <filename>myfile1.txt</filename>, <filename>myfile2.txt</filename> etc.
     You want to search for certain files according to their properties.
    </para>
    <step>
     <para>
      First, create some test files in your home directory:
     </para>
     <substeps>
      <step>
       <para>
        Use the <command>touch</command> command to create several (empty)
        files with different file extensions, for example
        <filename>.pdf</filename>, <filename>.xml</filename> and
        <filename>.jpg</filename>.
       </para>
       <para>
        You can do this consecutively (do not forget to use the Bash history
        function) or with only one <command>touch</command> command: simply
        add several filenames separated by a space.
       </para>
      </step>
      <step>
       <para>
        Create at least two files that have the same file extension, for
        example <filename>.html</filename>.
       </para>
      </step>
      <step>
       <para>
        To create several <quote>versions</quote> of one file, enter
       </para>
<screen>touch myfile{1..5}.txt</screen>
       <para>
        This command creates five consecutively numbered files:
       </para>
<screen>myfile1.txt,&hellip;,myfile5.txt</screen>
      </step>
      <step>
       <para>
        List the contents of your home directory. It should look similar to
        this:
       </para>
<screen>-rw-r--r-- 1 tux users   0 2006-07-14 13:34 foo.xml
-rw-r--r-- 1 tux users   0 2006-07-14 13:47 home.html
-rw-r--r-- 1 tux users   0 2006-07-14 13:47 index.html
-rw-r--r-- 1 tux users   0 2006-07-14 13:47 toc.html
-rw-r--r-- 1 tux users   0 2006-07-14 13:34 manual.pdf
-rw-r--r-- 1 tux users   0 2006-07-14 13:49 myfile1.txt
-rw-r--r-- 1 tux users   0 2006-07-14 13:49 myfile2.txt
-rw-r--r-- 1 tux users   0 2006-07-14 13:49 myfile3.txt
-rw-r--r-- 1 tux users   0 2006-07-14 13:49 myfile4.txt
-rw-r--r-- 1 tux users   0 2006-07-14 13:49 myfile5.txt
-rw-r--r-- 1 tux users   0 2006-07-14 13:32 tux.png
       </screen>
      </step>
     </substeps>
    </step>
    <step>
     <para>
      With the help of wild cards, select certain subsets of the files
      according to various criteria:
     </para>
     <substeps>
      <step>
       <para>
        To list all files with the <filename>.html</filename> extension,
        enter
       </para>
<screen> ls -l *.html</screen>
      </step>
      <step>
       <para>
        To list all <quote>versions</quote> of
        <filename>myfile.txt</filename>, enter
       </para>
<screen>ls -l myfile?.txt</screen>
       <para>
        Note that you can only use the <literal>?</literal> wild card here
        because the numbering of the files is single-digit. As soon as you
        have a file named <filename>myfile10.txt</filename> you must to use
        the <literal>*</literal> wild card to view all versions of
        <filename>myfile.txt</filename> (or add another question mark, so
        your string looks like <command>myfile??.txt</command>).
       </para>
      </step>
      <step>
       <para>
        To remove, for example, version 1-3 and version 5 of
        <filename>myfile.txt</filename>, enter
       </para>
<screen>rm myfile[1-3,5].txt</screen>
      </step>
      <step>
       <para>
        Check the result with
       </para>
<screen>ls -l</screen>
       <para>
        Of all <filename>myfile.txt</filename> versions only
        <filename>myfile4.txt</filename> should be left.
       </para>
      </step>
     </substeps>
    </step>
   </procedure>
   <para>
    You can also combine several wild cards in one command. In the example
    above, <command>rm myfile[1-3,5].*</command> would lead to the same
    result as <command>rm myfile[1-3,5].txt</command> because there are only
    files with the extension <filename>.txt</filename> available.
   </para>
   <note>
    <title>Using Wildcards in rm Commands</title>
    <para>
     Wildcards in a <command>rm </command> command can be very useful but
     also dangerous: you might delete more files from your directory than
     intended. To see which files would be affected by the
     <command>rm</command>, run your wildcard string with
     <command>ls</command> instead of <command>rm</command> first.
    </para>
   </note>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.new.bash.edit">
  <title>Editing Texts</title><indexterm>

  <primary>files</primary>

  <secondary>editing</secondary></indexterm><indexterm>

  <primary>vi</primary></indexterm><indexterm>

  <primary>editor</primary>

  <secondary>vi</secondary></indexterm>

  <para>
   In order to edit files from the command line, you will need to know the
   vi editor. vi is a default editor which can be found on nearly every
   UNIX/Linux system. It can run several operating modes in which the keys
   you press have different functions. This does not make it very easy for
   beginners, but you should know at least the most basic operations with
   vi. There may be situations where no other editor than vi is available.
  </para>

  <para>
   Basically, vi makes use of three operating modes:
  </para>

  <variablelist>
   <varlistentry>
    <term><emphasis>command</emphasis> mode</term>
    <listitem>
     <para>
      In this mode, vi accepts certain key combinations as commands. Simple
      tasks such as searching words or deleting a line can be executed.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><emphasis>insert</emphasis> mode</term>
    <listitem>
     <para>
      In this mode, you can write normal text.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><emphasis>extended</emphasis> mode</term>
    <listitem>
     <para>
      In this mode, also known as colon mode (as you have to enter a colon
      to switch to this mode), vi can execute also more complex tasks such
      as searching and replacing text.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   In the following (very simple) example, you will learn how to open and
   edit a file with vi, how to save your changes and quit vi.
  </para>

  <sect2 xml:id="sec.new.bash.edit.ex">
   <title>Example: Editing with vi</title>
   <procedure>
    <note>
     <title>Display of Keys</title>
     <para>
      In the following, find several commands that you can enter in vi by
      just pressing keys. These appear in uppercase as on a keyboard. If you
      need to enter a key in uppercase, this is stated explicitly by showing
      a key combination including the <keycap function="shift"/> key.
     </para>
    </note>
    <step>
     <para>
      To create and open a new file with vi, enter
     </para>
<screen>vi textfile.txt</screen>
     <para>
      By default, vi opens in <emphasis>command</emphasis> mode in which you
      cannot enter text.
     </para>
    </step>
    <step>
     <para>
      Press <keycap>I</keycap> to switch to insert mode. The bottom line
      changes and indicates that you now can insert text.
     </para>
    </step>
    <step>
     <para>
      Write some sentences. If you want to insert a new line, first press
      <keycap
       function="escape"/> to switch back to command mode.
      Press <keycap>O</keycap> to insert a new line and to switch to insert
      mode again.
     </para>
    </step>
    <step>
     <para>
      In the insert mode, you can edit the text with the arrow keys and with
      <keycap
       function="delete"/>.
     </para>
    </step>
    <step>
     <para>
      To leave vi, press <keycap function="escape"/> to switch to command
      mode again. Then press <keycap>:</keycap> which takes you to the
      extended mode. The bottom line now shows a colon.
     </para>
    </step>
    <step>
     <para>
      To leave vi and save your changes, type <command>wq</command>
      (<literal>w</literal> for <literal>write</literal>;
      <literal>q</literal> for <literal>quit</literal>) and press
      <keycap
       function="enter"/>. If you want to save the file under
      a different name, type <command>w
      <replaceable>filename</replaceable></command> and press
      <keycap function="enter"/>.
     </para>
     <para>
      To leave vi without saving, type <command>q!</command> instead and
      press <keycap
       function="enter"/>.
     </para>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.new.bash.search">
  <title>Searching for Files or Contents</title><indexterm>

  <primary>files</primary>

  <secondary>searching</secondary></indexterm><indexterm>

  <primary>Bash</primary>

  <secondary>searching</secondary></indexterm>

  <para>
   Bash offers you several commands to search for files and to search for
   the contents of files:
  </para>

  <variablelist>
   <varlistentry>
    <term><command>locate</command><indexterm>
     <primary>commands</primary>
     <secondary>locate</secondary></indexterm>
    </term>
    <listitem>
     <para>
      This utility is only available if you have installed the
      <systemitem class="resource"
       >findutils-locate</systemitem>
      package. With this command you can find out in which directory a
      specified file is located. If desired, use wild cards to specify
      filenames. The program is very quick, because it uses a database
      specifically created for the purpose (rather than searching through
      the entire file system). This very fact, however, also results in a
      major drawback: locate is unable to find any files created after the
      latest update of its database. The database can be generated by
      &rootuser; running
      <command>updatedb</command>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>find</command><indexterm>
     <primary>commands</primary>
     <secondary>find</secondary></indexterm>
    </term>
    <listitem>
     <para>
      With <command>find</command>, search for a file in a given directory.
      The first argument specifies the directory in which to start the
      search. The option <option>-name</option> must be followed by a search
      string, which may also include wild cards. Unlike
      <command>locate</command>, which uses a database,
      <command>find</command> scans the actual directory.
     </para>
    </listitem>
   </varlistentry>
<!-- taroth 060717: this does not really match the topic of this section-->
<!--<varlistentry>
    <term>file</term>
    <listitem>
     <para>As files in Linux may have a file extensions but do not need to have
      one the <command>file</command> helps you to determine the file type of a
      given file. According to the output of <command>file</command> you can
      then choose an appropriate application with which to open the file. For
      images or multimedia files, <command>find</command> also shows some
      properties of the file (depending on the program or camera with which the
      image has been created).</para> </listitem>
   </varlistentry>-->
   <varlistentry>
    <term><command>grep</command><indexterm>
     <primary>commands</primary>
     <secondary>grep</secondary></indexterm>
    </term>
    <listitem>
     <para>
      The <command>grep</command> command finds a specific search string in
      the specified text files. If the search string is found, the command
      displays the line in which <literal>searchstring</literal> was found,
      along with the filename. If desired, use wild cards to specify
      filenames.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <sect2>
   <title>Examples for Searching</title>
   <procedure>
    <para>
     The KDE and GNOME desktops store user-specific application data in
     hidden directories, for example <filename>.kde</filename> and
     <filename>.gnome</filename>.
    </para>
    <step>
     <para>
      To locate these directories on your computer, enter
     </para>
<screen>locate .kde</screen>
     <para>
      if you have installed KDE desktop or
     </para>
<screen>locate .gnome</screen>
     <para>
      if you have installed GNOME desktop.
     </para>
     <para>
      You will see that <command>locate</command> displays all file names in
      the database that contain the string <literal>.kde</literal> or
      <literal>.gnome</literal> anywhere. To learn how to modify this
      behavior refer to the man page of <command>locate</command>.
     </para>
    </step>
    <step>
     <para>
      To search your home directory for all occurrences of filenames that
      contain the file extension <filename>.txt</filename>, use
     </para>
<screen>find ~ -name '*.txt' -print</screen>
    </step>
<!-- taroth 060717: this does not really match the topic of this section-->
<!-- <step><para>You home directory by default contains the file
      <filename>.bash_history</filename> which stores the commands you entered.
       To view the file type of this file, enter <command>file
        .bash_history</command>.
      </para></step>-->
    <step>
     <para>
      To search a directory (in this case, your home directory) for all
      occurrences of files which contain, for example, the word
      <literal>music</literal>, enter
     </para>
<screen>grep music ~/*</screen>
     <para>
      Note that grep is case-sensitive&mdash; unless you use it with the
      <option>-i</option> option. With the command above you will not find
      any files containing <literal>Music</literal>.
     </para>
     <para>
      If you want to use a search string which consists of more than one
      word, enclose the string in double quotation marks, for example:
     </para>
<screen>grep "music is great" ~/*</screen>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.new.bash.view">
  <title>Viewing Text Files</title><indexterm>

  <primary>files</primary>

  <secondary>viewing</secondary></indexterm>

  <para>
   When searching for the contents of a file with <command>grep</command>,
   the output gives you the line in which the
   <literal>searchstring</literal> was found along with the filename. Often
   this contextual information is still not enough information to decide
   whether you want to open and edit this file. Bash offers you several
   commands to have a quick look at the contents of a text file directly in
   the shell, without opening an editor.
  </para>

  <variablelist>
   <varlistentry>
    <term><command>head</command><indexterm>
     <primary>commands</primary></indexterm><indexterm>
     <primary>head</primary></indexterm>
    </term>
    <listitem>
     <para>
      With <command>head</command> you can view the first lines of a text
      file. If you do not specify the command any further,
      <command>head</command> shows the first 10 lines of a text file.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>tail</command><indexterm>
     <primary>commands</primary></indexterm><indexterm>
     <primary>tail</primary></indexterm>
    </term>
    <listitem>
     <para>
      The <command>tail</command> command is the counterpart of
      <command>head</command>. If you use <command>tail</command> without
      any further options it displays the last 10 lines of a text file. This
      can be very useful to view log files of your system, where the most
      recent messages or log entries are usually found at the end of the
      file.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>less</command><indexterm>
     <primary>commands</primary></indexterm><indexterm>
     <primary>less</primary></indexterm>
    </term>
    <listitem>
     <para>
      With <command>less</command>, display the whole contents of a text
      file. To move up and down half a page use <keycap function="pageup"/>
      and <keycap function="pagedown"/>. Use <keycap function="space"/> to
      scroll down one page. <keycap function="home"/> takes you to the
      beginning, and <keycap function="end"/> to the end of the document. To
      end the viewing mode, press <keycap>Q</keycap>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>more</command><indexterm>
     <primary>commands</primary></indexterm><indexterm>
     <primary>more</primary></indexterm>
    </term>
    <listitem>
     <para>
      Instead of <literal>less</literal>, you can also use the older program
      <literal>more</literal>. It has basically the same
      function&mdash;however, it is less convenient because it does not
      allow you to scroll backwards. Use <keycap function="space"/> to move
      forward. When you reach the end of the document, the viewer closes
      automatically.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>cat</command><indexterm>
     <primary>commands</primary></indexterm><indexterm>
     <primary>cat</primary></indexterm>
    </term>
    <listitem>
     <para>
      The <command>cat</command> command displays the contents of a file,
      printing the entire contents to the screen without interruption. As
      <command>cat</command> does not allow you to scroll it is not very
      useful as viewer but it is rather often used in combination with other
      commands.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

<!--<para> The program less got its name from the the precept that
   <emphasis>less is more</emphasis> and can also be used to view
   the output of commands in a convenient way. To see how this
   works, read <xref linkend="sec.bash.feat.pipes"></xref>.
  </para>-->
 </sect1>
 <sect1 xml:id="sec.new.bash.redir">
  <title>Redirection and Pipes</title><indexterm>

  <primary>shell</primary>

  <secondary>pipes</secondary></indexterm><indexterm>

  <primary>Bash</primary>

  <secondary>pipes</secondary></indexterm><indexterm>

  <primary>shell</primary>

  <secondary>redirection</secondary></indexterm><indexterm>

  <primary>Bash</primary>

  <secondary>redirection</secondary></indexterm><indexterm>

  <primary>redirection</primary>

  <secondary>shell</secondary></indexterm><indexterm>

  <primary>pipes</primary>

  <secondary>shell</secondary></indexterm>

  <para>
   Sometimes it would be useful if you could write the output of a command
   to a file for further editing or if you could combine several commands,
   using the output of one command as the input for the next one. The shell
   offers this function by means of redirection or pipes.
  </para>

  <para>
   Normally, the standard output in the shell is your screen (or an open
   shell window) and the standard input is the keyboard. With the help of
   certain symbols you can redirect the input or the output to another
   object, such as a file or another command.
  </para>

  <variablelist>
   <varlistentry>
    <term>Redirection</term>
    <listitem>
     <para>
      With <literal>&gt;</literal> you can forward the output of a command
      to a file (output redirection), with <literal>&lt;</literal> you can
      use a file as input for a command (input redirection).
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Pipe</term>
    <listitem>
     <para>
      By means of a pipe symbol <literal>|</literal> you can also redirect
      the output: with a pipe, you can combine several commands, using the
      output of one command as input for the next command. In contrast to
      the other redirection symbols &gt; and &lt;, the use of the pipe is
      not constrained to files.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <sect2 xml:id="sec.new.bash.redir.ex">
   <title>Examples for Redirection and Pipe</title>
   <procedure>
    <step>
     <para>
      To write the output of a command like <command>ls</command> to a file,
      enter
     </para>
<screen>ls -l &gt; filelist.txt</screen>
     <para>
      This creates a file named <filename>filelist.txt</filename> that
      contains the list of contents of your current directory as generated
      by the <command>ls</command> command.
     </para>
     <para>
      However, if a file named <filename>filelist.txt</filename> already
      exists, this command overwrites the existing file. To prevent this,
      use <literal>&gt;&gt;</literal> instead of &gt;. Entering
     </para>
<screen>ls -l &gt;&gt; filelist.txt </screen>
     <para>
      simply appends the output of the <command>ls</command> command to an
      already existing file named <filename>filelist.txt</filename>. If the
      file does not exist, it is created.
     </para>
    </step>
    <step>
     <para>
      Redirections also works the other way round. Instead of using the
      standard input from the keyboard for a command, you can use a file as
      input:
     </para>
<screen>sort &lt; filelist.txt</screen>
     <para>
      This will force the <command>sort</command> command to get its input
      from the contents of <filename>filelist.txt</filename>. The result is
      shown on the screen. Of course, you can also write the result into
      another file, using a combination of redirections:
     </para>
<screen>sort  &lt; filelist.txt &gt; sorted_filelist.txt</screen>
    </step>
    <step>
     <para>
      If a command generates a lengthy output, like <command>ls</command>
      <option>-l</option> may do, it may be useful to pipe the
      output to a viewer like <literal>less</literal> to be able to scroll
      through the pages. To do so, enter
     </para>
<screen>ls -l | less</screen>
     <para>
      The list of contents of the current directory is shown in
      <literal>less</literal>.
     </para>
     <para>
      The pipe is also often used in combination with the
      <command>grep</command> command in order to search for a certain
      string in the output of another command. For example, if you want to
      view a list of files in a directory which are owned by the user
      &exampleuser;, enter
     </para>
<screen>ls -l | grep tux</screen>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.new.bash.jobs">
  <title>Starting Programs and Handling Processes</title><indexterm>

  <primary>shell</primary>

  <secondary>processes</secondary></indexterm><indexterm>

  <primary>Bash</primary>

  <secondary>processes</secondary></indexterm><indexterm>

  <primary>shell</primary>

  <secondary>jobs</secondary></indexterm><indexterm>

  <primary>Bash</primary>

  <secondary>jobs</secondary></indexterm><indexterm>

  <primary>processes</primary>

  <secondary>shell</secondary></indexterm><indexterm>

  <primary>jobs</primary>

  <secondary>shell</secondary></indexterm>

  <para>
   As you have seen in <xref linkend="sec.new.bash.edit"/>, programs can be
   started from the shell. Applications with a graphical user interface need
   the X Window System and can only be started from a terminal window within
   a graphical user interface. For example, if you want to open a file named
   <filename>vacation.pdf</filename> in your home directory from a terminal
   window in KDE or GNOME, simply run
   <command>okular&nbsp;~/vacation.pdf</command> (or
   <command>evince&nbsp;~/vacation.pdf</command>) to start a PDF viewer
   displaying your file.
  </para>

  <para>
   When looking at the terminal window again you will realize that the
   command line is blocked as long as the PDF viewer is open, meaning that
   your prompt is not available. To change this, press <keycombo>
   <keycap function="control"/> <keycap>Z</keycap> </keycombo> to suspend
   the process and enter <indexterm>
   <primary>commands</primary>
   <secondary>bg</secondary>
   </indexterm> <command>bg</command> to send the process to the background.
   Now you can still have a look at <filename>vacation.pdf</filename> while
   your prompt is available for further commands. An easier way to achieve
   this is by sending a process to the background directly when starting it.
   To do so, add an ampersand at the end of the command:
  </para>

<screen>okular ~/vacation.pdf &amp;</screen>

  <para>
   If you have started several background processes (also named jobs) from
   the same shell, the <command>jobs</command> <indexterm>
   <primary>commands</primary>
   <secondary>jobs</secondary>
   </indexterm> command gives you an overview of the jobs. It also shows the
   job number in brackets and their status:
  </para>

<screen>tux@linux:~&gt; jobs
[1]   Running        okular book.opensuse.startup-xep.pdf &amp;
[2]-  Running        okular book.opensuse.reference-xep.pdf &amp;
[3]+  Stopped        man jobs</screen>

  <para>
   To bring a job to the foreground again, enter <indexterm>
   <primary>commands</primary>
   <secondary>fg</secondary>
   </indexterm> <command>fg <replaceable>job_number</replaceable></command>.
  </para>

  <para>
   <indexterm>
   <primary>commands</primary>
   <secondary>ps</secondary>
   </indexterm> Whereas <command>job</command> only shows the background
   processes started from a specific shell, the <command>ps</command>
   command (run without options) shows a list of all your
   processes&mdash;those you started. Find an example output below:
  </para>

<screen>tux@linux:~&gt; ps
PID TTY          TIME CMD
15500 pts/1    00:00:00 bash
28214 pts/1    00:00:00 okular
30187 pts/1    00:00:00 kwrite
30280 pts/1    00:00:00 ps</screen>

  <para>
   <indexterm>
   <primary>commands</primary>
   <secondary>kill</secondary>
   </indexterm> In case a program cannot be terminated in the normal way,
   use the <command>kill</command> command to stop the process (or
   processes) belonging to that program. To do so, specify the process ID
   (PID) shown by the output of <command>ps</command>. For example, to shut
   down the KWrite editor in the example above, enter
  </para>

<screen>kill 30187</screen>

  <para>
   This sends a <emphasis>TERM</emphasis> signal that instructs the program
   to shut itself down.
  </para>

  <para>
   Alternatively, if the program or process you want to terminate is a
   background job and is shown by the <command>jobs</command> command, you
   can also use the <command>kill</command> command in combination with the
   job number to terminate this process. When identifying the job with the
   job number, you must prefix the number with a percent character
   (<literal>%</literal>):
  </para>

<screen>kill %<replaceable>job_number</replaceable></screen>

  <para>
   If <command>kill</command> does not help&mdash;as is sometimes the case
   for <quote>runaway</quote> programs&mdash;try
  </para>

<screen>kill -9 <replaceable>PID</replaceable></screen>

  <para>
   This sends a <emphasis>KILL</emphasis> signal instead of a
   <emphasis>TERM</emphasis> signal, bringing the specified process to an
   end in most cases.
  </para>

  <para>
   This section is intended to introduce the most basic set of commands for
   handling jobs and processes. Find an overview for system administrators
   in <xref linkend="sec.util.processes"/>.
  </para>
 </sect1>
 <xi:include
  xmlns:xi="http://www.w3.org/2001/XInclude" href="newbie_bash_commands_i.xml"/>
</chapter>
<!--taroth: 06-09-29: taken from bash.xml - revise and integrate for next
   release -->
<!--
 <sect2 xml:id="sec.bash.tar">
  <title>Archives and Data Compression</title>
  <indexterm>
   <primary>commands</primary>
   <secondary>tar</secondary>
  </indexterm>
  <indexterm>
   <primary>tar</primary>
  </indexterm>
  <indexterm>
   <primary>files</primary>
   <secondary>compressing</secondary>
  </indexterm>
  <indexterm>
   <primary>files</primary>
   <secondary>archiving</secondary>
  </indexterm>
  <para> Now that you have already created a number of files and
   directories, consider the subject of archives and data
   compression. Suppose you want to have the entire
   <filename>test</filename> directory packed in one file that you
   can save on a USB stick as a backup copy or send by e-mail. To do
   so, use the command <command>tar</command> (for <emphasis>tape
    archiver</emphasis>). With <command>tar MINUS MINUS help</command>, view
   all the options for the <command>tar</command> command. The most
   important of these options are explained here: </para>
  <variablelist>
   <varlistentry>
    <term>-c</term>
    <listitem>
     <para>(for create) Create a new archive.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>-t</term>
    <listitem>
     <para>(for table) Display the contents of an archive.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>-x</term>
    <listitem>
     <para>(for extract) Unpack the archive.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>-v</term>
    <listitem>
     <para>(for verbose) Show all files on screen while creating
      the archive.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>-f</term>
    <listitem>
     <para>(for file) Choose a filename for the archive file. When
      creating an archive, this option must always be given as the
      last one.</para>
    </listitem>
   </varlistentry>
  </variablelist>
  <para>To pack the <filename>test</filename> directory with all its
   files and subdirectories into an archive named
   <filename>testarchive.tar</filename>, do the following:</para>
  <procedure>
   <step>
    <para>Open a shell.</para>
   </step>
   <step>
    <para>Use <command>cd</command> to your home directory where the
     <filename>test</filename> directory is located.</para>
   </step>
   <step>
    <para>Enter
     <command>tar -cvf testarchive.tar test</command>.
     The <option>-c</option> option creates the archive, making it a file
     as directed by
     <option>-f</option>. The <option>-v</option> option lists the files as
     they are processed.</para>
   </step>
   <step>
    <para>View the contents of the archive file with
     <command>tar -tf testarchive.tar</command>.</para>
   </step>
  </procedure>

  <para>The <filename>test</filename> directory with all its files and
   directories has remained unchanged on your hard disk. To unpack the archive,
   enter <command>tar -xvf testarchive.tar</command>, but do not try this
   yet. </para>

  <para> For file compression, the obvious choice is
   <command>gzip</command> or, for a even better compression ratio,
   <command>bzip2</command>. <indexterm>
    <primary>gzip</primary>
   </indexterm>
   <indexterm>
    <primary>commands</primary>
    <secondary>gzip</secondary>
   </indexterm>
   <indexterm>
    <primary>bzip2</primary>
   </indexterm>
   <indexterm>
    <primary>commands</primary>
    <secondary>bzip2</secondary>
   </indexterm> Just enter <command>gzip testarchive.tar</command>
   (or <command>bzip2 testarchive.tar</command>, but
   <command>gzip</command> is used in this example). With
   <command>ls</command>, now see that the file
   <filename>testarchive.tar</filename> is no longer there and that
   the file <filename>testarchive.tar.gz</filename> has been created
   instead. This file is much smaller and therefore much better
   suited for transfer via e-mail or storage on a USB stick. </para>
  <para> Now, unpack this file in the <filename>test2</filename>
   directory created earlier. To do so, enter
   <command>cp
    testarchive.tar.gz test2</command> to copy the
   file to that directory. Change to the directory with
   <command>cd
    test2</command>. A compressed archive with the
   <systemitem>.tar.gz</systemitem> extension can be unzipped <indexterm>
    <primary>files</primary>
    <secondary>uncompressing</secondary>
   </indexterm> with the <command>gunzip</command> command. Enter
   <command>gunzip testarchive.tar.gz</command>, <indexterm>
    <primary>gunzip</primary>
   </indexterm> which results in the file
   <filename>testarchive.tar</filename>, which then needs to be
   extracted or <emphasis>untarred</emphasis> with
   <command>tar -xvf
    testarchive.tar</command>. You can also
   unzip and extract a compressed archive in one step with
   <command>tar -xvf
    testarchive.tar.gz</command> (adding the
   <systemitem>-z</systemitem> option is no longer required). With
   <command>ls</command>, you can see that a new
   <filename>test</filename> directory has been created with the same
   contents as your <filename>test</filename> directory in your home
   directory. </para>
 </sect2>
-->
