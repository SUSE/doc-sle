<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="containers-docker-containerize-app.xml" xml:id="cha-docker-containerize-app" xml:lang="zh-cn" version="5.0">
 <info>
  <title>创建应用程序映像</title>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>
 <para>
  使用 Docker 开源引擎可以同时运行多个独立的应用程序环境，与使用整个虚拟机相比，所需的资源用量更少。有多种类型的应用程序适合在容器内部运行：守护程序、Web 服务器以及公开 IP 通讯端口的应用程序。您可以使用 Docker 开源引擎通过在容器内部执行构建过程、构建映像，然后部署基于映像的容器来自动完成构建和部署过程。
 </para>
 <para>
  在容器内部运行应用程序具有以下优势：
 </para>
 <itemizedlist>
  <listitem>
   <para>
    包含应用程序的映像可在运行不同 Linux 主机发行套件和版本的服务器之间移植。
   </para>
  </listitem>
  <listitem>
   <para>
    可以使用软件源来共享应用程序的映像。
   </para>
  </listitem>
  <listitem>
   <para>
    可以在容器和主机系统中使用不同的软件版本，而不会造成依赖关系方面的问题。
   </para>
  </listitem>
  <listitem>
   <para>
    可以运行同一应用程序多个彼此完全独立的实例。
   </para>
  </listitem>
 </itemizedlist>
 <para>
  使用 Docker 开源引擎构建应用程序具有以下优势：
 </para>
 <itemizedlist>
  <listitem>
   <para>
    可以准备整个构建环境的映像。
   </para>
  </listitem>
  <listitem>
   <para>
    应用程序可以在构建它的同一个环境中运行。
   </para>
  </listitem>
  <listitem>
   <para>
    开发人员可以在同一环境中测试其代码，就如同在生产环境中使用时一样。
   </para>
  </listitem>
 </itemizedlist>
 <para>
  下一节提供了有关为应用程序创建容器映像的示例和建议。在继续操作之前，请确保已按照<xref linkend="sec-download-prebuild-images"/>中所述激活 <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 基本映像。
 </para>
 <sect1 xml:id="sec-application-with-specific-dependencies">
  <title>运行采用特定软件包版本的应用程序</title>

  <para>
   如果您的应用程序所需的软件包版本不同于系统上安装的软件包版本，您可以创建一个包含应用程序所需软件包版本的容器映像。下面的示例 <filename>Dockerfile</filename> 允许使用较旧的 <literal>example</literal> 软件包版本构建基于最新 <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 版本的映像：
  </para>

<screen>FROM registry.suse.com/suse/sle15
LABEL maintainer=tux
RUN zypper ref &amp;&amp; zypper in -f example-1.0.0-0
COPY application.rpm /tmp/
RUN zypper --non-interactive in /tmp/application.rpm
ENTRYPOINT ["/etc/bin/application"]
CMD ["-i"]</screen>

  <para>
   通过在 <filename>Dockerfile</filename> 所在的目录中运行以下命令来构建映像：
  </para>

<screen><prompt>&gt; </prompt>docker build --tag tux_application:latest .</screen>

  <para>
   上面显示的 <filename>Dockerfile</filename> 示例会在 <command>docker build</command> 运行期间执行以下操作：
  </para>

  <orderedlist>
   <listitem>
    <para>
     更新 <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 软件源。
    </para>
   </listitem>
   <listitem>
    <para>
     安装所需的 <literal>example</literal> 软件包版本。
    </para>
   </listitem>
   <listitem>
    <para>
     将应用程序软件包复制到映像。必须在构建环境中放置二进制 RPM。
    </para>
   </listitem>
   <listitem>
    <para>
     将应用程序解包。
    </para>
   </listitem>
   <listitem>
    <para>
     最后两个步骤会在容器启动后运行应用程序。
    </para>
   </listitem>
  </orderedlist>

  <para>
   成功构建 <literal>tux_application</literal> 映像后，可使用以下命令启动基于新映像的容器：
  </para>

<screen><prompt>&gt; </prompt>docker run -it --name application_instance tux_application:latest</screen>

  <para>
   请记住，关闭应用程序后，容器也会退出。
  </para>
 </sect1>
 <sect1 xml:id="sec-applications-with-configuration">
  <title>运行采用特定配置的应用程序</title>

  <para>
   要运行使用不同配置的实例，请创建派生映像并在其中包含附加配置。例如，如果您的应用程序名为 <emphasis>example</emphasis> 且可以使用 <filename>/etc/example/configuration_example</filename> 文件来配置，则您可以使用：
  </para>

<screen>FROM registry.suse.com/suse/sle15 <co xml:id="co-dockerfile-specificconf-from"/>
RUN zypper ref &amp;&amp; zypper --non-interactive in example <co xml:id="co-dockerfile-specificconf-refreshinstall"/>
ENV BACKUP=/backup <co xml:id="co-dockerfile-specificconf-env"/>
RUN mkdir -p $BACKUP <co xml:id="co-dockerfile-specificconf-mkdir"/>
COPY configuration_example /etc/example/ <co xml:id="co-dockerfile-specificconf-configuration"/>
ENTRYPOINT ["/etc/bin/example"] <co xml:id="co-dockerfile-specificconf-entrypoint"/></screen>

  <para>
   上面的示例 <filename>Dockerfile</filename> 会执行以下操作：
  </para>

  <calloutlist>
   <callout arearefs="co-dockerfile-specificconf-from">
    <para>
     从 <xref linkend="sec-download-prebuild-images"/> 中提取 <literal>sle15</literal> 基本映像。
    </para>
   </callout>
   <callout arearefs="co-dockerfile-specificconf-refreshinstall">
    <para>
     刷新 <emphasis>example</emphasis> 的软件源和安装。
    </para>
   </callout>
   <callout arearefs="co-dockerfile-specificconf-env">
    <para>
     设置 <literal>BACKUP</literal> 环境变量（在从映像启动的容器中持久保存的变量）。您始终可以在运行容器时通过指定新值来重写该变量的值。
    </para>
   </callout>
   <callout arearefs="co-dockerfile-specificconf-mkdir">
    <para>
     创建 <literal>/backup</literal> 目录。
    </para>
   </callout>
   <callout arearefs="co-dockerfile-specificconf-configuration">
    <para>
     将 <filename>configuration_example</filename> 复制到映像。
    </para>
   </callout>
   <callout arearefs="co-dockerfile-specificconf-entrypoint">
    <para>
     运行 <literal>example</literal> 应用程序。
    </para>
   </callout>
  </calloutlist>

  <para>
   现在可以构建映像。成功构建后，可以基于刚刚创建的映像运行容器。
  </para>
 </sect1>
 <sect1 xml:id="sec-run-application-with-volumes">
  <title>在应用程序与主机系统之间共享数据</title>

  <para>
   Docker 开源引擎允许使用<emphasis>卷</emphasis>在主机与容器之间共享数据。您可以直接在 <filename>Dockerfile</filename> 中指定挂载点，但不能在 <filename>Dockerfile</filename> 中指定主机系统上的目录，因为该目录在构建时可能无法访问。在主机系统上的 <literal>/var/lib/docker/volumes/</literal> 下找到挂载的目录。
  </para>

  <note>
   <title>丢弃对要共享的目录所做的更改</title>
   <para>
    使用 <literal>VOLUME</literal> 指令指定挂载点后，将会丢弃使用 <literal>RUN</literal> 指令对目录所做的所有更改。指定挂载点后，该卷将成为临时容器的一部分，而成功构建后会去除该临时容器。这表示要使某些操作生效，必须在指定挂载点<emphasis>之前</emphasis>执行这些操作。例如，如果您需要更改权限，请先进行更改，然后再在 <filename>Dockerfile</filename> 中将目录指定为挂载点。
   </para>
  </note>

  <para>
   运行容器时，使用 <literal>-v</literal> 选项指定主机系统上的特定挂载点：
  </para>

<screen><prompt>&gt; </prompt>docker run -it --name testing -v /home/tux/data:/data sles12sp4:latest /bin/bash</screen>

  <note>
   <para>
    如果您在容器中指定相同的挂载点，<literal>-v</literal> 选项会重写 <literal>VOLUME</literal> 指令。
   </para>
  </note>

  <para>
   下面的示例映像包含一个从主机文件系统读取 Web 内容的 Web 服务器。<filename>Dockerfile</filename> 可能如下所示：
  </para>

<screen>FROM registry.suse.com/suse/sles12sp4
RUN zypper ref &amp;&amp; zypper --non-interactive in apache2
COPY apache2 /etc/sysconfig/
RUN chown -R admin /data
EXPOSE 80
VOLUME /data
ENTRYPOINT ["apache2ctl"]</screen>

  <para>
   上面的示例将 Apache Web 服务器安装到映像，并将整个配置复制到该映像。<literal>data</literal> 目录由 <emphasis>admin</emphasis> 用户拥有，用作储存网页的挂载点。
  </para>
 </sect1>
 <sect1 xml:id="sec-docker-daemons">
  <title>在后台运行的应用程序</title>

  <para>
   如果您的应用程序需要作为守护程序在后台运行，或者作为公开通讯端口的应用程序运行，您可以在后台运行容器。
  </para>

  <para>
   公开端口的应用程序的示例 <filename>Dockerfile</filename> 如下所示：
  </para>

  <example xml:id="ex-docker-dockerfile-apache2">
   <title>构建 Apache2 Web 服务器容器 (<filename>Dockerfile</filename>)</title>
<screen>FROM registry.suse.com/suse/sle15 <co xml:id="co-dockerfile-apache2-from"/>
LABEL maintainer=tux <co xml:id="co-dockerfile-apache2-maintainer"/>
ADD etc/ /etc/zypp/ <co xml:id="co-dockerfile-apache2-repos-services"/>
RUN zypper refs &amp;&amp; zypper refresh <co xml:id="co-dockerfile-apache2-refresh"/>
RUN zypper --non-interactive in apache2 <co xml:id="co-dockerfile-apache2-install"/>
RUN echo "The Web server is running" &gt; /srv/www/htdocs/test.html <co xml:id="co-dockerfile-apache2-echo"/>
# COPY data/* /srv/www/htdocs/ <co xml:id="co-dockerfile-apache2-copy"/>
EXPOSE 80 <co xml:id="co-dockerfile-apache2-expose"/>
ENTRYPOINT ["/usr/sbin/httpd"]
CMD ["-D", "FOREGROUND"]</screen>
   <calloutlist>
    <callout arearefs="co-dockerfile-apache2-from">
     <para>
      按<xref linkend="sec-download-prebuild-images"/>中所述提取基本映像。
     </para>
    </callout>
    <callout arearefs="co-dockerfile-apache2-maintainer">
     <para>
      映像的维护者（可选）。
     </para>
    </callout>
    <callout arearefs="co-dockerfile-apache2-repos-services">
     <para>
      要复制到 <filename>/etc/zypp/repos.d</filename> 和 <filename>/etc/zypp/services.d</filename> 的软件源与服务文件。如此这些文件便可在容器中的主机上使用。
     </para>
    </callout>
    <callout arearefs="co-dockerfile-apache2-refresh">
     <para>
      用于刷新软件源和服务的命令。
     </para>
    </callout>
    <callout arearefs="co-dockerfile-apache2-install">
     <para>
      用于安装 Apache2 的命令。
     </para>
    </callout>
    <callout arearefs="co-dockerfile-apache2-echo">
     <para>
      用于调试的测试代码行。如果一切符合预期，则可以删除此行。
     </para>
    </callout>
    <callout arearefs="co-dockerfile-apache2-copy">
     <para>
      <literal>COPY</literal> 指令将主机系统中的数据复制到服务器所用容器中的目录。前导井号字符 (<literal>#</literal>) 会将此行标记为注释，系统不会执行此行。
     </para>
    </callout>
    <callout arearefs="co-dockerfile-apache2-expose">
     <para>
      Apache Web 服务器的公开端口。
     </para>
    </callout>
   </calloutlist>
  </example>

  <note>
   <title>确保容器映像所用的端口未被使用</title>
   <para>
    要使用端口 80，请确保主机中没有任何其他服务器软件在此端口上运行。
   </para>
  </note>

  <para>
   要使用容器，请执行以下操作：
  </para>

  <procedure xml:id="pro-docker-apache2">
   <title>测试 Apache2 Web 服务器</title>
   <step>
    <para>
     准备好用于执行构建过程的主机系统。
    </para>
    <substeps>
     <step>
      <para>
       确保主机系统已订阅 <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 的 <guimenu>Server Applications 模块</guimenu>。要查看已安装的模块或安装其他模块，请打开 YaST 并选择<guimenu>添加系统扩展或模块</guimenu>。
      </para>
     </step>
     <step>
      <para>
       确保已按<xref linkend="sec-download-prebuild-images"/>中所述安装了 SUSE 注册表中的 SUSE Linux Enterprise 映像。
      </para>
     </step>
     <step>
      <para>
       将 <xref linkend="ex-docker-dockerfile-apache2"/> 中的 <filename>Dockerfile</filename> 保存到 <filename class="directory">docker</filename> 目录中。
      </para>
     </step>
     <step>
      <para>
       在容器中，您需要访问已在主机上注册的软件源和服务。要使这些软件源和服务可用，请将主机中其对应的文件复制到 <filename class="directory">docker/etc</filename> 目录：
      </para>
<screen><prompt>&gt; </prompt>cd docker
<prompt>&gt; </prompt>mkdir etc
<prompt>&gt; </prompt><command>sudo</command> cp -a /etc/zypp/{repos.d,services.d} etc/</screen>
      <para>
       您也可以不复制所有软件源和服务文件，只复制容器所需的一部分文件。
      </para>
     </step>
     <step>
      <para>
       将网站数据（例如 HTML 文件）添加到 <filename>docker/data</filename> 目录中。此目录的内容将复制到容器映像，从而由 Web 服务器发布。
      </para>
     </step>
    </substeps>
   </step>
   <step xml:id="st-docker-apache2-build">
    <para>
     构建容器。使用 <option>-t</option> 选项为映像设置标签（在下面的命令中，标签为 <literal>tux/apache2</literal>）：
    </para>
<screen><prompt>&gt; </prompt><command>sudo</command> docker build -t tux/apache2 .</screen>
    <para>
     Docker 开源引擎会执行 <filename>Dockerfile</filename> 中提供的指令：提取基本映像、复制内容、刷新软件源、安装 Apache2 等
    </para>
   </step>
   <step>
    <para>
     从上一步中创建的映像启动容器实例：
    </para>
<screen><prompt>&gt; </prompt>docker run --detach --interactive --tty tux/apache2</screen>
    <para>
     Docker 开源引擎将返回容器 ID，例如：
    </para>
<screen>7bd674eb196d330d50f8a3cfc2bc61a243a4a535390767250b11a7886134ab93</screen>
   </step>
   <step>
    <para>
     将浏览器指向 <uri>http://localhost:80/test.html</uri>。您应该会看到消息 <literal>Web 服务器正在运行</literal>。
    </para>
   </step>
   <step>
    <para>
     要查看正在运行的容器的概览，请使用：
    </para>
<screen><prompt>&gt; </prompt>docker ps --latest
CONTAINER ID        IMAGE               COMMAND                  [...]
<emphasis role="bold">7bd674eb196d</emphasis>
tux/apache2         "/usr/sbin/httpd -..."   [...]</screen>
    <para>
     要停止并删除容器，请运行以下命令：
    </para>
<screen><prompt>&gt; </prompt>docker rm --force 7bd674eb196d</screen>
   </step>
  </procedure>

  <para>
   您可以执行以下步骤来使用生成的容器通过 Apache2 Web 服务器提供数据：
  </para>

  <procedure>
   <title>使用您自己的数据创建容器</title>
   <step>
    <para>
     在 <filename>Dockerfile</filename> 中：
    </para>
    <itemizedlist>
     <listitem>
      <para>
       在以 <literal>RUN echo</literal> 开头的行的前面添加 <literal>#</literal> 字符以注释掉该行（<xref linkend="ex-docker-dockerfile-apache2"/>中的 <xref linkend="co-dockerfile-apache2-echo"/>）。
      </para>
     </listitem>
     <listitem>
      <para>
       去除以 <literal>COPY</literal> 开头的行的前导 <literal>#</literal> 字符以取消注释该行（<xref linkend="ex-docker-dockerfile-apache2"/>中的 <xref linkend="co-dockerfile-apache2-copy"/>）。
      </para>
     </listitem>
    </itemizedlist>
   </step>
   <step>
    <para>
     按<xref linkend="pro-docker-apache2" xrefstyle="select:label"/> 的<xref linkend="st-docker-apache2-build"/> 中所述重构建该映像。
    </para>
   </step>
   <step>
    <para>
     在分离模式下运行映像：
    </para>
<screen><prompt>&gt; </prompt>docker run --detach --interactive --tty tux/apache2</screen>
    <para>
     Docker 开源引擎将返回容器 ID，例如：
    </para>
<screen>e43fff4ae9832ecdb7677c058a73039d7610c32145a1d9b6ad0a4ed52b5c4dc7</screen>
   </step>
  </procedure>

  <para>
   要查看发布的数据，请将浏览器指向 <uri>http://localhost:80/test.html</uri>。
  </para>

  <para>
   为了避免将网站数据复制到容器中，请与容器共享主机的某个目录。有关详细信息，请参见 <link xlink:href="https://docs.docker.com/storage/volumes/"/>。
  </para>
 </sect1>
</chapter>
