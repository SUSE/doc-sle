<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "generic-entities.ent">
    %entities;
]>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="cha-libvirt-managing">
  <title>Basic &vmguest; management</title>
  <info>
    <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
      <dm:bugtracker></dm:bugtracker>
      <dm:translation>yes</dm:translation>
    </dm:docmanager>
  </info>
  <para>
    Most management tasks, such as starting or stopping a &vmguest;, can either
    be done using the graphical application &vmm; or on the command line using
    <command>virsh</command>. Connecting to the graphical console via VNC is
    only possible from a graphical user interface.
  </para>
  <note>
    <title>Managing &vmguest;s on a remote &vmhost;</title>
    <para>
      If started on a &vmhost;, the &libvirt; tools &vmm;,
      <command>virsh</command>, and <command>virt-viewer</command> can be used
      to manage &vmguest;s on the host. However, it is also possible to manage
      &vmguest;s on a remote &vmhost;. This requires configuring remote access
      for &libvirt; on the host. For instructions, see
      <xref linkend="cha-libvirt-connect"/>.
    </para>
    <para>
      To connect to such a remote host with &vmm;, you need to set up a
      connection as explained in
      <xref linkend="sec-libvirt-connect-connecting-vmm"/>. If connecting to a
      remote host using <command>virsh</command> or
      <command>virt-viewer</command>, you need to specify a connection URI with
      the parameter <option>-c</option>, for example, <command>virsh -c
      qemu+tls://&wsIIIname;/system</command> or <command>virsh -c
      xen+ssh://</command>. The form of connection URI depends on the
      connection type and the hypervisor&mdash;see
      <xref linkend="sec-libvirt-connect-connecting"/> for details.
    </para>
    <para>
      Examples in this chapter are all listed without a connection URI.
    </para>
  </note>
  <sect1 xml:id="sec-libvirt-managing-list">
    <title>Listing &vmguest;s</title>

    <para>
      The &vmguest; listing shows all &vmguest;s managed by &libvirt; on a
      &vmhost;.
    </para>

    <sect2 xml:id="sec-libvirt-managing-list-vmm">
      <title>Listing &vmguest;s with &vmm;</title>
      <para>
        The main window of the &vmm; lists all &vmguest;s for each &vmhost; it
        is connected to. Each &vmguest; entry contains the machine's name, its
        status (<guimenu>Running</guimenu>, <guimenu>Paused</guimenu>, or
        <guimenu>Shutoff</guimenu>) displayed as an icon and literally, and a
        CPU usage bar.
      </para>
    </sect2>

    <sect2 xml:id="sec-libvirt-managing-list-virsh">
      <title>Listing &vmguest;s with <command>virsh</command></title>
      <para>
        Use the command <command>virsh</command> <option>list</option> to get a
        list of &vmguest;s:
      </para>
      <variablelist>
        <varlistentry>
          <term>List all running guests</term>
          <listitem>
<screen>&prompt.user;virsh list</screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>List all running and inactive guests</term>
          <listitem>
<screen>&prompt.user;virsh list --all</screen>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
        For more information and further options, see <command>virsh help
        list</command> or <command>man 1 virsh</command>.
      </para>
    </sect2>
  </sect1>
  <sect1 xml:id="sec-libvirt-managing-console">
    <title>Accessing the &vmguest; via console</title>

    <para>
      &vmguest;s can be accessed via a VNC connection (graphical console) or,
      if supported by the guest operating system, via a serial console.
    </para>

    <sect2 xml:id="sec-libvirt-managing-console-vnc">
      <title>Opening a graphical console</title>
      <para>
        Opening a graphical console to a &vmguest; lets you interact with the
        machine like a physical host via a VNC connection. If accessing the VNC
        server requires authentication, you are prompted to enter a user name
        (if applicable) and a password.
      </para>
      <para>
        When you click into the VNC console, the cursor is
        <quote>grabbed</quote> and cannot be used outside the console anymore.
        To release it, press <keycombo> <keycap function="alt"/>
        <keycap function="control"/> </keycombo>.
      </para>
      <tip>
        <title>Seamless (absolute) cursor movement</title>
        <para>
          To prevent the console from grabbing the cursor and to enable
          seamless cursor movement, add a tablet input device to the &vmguest;.
          See <xref linkend="sec-libvirt-config-input"/> for more information.
        </para>
      </tip>
      <para>
        Certain key combinations such as <keycombo>
        <keycap function="control"/> <keycap function="alt"/>
        <keycap function="delete"/> </keycombo> are interpreted by the host
        system and are not passed to the &vmguest;. To pass such key
        combinations to a &vmguest;, open the <guimenu>Send Key</guimenu> menu
        from the VNC window and choose the desired key combination entry. The
        <guimenu>Send Key</guimenu> menu is only available when using &vmm; and
        <command>virt-viewer</command>. With &vmm;, you can alternatively use
        the <quote>sticky key</quote> feature as explained in
        <xref linkend="tip-libvirt-inst-vmm-sticky"/>.
      </para>
      <note>
        <title>Supported VNC viewers</title>
        <para>
          Principally all VNC viewers can connect to the console of a
          &vmguest;. However, if you are using SASL authentication and/or
          TLS/SSL connection to access the guest, the options are limited.
          Common VNC viewers such as <command>tightvnc</command> or
          <command>tigervnc</command> support neither SASL authentication nor
          TLS/SSL. The only supported alternative to &vmm; and
          <command>virt-viewer</command> is Remmina (refer to
          <xref linkend="vnc-remmina"/>).
        </para>
      </note>
      <sect3 xml:id="sec-libvirt-managing-console-vnc-vmm">
        <title>Opening a graphical console with &vmm;</title>
        <procedure>
          <step>
            <para>
              In the &vmm;, right-click a &vmguest; entry.
            </para>
          </step>
          <step>
            <para>
              Choose <guimenu>Open</guimenu> from the pop-up menu.
            </para>
          </step>
        </procedure>
      </sect3>
      <sect3 xml:id="sec-libvirt-managing-vnc-viewer">
        <title>Opening a graphical console with <command>virt-viewer</command></title>
        <para>
          <command>virt-viewer</command> is a simple VNC viewer with added
          functionality for displaying &vmguest; consoles. For example, it can
          be started in <quote>wait</quote> mode, where it waits for a
          &vmguest; to start before it connects. It also supports automatically
          reconnecting to a &vmguest; that is rebooted.
        </para>
        <para>
          <command>virt-viewer</command> addresses &vmguest;s by name, by ID or
          by UUID. Use <command>virsh</command> <option>list --all</option> to
          get this data.
        </para>
        <para>
          To connect to a guest that is running or paused, use either the ID,
          UUID or name. &vmguest;s that are shut off do not have an
          ID&mdash;you can only connect to them by UUID or name.
        </para>
        <variablelist>
          <varlistentry>
            <term>Connect to guest with the ID <literal>8</literal></term>
            <listitem>
<screen>&prompt.user;virt-viewer 8</screen>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Connect to the inactive guest named <literal>sles12</literal>; the connection window opens once the guest starts</term>
            <listitem>
<screen>&prompt.user;virt-viewer --wait sles12</screen>
              <para>
                With the <option>--wait</option> option, the connection is
                upheld even if the &vmguest; is not running at the moment. When
                the guest starts, the viewer is launched.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
        <para>
          For more information, see <command>virt-viewer</command>
          <option>--help</option> or <command>man 1 virt-viewer</command>.
        </para>
        <note>
          <title>Password input on remote connections with SSH</title>
          <para>
            When using <command>virt-viewer</command> to open a connection to a
            remote host via SSH, the SSH password needs to be entered twice.
            The first time for authenticating with &libvirt;, the second time
            for authenticating with the VNC server. The second password needs
            to be provided on the command line where virt-viewer was started.
          </para>
        </note>
      </sect3>
    </sect2>

    <sect2 xml:id="sec-libvirt-managing-console-serial">
      <title>Opening a serial console</title>
      <para>
        Accessing the graphical console of a virtual machine requires a
        graphical environment on the client accessing the &vmguest;. As an
        alternative, virtual machines managed with libvirt can also be accessed
        from the shell via the serial console and <command>virsh</command>. To
        open a serial console to a &vmguest; named <quote>sles12</quote>, run
        the following command:
      </para>
<screen>&prompt.user;virsh console sles12</screen>
      <para>
        <command>virsh console</command> takes two optional flags:
        <option>--safe</option> ensures exclusive access to the console,
        <option>--force</option> disconnects any existing sessions before
        connecting. Both features need to be supported by the guest operating
        system.
      </para>
      <para>
        Being able to connect to a &vmguest; via serial console requires that
        the guest operating system supports serial console access and is
        properly supported. Refer to the guest operating system manual for more
        information.
      </para>
      <tip>
        <title>Enabling serial console access for &sle; and &opensuse; guests</title>
        <para>
          Serial console access in &sle; and &opensuse; is disabled by default.
          To enable it, proceed as follows:
        </para>
        <variablelist>
          <varlistentry>
            <term>&slsa; 12, 15 and &opensuse;</term>
            <listitem>
              <para>
                Launch the &yast; Boot Loader module and switch to the
                <guimenu>Kernel Parameters</guimenu> tab. Add
                <literal>console=ttyS0</literal> to the field <guimenu>Optional
                Kernel Command Line Parameter</guimenu>.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>&slsa; 11</term>
            <listitem>
              <para>
                Launch the &yast; Boot Loader module and select the boot entry
                for which to activate serial console access. Choose
                <guimenu>Edit</guimenu> and add
                <literal>console=ttyS0</literal> to the field <guimenu>Optional
                Kernel Command Line Parameter</guimenu>. Additionally, edit
                <filename>/etc/inittab</filename> and uncomment the line with
                the following content:
              </para>
<screen>#S0:12345:respawn:/sbin/agetty -L 9600 ttyS0 vt102</screen>
            </listitem>
          </varlistentry>
        </variablelist>
      </tip>
    </sect2>
  </sect1>
  <sect1 xml:id="sec-libvirt-managing-status">
    <title>Changing a &vmguest;'s state: start, stop, pause</title>

    <para>
      Starting, stopping or pausing a &vmguest; can be done with either &vmm;
      or <command>virsh</command>. You can also configure a &vmguest; to be
      automatically started when booting the &vmhost;.
    </para>

    <para>
      When shutting down a &vmguest;, you may either shut it down gracefully,
      or force the shutdown. The latter is equivalent to pulling the power plug
      on a physical host and is only recommended if there are no alternatives.
      Forcing a shutdown may cause file system corruption and loss of data on
      the &vmguest;.
    </para>

    <tip>
      <title>Graceful shutdown</title>
      <para>
        To be able to perform a graceful shutdown, the &vmguest; must be
        configured to support <xref linkend="gloss-vt-acpi"/>. If you have
        created the guest with the &vmm;, ACPI should be available in the
        &vmguest;.
      </para>
      <para>
        Depending on the guest operating system, availability of ACPI may not
        be sufficient to perform a graceful shutdown. It is strongly
        recommended to test shutting down and rebooting a guest before using it
        in production. &opensuse; or &sled;, for example, can require &pk;
        authorization for shutdown and reboot. Make sure this policy is turned
        off on all &vmguest;s.
      </para>
      <para>
        If ACPI was enabled during a Windows XP/Windows Server 2003 guest
        installation, turning it on in the &vmguest; configuration only is not
        sufficient. For more information, see:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            <link xlink:href="https://support.microsoft.com/en-us/kb/314088"/>
          </para>
        </listitem>
        <listitem>
          <para>
            <link xlink:href="https://support.microsoft.com/en-us/kb/309283"/>
          </para>
        </listitem>
      </itemizedlist>
      <para>
        Regardless of the &vmguest;'s configuration, a graceful shutdown is
        always possible from within the guest operating system.
      </para>
    </tip>

    <sect2 xml:id="sec-libvirt-managing-status-vmm">
      <title>Changing a &vmguest;'s state with &vmm;</title>
      <para>
        Changing a &vmguest;'s state can be done either from &vmm;'s main
        window, or from a VNC window.
      </para>
      <procedure>
        <title>State change from the &vmm; window</title>
        <step>
          <para>
            Right-click a &vmguest; entry.
          </para>
        </step>
        <step>
          <para>
            Choose <guimenu>Run</guimenu>, <guimenu>Pause</guimenu>, or one of
            the <guimenu>Shutdown options</guimenu> from the pop-up menu.
          </para>
        </step>
      </procedure>
      <procedure>
        <title>State change from the VNC window</title>
        <step>
          <para>
            Open a VNC Window as described in
            <xref linkend="sec-libvirt-managing-console-vnc-vmm"/>.
          </para>
        </step>
        <step>
          <para>
            Choose <guimenu>Run</guimenu>, <guimenu>Pause</guimenu>, or one of
            the <guimenu>Shut Down</guimenu> options either from the toolbar or
            from the <guimenu>Virtual Machine</guimenu> menu.
          </para>
        </step>
      </procedure>
      <sect3 xml:id="sec-libvirt-managing-status-vmm-autostart">
        <title>Automatically starting a &vmguest;</title>
        <para>
          You can automatically start a guest when the &vmhost; boots. This
          feature is not enabled by default and needs to be enabled for each
          &vmguest; individually. There is no way to activate it globally.
        </para>
        <procedure>
          <step>
            <para>
              Double-click the &vmguest; entry in &vmm; to open its console.
            </para>
          </step>
          <step>
            <para>
              Choose <menuchoice> <guimenu>View</guimenu>
              <guimenu>Details</guimenu></menuchoice> to open the &vmguest;
              configuration window.
            </para>
          </step>
          <step>
            <para>
              Choose <guimenu>Boot Options</guimenu> and check <guimenu>Start
              virtual machine on host boot up</guimenu>.
            </para>
          </step>
          <step>
            <para>
              Save the new configuration with <guimenu>Apply</guimenu>.
            </para>
          </step>
        </procedure>
      </sect3>
    </sect2>

    <sect2 xml:id="sec-libvirt-managing-status-virsh">
      <title>Changing a &vmguest;'s state with <command>virsh</command></title>
      <para>
        In the following examples, the state of a &vmguest; named
        <quote>sles12</quote> is changed.
      </para>
      <variablelist>
        <varlistentry>
          <term>Start</term>
          <listitem>
<screen>&prompt.user;virsh start sles12</screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Pause</term>
          <listitem>
<screen>&prompt.user;virsh suspend sles12</screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Resume (a suspended &vmguest;)</term>
          <listitem>
<screen>&prompt.user;virsh resume sles12</screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Reboot</term>
          <listitem>
<screen>&prompt.user;virsh reboot sles12</screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Graceful shutdown</term>
          <listitem>
<screen>&prompt.user;virsh shutdown sles12</screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Force shutdown</term>
          <listitem>
<screen>&prompt.user;virsh destroy sles12</screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Turn on automatic start</term>
          <listitem>
<screen>&prompt.user;virsh autostart sles12</screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Turn off automatic start</term>
          <listitem>
<screen>&prompt.user;virsh autostart --disable sles12</screen>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>
  </sect1>
  <sect1 xml:id="sec-libvirt-manage-save">
    <title>Saving and restoring the state of a &vmguest;</title>

    <para>
      Saving a &vmguest; preserves the exact state of the guest’s memory. The
      operation is similar to <emphasis>hibernating</emphasis> a computer. A
      saved &vmguest; can be quickly restored to its previously saved running
      condition.
    </para>

    <para>
      When saved, the &vmguest; is paused, its current memory state is saved to
      disk, and then the guest is stopped. The operation does not make a copy
      of any portion of the &vmguest;’s virtual disk. The amount of time taken
      to save the virtual machine depends on the amount of memory allocated.
      When saved, a &vmguest;’s memory is returned to the pool of memory
      available on the &vmhost;.
    </para>

    <para>
      The restore operation loads a &vmguest;’s previously saved memory state
      file and starts it. The guest is not booted but instead resumed at the
      point where it was previously saved. The operation is similar to coming
      out of hibernation.
    </para>

    <para>
      The &vmguest; is saved to a state file. Make sure there is enough space
      on the partition you are going to save to. For an estimation of the file
      size in megabytes to be expected, issue the following command on the
      guest:
    </para>

<screen>&prompt.user;free -mh | awk '/^Mem:/ {print $3}'</screen>

    <warning xml:id="adm-vm-restore">
      <title>Always restore saved guests</title>
      <para>
        After using the save operation, do not boot or start the saved
        &vmguest;. Doing so would cause the machine's virtual disk and the
        saved memory state to get out of synchronization. This can result in
        critical errors when restoring the guest.
      </para>
      <para>
        To be able to work with a saved &vmguest; again, use the restore
        operation. If you used <command>virsh</command> to save a &vmguest;,
        you cannot restore it using &vmm;. In this case, make sure to restore
        using <command>virsh</command>.
      </para>
    </warning>

    <important>
      <title>Synchronize &vmguest;'s time after restoring it</title>
      <para>
        If you restore the &vmguest; after a long pause (hours) since it was
        saved, its time synchronization service, for example,
        &chronyd;, may refuse to synchronize its time. In this case,
        manually synchronize &vmguest;'s time. For example, for &kvm; hosts,
        you can use the &qemu; guest agent and instruct the guest with the
        <command>guest-set-time</command>. Refer to
        <xref linkend="cha-qemu-ga"/> for more details.
      </para>
    </important>

    <important>
      <title>Only for &vmguest;s with disk types <literal>raw</literal>, <literal>qcow2</literal></title>
      <para>
        Saving and restoring &vmguest;s is only possible if the &vmguest; is
        using a virtual disk of the type <literal>raw</literal>
        (<filename>.img</filename>), or <emphasis>qcow2</emphasis>.
      </para>
    </important>

    <sect2 xml:id="sec-libvirt-manage-save-vmm">
      <title>Saving/restoring with &vmm;</title>
      <procedure>
        <title>Saving a &vmguest;</title>
        <step>
          <para>
            Open a VNC connection window to a &vmguest;. Make sure the guest is
            running.
          </para>
        </step>
        <step>
          <para>
            Choose <menuchoice> <guimenu>Virtual Machine</guimenu>
            <guimenu>Shutdown</guimenu> <guimenu>Save</guimenu> </menuchoice>.
          </para>
        </step>
      </procedure>
      <procedure>
        <title>Restoring a &vmguest;</title>
        <step>
          <para>
            Open a VNC connection window to a &vmguest;. Make sure the guest is
            not running.
          </para>
        </step>
        <step>
          <para>
            Choose <menuchoice> <guimenu>Virtual Machine</guimenu>
            <guimenu>Restore</guimenu> </menuchoice>.
          </para>
          <para>
            If the &vmguest; was previously saved using &vmm;, you are not
            offered an option to <guimenu>Run</guimenu> the guest. However,
            note the caveats on machines saved with <command>virsh</command>
            outlined in <xref linkend="adm-vm-restore"/>.
          </para>
        </step>
      </procedure>
    </sect2>

    <sect2 xml:id="sec-libvirt-manage-save-virsh">
      <title>Saving and restoring with <command>virsh</command></title>
      <para>
        Save a running &vmguest; with the command <command>virsh</command>
        <option>save</option> and specify the file which it is saved to.
      </para>
      <variablelist>
        <varlistentry>
          <term>Save the guest named <literal>opensuse13</literal></term>
          <listitem>
<screen>&prompt.user;virsh save opensuse13 /virtual/saves/opensuse13.vmsav</screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Save the guest with the ID <literal>37</literal></term>
          <listitem>
<screen>&prompt.user;virsh save 37 /virtual/saves/opensuse13.vmsave</screen>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
        To restore a &vmguest;, use <command>virsh</command>
        <option>restore</option>:
      </para>
<screen>&prompt.user;virsh restore /virtual/saves/opensuse13.vmsave</screen>
    </sect2>
  </sect1>
  <sect1 xml:id="sec-libvirt-managing-snapshots">
    <title>Creating and managing snapshots</title>

    <para>
      &vmguest; snapshots are snapshots of the complete virtual machine
      including the state of CPU, RAM, devices and the content of all writable
      disks. To use virtual machine snapshots, all the attached hard disks need
      to use the qcow2 disk image format, and at least one of them needs to be
      writable.
    </para>

    <para>
      Snapshots let you restore the state of the machine at a particular point
      in time. This is useful when undoing a faulty configuration or the
      installation of a lot of packages. After starting a snapshot that was
      created while the &vmguest; was shut off, you need to boot it. Any
      changes written to the disk afterward are lost when starting the
      snapshot.
    </para>

    <note>
      <para>
        Snapshots are supported on &kvm; &vmhost;s only.
      </para>
    </note>

    <sect2 xml:id="libvirt-snapshots-terminology">
      <title>Terminology</title>
      <para>
        There are several specific terms used to describe the types of
        snapshots:
      </para>
      <variablelist>
        <varlistentry>
          <term>Internal snapshots</term>
          <listitem>
            <para>
              Snapshots that are saved into the qcow2 file of the original
              &vmguest;. The file holds both the saved state of the snapshot
              and the changes made since the snapshot was taken. The main
              advantage of internal snapshots is that they are all stored in
              one file and therefore it is easy to copy or move them across
              multiple machines.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>External snapshots</term>
          <listitem>
            <para>
              When creating an external snapshot, the original qcow2 file is
              saved and made read-only, while a new qcow2 file is created to
              hold the changes. The original file is sometimes called a
              <emphasis>backing</emphasis> or <emphasis>base</emphasis> file,
              while the new file with all the changes is called an
              <emphasis>overlay</emphasis> or <emphasis>derived</emphasis>
              file. External snapshots are useful when performing backups of
              &vmguest;s. However, external snapshots are not supported by
              &vmm;, and cannot be deleted by <command>virsh</command>
              directly. For more information on external snapshots in &qemu;,
              refer to <xref linkend="cha-qemu-guest-inst-qemu-img-effect"/>.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Live snapshots</term>
          <listitem>
            <para>
              Snapshots created when the original &vmguest; is running.
              Internal live snapshots support saving the devices, and memory
              and disk states, while external live snapshots with
              <command>virsh</command> support saving either the memory state,
              or the disk state, or both.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Offline snapshots</term>
          <listitem>
            <para>
              Snapshots created from a &vmguest; that is shut off. This ensures
              data integrity as all the guest's processes are stopped and no
              memory is in use.
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>

    <sect2 xml:id="sec-libvirt-managing-snapshots-vmm">
      <title>Creating and managing snapshots with &vmm;</title>
      <important>
        <title>Internal snapshots only</title>
        <para>
          &vmm; supports only internal snapshots, either live or offline.
        </para>
      </important>
      <para>
        To open the snapshot management view in &vmm;, open the VNC window as
        described in <xref linkend="sec-libvirt-managing-console-vnc-vmm"/>.
        Now either choose <menuchoice> <guimenu>View</guimenu>
        <guimenu>Snapshots</guimenu> </menuchoice> or click <guimenu>Manage VM
        Snapshots</guimenu> in the toolbar.
      </para>
      <informalfigure>
        <mediaobject>
          <imageobject role="fo">
            <imagedata fileref="virt_vmm_snapshots_list.png" width="75%"/>
          </imageobject>
          <imageobject role="html">
            <imagedata fileref="virt_vmm_snapshots_list.png" width="75%"/>
          </imageobject>
        </mediaobject>
      </informalfigure>
      <para>
        The list of existing snapshots for the chosen &vmguest; is displayed in
        the left-hand part of the window. The snapshot that was last started is
        marked with a green tick. The right-hand part of the window shows
        details of the snapshot currently marked in the list. These details
        include the snapshot's title and time stamp, the state of the &vmguest;
        at the time the snapshot was taken and a description. Snapshots of
        running guests also include a screenshot. The
        <guimenu>Description</guimenu> can be changed directly from this view.
        Other snapshot data cannot be changed.
      </para>
      <sect3 xml:id="sec-libvirt-managing-snapshots-vmm-add">
        <title>Creating a snapshot</title>
        <para>
          To take a new snapshot of a &vmguest;, proceed as follows:
        </para>
        <procedure>
          <step>
            <para>
              Optionally, shut down the &vmguest; to create an offline
              snapshot.
            </para>
          </step>
          <step>
            <para>
              Click <guimenu>Add</guimenu> in the bottom left corner of the VNC
              window.
            </para>
            <para>
              The window <guimenu>Create Snapshot</guimenu> opens.
            </para>
          </step>
          <step>
            <para>
              Provide a <guimenu>Name</guimenu> and, optionally, a description.
              The name cannot be changed after the snapshot has been taken. To
              be able to identify the snapshot later easily, use a
              <quote>speaking name</quote>.
            </para>
          </step>
          <step>
            <para>
              Confirm with <guimenu>Finish</guimenu>.
            </para>
          </step>
        </procedure>
      </sect3>
      <sect3 xml:id="sec-libvirt-managing-snapshots-vmm-delete">
        <title>Deleting a snapshot</title>
        <para>
          To delete a snapshot of a &vmguest;, proceed as follows:
        </para>
        <procedure>
          <step>
            <para>
              Click <guimenu>Delete</guimenu> in the bottom left corner of the
              VNC window.
            </para>
          </step>
          <step>
            <para>
              Confirm the deletion with <guimenu>Yes</guimenu>.
            </para>
          </step>
        </procedure>
      </sect3>
      <sect3 xml:id="sec-libvirt-managing-snapshots-vmm-start">
        <title>Starting a snapshot</title>
        <para>
          To start a snapshot, proceed as follows:
        </para>
        <procedure>
          <step>
            <para>
              Click <guimenu>Run</guimenu> in the bottom left corner of the VNC
              window.
            </para>
          </step>
          <step>
            <para>
              Confirm the start with <guimenu>Yes</guimenu>.
            </para>
          </step>
        </procedure>
      </sect3>
    </sect2>

    <sect2 xml:id="sec-libvirt-managing-snapshots-virsh">
      <title>Creating and managing snapshots with <command>virsh</command></title>
      <para>
        To list all existing snapshots for a domain
        (<replaceable>admin_server</replaceable> in the following), run the
        <literal>snapshot-list</literal> command:
      </para>
<screen>&prompt.user;virsh snapshot-list --domain sle-ha-node1
 Name                 Creation Time             State
------------------------------------------------------------
 sleha_12_sp2_b2_two_node_cluster 2016-06-06 15:04:31 +0200 shutoff
 sleha_12_sp2_b3_two_node_cluster 2016-07-04 14:01:41 +0200 shutoff
 sleha_12_sp2_b4_two_node_cluster 2016-07-14 10:44:51 +0200 shutoff
 sleha_12_sp2_rc3_two_node_cluster 2016-10-10 09:40:12 +0200 shutoff
 sleha_12_sp2_gmc_two_node_cluster 2016-10-24 17:00:14 +0200 shutoff
 sleha_12_sp3_gm_two_node_cluster 2017-08-02 12:19:37 +0200 shutoff
 sleha_12_sp3_rc1_two_node_cluster 2017-06-13 13:34:19 +0200 shutoff
 sleha_12_sp3_rc2_two_node_cluster 2017-06-30 11:51:24 +0200 shutoff
 sleha_15_b6_two_node_cluster 2018-02-07 15:08:09 +0100 shutoff
 sleha_15_rc1_one-node 2018-03-09 16:32:38 +0100 shutoff</screen>
      <para>
        The snapshot that was last started is shown with the
        <literal>snapshot-current command:</literal>
      </para>
<screen>&prompt.user;virsh snapshot-current --domain admin_server
Basic installation incl. SMT for CLOUD4
</screen>
      <para>
        Details about a particular snapshot can be obtained by running the
        <literal>snapshot-info</literal> command:
      </para>
<screen>&prompt.user;virsh snapshot-info --domain admin_server \
   -name  "Basic installation incl. SMT for CLOUD4"
Name:           Basic installation incl. SMT for CLOUD4
Domain:         admin_server
Current:        yes
State:          shutoff
Location:       internal
Parent:         Basic installation incl. SMT for CLOUD3-HA
Children:       0
Descendants:    0
Metadata:       yes
</screen>
      <sect3 xml:id="sec-libvirt-managing-snapshots-virsh-add">
        <title>Creating internal snapshots</title>
        <para>
          To take an internal snapshot of a &vmguest;, either a live or
          offline, use the <literal>snapshot-create-as</literal> command as
          follows:
        </para>
<screen>&prompt.user;virsh snapshot-create-as --domain admin_server<co xml:id="virsh-snapshot-add-domain"/> --name "Snapshot 1"<co xml:id="virsh-snapshot-add-name"/> \
--description "First snapshot"<co xml:id="virsh-snapshot-add-description"/></screen>
        <calloutlist>
          <callout arearefs="virsh-snapshot-add-domain">
            <para>
              Domain name. Mandatory.
            </para>
          </callout>
          <callout arearefs="virsh-snapshot-add-name">
            <para>
              Name of the snapshot. It is recommended to use a <quote>speaking
              name</quote>, since that makes it easier to identify the
              snapshot. Mandatory.
            </para>
          </callout>
          <callout arearefs="virsh-snapshot-add-description">
            <para>
              Description for the snapshot. Optional.
            </para>
          </callout>
        </calloutlist>
      </sect3>
      <sect3 xml:id="sec-libvirt-managing-snapshots-virsh-add-ext">
        <title>Creating external snapshots</title>
        <para>
          With <command>virsh</command>, you can take external snapshots of the
          guest's memory state, disk state, or both.
        </para>
        <para>
          To take both live and offline external snapshots of the guest's disk,
          specify the <option>--disk-only</option> option:
        </para>
<screen>&prompt.user;virsh snapshot-create-as --domain admin_server --name \
 "Offline external snapshot" --disk-only</screen>
        <para>
          You can specify the <option>--diskspec</option> option to control how
          the external files are created:
        </para>
<screen>&prompt.user;virsh snapshot-create-as --domain admin_server --name \
 "Offline external snapshot" \
 --disk-only --diskspec vda,snapshot=external,file=/path/to/snapshot_file</screen>
        <para>
          To take a live external snapshot of the guest's memory, specify the
          <option>--live</option> and <option>--memspec</option> options:
        </para>
<screen>&prompt.user;virsh snapshot-create-as --domain admin_server --name \
 "Offline external snapshot" --live \
 --memspec snapshot=external,file=/path/to/snapshot_file</screen>
        <para>
          To take a live external snapshot of both the guest's disk and memory
          states, combine the <option>--live</option>,
          <option>--diskspec</option>, and <option>--memspec</option> options:
        </para>
<screen>&prompt.user;virsh snapshot-create-as --domain admin_server --name \
 "Offline external snapshot" --live \
 --memspec snapshot=external,file=/path/to/snapshot_file
 --diskspec vda,snapshot=external,file=/path/to/snapshot_file</screen>
        <para>
          Refer to the <citetitle>SNAPSHOT COMMANDS</citetitle> section in
          <command>man 1 virsh</command> for more details.
        </para>
      </sect3>
      <sect3 xml:id="sec-libvirt-managing-snapshots-virsh-delete">
        <title>Deleting a snapshot</title>
        <para>
          External snapshots cannot be deleted with <command>virsh</command>.
          To delete an internal snapshot of a &vmguest; and restore the disk
          space it occupies, use the <literal>snapshot-delete</literal>
          command:
        </para>
<screen>&prompt.user;virsh snapshot-delete --domain admin_server --snapshotname "Snapshot 2"</screen>
      </sect3>
      <sect3 xml:id="sec-libvirt-managing-snapshots-virsh-start">
        <title>Starting a snapshot</title>
        <para>
          To start a snapshot, use the <literal>snapshot-revert</literal>
          command:
        </para>
<screen>&prompt.user;virsh snapshot-revert --domain admin_server --snapshotname "Snapshot 1"</screen>
        <para>
          To start the current snapshot (the one the &vmguest; was started
          off), it is sufficient to use <option>--current</option> rather than
          specifying the snapshot name:
        </para>
<screen>&prompt.user;virsh snapshot-revert --domain admin_server --current</screen>
      </sect3>
    </sect2>
  </sect1>
  <sect1 xml:id="sec-libvirt-managing-delete">
    <title>Deleting a &vmguest;</title>

    <para>
      By default, deleting a &vmguest; using <command>virsh</command> removes
      only its XML configuration. Since attached storage is not deleted by
      default, you can reuse it with another &vmguest;. With &vmm;, you can
      also delete a guest's storage files as well.
    </para>

    <sect2 xml:id="sec-libvirt-managing-delete-vmm">
      <title>Deleting a &vmguest; with &vmm;</title>
      <procedure>
        <step>
          <para>
            In the &vmm;, right-click a &vmguest; entry.
          </para>
        </step>
        <step>
          <para>
            From the context menu, choose <guimenu>Delete</guimenu>.
          </para>
        </step>
        <step>
          <para>
            A confirmation window opens. Clicking <guimenu>Delete</guimenu>
            permanently erases the &vmguest;. The deletion is not recoverable.
          </para>
          <para>
            You can also permanently delete the guest's virtual disk by
            activating <guimenu>Delete Associated Storage Files</guimenu>. The
            deletion is not recoverable either.
          </para>
        </step>
      </procedure>
    </sect2>

    <sect2 xml:id="sec-libvirt-managing-delete-virsh">
      <title>Deleting a &vmguest; with <command>virsh</command></title>
      <para>
        To delete a &vmguest;, it needs to be shut down first. It is not
        possible to delete a running guest. For information on shutting down,
        see <xref linkend="sec-libvirt-managing-status"/>.
      </para>
      <para>
        To delete a &vmguest; with <command>virsh</command>, run
        <command>virsh</command> <option>undefine</option>
        <replaceable>VM_NAME</replaceable>.
      </para>
<screen>&prompt.user;virsh undefine sles12</screen>
      <para>
        There is no option to automatically delete the attached storage files.
        If they are managed by libvirt, delete them as described in
        <xref linkend="sec-libvirt-storage-virsh-del-volumes"/>.
      </para>
    </sect2>
  </sect1>
  <sect1 xml:id="cha-libvirt-admin-monitor">
    <title>Monitoring</title>

    <para/>

    <sect2 xml:id="cha-libvirt-admin-monitor-virt-manager">
      <title>Monitoring with &vmm;</title>
      <para>
        After starting &vmm; and connecting to the &vmhost;, a CPU usage graph
        of all the running guests is displayed.
      </para>
      <para>
        It is also possible to get information about disk and network usage
        with this tool, however, you must first activate this in
        <guimenu>Preferences</guimenu>:
      </para>
      <procedure>
        <step>
          <para>
            Run <command>virt-manager</command>.
          </para>
        </step>
        <step>
          <para>
            Select <menuchoice><guimenu>Edit</guimenu>
            <guimenu>Preferences</guimenu></menuchoice>.
          </para>
        </step>
        <step>
          <para>
            Change the tab from <guimenu>General</guimenu> to
            <guimenu>Polling</guimenu>.
          </para>
        </step>
        <step>
          <para>
            Activate the check boxes for the kind of activity you want to see:
            <guimenu>Poll Disk I/O</guimenu>, <guimenu>Poll Network
            I/O</guimenu>, and <guimenu>Poll Memory stats</guimenu>.
          </para>
        </step>
        <step>
          <para>
            If desired, also change the update interval using <guimenu>Update
            status every n seconds</guimenu>.
          </para>
        </step>
        <step>
          <para>
            Close the <guimenu>Preferences</guimenu> dialog.
          </para>
        </step>
        <step>
          <para>
            Activate the graphs that should be displayed under <menuchoice>
            <guimenu>View</guimenu> <guimenu>Graph</guimenu> </menuchoice>.
          </para>
        </step>
      </procedure>
      <para>
        Afterward, the disk and network statistics are also displayed in the
        main window of the &vmm;.
      </para>
      <para>
        More precise data is available from the VNC window. Open a VNC window
        as described in <xref linkend="sec-libvirt-managing-console-vnc"/>.
        Choose <guimenu>Details</guimenu> from the toolbar or the
        <guimenu>View</guimenu> menu. The statistics are displayed from the
        <guimenu>Performance</guimenu> entry of the left-hand tree menu.
      </para>
    </sect2>

    <sect2 xml:id="cha-libvirt-admin-monitor-virt-top">
      <title>Monitoring with <command>virt-top</command></title>
      <para>
        <command>virt-top</command> is a command-line tool similar to the
        well-known process monitoring tool <command>top</command>.
        <command>virt-top</command> uses libvirt and therefore is capable of
        showing statistics for &vmguest;s running on different hypervisors. It
        is recommended to use <command>virt-top</command> instead of
        hypervisor-specific tools like <command>xentop</command>.
      </para>
      <para>
        By default <command>virt-top</command> shows statistics for all running
        &vmguest;s. Among the data that is displayed is the percentage of
        memory used (<literal>%MEM</literal>) and CPU (<literal>%CPU</literal>)
        and the uptime of the guest (<literal>TIME</literal>). The data is
        updated regularly (every three seconds by default). The following shows
        the output on a &vmhost; with seven &vmguest;s, four of them inactive:
      </para>
<screen>virt-top 13:40:19 - x86_64 8/8CPU 1283MHz 16067MB 7.6% 0.5%
7 domains, 3 active, 3 running, 0 sleeping, 0 paused, 4 inactive D:0 O:0 X:0
CPU: 6.1%  Mem: 3072 MB (3072 MB by guests)

   ID S RDRQ WRRQ RXBY TXBY %CPU %MEM    TIME   NAME
    7 R  123    1  18K  196  5.8  6.0   0:24.35 sled12_sp1
    6 R    1    0  18K    0  0.2  6.0   0:42.51 sles12_sp1
    5 R    0    0  18K    0  0.1  6.0  85:45.67 opensuse_leap
    -                                           (Ubuntu_1410)
    -                                           (debian_780)
    -                                           (fedora_21)
    -                                           (sles11sp3)</screen>
      <para>
        By default the output is sorted by ID. Use the following key
        combinations to change the sort field:
      </para>
      <simplelist><member><keycombo><keycap function="shift"/><keycap>P</keycap></keycombo>: CPU
     usage
    </member><member><keycombo><keycap function="shift"/><keycap>M</keycap></keycombo>:
     Total memory allocated by the guest
    </member><member><keycombo><keycap function="shift"/><keycap>T</keycap></keycombo>: time
    </member><member><keycombo><keycap function="shift"/><keycap>I</keycap></keycombo>: ID
    </member>
      </simplelist>
      <para>
        To use any other field for sorting, press <keycombo>
        <keycap
    function="shift"/> <keycap>F</keycap> </keycombo> and
        select a field from the list. To toggle the sort order, use <keycombo>
        <keycap
    function="shift"/> <keycap>R</keycap> </keycombo>.
      </para>
      <para>
        <command>virt-top</command> also supports different views on the
        &vmguest;s data, which can be changed on-the-fly by pressing the
        following keys:
      </para>
      <simplelist><member><keycap>0</keycap>: default view</member><member><keycap>1</keycap>: show physical CPUs</member><member><keycap>2</keycap>: show network interfaces</member><member><keycap>3</keycap>: show virtual disks</member>
      </simplelist>
      <para>
        <command>virt-top</command> supports more hot keys to change the view
        of the data and many command line switches that affect the behavior of
        the program. For more information, see <command>man 1
        virt-top</command>.
      </para>
    </sect2>

    <sect2 xml:id="cha-libvirt-admin-monitor-kvm-stat">
      <title>Monitoring with <command>kvm_stat</command></title>
      <para>
        <command>kvm_stat</command> can be used to trace &kvm; performance
        events. It monitors <filename>/sys/kernel/debug/kvm</filename>, so it
        needs the debugfs to be mounted. On &productname; it should be mounted
        by default. In case it is not mounted, use the following command:
      </para>
<screen>&prompt.sudo;mount -t debugfs none /sys/kernel/debug</screen>
      <para>
        <command>kvm_stat</command> can be used in three different modes:
      </para>
<screen>kvm_stat                    # update in 1 second intervals
kvm_stat -1                 # 1 second snapshot
kvm_stat -l &gt; kvmstats.log  # update in 1 second intervals in log format
                            # can be imported to a spreadsheet</screen>
      <example>
        <title>Typical output of <command>kvm_stat</command></title>
<screen>kvm statistics

 efer_reload                  0       0
 exits                 11378946  218130
 fpu_reload               62144     152
 halt_exits              414866     100
 halt_wakeup             260358      50
 host_state_reload       539650     249
 hypercalls                   0       0
 insn_emulation         6227331  173067
 insn_emulation_fail          0       0
 invlpg                  227281      47
 io_exits                113148      18
 irq_exits               168474     127
 irq_injections          482804     123
 irq_window               51270      18
 largepages                   0       0
 mmio_exits                6925       0
 mmu_cache_miss           71820      19
 mmu_flooded              35420       9
 mmu_pde_zapped           64763      20
 mmu_pte_updated              0       0
 mmu_pte_write           213782      29
 mmu_recycled                 0       0
 mmu_shadow_zapped       128690      17
 mmu_unsync                  46      -1
 nmi_injections               0       0
 nmi_window                   0       0
 pf_fixed               1553821     857
 pf_guest               1018832     562
 remote_tlb_flush        174007      37
 request_irq                  0       0
 signal_exits                 0       0
 tlb_flush               394182     148</screen>
      </example>
      <para>
        See
        <link xlink:href="https://clalance.blogspot.com/2009/01/kvm-performance-tools.html"/>
        for further information on how to interpret these values.
      </para>
    </sect2>
  </sect1>
</chapter>
