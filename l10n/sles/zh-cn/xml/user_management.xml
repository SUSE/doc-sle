<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="user_management.xml" version="5.0" role="General" xml:id="sec-sec-user-management">
 <title>用户管理</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>

  <sect1 xml:id="sec-sec-prot-general-accounts">
   <title>各种帐户检查</title>

   <sect2 xml:id="sec-sec-prot-general-accounts-unlocked">
    <title>未锁定的帐户</title>
    <para>
     请务必锁定未用于登录的所有系统帐户和供应商帐户。要获取您系统中未锁定帐户的列表，可以在 <filename>/etc/shadow</filename> 文件中查看<emphasis>不含</emphasis>以 <literal>!</literal> 或 <literal>*</literal> 开头的已加密口令字符串的帐户。如果您使用 <command>passwd</command> <option>-l</option> 锁定某个帐户，此命令会在已加密口令的前面添加 <literal>!!</literal> 符号，这实际上表示禁用该口令。如果您使用 <command>usermod</command> <option>-L</option> 锁定某个帐户，此命令会在已加密口令的前面添加 <literal>!</literal> 符号。默认情况下，许多系统帐户和共享帐户的口令字段中包含 <literal>*</literal> 或 <literal>!!</literal> 符号（将已加密口令呈现为无效字符串），从而锁定了这些帐户。因此，要获取所有未锁定（可加密）帐户的列表，请运行以下命令：
    </para>
    <screen><prompt role="root"># </prompt>egrep -v ':\*|:\!' /etc/shadow | awk -F: '{print $1}'</screen>
    <para>
     另请确保所有帐户在 <filename>/etc/passwd</filename> 中的口令字段中都包含 <literal>x</literal> 符号。以下命令列出口令字段中没有 <literal>x</literal> 符号的所有帐户：
    </para>
    <screen><prompt role="root"># </prompt>grep -v ':x:' /etc/passwd</screen>
    <para>
     口令字段中的 <literal>x</literal> 符号表示该口令已阴影化，例如，需要在 <filename>/etc/shadow</filename> 文件中查找已加密口令。如果 <filename>/etc/passwd</filename> 中的口令字段为空，则系统将不会查找阴影文件，并且不会在出现登录提示时提示用户提供口令。
    </para>
   </sect2>

   <sect2 xml:id="sec-sec-prot-general-accounts-unused">
    <title>未使用的帐户</title>
    <para>
     应从系统中去除未被用户、应用程序、系统或守护程序使用的所有系统帐户或供应商帐户。您可以使用以下命令，查找特定帐户是否拥有任何文件：
    </para>
    <screen><prompt role="root"># </prompt>find / -path /proc -prune -o -user <replaceable>ACCOUNT</replaceable> -ls</screen>
    <para>
     在此示例中，<option>-prune</option> 选项用于跳过 /proc 文件系统。如果您确定可以删除某个帐户，可以使用以下命令去除该帐户：
    </para>
    <screen><prompt role="root"># </prompt>userdel -r <replaceable>ACCOUNT</replaceable></screen>
    <para>
     如果不指定 <option>-r</option> 选项，<command>userdel</command> 不会删除用户的主目录和邮件假脱机目录 (<filename>/var/spool/mail/<replaceable>USER</replaceable></filename>)。许多系统帐户没有主目录。
    </para>
   </sect2>
  </sect1>
  <sect1 xml:id="sec-sec-prot-general-pw-aging">
   <title>启用口令时效</title>

   <para>
    口令失效是一种普遍采用的最佳实践，但对于某些系统帐户和共享帐户（例如 Oracle）而言，可能需要将其排除。如果应用程序帐户失效，这些帐户的失效口令可能会导致系统服务中断。
   </para>

   <para>
    通常情况下，应针对系统帐户和共享帐户的口令更改规则/程序制定相应的公司政策。但常规用户帐户口令应该会自动失效。以下示例显示如何针对各个用户帐户设置口令失效。
   </para>

   <para>
    使用 <command>useradd</command> 命令创建新帐户时，可以使用下表中的文件和参数。将在 <filename>/etc/shadow</filename> 文件中为每个用户帐户存储此类设置。如果使用 YaST 工具（<guimenu>用户和组管理</guimenu>）添加用户，则会为每个用户提供该设置。下面是各种不同的设置，其中一些也可能是系统范围的设置（例如，<filename>/etc/login.defs</filename> 和 <filename>/etc/default/useradd</filename> 的修改）：
   </para>

   <informaltable>
    <tgroup cols="3">
     <tbody>
      <row>
       <entry>
        <para>
         <filename>/etc/login.defs</filename>
        </para>
       </entry>
       <entry>
        <para>
         <literal>PASS_MAX_DAYS</literal>
        </para>
       </entry>
       <entry>
        <para>
         口令保持有效的最大天数。
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>/etc/login.defs</filename>
        </para>
       </entry>
       <entry>
        <para>
         <literal>PASS_MIN_DAYS</literal>
        </para>
       </entry>
       <entry>
        <para>
         自上次更改到用户下次可更改口令之前的最小天数。
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>/etc/login.defs</filename>
        </para>
       </entry>
       <entry>
        <para>
         <literal>PASS_WARN_AGE</literal>
        </para>
       </entry>
       <entry>
        <para>
         从上次更改口令到下次提醒更改口令间隔的天数。
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>/etc/default/useradd</filename>
        </para>
       </entry>
       <entry>
        <para>
         <literal>INACTIVE</literal>
        </para>
       </entry>
       <entry>
        <para>
          口令失效后帐户处于禁用状态的天数。
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>/etc/default/useradd</filename>
        </para>
       </entry>
       <entry>
        <para>
         <literal>EXPIRE</literal>
        </para>
       </entry>
       <entry>
        <para>
         帐户失效日期（采用 YYYY-MM-DD 格式）。
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>

   <note>
    <title>现有用户不受影响</title>
    <para>
     在进行这些修改之前创建的用户不受影响。
    </para>
   </note>

   <para>
    确保在 <filename>/etc/login.defs</filename> 和 <filename>/etc/default/useradd</filename> 文件中更改上述参数。<filename>/etc/shadow</filename> 文件会显示添加用户后这些设置的存储方式。
   </para>

   <para>
    要创建新用户帐户，请执行以下命令：
   </para>

   <screen><prompt role="root"># </prompt>useradd -c "<replaceable>TEST_USER</replaceable>" -g <replaceable>USERS</replaceable> <replaceable>TEST</replaceable></screen>

   <para>
    <option>-g</option> 选项指定此帐户的主组：
   </para>

<screen><prompt role="root"># </prompt>id <replaceable>TEST</replaceable>
uid=509(test) gid=100(users) groups=100(users)</screen>

   <para>
    <filename>/etc/login.defs</filename> 和 <filename>/etc/default/useradd</filename> 中的设置是为 <filename>/etc/shadow</filename> 文件中的测试用户记录的，如下所示：
   </para>

<screen><prompt role="root"># </prompt>grep <replaceable>TEST</replaceable> /etc/shadow
test:!!:12742:7:60:7:14::</screen>

   <para>
    可以使用 <command>chage</command> 命令随时修改口令时效。要禁用系统帐户和共享帐户的口令时效，可以运行以下 <command>chage</command> 命令：
   </para>

   <screen><prompt role="root"># </prompt>chage -M -1 <replaceable>SYSTEM_ACCOUNT_NAME</replaceable></screen>

   <para>
    要获取口令失效信息，请运行：
   </para>

   <screen><prompt role="root"># </prompt>chage -l <replaceable>SYSTEM_ACCOUNT_NAME</replaceable></screen>

   <para>
    例如：
   </para>

<screen><prompt role="root"># </prompt>chage -l <replaceable>TEST</replaceable>
Minimum: 7
Maximum: 60
Warning: 7
Inactive: 14
Last Change: Jan 11, 2015
Password Expires: Mar 12, 2015
Password Inactive: Mar 26, 2015
Account Expires: Never</screen>
  </sect1>
  <sect1 xml:id="sec-sec-prot-general-pw-strength">
   <title>实施更强的口令</title>

   <para>
    在经审计的系统上，请务必限制用户使用可被轻松破解的简单口令。可以记下复杂口令，前提是将其妥善保管。有些人主张通过强口令来保护您免受字典攻击，并可通过数次失败尝试之后锁定帐户来防御此类攻击。但此方法并非始终有效。如果进行此类设置，锁定系统帐户可能会使应用程序和系统服务中断，这会产生另一个同样棘手的问题 — 拒绝服务攻击。
   </para>

   <para>
    但无论怎样，实施有效的口令管理安全措施都很重要。大多数公司会要求口令至少包含一个数字、一个小写字母和一个大写字母。虽然政策各不相同，但要在口令强度/复杂性和管理难易度之间保持平衡可能并不容易。
   </para>
  </sect1>
  <xi:include href="hardening_pam_stack.xml"/>
  <sect1 xml:id="sec-sec-prot-restrict-root">
   <title>限制 <systemitem class="username">root</systemitem> 登录</title>

   <para>
    默认情况下，为 <systemitem class="username">root</systemitem> 用户分配了口令，并且该用户可以使用各种方法进行登录 — 例如，在本地终端上、在图形会话中，或者通过 SSH 远程登录。应尽可能限制使用这些方法登录。应避免共享使用 root 帐户。个人管理员应使用 <literal>su</literal> 或 <literal>sudo</literal> 等工具（如需详细信息，请键入 <command>man 1 su</command> 或 <command>man 8 sudo</command>）来获取提升的特权。如此可将 <systemitem class="username">root</systemitem> 登录与特定用户相关联。同时还可增加了另一层安全保护；要获得完全的 root 访问权限，需要破解的不仅仅是 <systemitem class="username">root</systemitem> 口令，而是 <systemitem class="username">root</systemitem> <emphasis> 口令以及</emphasis>管理员普通帐户的口令。本节说明如何限制在不同级别系统上的直接 root 登录。
   </para>
   <sect2 xml:id="sec-sec-prot-restrict-root-tty">
    <title>限制本地文本控制台登录</title>

    <para>
     TTY 设备通过控制台提供文本模式的系统访问权限。对于桌面系统，通过本地键盘进行访问；如果是服务器系统，则通过连接到 KVM 交换机或远程管理卡（例如 ILO 和 DRAC）的输入设备进行访问。Linux 默认会提供 6 个不同的控制台，在文本模式下运行时，可通过组合键 <keycombo><keycap function="alt"/><keycap>F1</keycap></keycombo> 到 <keycombo><keycap function="alt"/><keycap>F6</keycap></keycombo> 切换它们；在图形会话中运行时，可通过组合键 <keycombo><keycap function="control"/><keycap function="alt"/><keycap>F1</keycap></keycombo> 到 <keycombo><keycap function="control"/><keycap function="alt"/><keycap>F6</keycap></keycombo> 进行切换。关联的终端设备命名为 <literal>tty1</literal> 到 <literal>tty6</literal>。
    </para>

    <para>
     下面的步骤限制对第一个 TTY 的 root 访问。此访问方法仅作为系统的紧急访问方式，绝不应将其用于日常系统管理任务。
    </para>

    <note>
     <para>
      此处显示的步骤根据 PC 体系结构（x86 和 AMD64/Intel 64）进行定制。在 POWER 等体系结构上，可以使用 <literal>tty1</literal> 以外的其他终端设备名称。请小心不要因为指定了错误的终端设备名称而将您自己锁定。可以通过运行 <literal>tty</literal> 命令确定当前登录的终端的设备名称。请注意不要在虚拟终端（例如通过 SSH）或图形会话（设备名称 <filename>/dev/pts/<replaceable>N</replaceable></filename>）中执行此操作，而只通过实际登录终端（可按 <keycombo><keycap function="alt"/><keycap>F<replaceable>N</replaceable></keycap></keycombo> 访问）进行操作。
     </para>
    </note>

    <procedure>
     <title>限制在本地 TTY 上进行 root 登录</title>
     <step>
      <para>
       确保 PAM 堆栈配置文件 <filename>/etc/pam.d/login</filename> 在 <literal>auth</literal> 块中包含 <literal>pam_securetty</literal> 模块：
      </para>
      <screen>auth     requisite      pam_nologin.so
 auth     [user_unknown=ignore success=ok ignore=ignore auth_err=die default=bad] pam_securetty.so noconsole
 auth     include        common-auth</screen>
      <para>
        这样系统会在本地控制台上处理身份验证期间包含 <literal>pam_securetty</literal> 模块，该模块会将 <systemitem class="username">root</systemitem> 限制为仅可在文件 <filename>/etc/securetty</filename> 中列出的 TTY 设备上登录。
      </para>
     </step>
     <step>
      <para>
       在 <filename>/etc/securetty</filename> 中仅保留一个项，并去除所有其他项。这将限制对 TTY 设备的 root 访问。
      </para>
     <screen>#
# This file contains the device names of tty lines (one per line,
# without leading /dev/) on which root is allowed to login.
#
tty1</screen>
     </step>
     <step>
      <para>
       检查是否拒绝 <systemitem class="username">root</systemitem> 登录到其他终端。应立即拒绝在 <literal>tty2</literal> 等终端上登录，甚至无需查询帐户口令。同时确保您仍可成功登录到 <literal>tty1</literal>，因而不会将 <systemitem class="username">root</systemitem> 锁定在系统之外。
      </para>
     </step>
    </procedure>

    <important>
     <title>请不要添加 pam_securetty 模块</title>
     <para>
      不要将 <literal>pam_securetty</literal> 模块添加到 <filename>/etc/pam.d/common-auth</filename> 文件中。这会破坏 <command>su</command> 和 <command>sudo</command> 命令，因为这些工具也会拒绝 <systemitem class="username">root</systemitem> 身份验证。
     </para>
    </important>

    <important>
     <para>
      这些配置更改还将导致拒绝在 <filename>/dev/ttyS0</filename> 等串行控制台上进行 root 登录。如果您需要此类用例，则需要在 <filename>/etc/securetty</filename> 文件中额外列出相应的 TTY 设备。
     </para>
    </important>
   </sect2>

   <sect2 xml:id="sec-sec-prot-restrict-root-graphical">
    <title>限制图形会话登录</title>

    <para>
     要提高您服务器的安全性，请完全避免使用图形环境。通常，图形程序不会设计为以 <systemitem class="username">root</systemitem> 身份运行，因此与控制台程序相比可能包含安全问题。如果您需要图形登录，请使用非 <systemitem class="username">root</systemitem> 登录。配置您的系统，禁止通过 <systemitem class="username">root</systemitem> 登录图形会话。
    </para>

    <para>
     为了防止通过 <systemitem class="username">root</systemitem> 登录图形会话，您可以采用<xref linkend="sec-sec-prot-restrict-root-tty"/>中概述的相同基本步骤。只需将 <literal>pam_securetty</literal> 模块添加到属于显示管理器的 PAM 堆栈文件 — 例如，GDM 的 <filename>/etc/pam.d/gdm</filename>。图形会话还会在 TTY 设备上运行：默认为 <literal>tty7</literal>。因此，如果您限制 <systemitem class="username">root</systemitem> 登录到 <literal>tty1</literal>，则会拒绝 <systemitem class="username">root</systemitem> 在图形会话中登录。
    </para>
   </sect2>

   <sect2 xml:id="sec-sec-prot-restrict-root-ssh">
    <title>限制 SSH 登录</title>
    <para>
     默认情况下，还允许 <systemitem class="username">root</systemitem> 用户通过 SSH 网络协议远程登录计算机（如果 SSH 端口未被防火墙阻止）。要限制此类登录，请对 OpenSSH 配置进行以下更改：
    </para>
    <procedure>
     <step>
      <para>编辑 <filename>/etc/ssh/sshd_config</filename> 并调整以下参数：</para>
      <screen>PermitRootLogin no</screen>
     </step>
     <step>
      <para>重启动 <systemitem class="service">sshd</systemitem> 服务以使更改生效：</para>
      <screen>systemctl restart sshd.service</screen>
     </step>
    </procedure>
    <note>
     <para>
      对于 OpenSSH，不适合使用 PAM <literal>pam_securetty</literal> 模块，因为在授权期间并非所有 SSH 登录都会通过 PAM 堆栈进行（例如使用 SSH 公共密钥身份验证时）。此外，攻击者能够区分错误口令和策略只能在稍后予以拒绝的成功登录。
     </para>
    </note>
   </sect2>

  </sect1>

 <sect1 xml:id="sec-sec-prot-restrict-sudo">
   <title>限制 <command>sudo</command> 用户</title>
   <para>
    <command>sudo</command> 命令允许用户在另一个用户（通常是 <systemitem class="username">root</systemitem> 用户）的环境中执行命令。<command>sudo</command> 配置包含一个规则集，该规则集定义了要执行的命令与其允许的源和目标用户及组之间的映射。该配置存储在文件 <filename>/etc/sudoers</filename> 中。<phrase os="sles;sled">有关 <command>sudo</command> 的详细信息，请参见<xref linkend="cha-adm-sudo"/>。</phrase>
   </para>
   <para>
    默认情况下，<command>sudo</command> 会请求提供 SUSE 系统上的 <systemitem class="username">root</systemitem> 口令。但是，与 <command>su</command> 不同的是，<command>sudo</command> 会记住该口令并允许以 <systemitem class="username">root</systemitem> 身份执行其他命令，而不会在五分钟内再次请求提供口令。因此，应该仅为选定的管理员用户启用 <command>sudo</command>。
   </para>
   <procedure>
    <title>限制普通用户使用 <command>sudo</command></title>
    <step>
     <para>
      编辑文件 <filename>/etc/sudoers</filename>（例如，通过执行 <command>visudo</command>）。
     </para>
    </step>
    <step>
     <para>
      注释掉只要每个用户知道他们想要使用的用户的口令，就能运行每个命令的行。然后，该行应如下所示：
     </para>
<screen>#ALL ALL=(ALL) ALL # WARNING! Only use this together with 'Defaults targetpw'!</screen>
    </step>
    <step>
     <para>
      取消注释以下行：
     </para>
<screen>%wheel ALL=(ALL) ALL</screen>
     <para>
      这会将上述功能限制为仅供 <systemitem class="groupname">wheel</systemitem> 组的成员使用。您可以根据自己的设置使用其他组，因为 <systemitem class="groupname">wheel</systemitem> 可能有其他不当的作用。
     </para>
    </step>
    <step>
     <para>
      将应该允许其使用 <command>sudo</command> 的用户添加到所选的组。要将用户 <systemitem class="username">tux</systemitem> 添加到组 <systemitem class="groupname">wheel</systemitem>，请使用：
     </para>
<screen><command>usermod -aG <replaceable>wheel</replaceable> <replaceable>tux</replaceable></command></screen>
     <para>
      要获得新的组成员资格，用户必须注销再重新登录。
     </para>
    </step>
    <step>
     <para>
      使用不在您选择用于进行访问控制的组中的用户运行某个命令，以校验更改。此时应会看到以下错误消息：
     </para>
<screen>wilber is not in the sudoers file.  This incident will be reported.</screen>
     <para>
      接下来，尝试使用该组的成员执行相同的操作。该成员应该仍可通过 <command>sudo</command> 执行命令。
     </para>
    </step>
   </procedure>
   <para>
    此配置只会限制 <command>sudo</command> 功能。<command>su</command> 命令仍可供所有用户使用。如果能以其他方式访问系统，知道 <systemitem class="username">root</systemitem> 口令的用户可以轻松通过这种途径执行命令。
   </para>
  </sect1>

  <sect1 xml:id="sec-sec-prot-inactivity-logout">
   <title>为交互式外壳会话设置无活动超时</title>
   <para>
    最好在一段无活动时间之后终止交互式外壳会话。例如，通过此方式可以阻止打开的无人监管会话或避免浪费系统资源。
   </para>
   <para>
    默认情况下，外壳没有无活动超时。如果外壳处于打开状态且在几天甚至几年内未被使用，将不会有任何反应。不过，您可以将大多数外壳配置为在一段时间后自动终止空闲会话。以下示例显示如何为多种常见类型的外壳设置无活动超时。
   </para>
   <para>
    可仅为登录外壳配置无活动超时，也可以为所有交互式外壳配置无活动超时。在后一种情况下，将针对每个外壳实例单独运行无活动超时。这意味着超时将会累积。当启动子外壳时，会为子外壳开始新的超时，并且仅在此超时过后，才会继续运行父外壳的超时。
   </para>
   <para>
    下表包含 <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 随附的常见外壳选集的配置详细信息：
   </para>
   <informaltable frame="all" rowsep="1" colsep="1">
    <tgroup cols="7">
     <colspec colname="col_1" colwidth="14.2857*"/>
     <colspec colname="col_2" colwidth="14.2857*"/>
     <colspec colname="col_3" colwidth="14.2857*"/>
     <colspec colname="col_4" colwidth="14.2857*"/>
     <colspec colname="col_5" colwidth="14.2857*"/>
     <colspec colname="col_6" colwidth="14.2857*"/>
     <colspec colname="col_7" colwidth="14.2858*"/>
     <thead>
      <row>
       <entry>软件包</entry>
       <entry>外壳特点</entry>
       <entry align="center">外壳变量</entry>
       <entry align="center">时间单位</entry>
       <entry>只读设置</entry>
       <entry align="center">配置路径（仅登录外壳）</entry>
       <entry align="center">配置路径（所有外壳）</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><para><literal>bash</literal></para></entry>
       <entry><para><literal>bash, sh</literal></para></entry>
       <entry align="center"><para><literal>TMOUT</literal></para></entry>
       <entry align="center"><para>秒</para></entry>
       <entry><para><literal>read-only TMOUT=</literal></para></entry>
       <entry><para><filename>/etc/profile.local</filename>，<filename>/etc/profile.d/</filename></para></entry>
       <entry><para><filename>/etc/bash.bashrc</filename></para></entry>
      </row>
      <row>
       <entry><para><literal>mksh</literal></para></entry>
       <entry><para><literal>ksh, lksh, mksh, pdksh</literal></para></entry>
       <entry align="center"><para><literal>TMOUT</literal></para></entry>
       <entry align="center"><para>秒</para></entry>
       <entry><para><literal>read-only TMOUT=</literal></para></entry>
       <entry><para><filename>/etc/profile.local</filename>，<filename>/etc/profile.d/</filename></para></entry>
       <entry><para><filename>/etc/ksh.kshrc.local</filename></para></entry>
      </row>
      <row>
       <entry><para><literal>tcsh</literal></para></entry>
       <entry><para><literal>csh, tcsh</literal></para></entry>
       <entry align="center"><para><literal>autologout</literal></para></entry>
       <entry align="center"><para>分钟</para></entry>
       <entry><para><literal>set -r autologout=</literal></para></entry>
       <entry><para><filename>/etc/csh.login.local</filename></para></entry>
       <entry><para><filename>/etc/csh.cshrc.local</filename></para></entry>
      </row>
      <row>
       <entry><para><literal>zsh</literal></para></entry>
       <entry><para><literal>zsh</literal></para></entry>
       <entry align="center"><para><literal>TMOUT</literal></para></entry>
       <entry align="center"><para>秒</para></entry>
       <entry><para><literal>readonly TMOUT=</literal></para></entry>
       <entry><para><filename>/etc/profile.local</filename>，<filename>/etc/profile.d/</filename></para></entry>
       <entry><para><filename>/etc/zsh.zshrc.local</filename></para></entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
   <para>
    每个列出的外壳支持使用一个内部超时外壳变量，可将该变量设置为某个特定时间值以触发无活动超时。如果您要防止用户覆盖超时设置，可以将相应的外壳超时变量标记为只读。上表中还提供了相应的变量声明语法。
   </para>

   <note>
    <title>无法针对恶意用户提供保护</title>
    <para>
     此功能仅有助于避免因用户疏忽或遵循不安全做法而导致的风险。而无法防范恶意用户。超时只适用于外壳的交互式等待状态。恶意用户总是能找到绕过超时的方法，使得无论在任何情况下，都可以让其会话保持打开状态。
    </para>
   </note>

   <para>
    要配置无活动超时，需要为每个外壳的启动脚本都添加匹配的超时变量声明。可仅为登录外壳使用一种路径，或为所有外壳使用一种路径，如表中所列。以下示例使用适合 <command>bash</command> 和 <command>ksh</command> 的路径和设置，设置了无法被用户覆盖的只读登录外壳超时。创建包含以下内容的 <filename>/etc/profile.d/timeout.sh</filename> 文件：
   </para>
   <screen># /etc/profile.d/timeout.sh for SUSE Linux
#
# Timeout in seconds until the bash/ksh session is terminated
# in case of inactivity.
# 24h = 86400 sec
readonly TMOUT=86400</screen>

   <tip>
    <para>
     建议使用 <command>screen</command> 工具在注销前分离会话。<command>screen</command> 会话不会终止，一旦有需要便可重新挂接。可以在未注销的情况下锁定活动会话（有关细节，请阅读 <command>man screen</command> 中的 <keycombo>
      <keycombo><keycap function="control"/><keycap>A</keycap></keycombo>
      <keycap>X</keycap></keycombo>/<command>lockscreen</command>）。
    </para>
   </tip>

  </sect1>
  <sect1 xml:id="sec-sec-prot-dos">
   <title>防止意外拒绝服务</title>

   <para>
    Linux 允许您对用户和组可以使用的系统资源量设置限制。如果因为程序中的 bug 导致用户和组耗尽太多资源（例如内存泄漏）、降低计算机速度，甚至使系统无法使用，此项设置也非常有用。错误的设置可能会允许程序使用过多资源，这可能会导致服务器无法响应新连接，甚至无法响应本地登录请求（例如，如果某个程序用掉主机上的所有可用文件句柄）。这也会成为一个安全问题，例如，如果允许某人用掉所有系统资源，将会导致拒绝服务攻击（无论是无意的还是更糟的恶意攻击）。设置用户和组的资源限制可能是一种有效的系统保护方法，具体视环境而定。
   </para>

   <sect2 xml:id="sec-sec-prot-dos-restrict-resources">
    <title>限制系统资源示例</title>
    <para>
     以下示例演示了设置或限制 Oracle 用户帐户的系统资源使用的实际用法。有关系统资源设置的列表，请参见 <filename>/etc/security/limits.conf</filename> 或 <command>man
     limits.conf</command>。
    </para>
    <para>
     Bash 等大多数外壳都会提供基于用户的各种资源控制（例如允许的打开文件描述符数量上限或最大进程数）。要检查外壳中的所有当前限制，请执行以下命令：
    </para>
    <screen><prompt role="root"># </prompt>ulimit -a</screen>
    <para>
     有关 Bash 外壳的 <command>ulimit</command> 的详细信息，请查看 Bash 手册页。
    </para>
    <important>
     <title>设置 SSH 会话的限制</title>
     <para>
      使用 SSH 会话时，设置<quote>硬</quote>限制和<quote>软</quote>限制可能不会起到预期的效果。要查看有效行为，可能需要以 root 身份登录，然后使用 <command>su</command> 命令切换到权限受限的身份（例如，在这些示例中为 <literal>Oracle</literal>）。假设应用程序在引导过程中已自动启动，资源限制也应生效。如果对资源限制所做的更改看起来不起作用，可能需要将 <filename>/etc/ssh/sshd_config</filename> 中的 <option>UsePrivilegeSeparation</option> 设置为 <literal>no</literal> 并重启动 SSH 守护程序 (<command>systemctl restart sshd</command>)（通过 SSH）。但一般不建议这样做，因为这会降低系统安全性。
     </para>
    </important>
    <tip>
     <title>禁用通过 <command>ssh</command> 进行口令登录功能</title>
     <para>
      可以通过禁用 SSH 的口令身份验证来进一步提高服务器的安全性。请记住，您需要配置 SSH 密钥，否则无法访问服务器。要禁用口令登录，请将以下行添加到 <filename>/etc/ssh/sshd_config</filename> 中：
     </para>
<screen>UseLogin no
UsePAM no
PasswordAuthentication no
PubkeyAuthentication yes</screen>
    </tip>
    <para>
     在此示例中，可通过以 <systemitem class="username">root</systemitem> 身份编辑 <filename>/etc/security/limits.conf</filename> 并进行以下更改，来更改用户 <literal>oracle</literal> 可使用的文件句柄数或打开的文件数：
    </para>
<screen>oracle           soft    nofile          4096
oracle           hard    nofile          63536</screen>
    <para>
     第一行中的软限制定义了登录后 <systemitem class="username">oracle</systemitem> 用户将拥有的文件句柄（打开的文件）数目限制。如果用户看到有关文件句柄用尽的错误消息，则可以执行以下命令，将此示例中所示的文件句柄数增加到硬限制（在此示例中为 63536）：
    </para>
    <screen><prompt role="root"># </prompt>ulimit -n 63536</screen>
    <para>
     必要时，您可以设置更高的软限制和硬限制。
    </para>
    <note>
     <title>慎用 ulimit</title>
     <para>
      请务必合理利用 ulimit。允许对用户的 <literal>nofile</literal> 施加与内核限制 (<filename>/proc/sys/fs/file-max</filename>) 相同的<quote>硬</quote>限制是不当做法。如果用户占用了所有可用文件句柄，系统将无法启动新的登录，因为它无法访问执行登录所需的 PAM 模块。
     </para>
    </note>
    <para>
     您还需要确保在 <filename>/etc/pam.d/common-auth</filename> 中全局配置 <literal>pam_limits</literal>，或者针对以下文件中的 SSH、su、login 和 telnet 等个别服务进行配置：
    </para>
    <simplelist>
     <member><filename>/etc/pam.d/sshd</filename>（对于 SSH）</member>
     <member><filename>/etc/pam.d/su</filename>（对于 su）</member>
     <member><filename>/etc/pam.d/login</filename>（本地登录和 telnet）</member>
    </simplelist>
    <para>
     如果您不想为所有登录启用该配置，可以通过一个特定的 PAM 模块读取 <filename>/etc/security/limits.conf</filename> 文件。PAM 配置指令中的项如下所示：
    </para>
<screen>session     required      /lib/security/pam_limits.so
session     required      /lib/security/pam_unix.so</screen>
    <para>
     更改不会立即生效，需要建立新的登录会话才会生效：
    </para>
<screen><prompt role="root"># </prompt>su - oracle
<prompt>&gt; </prompt>ulimit -n
4096</screen>
    <para>
     请注意，这些示例特定于 Bash 外壳；其他外壳的 <command>ulimit</command> 选项有所不同。用户 <literal>oracle</literal> 的默认限制为 <literal>4096</literal>。要将用户 <literal>oracle</literal> 可使用的文件句柄数增加至 <literal>63536</literal>，请执行以下命令：
    </para>
<screen><prompt role="root"># </prompt>su - oracle
<prompt>&gt; </prompt>ulimit -n
4096
<prompt>&gt; </prompt>ulimit -n 63536
<prompt>&gt; </prompt>ulimit -n
63536</screen>
    <para>
     要使其成为永久设置，需要向用户配置文件（<filename>~/.bashrc</filename> 或 <filename>~/.profile</filename> 文件）添加设置 <command>ulimit -n 63536</command>（仍是适用于 Bash），该配置文件是 <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 上的 Bash 外壳的用户启动文件（要校验外壳，请运行 <command>echo $SHELL</command>）。为此，可以针对用户 <literal>oracle</literal> 的 Bash 外壳运行以下命令：
    </para>
<screen><prompt role="root"># </prompt>su - oracle
<prompt>&gt; </prompt>cat &gt;&gt; ~oracle/.bash_profile &lt;&lt; EOF
ulimit -n 63536
EOF</screen>
   </sect2>
  </sect1>

  <sect1 xml:id="sec-sec-prot-banners">
   <title>显示登录标题</title>

   <para>
    出于法律/审计政策原因，或者为了向用户提供安全说明，通常有必要在所有服务器上的登录屏幕上设置一个标题。
   </para>

   <para>
    要在用户登录到文本型终端（例如，使用 SSH 或在本地控制台上）<emphasis>之后</emphasis>列显登录标题，可以使用 <filename>/etc/motd</filename> 文件（motd = 当天的消息）。默认情况下，该文件存在于 <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 上，但是空文件。只需向适用的/组织所需的文件中添加内容。
   </para>

   <note>
    <title>标题长度</title>
    <para>
     请尽量将登录标题内容放在一个终端页面（或更少）中，如果一页容纳不下而需要滚动屏幕，会使阅读变得更加困难。
    </para>
   </note>

   <para>
    您也可以在用户登录文本型终端<emphasis>前</emphasis>列显登录标题。对于本地控制台登录，您可以编辑 <filename>/etc/issue</filename> 文件，这会使标题在出现登录提示之前显示。如果通过 SSH 进行登录，您可以编辑 <filename>/etc/ssh/sshd_config</filename> 文件中的 <quote>Banner</quote> 参数，这样会在出现 SSH 登录提示之前相应地显示标题文本。
   </para>

   <para>
    如果通过 GDM 进行图形登录，您可以遵循 <link xlink:href="https://help.gnome.org/admin/system-admin-guide/stable/login-banner.html.en">
    the GNOME admin guide</link> 设置登录标题。此外，您可以进行以下更改，以要求用户通过选择<guimenu>是</guimenu>或<guimenu>否</guimenu>来对法律标题进行确认。编辑 <filename>/etc/gdm/Xsession</filename> 文件，并在脚本<emphasis>开头</emphasis>添加下面几行：
   </para>

<screen>if ! /usr/bin/gdialog --yesno '\n<replaceable>This system is classified...</replaceable>\n' 10 10; then
    /usr/bin/gdialog --infobox 'Aborting login'
    exit 1;
fi</screen>

   <para>
    需将文本 <replaceable>This system is classified...</replaceable> 替换为所需的标题文本。请注意，此对话框不会阻止登录继续进行。有关 GDM 脚本的详细信息，请参见 <link xlink:href="https://help.gnome.org/admin/gdm/stable/configuration.html.en#scripting">
    GDM Admin Manual</link>。
   </para>
  </sect1>
     <sect1 xml:id="sec-sec-prot-misc-account-utils">
    <title>连接统计实用程序</title>
    <para>
     下面是您可以用于获取有关用户登录的数据的命令列表：
    </para>
    <formalpara>
     <title><command>who</command></title>
     <para>
      列出当前登录的用户。
     </para>
    </formalpara>
    <formalpara>
     <title><command>w</command></title>
     <para>
      显示登录者及其执行的操作。
     </para>
    </formalpara>
    <formalpara>
     <title><command>last</command></title>
     <para>
      显示最近登录的用户列表，包括登录时间、注销时间、登录 IP 地址等。
     </para>
    </formalpara>
    <formalpara>
     <title><command>lastb</command></title>
     <para>
      与 <command>last</command> 相同，只不过此命令默认会显示包含所有无效登录尝试的 <filename>/var/log/btmp</filename>。
     </para>
    </formalpara>
    <formalpara>
     <title><command>lastlog</command></title>
     <para>
      此命令报告 <filename>/var/log/lastlog</filename> 中维护的数据，该文件记录用户上次登录的情况。
     </para>
    </formalpara>
    <formalpara>
     <title><command>ac</command></title>
     <para>
      安装 <systemitem>acct</systemitem> 软件包之后提供。按用户或每天列显连接时间（以小时为单位）。此命令会读取 <filename>/var/log/wtmp</filename>。
     </para>
    </formalpara>
    <formalpara>
     <title><command>dump-utmp</command></title>
     <para>
      将原始数据从 /var/run/utmp 或 <filename>/var/log/wtmp</filename> 转换为 ASCII 可分析格式。
     </para>
    </formalpara>
    <para>
     此外，如果未运行任何日志记录工具，请检查 <filename>/var/log/messages</filename> 文件或 <command>journalctl</command> 的输出。有关<systemitem class="daemon">systemd</systemitem>日志的详细信息，请参见<xref linkend="cha-journalctl"/>。
    </para>
   </sect1>
  </chapter>
