<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>

<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="cha-ssh">
 <title>SSH: Secure Network Operations</title>
 <info>
  <abstract>
   <para>
    In networked environments, it is often necessary to access hosts from a
    remote location. If a user sends login and password strings for
    authentication purposes as plain text, they could be intercepted and
    misused to gain access to that user account. This would open all the user's files to an attacker
    and the illegal account could be used to obtain administrator or
    <systemitem class="username">root</systemitem> access, or to penetrate
    other systems. In the past, remote connections were established with
    <command>telnet</command>, <command>rsh</command> or
    <command>rlogin</command>, which offered no guards against eavesdropping
    in the form of encryption or other security mechanisms. There are other
    unprotected communication channels, like the traditional FTP protocol
    and some remote copying programs like <command>rcp</command>.
   </para>
  </abstract>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker>
   </dm:bugtracker>
  </dm:docmanager>
 </info>
 <para>
  The SSH suite provides the necessary protection by encrypting the
  authentication strings (usually a login name and a password) and all the
  other data exchanged between the hosts. With SSH, the data flow could
  still be recorded by a third party, but the contents are encrypted and
  cannot be reverted to plain text unless the encryption key is known. So
  SSH enables secure communication over insecure networks, such as the
  Internet. The SSH implementation coming with &productname; is OpenSSH.
 </para>
 <para>
  &productname; installs the OpenSSH package by default providing the
  commands <command>ssh</command>, <command>scp</command>, and
  <command>sftp</command>. In the default configuration, remote access of a
  &productname; system is only possible with the OpenSSH utilities, and
  only if the <systemitem class="daemon">sshd</systemitem> is running and
  the firewall permits access.
 </para>
 <para>
  SSH on &productname; uses cryptographic hardware acceleration
  if available. As a result, the transfer of large quantities of data
  through an SSH connection is considerably faster than without
  cryptographic hardware. As an additional benefit, the CPU will see a
  significant reduction in load.
 </para>
 <sect1 xml:id="sec-ssh-programm">
  <title><command>ssh</command>&mdash;Secure Shell</title>

  <para>
   With <command>ssh</command> it is possible to log in to remote
   systems and to work interactively. To log in to the host
   <literal>&exampleserver;</literal> as user &exampleuser; enter one of
   the following commands:
  </para>

<screen>&prompt.user;ssh &exampleuser_plain;@&exampleserver;
&prompt.user;ssh -l &exampleuser_plain; &exampleserver;</screen>

  <para>
   If the user name is the same on both machines, you can omit it. Using
   <command>ssh &exampleserver;</command> is sufficient. The remote host
   prompts for the remote user's password. After a successful
   authentication, you can work on the remote command line or use
   interactive applications, such as &yast; in text mode.
  </para>

  <para>
   Furthermore, <command>ssh</command> offers the possibility to run
   non-interactive commands on remote systems using <command>ssh</command>
   <replaceable>HOST</replaceable> <replaceable>COMMAND</replaceable>.
   <replaceable>COMMAND</replaceable> needs to be properly quoted. Multiple
   commands can be concatenated as on a local shell.
  </para>

<screen>&prompt.user;ssh root@&exampleserver; "dmesg -T | tail -n 25"
&prompt.user;ssh root@&exampleserver; "cat /etc/issue &amp;&amp; uptime"</screen>

  <sect2 xml:id="sec-ssh-programm-x">
   <title>Starting X Applications on a Remote Host</title>
   <para>
    SSH also simplifies the use of remote X applications. If you run
    <command>ssh</command> with the <option>-X</option> option, the
    <envar>DISPLAY</envar> variable is automatically set on the remote
    machine and all X output is exported to the local machine over the
    existing SSH connection. At the same time, X applications started
    remotely cannot be intercepted by unauthorized individuals.
   </para>
  </sect2>

  <sect2 xml:id="sec-ssh-programm-forwarding">
   <title>Agent Forwarding</title>
   <para>
    By adding the <option>-A</option> option, the ssh-agent authentication
    mechanism is carried over to the next machine. This way, you can work
    from different machines without having to enter a password, but only if
    you have distributed your public key to the destination hosts and
    properly saved it there. Refer to
    <xref linkend="sec-ssh-authentic-key-copy"/> for details.
   </para>
   <para>
    This mechanism is deactivated in the default settings, but can be
    permanently activated at any time in the system-wide configuration file
    <filename>/etc/ssh/sshd_config</filename> by setting
    <literal>AllowAgentForwarding yes</literal>.
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-ssh-copy">
  <title><command>scp</command>&mdash;Secure Copy</title>

  <para>
   <command>scp</command> copies files to or from a remote machine.  If
   the user name on &wsI; is different than the user name on
   &exampleserver;, specify the latter using the
   <option><replaceable>USER_NAME</replaceable>@host</option> format. If
   the file should be copied into a directory other than the remote
   user's home directory, specify it as
   &exampleserver;:<replaceable>DIRECTORY</replaceable>. The following
   examples show how to copy a file from a local to a remote machine and
   vice versa.
  </para>

<screen>&prompt.user;scp ~/MyLetter.tex &exampleuser_plain;@&exampleserver;:/tmp <co xml:id="co-scp-local-remote"/>
&prompt.user;scp &exampleuser_plain;@&exampleserver;:/tmp/MyLetter.tex ~ <co xml:id="co-scp-remote-local"/></screen>
<calloutlist>
 <callout arearefs="co-scp-local-remote">
  <para>local to remote</para>
</callout>
 <callout arearefs="co-scp-remote-local">
  <para>remote to local</para>
 </callout>
</calloutlist>
  <tip>
   <title>The <option>-l</option> Option</title>
   <para>
    With the <command>ssh</command> command, the option
    <option>-l</option> can be used to specify a remote user (as an
    alternative to the
    <option><replaceable>USER_NAME</replaceable>@host</option>
    format). With <command>scp</command> the option <option>-l</option>
    is used to limit the bandwidth consumed by <command>scp</command>.
   </para>
  </tip>

  <para>
   After the correct password is entered, <command>scp</command> starts the
   data transfer. It displays a progress bar and the time remaining for each
   file that is copied. Suppress all output with the <option>-q</option>
   option.
  </para>

  <para>
   <command>scp</command> also provides a recursive copying feature for
   entire directories. The command
  </para>

<screen>&prompt.user;scp -r src/ sun:backup/</screen>

  <para>
   copies the entire contents of the directory <filename>src</filename>
   including all subdirectories to the <filename>~/backup</filename>
   directory on the host &exampleserver;. If this subdirectory does not
   exist, it is created automatically.
  </para>

  <para>
   The <option>-p</option> option tells <command>scp</command> to leave the
   time stamp of files unchanged. <option>-C</option> compresses the data
   transfer. This minimizes the data volume to transfer, but creates a
   heavier burden on the processors of both machines.
  </para>
 </sect1>
 <sect1 xml:id="sec-ssh-sftp">
  <title><command>sftp</command>&mdash;Secure File Transfer</title>

  <sect2 xml:id="sec-ssh-sftp-using">
   <title>Using <command>sftp</command></title>
  <para>
   If you want to copy several files from or to different locations,
   <command>sftp</command> is a convenient alternative to
   <command>scp</command>. It opens a shell with a set of commands similar
   to a regular FTP shell. Type <command>help</command> at the sftp-prompt
   to get a list of available commands. More details are available from the
   <command>sftp</command> man page.
  </para>

<screen>&prompt.user;sftp &exampleserver;
Enter passphrase for key '/home/&exampleuser_plain;/.ssh/id_rsa':
Connected to &exampleserver;.
sftp&gt; help
Available commands:
bye                                Quit sftp
cd path                            Change remote directory to 'path'
[...]</screen>
  </sect2>
  <sect2 xml:id="sec-ssh-sftp-perms">
   <title>Setting Permissions for File Uploads</title>
   <para>
    As with a regular FTP server, a user cannot only download,
        but also upload files to a remote machine running an SFTP server
        by using the <command>put</command> command. By default the
        files will be uploaded to the remote host with the same
        permissions as on the local host. There are two options to
        automatically alter these permissions:
   </para>
   <variablelist>
    <varlistentry>
     <term>Setting a umask</term>
     <listitem>
      <para>
       A umask works as a filter against the permissions of the original
       file on the local host. It can only withdraw permissions:
      </para>
      <table>
       <title/>
       <tgroup cols="3">
        <colspec colnum="1" colname="1" colwidth="33*"/>
        <colspec colnum="2" colname="2" colwidth="33*"/>
        <colspec colnum="3" colname="3" colwidth="33*"/>
        <thead>
         <row>
          <entry>
           <para>
            permissions original
           </para>
          </entry>
          <entry>
           <para>
            umask
           </para>
          </entry>
          <entry>
           <para>
            permissions uploaded
           </para>
          </entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry>
           <para>
            0666
           </para>
          </entry>
          <entry>
           <para>
            0002
           </para>
          </entry>
          <entry>
           <para>
            0664
           </para>
          </entry>
         </row>
         <row>
          <entry>
           <para>
            0600
           </para>
          </entry>
          <entry>
           <para>
            0002
           </para>
          </entry>
          <entry>
           <para>
            0600
           </para>
          </entry>
         </row>
         <row>
          <entry>
           <para>
            0775
           </para>
          </entry>
          <entry>
           <para>
            0025
           </para>
          </entry>
          <entry>
           <para>
            0750
           </para>
          </entry>
         </row>
        </tbody>
       </tgroup>
      </table>
      <para>
       To apply a umask on an SFTP server, edit the file
       <filename>/etc/ssh/sshd_configuration</filename>. Search for the line
       beginning with <literal>Subsystem sftp</literal> and add the
       <option>-u</option> parameter with the desired setting, for example:
      </para>
<screen>Subsystem sftp /usr/lib/ssh/sftp-server -u 0002</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Explicitly Setting the Permissions</term>
     <listitem>
      <para>
       Explicitly setting the permissions sets the same permissions for all
       files uploaded via SFTP. Specify a three-digit pattern such as
       <literal>600</literal>, <literal>644</literal>, or
       <literal>755</literal> with <option>-u</option>. When both
       <option>-m</option> and <option>-u</option> are specified,
       <literal>-u</literal> is ignored.
      </para>
      <para>
       To apply explicit permissions for uploaded files on an SFTP server,
       edit the file <filename>/etc/ssh/sshd_configuration</filename>.
       Search for the line beginning with <literal>Subsystem sftp</literal>
       and add the <option>-m</option> parameter with the desired setting,
       for example:
      </para>
<screen>Subsystem sftp /usr/lib/ssh/sftp-server -m 600</screen>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-ssh-sshdserver">
  <title>The SSH Daemon (<systemitem class="daemon">sshd</systemitem>)</title>

  <para>
   To work with the SSH client programs <command>ssh</command> and
   <command>scp</command>, a server (the SSH daemon) must be running in the
   background, listening for connections on <literal>TCP/IP port
   22</literal>. The daemon generates three key pairs when starting for the
   first time. Each key pair consists of a private and a public key.
   Therefore, this procedure is called public key-based. To
   guarantee the security of the communication via SSH, access to the
   private key files must be restricted to the system administrator. The
   file permissions are set accordingly by the default installation. The
   private keys are only required locally by the SSH daemon and must not be
   given to anyone else. The public key components (recognizable by the name
   extension <filename>.pub</filename>) are sent to the client requesting
   the connection. They are readable for all users.
  </para>

  <para>
   A connection is initiated by the SSH client. The waiting SSH daemon and
   the requesting SSH client exchange identification data to compare the
   protocol and software versions, and to prevent connections through the
   wrong port. Because a child process of the original SSH daemon replies to
   the request, several SSH connections can be made simultaneously.
  </para>

  <para>
   For the communication between SSH server and SSH client, OpenSSH supports
   versions&nbsp;1 and 2 of the SSH protocol. Version&nbsp;2 of the
   SSH protocol is used by default. Override this to use version&nbsp;1
   of protocol with the <option>-1</option> option.
  </para>

  <para>
   When using version&nbsp;1 of SSH, the server sends its public host key
   and a server key, which is regenerated by the SSH daemon every hour. Both
   allow the SSH client to encrypt a freely chosen session key, which is
   sent to the SSH server. The SSH client also tells the server which
   encryption method (cipher) to use. Version&nbsp;2 of the SSH protocol
   does not require a server key. Both sides use an algorithm according to
   Diffie-Hellman to exchange their keys.
  </para>

  <para>
   The private host and server keys are absolutely required to decrypt the
   session key and cannot be derived from the public parts. Only the
   contacted SSH daemon can decrypt the session key using its private keys.
   This initial connection phase can be watched closely by turning on
   verbose debugging using the <option>-v</option> option of the SSH client.
  </para>


  <tip>
   <title>Viewing the SSH Daemon Log File</title>
   <para>
    To watch the log entries from the <systemitem
    class="daemon">sshd</systemitem> use the following command:
   </para>
   <screen>&prompt.sudo;journalctl -u sshd</screen>
  </tip>


  <sect2>
   <title>Maintaining SSH Keys</title>
  <para>
   It is recommended to back up the private and public keys stored in
   <filename>/etc/ssh/</filename> in a secure, external location. In this
   way, key modifications can be detected or the old ones can be used again
   after having installed a new system.
  </para>

  <tip>
   <title>Existing SSH Host Keys</title>
   <para>
    If you install &productname; on a machine with existing Linux
    installations, the installation routine automatically imports the SSH
    host key with the most recent access time from an existing installation.
   </para>
  </tip>

  <para>
   When establishing a secure connection with a remote host for the first
   time, the client stores all public host keys in
   <filename>~/.ssh/known_hosts</filename>. This prevents any
   man-in-the-middle attacks&mdash;attempts by foreign SSH servers to use
   spoofed names and IP addresses. Such attacks are detected either by a
   host key that is not included in <filename>~/.ssh/known_hosts</filename>,
   or by the server's inability to decrypt the session key in the absence of
   an appropriate private counterpart.
  </para>

  <para>
   If the public keys of a host have changed (that needs to be verified
   before connecting to such a server), the offending keys can be
   removed with <command>ssh-keygen -r
   <replaceable>HOSTNAME</replaceable></command>.
  </para>
  </sect2>
  <sect2 xml:id="sec-ssh-sshdserver-rotating">
   <title>Rotating Host Keys</title>
   <para>
    As of version 6.8, OpenSSH comes with a protocol extension that
    supports host key rotation.  It makes sense to replace keys, if you
    are still using weak keys such as 1024-bit RSA keys.  It is strongly
    recommended to replace such a key and go for 2048-bit DSA keys or
    something even better.  The client will then use the
    <quote>best</quote> host key.
   </para>
   <tip>
    <title>Restarting sshd</title>
    <para>
     After installing new host keys on the server, restart sshd.
    </para>
   </tip>
   <para>
    This protocol extension can
    inform a client of all the new host keys on the server, if the user
    initiates a connection with <command>ssh</command>.  Then, the
    software on the client updates
    <filename>~/.ssh/known_hosts</filename>, and the user is not
    required to accept new keys of previously known and trusted hosts
    manually.  The local <filename>known_hosts</filename> file will
    contain all the host keys of the remote hosts, in addition to the
    one that authenticated the host during this session.
   </para>
   <para>
    Once the administrator of the server knows that all the clients have
    fetched the new keys, they can remove the old keys. The protocol
    extension ensures that the obsolete keys will be removed from the
    client's configuration, too. The key removal occurs while initiating
    an <command>ssh</command> session.
   </para>
   <para>
    For more information, see:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      <link xlink:href="http://blog.djm.net.au/2015/02/key-rotation-in-openssh-68.html"/>
     </para>
    </listitem>
    <listitem>
     <para>
      <link xlink:href="http://heise.de/-2540907"/>
      (<quote xml:lang="de">Endlich neue Schlüssel für SSH-Server,</quote> German only)
     </para>
    </listitem>
   </itemizedlist>
  </sect2>
 </sect1>

 <!-- ================================================================ -->

<sect1 xml:id="sec-ssh-authentic">
  <title>SSH Authentication Mechanisms</title>

  <para>
   In its simplest form, authentication is done by entering the user's
   password just as if logging in locally. However, having to memorize
   passwords of several users on remote machines is inefficient. What is
   more, these passwords may change. On the other hand&mdash;when
   granting &rootuser; access&mdash;an administrator needs to be able
   to quickly revoke such a permission without having to change the
   &rootuser; password.
  </para>

  <para>
   To accomplish a login that does not require to enter the remote
   user's password, SSH uses another key pair, which needs to be generated
   by the user. It consists of a public (<filename>id_rsa.pub</filename> or
   <filename>id_dsa.pub</filename>) and a private key
   (<filename>id_rsa</filename> or <filename>id_dsa</filename>).
  </para>

  <para>
   To be able to log in without having to specify the remote user's
   password, the public key of the <quote>SSH user</quote> must be
   in <filename>~/.ssh/authorized_keys</filename>. This approach also
   ensures that the remote user has got full control: adding the key
   requires the remote user's password and removing the key revokes the
   permission to log in from remote.
  </para>

  <para>
   For maximum security such a key should be protected by a passphrase which
   needs to be entered every time you use <command>ssh</command>,
   <command>scp</command>, or <command>sftp</command>. Contrary to the
   simple authentication, this passphrase is independent from the remote
   user and therefore always the same.
  </para>

  <para>
   An alternative to the key-based authentication described above, SSH also
   offers a host-based authentication. With host-based authentication, users
   on a trusted host can log in to another host on which this feature is
   enabled using the same user name. &productname; is set up for using
   key-based authentication, covering setting up host-based authentication
   on &productname; is beyond the scope of this manual.
  </para>

  <note>
<!-- fix for bug #398647 -->
   <title>File Permissions for Host-Based Authentication</title>
   <para>
    If the host-based authentication is to be used, the file
    <filename>/usr/lib/ssh/ssh-keysign</filename> (32-bit systems) or
    <filename>/usr/lib64/ssh/ssh-keysign</filename> (64-bit systems) should
    have the setuid bit set, which is not the default setting in
    &productname;. In such case, set the file permissions manually. You
    should use <filename>/etc/permissions.local</filename> for this purpose,
    to make sure that the setuid bit is preserved after security updates of
    <package>openssh</package>.
   </para>
  </note>

  <sect2 xml:id="sec-ssh-authentic-gen-key">
   <title>Generating an SSH Key</title>
   <procedure>
    <step>
     <para>
      To generate a key with default parameters (RSA, 2048 bits), enter the
      command <command>ssh-keygen</command>.
     </para>
    </step>
    <step>
     <para>
      Accept the default location to store the key
      (<filename>~/.ssh/id_rsa</filename>) by pressing
      <keycap function="enter"/> (strongly recommended) or enter an
      alternative location.
     </para>
    </step>
    <step>
     <para>
      Enter a passphrase consisting of 10 to 30 characters. The same rules
      as for creating safe passwords apply. It is strongly advised to
      refrain from specifying no passphrase.
     </para>
    </step>
   </procedure>
   <para>
    You should make absolutely sure that the private key is not accessible
    by anyone other than yourself (always set its permissions to
    <literal>0600</literal>). The private key must never fall into the hands
    of another person.
   </para>
   <para>
    To change the password of an existing key pair, use the command
    <command>ssh-keygen -p</command>.
   </para>
  </sect2>

  <sect2 xml:id="sec-ssh-authentic-key-copy">
   <title>Copying an SSH Key</title>
   <para>
    To copy a public SSH key to <filename>~/.ssh/authorized_keys</filename>
    of a user on a remote machine, use the command
    <command>ssh-copy-id</command>. To copy your personal key
    stored under <filename>~/.ssh/id_rsa.pub</filename> you may use the
    short form. To copy DSA keys or keys of other users, you need
    to specify the path:
   </para>
  <screen>&prompt.user;<prompt>~/.ssh/id_rsa.pub</prompt>
ssh-copy-id -i &exampleuser_plain;@&exampleserver;

&prompt.user;<prompt>~/.ssh/id_dsa.pub</prompt>
ssh-copy-id -i ~/.ssh/id_dsa.pub  &exampleuser_plain;@&exampleserver;

&prompt.user;<prompt>~notme/.ssh/id_rsa.pub</prompt>
ssh-copy-id -i ~notme/.ssh/id_rsa.pub  &exampleuser_plain;@&exampleserver;</screen>
   <para>
    To successfully copy the key, you need to enter the remote
    user's password. To remove an existing key, manually edit
    <filename>~/.ssh/authorized_keys</filename>.
   </para>
  </sect2>

  <sect2 xml:id="sec-ssh-authentic-agent">
   <title>Using the <command>ssh-agent</command></title>
   <para>
    When doing lots of secure shell operations it is cumbersome to type the
    SSH passphrase for each such operation. Therefore, the SSH package
    provides another tool, <command>ssh-agent</command>, which retains the
    private keys for the duration of an X or terminal session. All other
    windows or programs are started as clients to the
    <command>ssh-agent</command>. By starting the agent, a set of
    environment variables is set, which will be used by
    <command>ssh</command>, <command>scp</command>, or
    <command>sftp</command> to locate the agent for automatic login. See
    the <command>ssh-agent</command> man page for details.
   </para>
   <para>
    After the <command>ssh-agent</command> is started, you need to add your
    keys by using <command>ssh-add</command>. It will prompt for the
    passphrase. After the password has been provided once, you can use the
    secure shell commands within the running session without having to
    authenticate again.
   </para>
   <sect3 xml:id="sec-ssh-authentic-agent-x">
    <title>Using <command>ssh-agent</command> in an X Session</title>
    <para>
     On &productname;, the <command>ssh-agent</command> is automatically
     started by the &gnome; display manager. To also invoke
     <command>ssh-add</command> to add your keys to the agent at the
     beginning of an X session, do the following:
    </para>
    <procedure>
     <step>
      <para>
       Log in as the desired user and check whether the file
       <filename>~/.xinitrc</filename> exists.
      </para>
     </step>
     <step>
      <para>
       If it does not exist, use an existing template or copy it from
       <filename>/etc/skel</filename>:
      </para>
<screen>if [ -f ~/.xinitrc.template ]; then mv ~/.xinitrc.template ~/.xinitrc; \
else cp /etc/skel/.xinitrc.template ~/.xinitrc; fi</screen>
     </step>
     <step>
      <para>
       If you have copied the template, search for the following lines and
       uncomment them. If <filename>~/.xinitrc</filename> already existed,
       add the following lines (without comment signs).
      </para>
<screen># if test -S "$SSH_AUTH_SOCK" -a -x "$SSH_ASKPASS"; then
#       ssh-add &lt; /dev/null
# fi</screen>
     </step>
     <step>
      <para>
       When starting a new X session, you will be prompted for your SSH
       passphrase.
      </para>
     </step>
    </procedure>
   </sect3>
   <sect3 xml:id="sec-ssh-authentic-agent-terminal">
    <title>Using <command>ssh-agent</command> in a Terminal Session</title>
    <para>
     In a terminal session you need to manually start the
     <command>ssh-agent</command> and then call <command>ssh-add</command>
     afterward. There are two ways to start the agent. The first example
     given below starts a new Bash shell on top of your existing shell. The
     second example starts the agent in the existing shell and modifies the
     environment as needed.
    </para>
<screen>&prompt.user;ssh-agent -s /bin/bash
eval $(ssh-agent)
    </screen>
    <para>
     After the agent has been started, run <command>ssh-add</command> to
     provide the agent with your keys.
    </para>
   </sect3>
  </sect2>

<!-- fs 2012-10-02:

     Not sure what to do with this...

    <sect2 id="sec-ssh-authentic-host-based">
   <title>Host-based Authentication</title>
   <para></para>
  </sect2>
-->
 </sect1>
 <sect1 xml:id="sec-ssh-port-forwarding">
  <title>Port Forwarding</title>

  <para>
   <command>ssh</command> can also be used to redirect TCP/IP connections.
   This feature, also called <literal>SSH tunneling</literal>, redirects TCP
   connections to a certain port to another machine via an encrypted
   channel.
  </para>

  <para>
   With the following command, any connection directed to &wsI; port 25
   (SMTP) is redirected to the SMTP port on &exampleserver;. This is
   especially useful for those using SMTP servers without SMTP-AUTH or
   POP-before-SMTP features. From any arbitrary location connected to a
   network, e-mail can be transferred to the <quote>home</quote> mail server
   for delivery.
  </para>

<screen>&prompt.root;ssh -L 25:&exampleserver;:25 &wsI;</screen>

  <para>
   Similarly, all POP3 requests (port&nbsp;110) on &wsI; can be
   forwarded to the POP3 port of &exampleserver; with this command:
  </para>

<screen>&prompt.root;ssh -L 110:&exampleserver;:110 &wsI;</screen>

  <para>
   Both commands must be executed as &rootuser;, because the connection
   is made to privileged local ports. E-mail is sent and retrieved by
   normal users in an existing SSH connection. The SMTP and POP3 host
   must be set to <literal>localhost</literal> for this to
   work. Additional information can be found in the manual pages for
   each of the programs described above and in the OpenSSH package
   documentation under
   <filename>/usr/share/doc/packages/openssh</filename>.
  </para>
 </sect1>

 <sect1 xml:id="sec-ssh-publickey">
  <title>Adding and Removing Public Keys on an Installed System</title>
  <para>
   In some environments, it is convenient or necessary to log in over SSH.
   As such, the user needs to provide a public SSH key. To add or remove
   an SSH key, proceed as follows:
  </para>
  <procedure>
   <step>
    <para>Open &yast;.</para>
   </step>
   <step>
    <para>
      Under <guimenu>Security and Users</guimenu>, open the
     <guimenu>User and Group Management</guimenu> module.
    </para>
   </step>
   <step>
    <para>
     Select the user you want to change and press <guimenu>Edit</guimenu>.
    </para>
   </step>
   <step>
    <para>
     Switch to the <guimenu>SSH Public Key</guimenu> tab.
    </para>
   </step>
   <step>
    <para>
     Add or remove your public key(s). If you add a public SSH key, look
     for the file extension <filename class="extension">.pub</filename>.
    </para>
   </step>
   <step>
    <para>Confirm with <guimenu>Ok</guimenu>.</para>
   </step>
  </procedure>

  <para>
   Your public SSH key is saved in <filename>~/.ssh/authorized_keys</filename>.
  </para>
 </sect1>

 <sect1 xml:id="sec-security-ssh-moreinfo">
  <title>For More Information</title>

  <para/>

  <variablelist>
   <varlistentry>
    <term><link xlink:href="http://www.openssh.com"/>
    </term>
    <listitem>
     <para>
      The home page of OpenSSH
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><link xlink:href="http://en.wikibooks.org/wiki/OpenSSH"/>
    </term>
    <listitem>
     <para>
      The OpenSSH Wikibook
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>man sshd</command>
    </term>
    <listitem>
     <para>
      The man page of the OpenSSH daemon
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>man ssh_config</command>
    </term>
    <listitem>
     <para>
      The man page of the OpenSSH SSH client configuration files
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>man scp</command>
    </term>
    <term><command>man sftp</command>
    </term>
    <term><command>man slogin</command>
    </term>
    <term><command>man ssh</command>
    </term>
    <term><command>man ssh-add</command>
    </term>
    <term><command>man ssh-agent</command>
    </term>
    <term><command>man ssh-copy-id</command>
    </term>
    <term><command>man ssh-keyconvert</command>
    </term>
    <term><command>man ssh-keygen</command>
    </term>
    <term><command>man ssh-keyscan</command>
    </term>
    <listitem>
     <para>
      Man pages of several binary files to securely copy files
      (<command>scp</command>, <command>sftp</command>), to log in
      (<command>slogin</command>, <command>ssh</command>), and to manage
      keys.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>
     <filename>/usr/share/doc/packages/openssh/README.SUSE</filename>
    </term>
    <term>
     <filename>/usr/share/doc/packages/openssh/README.FIPS</filename>
    </term>
    <listitem>
     <para>
      &suse; package specific documentation; changes in defaults with respect to
      upstream, notes on FIPS mode etc.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
</chapter>
