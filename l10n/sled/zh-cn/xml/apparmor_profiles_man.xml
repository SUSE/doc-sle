<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="apparmor_profiles_man.xml" version="5.0" role="General" xml:id="cha-apparmor-commandline">
 <title>从命令行构建配置文件</title>
 <info>
      <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
        <dm:bugtracker>
        </dm:bugtracker>
	<dm:translation>yes</dm:translation>
      </dm:docmanager>
    </info>
    <para>
  <phrase>AppArmor®</phrase> 可让用户使用命令行界面而不是图形界面来管理和配置系统安全性。可以使用 <phrase>AppArmor</phrase> 命令行工具来跟踪 <phrase>AppArmor</phrase> 的状态，以及创建、删除或修改 <phrase>AppArmor</phrase> 配置文件。
 </para>
 <tip>
  <title>背景信息</title>
  <para>
   在开始使用 <phrase>AppArmor</phrase> 命令行工具管理配置文件之前，请查看<xref linkend="cha-apparmor-concept"/>和<xref linkend="cha-apparmor-profiles"/>中提供的 <phrase>AppArmor</phrase> 一般简介。
  </para>
 </tip>
 <sect1 xml:id="sec-apparmor-commandline-status">
  <title>检查 <phrase>AppArmor</phrase> 状态</title>

  <para>
   <phrase>AppArmor</phrase> 可能会处于以下三种状态中的任何一种：
  </para>

  <variablelist>
   <varlistentry>
    <term>已卸载</term>
    <listitem>
     <para>
      <phrase>AppArmor</phrase> 未在内核中激活。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>正在运行</term>
    <listitem>
     <para>
      <phrase>AppArmor</phrase> 已在内核中激活，并在强制执行 <phrase>AppArmor</phrase> 程序策略。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>已停止</term>
    <listitem>
     <para>
      <phrase>AppArmor</phrase> 已在内核中激活，但未强制执行策略。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   通过检查 <filename>/sys/kernel/security/apparmor/profiles</filename> 来检测 <phrase>AppArmor</phrase> 的状态。如果 <command>cat /sys/kernel/security/apparmor/profiles</command> 报告了配置文件列表，则表示 <phrase>AppArmor</phrase> 正在运行。如果该文件为空且未返回任何消息，则表示 <phrase>AppArmor</phrase> 已停止。如果该文件不存在，则表示 <phrase>AppArmor</phrase> 已卸载。
  </para>

  <para>
   使用 <command>systemctl</command> 管理 <phrase>AppArmor</phrase>。您可以使用此工具执行以下操作：
  </para>

  <variablelist>
   <varlistentry>
    <term><command>sudo systemctl start apparmor</command>
    </term>
    <listitem>
     <para>
      行为取决于 <phrase>AppArmor</phrase> 的状态。如果 AppArmor 未激活，<option>start</option> 会将其激活并启动，同时将其置于运行状态。如果 AppArmor 已停止，<option>start</option> 会导致重新扫描 <filename>/etc/apparmor.d</filename> 中的 <phrase>AppArmor</phrase> 配置文件，并将 <phrase>AppArmor</phrase> 置于运行状态。如果 <phrase>AppArmor</phrase> 已在运行，<option>start</option> 会发出警告但不执行任何操作。
     </para>
     <note>
      <title>已在运行的进程</title>
      <para>
       要对已在运行的进程应用 <phrase>AppArmor</phrase> 配置文件，需要将其重启动。
      </para>
     </note>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>sudo systemctl stop apparmor</command>
    </term>
    <listitem>
     <para>
      通过去除内核内存中的所有配置文件来停止正在运行的 <phrase>AppArmor</phrase>，这会有效禁用所有访问控制，并将 <phrase>AppArmor</phrase> 置于停止状态。如果 <phrase>AppArmor</phrase> 已停止，<option>stop</option> 会尝试再次卸载配置文件，但不会有任何结果。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>sudo systemctl reload apparmor</command>
    </term>
    <listitem>
     <para>
      导致 <phrase>AppArmor</phrase> 模块重新扫描 <filename>/etc/apparmor.d</filename> 中的配置文件，但不取消限制正在运行的
      <remark>sknorr, 2014-08-26: "unconfining?" Sounds terrible. Would
       "freeing" be an option?
       tbazant, 2014-09-08: No, it's a used term, related to 'unconfined' state
       </remark>
      进程。强制执行新创建的配置文件，并去除 <filename>/etc/apparmor.d</filename> 目录中最近删除的配置文件。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
</sect1>
 <sect1 xml:id="sec-apparmor-commandline-build">
  <title>构建 <phrase>AppArmor</phrase> 配置文件</title>

  <para>
   <phrase>AppArmor</phrase> 模块配置文件定义以纯文本文件的形式存储在 <filename>/etc/apparmor.d</filename> 目录中。有关这些文件的详细语法说明，请参见<xref linkend="cha-apparmor-profiles"/>。
  </para>

  <para>
   <filename>/etc/apparmor.d</filename> 目录中的所有文件被解释为配置文件并装载为配置文件。要防止装载配置文件，对此目录中的文件进行重命名不是一种有效的方式。您必须去除此目录中的配置文件，以有效防止读取和评估这些配置文件；或者对配置文件调用 <command>aa-disable</command>，这会在 <filename>/etc/apparmor.d/disabled/</filename> 中创建一个符号链接。
  </para>

  <para>
   您可以使用 <command>vi</command> 等文本编辑器来访问和更改这些配置文件。以下各节包含构建配置文件的详细步骤：
  </para>

  <variablelist>
   <varlistentry>
    <term>添加或创建 <phrase>AppArmor</phrase> 配置文件</term>
    <listitem>
     <para>
      有关详细信息，请参见 <xref linkend="sec-apparmor-commandline-add"/>
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>编辑 <phrase>AppArmor</phrase> 配置文件</term>
    <listitem>
     <para>
      有关详细信息，请参见 <xref linkend="sec-apparmor-commandline-edit"/>
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>删除 <phrase>AppArmor</phrase> 配置文件</term>
    <listitem>
     <para>
      有关详细信息，请参见 <xref xrefstyle="SectTitleOnPage" linkend="sec-apparmor-commandline-del"/>
     </para>
    </listitem>
   </varlistentry>
  </variablelist>


 </sect1>
 <sect1 xml:id="sec-apparmor-commandline-add">
  <title>添加或创建 <phrase>AppArmor</phrase> 配置文件</title>

  <para>
   要为应用程序添加或创建 <phrase>AppArmor</phrase> 配置文件，可以使用系统的或独立的配置文件构建方法，视您的需要而定。<xref linkend="sec-apparmor-commandline-profiling"/>中详细介绍了这两种方法。
  </para>
 </sect1>
 <sect1 xml:id="sec-apparmor-commandline-edit">
  <title>编辑 <phrase>AppArmor</phrase> 配置文件</title>

  <para>
   以下步骤说明编辑 <phrase>AppArmor</phrase> 配置文件的过程：
  </para>

  <procedure>
   <step>
    <para>
     如果您当前不是以 <systemitem class="username">root</systemitem> 身份登录的，请在终端窗口中输入 <command>su</command>。
    </para>
   </step>
   <step>
    <para>
     出现提示时输入 <systemitem class="username">root</systemitem> 口令。
    </para>
   </step>
   <step>
    <para>
     使用 <command>cd
     /etc/apparmor.d/</command> 转到配置文件所在的目录。
    </para>
   </step>
   <step>
    <para>
     输入 <command>ls</command> 以查看所有当前安装的配置文件。
    </para>
   </step>
   <step>
    <para>
     在 vim 等文本编辑器中打开配置文件以进行编辑。
    </para>
   </step>
   <step>
    <para>
     完成必要的修改后保存配置文件。
    </para>
   </step>
   <step>
    <para>
     在终端窗口中输入 <command>systemctl reload
     apparmor</command> 重启动 <phrase>AppArmor</phrase>。
    </para>
   </step>
  </procedure>
 </sect1>
 <sect1 xml:id="sec-apparmor-commandline-unload">
  <title>卸载未知的 <phrase>AppArmor</phrase> 配置文件</title>
  <warning>
   <title>卸载所需配置文件的风险</title>
   <para>
    <command>aa-remove-unknown</command> 会卸装未存储在 <filename>/etc/apparmor.d</filename> 中的所有配置文件，例如自动生成的 LXD 配置文件。这可能会损害系统的安全性。使用 <option>-n</option> 参数列出所有已卸装的配置文件。
   </para>
  </warning>
  <para>
   要卸载不再位于 <filename>/etc/apparmor.d/</filename> 中的所有 <phrase>AppArmor</phrase> 配置文件，请运行：
  </para>
  <screen><prompt>&gt; </prompt><command>sudo</command> <command>aa-remove-unknown</command></screen>
  <para>
   您可以输出已去除的配置文件列表：
  </para>
  <screen><prompt>&gt; </prompt><command>sudo</command> <command>aa-remove-unknown -n</command></screen>
 </sect1>
 <sect1 xml:id="sec-apparmor-commandline-del">
  <title>删除 <phrase>AppArmor</phrase> 配置文件</title>
  <para>
   以下步骤说明删除 <phrase>AppArmor</phrase> 配置文件的过程。
  </para>
  <procedure>
   <step>
    <para>
     从内核中去除 <phrase>AppArmor</phrase> 定义：
    </para>
    <screen><prompt>&gt; </prompt><command>sudo</command> <command>apparmor_parser -R /etc/apparmor.d/<replaceable>PROFILE</replaceable></command></screen>
   </step>
   <step>
    <para>
     去除定义文件：
    </para>
    <screen><prompt>&gt; </prompt><command>sudo</command> <command>rm /etc/apparmor.d/<replaceable>PROFILE</replaceable></command>
    <prompt>&gt; </prompt><command>sudo</command> <command>rm /var/lib/apparmor/cache/<replaceable>PROFILE</replaceable></command></screen>
   </step>
  </procedure>
 </sect1>
 <sect1 xml:id="sec-apparmor-commandline-profiling">
  <title>构建配置文件的两种方式</title>

  <para>
   掌握<xref xrefstyle="SectTitleOnPage" linkend="cha-apparmor-profiles"/>中介绍的 <phrase>AppArmor</phrase> 配置文件语法后，您无需借助工具也能创建配置文件，但需要的工作量比较大。要避免这种情况，请使用 <phrase>AppArmor</phrase> 工具来自动创建和优化配置文件。
  </para>

  <para>
   可采用两种方法创建 <phrase>AppArmor</phrase> 配置文件。这两种方法都有可用的工具。
  </para>

  <variablelist>
   <varlistentry>
    <term>独立式配置文件构建</term>
    <listitem>
     <para>
      此方法适用于运行时间有限的小型应用程序，如邮件客户端等用户客户端应用程序。有关更多信息，请参见<xref linkend="sec-apparmor-commandline-profiling-stand-alone"/>。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>系统性配置文件构建</term>
    <listitem>
     <para>
      此方法适用于一次性为许多程序构建配置文件，还适用于为运行时间长达数日、数周或在重引导后连续运行的应用程序（如 Web 服务器、邮件服务器等网络服务器应用程序）构建配置文件。有关更多信息，请参见<xref linkend="sec-apparmor-commandline-profiling-systemic"/>。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   使用 <phrase>AppArmor</phrase> 工具可使自动开发配置文件的过程变得更易于管理。
  </para>

  <procedure>
   <step>
    <para>
     确定符合您的要求的配置文件构建方式。
    </para>
   </step>
   <step>
    <para>
     执行一次静态分析。根据所选的配置文件构建方法运行 <command>aa-genprof</command> 或 <command>aa-autodep</command>。
    </para>
   </step>
   <step>
    <para>
     启用动态学习。为所有构建了配置文件的程序启动学习模式。
    </para>
   </step>
  </procedure>

  <sect2 xml:id="sec-apparmor-commandline-profiling-stand-alone">
   <title>独立式配置文件构建</title>
   <para>
    独立式配置文件的生成和改进由一个称为 <command>aa-genprof</command> 的程序进行管理。此方式比较简单，因为全过程都由 <command>aa-genprof</command> 负责。但运行程序测试的整个过程中都必须运行 <command>aa-genprof</command>（在开发配置文件过程中不能重引导计算机），因此使用比较有限。
   </para>
   <para>
    要使用 <command>aa-genprof</command> 以独立方式构建配置文件，请参见<xref linkend="sec-apparmor-commandline-profiling-summary-genprof"/>。
   </para>
  </sect2>

  <sect2 xml:id="sec-apparmor-commandline-profiling-systemic">
   <title>系统性配置文件构建</title>
   <para>
    此方法之所以称为<emphasis>系统性配置文件构建</emphasis>，是因为它会一次性更新系统中所有的配置文件，而不像 <command>aa-genprof</command> 或独立式配置文件构建那样只针对一个或少数几个配置文件。采用系统性配置文件构建方法时，构建和改进配置文件的自动化程度会有所下降，但更灵活。此方法适用于为长时间运行且其行为会在重引导后持续的应用程序构建配置文件，或者一次性为许多程序构建配置文件。
   </para>
   <para>
    按如下方式为一组应用程序构建 <phrase>AppArmor</phrase> 配置文件：
   </para>
   <procedure>
    <step>
     <para>
      为构成应用程序的各个程序创建配置文件。
     </para>
     <para>
      尽管此方法是系统性的，但 <phrase>AppArmor</phrase> 只监视具有配置文件及其子配置文件的程序。要让 <phrase>AppArmor</phrase> 将某个程序考虑在内，您至少应通过 <command>aa-autodep</command> 为此程序创建一个大概的配置文件。要创建此大概的配置文件，请参见<xref linkend="sec-apparmor-commandline-profiling-summary-autodep"/>。
     </para>
    </step>
    <step>
     <para>
      使相关的配置文件进入学习或提示模式。
     </para>
     <para>
      在终端窗口中输入以下命令
     </para>
<screen><prompt>&gt; </prompt><command>sudo</command> aa-complain /etc/apparmor.d/*</screen>
     <para>
      （以 <systemitem class="username">root</systemitem> 身份登录后）,为所有构建了配置文件的程序激活学习或控诉模式。也可以通过<xref linkend="sec-apparmor-yast-manage-profmodes"/>中所述的“YaST 配置文件模式”模块使用此功能。
     </para>
     <para>
      处于学习模式时，访问请求不会被阻止，即使配置文件指示应阻止时也是如此。这样您就可以完整运行若干测试（如<xref linkend="st-apparmor-commandline-profiling-systemic-exec"/>所示）并了解程序正常运行时的访问需要。通过此信息，您可以确定配置文件的防护程度。
     </para>
     <para>
      有关使用学习模式和提示模式的具体说明，请参见<xref linkend="sec-apparmor-commandline-profiling-summary-complain"/>。
     </para>
    </step>
    <step xml:id="st-apparmor-commandline-profiling-systemic-exec">
     <para>
      演习应用程序。
     </para>
     <para>
      运行应用程序并行使其功能。演习程序的多少功能由您决定，但您必须让程序访问代表其访问要求的每个文件。由于执行不受 <command>aa-genprof</command> 的监督，因此此步骤可以持续数天或数周时间，而且在所有系统重引导后仍会持续。
     </para>
    </step>
    <step xml:id="st-apparmor-commandline-profiling-systemic-log">
     <para>
      分析日志。
     </para>
     <para>
      进行系统性配置文件构建时，请直接运行 <command>aa-logprof</command>，而不要让 <command>aa-genprof</command> 来运行它（进行独立式配置文件构建时会如此操作）。<command>aa-logprof</command> 的一般格式如下：
     </para>
<screen><prompt>&gt; </prompt><command>sudo</command> aa-logprof [ -d <replaceable>/path/to/profiles</replaceable> ] [ -f <replaceable>/path/to/logfile</replaceable> ]</screen>
     <para>
      有关使用 <command>aa-logprof</command> 的详细信息，请参见<xref linkend="sec-apparmor-commandline-profiling-summary-logprof"/>。
     </para>
    </step>
    <step>
     <para>
      重复<xref linkend="st-apparmor-commandline-profiling-systemic-exec"/> 和<xref linkend="st-apparmor-commandline-profiling-systemic-log"/>。
     </para>
     <para>
      这样会生成最佳的配置文件。此重复操作方式会捕捉可经过训练并重新载入策略引擎的较小数据集。后续重复操作将生成较少的消息，而且运行速度较快。
     </para>
    </step>
    <step>
     <para>
      编辑配置文件。
     </para>
     <para>
      您应该查看已生成的配置文件。可以使用文本编辑器打开和编辑 <filename>/etc/apparmor.d/</filename> 中的配置文件。
     </para>
    </step>
    <step>
     <para>
      返回到强制模式。
     </para>
     <para>
      此时系统会重新强制执行配置文件的规则，而不仅仅是记录信息。此操作可以通过从配置文件中去除 <literal>flags=(complain)</literal> 文本手动完成，也可以使用 <command>aa-enforce</command> 命令自动完成，该命令的工作方式与 <command>aa-complain</command> 命令完全相同，只不过会将配置文件设置为强制模式。也可以通过<xref linkend="sec-apparmor-yast-manage-profmodes"/>中所述的“YaST 配置文件模式”模块使用此功能。
     </para>
     <para>
      要确保所有配置文件都已解除控诉模式并已置于强制模式，请输入 <command>aa-enforce
      /etc/apparmor.d/*</command>。
     </para>
    </step>
    <step>
     <para>
      重新扫描所有配置文件。
     </para>
     <para>
      要让 <phrase>AppArmor</phrase> 重新扫描所有配置文件并在内核中更改该强制模式，请输入 <command>systemctl reload
      apparmor</command>。
     </para>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="sec-apparmor-commandline-profiling-summary">
   <title>构建配置文件的工具汇总</title>
   <para>
    <systemitem>apparmor-utils</systemitem> RPM 软件包提供了用于构建 <phrase>AppArmor</phrase> 配置文件的所有实用程序（存储在 <filename>/usr/sbin</filename> 中）。每个工具都有不同的用途。
   </para>
   <sect3 xml:id="sec-apparmor-commandline-profiling-summary-autodep">
    <title>aa-autodep — 创建大概的配置文件</title>
    <para>
     此工具可为所选的程序或应用程序创建大概的配置文件。您可以为二进制可执行文件和已解释的脚本程序生成大概的配置文件。生成的配置文件之所以称为<quote>大概的配置文件</quote>，是因为它不一定包含 <phrase>AppArmor</phrase> 正确限制程序所需的所有配置文件项。最小的 <command>aa-autodep</command> 大概配置文件至少具备基础的 include 指令，它包含大多数程序都需要的基本配置文件项。对于某些类型的程序，<command>aa-autodep</command> 会生成更扩展的配置文件。配置文件的生成方式是在命令行上列出的可执行文件上以递归方式调用 <command>ldd(1)</command>。
    </para>
    <para>
     要生成大概的配置文件，请使用 <command>aa-autodep</command> 程序。程序参数可以是程序的简单名称（<command>aa-autodep</command> 通过搜索外壳的路径变量找到此名称），也可以是完全限定的路径。程序本身可以是任意类型（ELF 二进制文件、外壳脚本、Perl 脚本等）。<command>aa-autodep</command> 会生成一个大概的配置文件，后续的动态配置文件构建过程会对其进行改进。
    </para>
    <para>
     生成的大概配置文件将写入到 <filename>/etc/apparmor.d</filename> 目录，并使用 <phrase>AppArmor</phrase> 配置文件命名约定，即在程序绝对路径后面命名配置文件，同时将路径中的正斜线 (<literal>/</literal>) 字符替换为句点 (<literal>&#x002E;</literal>) 字符。<command>aa-autodep</command> 的一般语法是在终端窗口中输入以下命令：
    </para>
<screen><prompt>&gt; </prompt><command>sudo</command> aa-autodep [ -d <replaceable>/PATH/TO/PROFILES</replaceable> ] [<replaceable>PROGRAM1</replaceable> <replaceable>PROGRAM2</replaceable>...]</screen>
    <para>
     如果不输入程序名称，则计算机会提示您输入它（它们）。如果您将配置文件保存在非默认位置，<replaceable>/path/to/profiles</replaceable> 会覆盖 <filename>/etc/apparmor.d</filename> 的默认位置。
    </para>
    <para>
     开始构建配置文件前，您必须为作为应用程序一部分的各个主可执行服务创建配置文件（它们启动后不会从属于其它已具备配置文件的程序）。此类程序的查找取决于相关的应用程序。以下是查找此类程序的一些策略：
    </para>
    <variablelist>
     <varlistentry>
      <term>目录</term>
      <listitem>
       <para>
        如果需要构建配置文件的所有程序都位于同一个目录内，而且此目录中没有其他程序，只需使用 <command>aa-autodep</command>
        <replaceable>/path/to/your/programs/*</replaceable> 命令就可以为此目录中的所有程序创建基本配置文件。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>pstree -p</term>
      <listitem>
       <para>
        您可以运行应用程序并使用标准的 Linux <command>pstree</command> 命令找到所有运行中的进程。然后手动搜寻这些程序的位置，并针对每个程序运行 <command>aa-autodep</command>。如果程序在您的路径中，则 <command>aa-autodep</command> 会为您找到它们。如果程序不在您的路径中，则标准的 Linux 命令 <command>find</command> 可能有助于您查找程序。执行 <command>find / -name '</command>
        <replaceable>MY_APPLICATION</replaceable>&apos; -print 可确定应用程序的路径（<replaceable>MY_APPLICATION</replaceable> 是示例应用程序）。如果情况适合，您可以使用通配符。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3 xml:id="sec-apparmor-commandline-profiling-summary-complain">
    <title>aa-complain — 进入控诉或学习模式</title>
    <para>
     控诉和学习模式工具 (<command>aa-complain</command>) 会检测对 <phrase>AppArmor</phrase> 配置文件规则的违规，例如构建了配置文件的程序访问配置文件不允许的其他文件。冲突是允许的，但也会被记录。要改进配置文件，请开启控诉模式，对程序运行一套测试以生成反映程序访问需求的日志事件，然后使用 <phrase>AppArmor</phrase> 工具对日志进行后处理，以将日志事件转换为改进的配置文件。
    </para>
    <para>
     手动激活控诉模式（使用命令行）会在配置文件的顶部添加一个标志，因此 <literal>/bin/foo</literal> 将变成 <literal>/bin/foo flags=(complain)</literal>。要使用控诉模式，请打开一个终端窗口，然后以 <systemitem class="username">root</systemitem> 身份输入以下命令：
    </para>
    <itemizedlist mark="bullet" spacing="normal">
     <listitem>
      <para>
       如果示例程序 (<replaceable>PROGRAM1</replaceable>) 在您的路径中，请使用：
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> aa-complain [<replaceable>PROGRAM1</replaceable> <replaceable>PROGRAM2</replaceable> ...]</screen>
     </listitem>
     <listitem>
      <para>
       如果程序不在您的路径中，请指定整个路径，如下所示：
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> aa-complain /sbin/<replaceable>PROGRAM1</replaceable></screen>
     </listitem>
     <listitem>
      <para>
       如果配置文件不在 <filename>/etc/apparmor.d</filename> 中，请输入以下命令以覆盖默认位置：
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> aa-complain <replaceable>/path/to/profiles/</replaceable><replaceable>PROGRAM1</replaceable></screen>
     </listitem>
     <listitem>
      <para>
       指定 <replaceable>/sbin/program1</replaceable> 的配置文件，如下所示：
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> aa-complain /etc/apparmor.d/sbin.<replaceable>PROGRAM1</replaceable></screen>
     </listitem>
    </itemizedlist>
    <para>
     上述每条命令都会激活所列配置文件或程序的控诉模式。如果程序名不包含其整个路径，则 <command>aa-complain</command> 会搜索程序的 <envar>$PATH</envar>。例如，<command>aa-complain /usr/sbin/*</command> 会查找与 <filename>/usr/sbin</filename> 中的所有程序关联的配置文件，并将其置于控诉模式。<command>aa-complain /etc/apparmor.d/*</command> 将 <filename>/etc/apparmor.d</filename> 中的所有配置文件置于控诉模式。
    </para>
    <tip>
     <title>使用 YaST 切换配置文件模式</title>
     <para>
      YaST 提供了一个用于切换控诉模式和强制模式的图形前端。有关信息，请参见 <xref linkend="sec-apparmor-yast-manage-profmodes"/>。
     </para>
    </tip>
   </sect3>
   <sect3 xml:id="sec-apparmor-commandline-profiling-summary-decode">
    <title>aa-decode — 解码 <phrase>AppArmor</phrase> 日志文件中的十六进制编码字符串</title>
    <para>
     <command>aa-decode</command> 解码 <phrase>AppArmor</phrase> 日志输出中的十六进制编码字符串。它还可以处理有关标准输入的审计日志，转换任何十六进制编码的 <phrase>AppArmor</phrase> 日志项，并在标准输出中显示这些项。
    </para>
   </sect3>
   <sect3 xml:id="sec-apparmor-commandline-profiling-summary-disable">
    <title>aa-disable — 禁用 <phrase>AppArmor</phrase> 安全配置文件</title>
    <para>
     使用 <command>aa-disable</command> 可以禁用一个或多个 <phrase>AppArmor</phrase> 配置文件的强制模式。此命令将从内核中卸载配置文件，并防止在 <phrase>AppArmor</phrase> 启动时装载该配置文件。可以使用 <command>aa-enforce</command> 或 <command>aa-complain</command> 实用程序更改此行为。
    </para>
   </sect3>
   <sect3 xml:id="sec-apparmor-commandline-profiling-summary-easyprof">
    <title>aa-easyprof — 轻松生成配置文件</title>
    <para>
     <command>aa-easyprof</command> 提供了易用的界面来生成 <phrase>AppArmor</phrase> 配置文件。<command>aa-easyprof</command> 支持使用模板和配置文件组来快速构建应用程序的配置文件。尽管 <command>aa-easyprof</command> 有助于生成配置文件，但其实用程序依赖于所用模板、配置文件组和抽象的质量。此外，此工具在创建配置文件方面的限制比手动或使用 <command>aa-genprof</command> 和 <command>aa-logprof</command> 创建配置文件要少一些。
    </para>
    <para>
     有关详细信息，请参见 <command>aa-easyprof</command> (8) 的手册页。
    </para>
   </sect3>
   <sect3 xml:id="sec-apparmor-commandline-profiling-summary-enforce">
    <title>aa-enforce — 进入强制模式</title>
    <para>
     强制模式会检测对 <phrase>AppArmor</phrase> 配置文件规则的违规，例如构建了配置文件的程序访问配置文件不允许的文件。违规会被记录下来，并且不会允许此类事件。默认会启用强制模式。如要仅记录违规但仍允许此类事件，请使用控诉模式。
    </para>
    <para>
     手动激活强制模式（使用命令行）会去除配置文件顶部的 complain 标志，使 <literal>/bin/foo
     flags=(complain)</literal> 变成 <literal>/bin/foo</literal>。要使用强制模式，请打开一个终端窗口，然后输入以下命令。
    </para>
    <itemizedlist mark="bullet" spacing="normal">
     <listitem>
      <para>
       如果示例程序 (<replaceable>PROGRAM1</replaceable>) 在您的路径中，请使用：
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> aa-enforce [<replaceable>PROGRAM1</replaceable> <replaceable>PROGRAM2</replaceable> ...]</screen>
     </listitem>
     <listitem>
      <para>
       如果程序不在您的路径中，请指定整个路径，如下所示：
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> aa-enforce /sbin/<replaceable>PROGRAM1</replaceable></screen>
     </listitem>
     <listitem>
      <para>
       如果配置文件不在 <replaceable>/etc/apparmor.d</replaceable> 中，请输入以下命令以覆盖默认位置：
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> aa-enforce -d <replaceable>/path/to/profiles/     program1</replaceable></screen>
     </listitem>
     <listitem>
      <para>
       指定 <replaceable>/sbin/program1</replaceable> 的配置文件，如下所示：
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> aa-enforce /etc/apparmor.d/sbin.<replaceable>PROGRAM1</replaceable></screen>
     </listitem>
    </itemizedlist>
    <para>
     上述命令会激活所列配置文件和程序的强制模式。
    </para>
    <para>
     如果不输入程序或配置文件的名称，则计算机会提示您输入名称。<replaceable>/path/to/profiles</replaceable> 覆盖 <filename>/etc/apparmor.d</filename> 的默认位置。
    </para>
    <para>
     参数可以是一个程序列表或一个配置文件列表。如果程序名不包含其整个路径，则 <command>aa-enforce</command> 会搜索程序的 <envar>$PATH</envar>。
    </para>
    <tip>
     <title>使用 YaST 切换配置文件模式</title>
     <para>
      YaST 提供了一个用于切换控诉模式和强制模式的图形前端。有关信息，请参见 <xref linkend="sec-apparmor-yast-manage-profmodes"/>。
     </para>
    </tip>
   </sect3>
   <sect3 xml:id="sec-apparmor-commandline-profiling-summary-exec">
    <title>aa-exec — 使用指定的配置文件限制程序</title>
    <para>
     使用 <command>aa-exec</command> 可以启动指定的配置文件和/或配置文件名称空间所限制的程序。如果同时指定了配置文件和名称空间，程序将由新名称空间中的配置文件限制。如果仅指定了配置文件名称空间，将使用当前限制的配置文件名称。如果配置文件和名称空间均未指定，将使用标准的配置文件附件运行命令 — 如同未使用 <command>aa-exec</command> 命令一样。
    </para>
    <para>
     有关该命令的选项的详细信息，请参见该命令的手册页 <command>man 8 aa-exec</command>。
    </para>
   </sect3>
   <sect3 xml:id="sec-apparmor-commandline-profiling-summary-genprof">
    <title>aa-genprof — 生成配置文件</title>
    <para>
     <command>aa-genprof</command> 是用于生成 <phrase>AppArmor</phrase> 配置文件的实用程序。它可以对指定的程序运行 <command>aa-autodep</command> 以创建大概配置文件（如果此程序尚不存在配置文件）、将其设置为控诉模式、将其重新装载到 <phrase>AppArmor</phrase>、标记日志、提示用户执行程序以及运用其功能。其语法如下所示：
    </para>
<screen><prompt>&gt; </prompt><command>sudo</command> aa-genprof [ -d <replaceable>/path/to/profiles</replaceable> ]  <replaceable>PROGRAM</replaceable></screen>
    <para>
     要为 Apache Web 服务器程序 httpd2-prefork 创建配置文件，请以 <systemitem class="username">root</systemitem> 身份执行以下操作：
    </para>
    <procedure>
     <step>
      <para>
       输入 <command>systemctl stop apache2</command>.
      </para>
     </step>
     <step>
      <para>
       接下来输入 <command>aa-genprof httpd2-prefork</command>。
      </para>
      <para>
       现在，<command>aa-genprof</command> 会执行以下操作：
      </para>
      <orderedlist spacing="normal">
       <listitem>
        <para>
         使用外壳的路径变量解析 httpd2-prefork 的完整路径。您也可以指定完整路径。在 <phrase role="productname"><phrase os="sled">SUSE Linux Enterprise Desktop</phrase></phrase> 上，默认的完整路径为 <phrase><filename>/usr/sbin/httpd2-prefork</filename></phrase>。
        </para>
       </listitem>
       <listitem>
        <para>
         检查 httpd2-prefork 是否已存在配置文件。如果已有，则会被更新。如果不存在，则会使用<xref linkend="sec-apparmor-commandline-profiling-summary"/>中所述的 <command>aa-autodep</command> 创建一个配置文件。
        </para>
       </listitem>
       <listitem>
        <para>
         将此程序的配置文件置于学习或控诉模式，这样会记录配置文件违规，但允许此类违规以便继续操作。日志事件如下所示（请参见 <filename>/var/log/audit/audit.log</filename>）：
        </para>
<screen>type=APPARMOR_ALLOWED msg=audit(1189682639.184:20816): \
apparmor="DENIED" operation="file_mmap" parent=2692 \
profile="/usr/sbin/httpd2-prefork//HANDLING_UNTRUSTED_INPUT" \
name="/var/log/apache2/access_log-20140116" pid=28730 comm="httpd2-prefork" \
requested_mask="::r" denied_mask="::r" fsuid=30 ouid=0</screen>
        <para>
         如果您未运行审计守护程序，<phrase>AppArmor</phrase> 事件将直接记录到 <systemitem class="daemon">systemd</systemitem> 日志（请参见<xref linkend="cha-journalctl"/>）：
        </para>
<screen>Sep 13 13:20:30 K23 kernel: audit(1189682430.672:20810): \
apparmor="DENIED" operation="file_mmap" parent=2692 \
profile="/usr/sbin/httpd2-prefork//HANDLING_UNTRUSTED_INPUT" \
name="/var/log/apache2/access_log-20140116" pid=28730 comm="httpd2-prefork" \
requested_mask="::r" denied_mask="::r" fsuid=30 ouid=0</screen>
        <para>
         也可以使用 <command>dmesg</command> 命令来查看这些事件：
        </para>
<screen>audit(1189682430.672:20810): apparmor="DENIED" \
operation="file_mmap" parent=2692 \
profile="/usr/sbin/httpd2-prefork//HANDLING_UNTRUSTED_INPUT" \
name="/var/log/apache2/access_log-20140116" pid=28730 comm="httpd2-prefork" \
requested_mask="::r" denied_mask="::r" fsuid=30 ouid=0</screen>
       </listitem>
       <listitem>
        <para>
         使用日志事件的起始标记来标记要考虑的日志。例如：
        </para>
<screen>
Sep 13 17:48:52 figwit root: GenProf: e2ff78636296f16d0b5301209a04430d</screen>
       </listitem>
      </orderedlist>
     </step>
     <step>
      <para>
       看到工具的提示时，在另一个终端窗口中运行应用程序，并执行尽可能多的应用程序功能。如此，学习模式便可以记录程序在正常运行时需要访问的文件和目录。例如，在新的终端窗口中输入 <command>systemctl start
       apache2</command>。
      </para>
     </step>
     <step>
      <para>
       执行程序功能后，在 <command>aa-genprof</command> 终端窗口中选择以下可用选项：
      </para>
      <itemizedlist mark="bullet" spacing="normal">
       <listitem>
        <para>
         <keycap>S</keycap> 会在 <command>aa-genprof</command> 启动并重新装载配置文件后从标记位置开始对系统日志运行 <command>aa-genprof</command>。如果日志中存在系统事件，<phrase>AppArmor</phrase> 会分析学习模式日志文件。这会生成一连串问题，您必须回答这些问题以指导 <command>aa-genprof</command> 生成安全配置文件。
        </para>
       </listitem>
       <listitem>
        <para>
         <keycap>F</keycap> 会退出工具。
        </para>
       </listitem>
      </itemizedlist>
      <note>
       <para>
        如果出现添加帽子的请求，请进入<xref linkend="cha-apparmor-hat"/>。
       </para>
      </note>
     </step>
     <step>
      <para>
       回答两类问题：
      </para>
      <itemizedlist mark="bullet" spacing="normal">
       <listitem>
        <para>
         构建配置文件的程序访问了配置文件中没有的资源（请参见<xref linkend="ex-apparmor-commandline-profiling-summary-genprof-learn"/>）。
        </para>
       </listitem>
       <listitem>
        <para>
         构建配置文件的程序执行了一个程序，而安全域转换尚未定义（请参见<xref linkend="ex-apparmor-commandline-profiling-summary-genprof-perms"/>）。
        </para>
       </listitem>
      </itemizedlist>
      <para>
       这两种类别都会生成一系列问题，您必须回答这些问题，以将资源或程序添加到配置文件。<xref linkend="ex-apparmor-commandline-profiling-summary-genprof-learn"/>和<xref linkend="ex-apparmor-commandline-profiling-summary-genprof-perms"/>提供了每种类别的示例。后续步骤将说明回答这些问题时的选项。
      </para>
      <itemizedlist mark="bullet" spacing="normal">
       <listitem>
        <para>
         处理执行权限非常复杂。您必须决定如何继续处理此项，指定向此项授予哪种执行权限类型：
        </para>
        <example xml:id="ex-apparmor-commandline-profiling-summary-genprof-learn">
         <title>学习模式例外：控制对特定资源的访问</title>
<screen>Reading log entries from /var/log/audit/audit.log.
Updating AppArmor profiles in /etc/apparmor.d.

Profile:  /usr/sbin/cupsd
Program:  cupsd
Execute:  /usr/lib/cups/daemon/cups-lpd
Severity: unknown

(I)nherit / (P)rofile / (C)hild / (N)ame / (U)nconfined / (X)ix / (D)eny / Abo(r)t / (F)inish</screen>
        </example>
        <variablelist>
         <varlistentry>
          <term>继承 (ix)</term>
          <listitem>
           <para>
            子程序继承父程序的配置文件，以与父程序相同的访问控制运行。当被限制的程序需要调用其它被限制的程序时此模式非常实用，无须获得目标程序配置文件的权限或失去当前配置文件的权限。当子程序是<emphasis>助手应用程序</emphasis>（例如，使用 <command>less</command> 作为分页器的 <command>/usr/bin/mail</command> 客户端）时，通常使用此模式。
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>配置文件 (px/px)</term>
          <listitem>
           <para>
            子程序以自己的配置文件运行，此配置文件必须载入内核。如果不存在配置文件，则尝试执行子程序时会因访问被拒而失败。这最适合父程序在调用全局服务的情形，如进行 DNS 查找或通过系统的 MTA 发送邮件时。
           </para>
           <para>
            选择<guimenu>含清洁执行的配置文件</guimenu> (Px) 选项可以整理在传递给子进程时可能会修改执行行为的环境变量的环境。
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>子项 (cx/cx)</term>
          <listitem>
           <para>
            设置目标为子配置文件的转换。它与 px/Px 转换类似，只不过是转换为子配置文件。
           </para>
           <para>
            选择<guimenu>含清洁执行的配置文件</guimenu> (Cx) 选项可以整理在传递给子进程时可能会修改执行行为的环境变量的环境。
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>未受限 (ux/ux)</term>
          <listitem>
           <para>
            对执行的资源不应用任何 <phrase>AppArmor</phrase> 配置文件，子项在没有限制的情况下运行。
           </para>
           <para>
            选择<guimenu>含清洁执行的未受限</guimenu> (Ux) 选项可以整理在传递给子进程时可能会修改执行行为的环境变量的环境。请注意，运行无限制的配置文件会造成安全漏洞，攻击者可能会利用此漏洞来避开 <phrase>AppArmor</phrase>。请仅在万不得已的情况下才这样做。
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>mmap (m)</term>
          <listitem>
           <para>
            此权限与 <envar>PROT_EXEC</envar> 标志结合表示基于配置文件运行的程序可以使用 mmap 系统调用来访问资源。这意味着可以执行其中映射的数据。如果在配置文件构建过程运行期间要求此权限，系统会提示您包含此权限。
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>拒绝</term>
          <listitem>
           <para>
            在配置文件中添加一条 <literal>deny</literal> 规则，以永久阻止程序访问指定的目录路径项。<phrase>AppArmor</phrase> 随后会继续处理下一个事件。
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>中止</term>
          <listitem>
           <para>
            中止 <command>aa-logprof</command>，到目前为止输入的所有规则更改将会丢失，所有配置文件都将保持不变。
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>完成</term>
          <listitem>
           <para>
            关闭 <command>aa-logprof</command>，同时保存到目前为止输入的所有规则更改并修改所有配置文件。
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </listitem>
       <listitem>
        <para>
         <xref linkend="ex-apparmor-commandline-profiling-summary-genprof-perms"/>演示了 <phrase>AppArmor</phrase> 建议允许使用通配模式 <filename>/var/run/nscd/*</filename> 进行读取，然后使用一个抽象来涵盖常用的 Apache 相关访问规则。
        </para>
        <example xml:id="ex-apparmor-commandline-profiling-summary-genprof-perms">
         <title>学习模式例外：定义项的权限</title>
<screen>Profile:  /usr/sbin/httpd2-prefork
Path:     /var/run/nscd/dbSz9CTr
Mode:     r
Severity: 3

  1 - /var/run/nscd/dbSz9CTr
 [2 - /var/run/nscd/*]

(A)llow / [(D)eny] / (G)lob / Glob w/(E)xt / (N)ew / Abo(r)t / (F)inish / (O)pts
Adding /var/run/nscd/* r to profile.

Profile:  /usr/sbin/httpd2-prefork
Path:     /proc/11769/attr/current
Mode:     w
Severity: 9

 [1 - #include &lt;abstractions/apache2-common&gt;]
  2 - /proc/11769/attr/current
  3 - /proc/*/attr/current

(A)llow / [(D)eny] / (G)lob / Glob w/(E)xt / (N)ew / Abo(r)t / (F)inish / (O)pts
Adding #include &lt;abstractions/apache2-common&gt; to profile.
</screen>
        </example>
        <para>
         <phrase>AppArmor</phrase> 提供了一个或多个路径或 include。通过输入选项编号选择所需的选项，然后继续执行下一步。
        </para>
        <note>
         <para>
          <phrase>AppArmor</phrase> 菜单中并不会始终显示所有这些选项。
         </para>
        </note>
        <variablelist>
         <varlistentry>
          <term><literal>#include</literal>
          </term>
          <listitem>
           <para>
            <phrase>AppArmor</phrase> 配置文件的此部分代表一个 include 文件，它会获取程序的访问权限。通过使用 include，您可以向程序赋予访问其它程序也需要的目录路径和文件的权限。使用 include 可减小配置文件的大小。选择建议的 include 是不错的做法。
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>通配形式</term>
          <listitem>
           <para>
            按下一步所述选择<guimenu>通配</guimenu>即可访问该部分。有关通配语法的更多信息，请参见<xref linkend="sec-apparmor-profiles-glob"/>。
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>实际路径</term>
          <listitem>
           <para>
            这是程序要正常运行需要访问的实际路径。
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
        <para>
         选择路径或 include 后，通过选择<guimenu>允许</guimenu>或<guimenu>拒绝</guimenu>来处理它，将它以项的形式加入到 <phrase>AppArmor</phrase> 配置文件中。如果您对显示的目录路径项不满意，也可以使用<guimenu>通配</guimenu>对其进行处理。
        </para>
        <para>
         以下选项用于处理学习模式项和构建配置文件：
        </para>
        <variablelist>
         <varlistentry>
          <term>选择 <keycap function="enter"/>
          </term>
          <listitem>
           <para>
            允许访问选定的目录路径。
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>允许</term>
          <listitem>
           <para>
            允许访问指定的目录路径项。<phrase>AppArmor</phrase> 会给出文件访问权限建议。有关更多信息，请参见<xref linkend="sec-apparmor-profiles-perm"/>。
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>拒绝</term>
          <listitem>
           <para>
            阻止程序访问指定目录路径项的权限。<phrase>AppArmor</phrase> 随后会继续处理下一个事件。
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>新建</term>
          <listitem>
           <para>
            提示您输入针对此事件的自己的规则，允许指定正则表达式。如果该表达式实际上不满足最初提示问题的事件，<phrase>AppArmor</phrase> 会要求您确认并允许您重新输入表达式。
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>通配</term>
          <listitem>
           <para>
            选择特定的路径，或使用通配符创建与更多路径集匹配的一般规则。要选择提供的任何路径，请输入该路径前面列显的编号，然后决定如何继续处理所选项。
           </para>
           <para>
            有关通配语法的详细信息，请参见<xref linkend="sec-apparmor-profiles-glob"/>。
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>保留扩展名的通配</term>
          <listitem>
           <para>
            此选项会修改原始目录路径，不过会保留文件扩展名。例如，<filename>/etc/apache2/file.ext</filename> 将变成 <filename>/etc/apache2/*.ext</filename>，其中添加了通配符（星号）来代替文件名。这样程序就可以访问建议目录下以 <literal>.ext</literal> 为扩展名的所有文件。
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>中止</term>
          <listitem>
           <para>
            中止 <command>aa-logprof</command>，到目前为止输入的所有规则更改将会丢失，所有配置文件都将保持不变。
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>完成</term>
          <listitem>
           <para>
            关闭 <command>aa-logprof</command>，同时保存到目前为止输入的所有规则更改并修改所有配置文件。
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </listitem>
      </itemizedlist>
     </step>
     <step>
      <para>
       要使用 <command>vi</command> 查看和编辑您的配置文件，请在终端窗口中输入 <command>vi /etc/apparmor.d/</command>
       <replaceable>PROFILENAME</replaceable>。要在 vim 中编辑 <phrase>AppArmor</phrase> 配置文件时启用语法突出显示，请依次使用命令 <command>:syntax on</command> 和 <command>:set
       syntax=apparmor</command>。有关 vim 和语法高亮显示的详细信息，请参见<xref linkend="sec-apparmor-commandline-profiling-summary-vim"/>。
      </para>
     </step>
     <step>
      <para>
       重启动 <phrase>AppArmor</phrase>，然后使用 <command>systemctl reload
       apparmor</command> 命令重新装载配置文件集，包括新建的配置文件。
      </para>
     </step>
    </procedure>
    <para>
     与用于构建 <phrase>AppArmor</phrase> 配置文件的图形前端一样，YaST 添加配置文件向导 <command>aa-genprof</command> 也支持使用 <filename>/usr/share/apparmor/extra-profiles</filename> 下的本地配置文件储存库。
    </para>
    <para>
     要使用本地软件源中的配置文件，请按如下所示继续操作：
    </para>
    <procedure>
     <step>
      <para>
       如上所述启动 <command>aa-genprof</command>。
      </para>
      <para>
       如果 <command>aa-genprof</command> 找到了非活动的本地配置文件，则终端窗口中会显示以下几行：
      </para>
<screen>Profile: /usr/bin/opera

 [1 - Inactive local profile for /usr/bin/opera]

[(V)iew Profile] / (U)se Profile / (C)reate New Profile / Abo(r)t / (F)inish</screen>
     </step>
     <step>
      <para>
       要使用此配置文件，请按 <keycap>U</keycap>（<guimenu>使用配置文件</guimenu>）并执行上文所述的配置文件生成过程。
      </para>
      <para>
       要在激活配置文件之前对其进行检查，请按 <keycap>V</keycap>（<guimenu>查看配置文件</guimenu>）。
      </para>
      <para>
       要忽略现有的配置文件，请按 <keycap>C</keycap>（<guimenu>创建新配置文件</guimenu>），并执行上文所述的配置文件生成过程从头开始创建配置文件。
      </para>
     </step>
     <step>
      <para>
       完成后，按 <keycap>F</keycap>（<guimenu>完成</guimenu>）退出 <command>aa-genprof</command> 并保存更改。
      </para>
     </step>
    </procedure>
   </sect3>
   <sect3 xml:id="sec-apparmor-commandline-profiling-summary-logprof">
    <title>aa-logprof — 扫描系统日志</title>
    <para>
     <command>aa-logprof</command> 是一个交互式工具，用于查看 <filename>/var/log/audit/audit.log</filename> 内的日志项中的控诉和强制模式事件，或直接查看 <systemitem class="daemon">systemd</systemitem> 日志中的此类事件（请参见<xref linkend="cha-journalctl"/>），以及在 <phrase>AppArmor</phrase> 安全配置文件中生成新的项。
    </para>
    <para>
     运行 <command>aa-logprof</command> 后，它会开始扫描在控诉和强制模式下生成的日志文件，如果存在现有配置文件集未涵盖的新安全事件，它会给出修改配置文件的建议。<command>aa-logprof</command> 使用此信息来观察程序行为。
    </para>
    <para>
     如果某个受限制的程序派生并执行另一个程序，<command>aa-logprof</command> 会注意到这种情况，并会询问用户在启动子进程时应使用哪种执行模式。执行模式 <emphasis>ix</emphasis>、<emphasis>px</emphasis>、<emphasis>Px</emphasis>、<emphasis>ux</emphasis>、<emphasis>Ux</emphasis>、<emphasis>cx</emphasis>、<emphasis>Cx</emphasis> 以及命名的配置文件均为用于启动子进程的选项。如果子进程具有单独的配置文件，则默认选择为 <emphasis>Px</emphasis>。如果不存在单独的配置文件，则默认为 <emphasis>ix</emphasis>。系统会对有单独配置文件的子进程运行 <command>aa-autodep</command> 并将其装载到 <phrase>AppArmor</phrase> 中（如果它正在运行）。
    </para>
    <para>
     <command>aa-logprof</command> 退出时，配置文件将由所做的更改更新。如果 <phrase>AppArmor</phrase> 处于活动状态，将重新装载更新的配置文件；如有任何生成安全事件的进程仍在 null-XXXX 配置文件（在控诉模式下临时创建的独有配置文件）中运行，这些进程将设置为基于其适当配置文件运行。
    </para>
    <para>
     要运行 <command>aa-logprof</command>，请以 <systemitem class="username">root</systemitem> 身份登录并在终端窗口中输入 <command>aa-logprof</command>。以下选项可用于 <command>aa-logprof</command>：
    </para>
    <variablelist>
     <varlistentry>
      <term><command>aa-logprof -d</command><replaceable>/path/to/profile/directory/</replaceable>
      </term>
      <listitem>
       <para>
        如果配置文件不在标准目录 <filename>/etc/apparmor.d/</filename> 中，此选项会指定配置文件所处位置的完整路径。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><command>aa-logprof -f</command><replaceable>/path/to/logfile/</replaceable>
      </term>
      <listitem>
       <para>
        如果日志文件不在默认目录或 <filename>/var/log/audit/audit.log</filename> 中，此选项会指定日志文件所在位置的完整路径。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><command>aa-logprof -m "string marker in logfile"</command>
      </term>
      <listitem>
       <para>
        标记 <command>aa-logprof</command> 要在系统日志中查看的起点。<command>aa-logprof</command> 会忽略系统日志中位于指定标记前面的所有事件。如果标记包含空格，必须将标记括在引号中才能正常工作。例如：
       </para>
<screen><prompt role="root"># </prompt>aa-logprof -m "17:04:21"</screen>
       <para>
        或
       </para>
<screen><prompt role="root"># </prompt>aa-logprof -m e2ff78636296f16d0b5301209a04430d</screen>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     <command>aa-logprof</command> 将扫描日志，询问您如何处理记录的每个事件。每个问题都会显示一个带有编号的 <phrase>AppArmor</phrase> 规则列表，按列表中项目的编号可以添加相应规则。
    </para>
    <para>
     默认情况下，<command>aa-logprof</command> 将在 <filename>/etc/apparmor.d/</filename> 中查找配置文件。以 <systemitem class="username">root</systemitem> 身份运行 <command>aa-logprof</command> 往往便足以更新配置文件。不过，您有时可能需要搜索存档的日志文件，例如当程序的执行时间段超过日志轮换期时（日志文件已存档，新的日志文件已开始时）。如果是这样，您可以输入 <command>zcat -f `ls
     -1tr</command> <replaceable>/path/to/logfile*</replaceable>` | aa-logprof -f -。
    </para>
   </sect3>
   <sect3 xml:id="sec-apparmor-commandline-profiling-summary-logprof-ex1">
    <title>aa-logprof 示例 1</title>
    <para>
     以下示例说明 <command>aa-logprof</command> 如何处理访问 <filename>/etc/group</filename> 文件的 httpd2-prefork。<literal>[]</literal> 表示默认选项。
    </para>
    <para>
     在本示例中，对 <command>/etc/group</command> 的访问是 httpd2-prefork 访问名称服务的一部分。相应的响应是 <literal>1</literal>，它包括预定义的 <phrase>AppArmor</phrase> 规则集。选择 <literal>1</literal> <literal>#include</literal>，名称服务软件包会解析与 DNS 查找相关的所有问题，同时使配置文件更不容易损坏，这样对 DNS 配置和关联名称服务配置文件软件包的更改可一次完成，而无需修改许多配置文件。
    </para>
<screen>
Profile:  /usr/sbin/httpd2-prefork
Path:     /etc/group
New Mode: r

[1 - #include &lt;abstractions/nameservice&gt;]
 2 - /etc/group
[(A)llow] / (D)eny / (N)ew / (G)lob / Glob w/(E)xt / Abo(r)t / (F)inish
</screen>
    <para>
     请选择以下响应之一：
    </para>
    <variablelist>
     <varlistentry>
      <term>选择 <keycap function="enter"/>
      </term>
      <listitem>
       <para>
        触发默认操作，在本示例中为允许访问指定的目录路径项。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>允许</term>
      <listitem>
       <para>
        允许访问指定的目录路径项。<phrase>AppArmor</phrase> 会给出文件访问权限建议。有关更多信息，请参见<xref linkend="sec-apparmor-profiles-perm"/>。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>拒绝</term>
      <listitem>
       <para>
        永久阻止程序访问指定的目录路径项。<phrase>AppArmor</phrase> 随后会继续处理下一个事件。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>新建</term>
      <listitem>
       <para>
        提示您输入您自己对此事件的规则，允许您指定任意形式的常规表达式。如果输入的表达式不满足最初提示问题的事件，<phrase>AppArmor</phrase> 会要求您确认并允许您重新输入表达式。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>通配</term>
      <listitem>
       <para>
        选择特定的路径，或使用通配符创建与更多路径集匹配的一般规则。要选择提供的任何路径，请输入路径前面列显的编号，然后决定如何继续处理所选项。
       </para>
       <para>
        有关通配语法的详细信息，请参见<xref linkend="sec-apparmor-profiles-glob"/>。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>保留扩展名的通配</term>
      <listitem>
       <para>
        此选项会修改原始目录路径，不过会保留文件扩展名。例如，<filename>/etc/apache2/file.ext</filename> 将变成 <filename>/etc/apache2/*.ext</filename>，其中添加了通配符（星号）来代替文件名。这样程序就可以访问建议目录下以 <literal>.ext</literal> 为扩展名的所有文件。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>中止</term>
      <listitem>
       <para>
        中止 <command>aa-logprof</command>，到目前为止输入的所有规则更改将会丢失，所有配置文件都将保持不变。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>完成</term>
      <listitem>
       <para>
        关闭 <command>aa-logprof</command>，同时保存到目前为止输入的所有规则更改并修改所有配置文件。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3 xml:id="sec-apparmor-commandline-profiling-summary-logprof-ex2">
    <title>aa-logprof 示例 2</title>
    <para>
     例如，在为 vsftpd 构建配置文件时，会看到以下问题：
    </para>
<screen>Profile:  /usr/sbin/vsftpd
Path:     /y2k.jpg

New Mode: r

[1 - /y2k.jpg]

(A)llow / [(D)eny] / (N)ew / (G)lob / Glob w/(E)xt / Abo(r)t / (F)inish
</screen>
    <para>
     此问题中出现了几个要注意的项目。首先，vsftpd 会询问树顶的路径项，即便默认情况下 <phrase role="productname"><phrase os="sled">SUSE Linux Enterprise Desktop</phrase></phrase> 上的 vsftpd 是从 <filename>/srv/ftp</filename> 提供 FTP 文件也不例外。这是因为 vsftpd 使用的是 chroot，对于 chroot jail 内部的代码部分，<phrase>AppArmor</phrase> 看到的是对 chroot 环境（而非全局绝对路径）的文件访问。
    </para>
    <para>
     第二个要注意的事项是，您应该授予对该目录中所有 JPEG 文件的 FTP 读取权限，以便可以使用<guimenu>保留扩展名的通配</guimenu>并使用建议的路径 <literal>/*.jpg</literal>。这样做会破坏前面授予对单个 <literal>.jpg</literal> 文件的访问权限的所有规则，并会阻止此后有关访问 <filename>.jpg</filename> 文件的所有问题。
    </para>
    <para>
     最后，您应该授予对 FTP 文件的更广泛的访问权限。如果在最后一项中选择<guimenu>通配</guimenu>，<command>aa-logprof</command> 会将建议的路径 <filename>/y2k.jpg</filename> 替换为 <filename>/*</filename>。此外，您应该授予对整个目录树的更多访问权限，在这种情况下，可以使用<guimenu>新建</guimenu>路径选项并输入 <literal>/**.jpg</literal>（这会授予对整个目录树中所有 <literal>.jpg</literal> 文件的访问权限）或 <filename>/**</filename>（这会授予对目录树中所有文件的访问权限）。
    </para>
    <para>
     这些项会处理读取访问权限。写权限与此类似，不同的是您在使用写权限的常规表达式时最好更加保守。处理执行权限较为复杂。<xref linkend="ex-apparmor-commandline-profiling-summary-genprof-learn"/>中提供了相应示例。
    </para>
    <para>
     在以下示例中，将为 <filename>/usr/bin/mail</filename> 邮件客户端构建配置文件，<command>aa-logprof</command> 发现 <command>/usr/bin/mail</command> 以助手应用程序的形式执行了 <command>/usr/bin/less</command>，以将长邮件消息<quote>分页</quote>。结果会显示以下提示：
    </para>
<screen>
/usr/bin/nail -&gt; /usr/bin/less
(I)nherit / (P)rofile / (C)hild / (N)ame / (U)nconfined / (X)ix / (D)eny
</screen>
    <note>
     <para>
      <filename>/usr/bin/mail</filename> 的实际可执行文件是 <filename>/usr/bin/nail</filename>，这并非拼写错误。
     </para>
    </note>
    <para>
     <filename>/usr/bin/less</filename> 程序可以简单地在长度大于一个屏幕的文本之间滚动，这其实就是 <filename>/usr/bin/mail</filename> 使用它的原因。但 <command>less</command> 实际上是一个功能强大的大型程序，使用了许多其他助手应用程序，例如 <command>tar</command> 和 <command>rpm</command>。
    </para>
    <tip>
     <para>
      对 tar 文件或 RPM 文件运行 <command>less</command>，它即会显示这些容器的库存。
     </para>
    </tip>
    <para>
     您不希望阅读邮件时自动运行 <command>rpm</command>（这会直接导致 Microsoft* Outlook 样式的病毒攻击，因为 RPM 具有安装和修改系统程序的能力），因此这种情况下的最佳选择为使用<guimenu>继承</guimenu>。这会使在本文中执行的 less 程序运行于 <filename>/usr/bin/mail</filename> 的配置文件之下。这会产生两种结果：
    </para>
    <itemizedlist mark="bullet" spacing="normal">
     <listitem>
      <para>
       您需要将 <filename>/usr/bin/less</filename> 的所有基本文件访问权限添加到 <filename>/usr/bin/mail</filename> 的配置文件中。
      </para>
     </listitem>
     <listitem>
      <para>
       您可以避免将助手应用程序（例如 <command>tar</command> 和 <command>rpm</command>）添加到 <filename>/usr/bin/mail</filename> 配置文件中，这样，当 <filename>/usr/bin/mail</filename> 在此环境中运行 <filename>/usr/bin/less</filename> 时，less 程序的危害性就远低于不受 <phrase>AppArmor</phrase> 保护时的情况。另一个选择是使用 Cx 执行模式。有关执行模式的详细信息，请参见<xref linkend="sec-apparmor-profiles-exec"/>。
      </para>
     </listitem>
    </itemizedlist>
    <para>
     在其它情况下，您可能想要使用<guimenu>配置文件</guimenu>选项。这会对 <command>aa-logprof</command> 产生以下影响：
    </para>
    <itemizedlist mark="bullet" spacing="normal">
     <listitem>
      <para>
       写入配置文件的规则使用 px/Px，这会强制转换到子项自己的配置文件。
      </para>
     </listitem>
     <listitem>
      <para>
       <command>aa-logprof</command> 会为子项构造一个配置文件，然后通过将子进程的事件指派到子项的配置文件并向 <command>aa-logprof</command> 用户提出问题，开始以构建父配置文件的相同方式构建此配置文件。如果您将子项作为独立程序运行，也会应用该配置文件。
      </para>
     </listitem>
    </itemizedlist>
    <para>
     如果某个受限制的程序派生并执行另一个程序，<command>aa-logprof</command> 会注意到这种情况，并会询问用户在启动子进程时应使用哪种执行模式。执行模式“继承”、“配置文件”、“未受限”、“子项”、“命名配置文件”，或用于拒绝执行的选项将会显示。
    </para>
    <para>
     如果子进程具有单独的配置文件，则默认选择为“配置文件”。如果不存在配置文件，则默认选择为“继承”。<xref linkend="sec-apparmor-profiles-perm"/>中介绍了继承选项 (<literal>ix</literal>)。
    </para>
    <para>
     该配置文件选项指示子程序应在其自己的配置文件中运行。一个从属问题会询问是否要清理子程序从父项继承的环境。如果您选择清理环境，<phrase>AppArmor</phrase> 配置文件中将会添加执行修饰符 <literal>Px</literal>。如果您选择不清理，配置文件中将会添加 <literal>px</literal>，这样就不会进行环境清理。如果您选择配置文件执行模式，默认的执行模式为 <literal>Px</literal>。
    </para>
    <para>
     不建议使用未受限执行模式，仅当没有任何其他选项能够可靠地生成程序的配置文件时，才应使用该模式。选择未受限模式会打开一个警告对话框，要求您确认该选择。如果您确认并选择<guimenu>是</guimenu>，另一个对话框将会打开，询问是否要清理环境。要在配置文件中使用执行模式 <literal>Ux</literal>，请选择<guimenu>是</guimenu>。要在配置文件中改用执行模式 <literal>ux</literal>，请选择<guimenu>否</guimenu>。默认选择的值为 <literal>Ux</literal>（表示未受限执行模式）。
    </para>
    <important>
     <title>未受限运行</title>
     <para>
      选择 <literal>ux or Ux</literal> 会造成很大的风险，它不会对子程序的最终执行行为强制执行策略（从安全角度而言）。
     </para>
    </important>
   </sect3>

   <sect3 xml:id="sec-apparmor-commandline-profiling-summary-unconfined">
    <title>aa-unconfined — 识别不受保护的进程</title>
    <para>
     <command>aa-unconfined</command> 命令会检查系统上的开放网络端口，将其与系统上装载的配置文件集进行比较，并报告不具备 <phrase>AppArmor</phrase> 配置文件的网络服务。它需要未被 <phrase>AppArmor</phrase> 配置文件限制的 <systemitem class="username">root</systemitem> 特权。
    </para>
    <para>
     要从 <filename>/proc</filename> 文件系统中检索进程可执行链接，就必须以 <systemitem class="username">root</systemitem> 身份运行 <command>aa-unconfined</command>。此程序易受以下竞态条件的影响：
    </para>
    <itemizedlist mark="bullet" spacing="normal">
     <listitem>
      <para>
       未链接的可执行文件被误处理
      </para>
     </listitem>
     <listitem>

      <para>
       进程在 <command>netstat(8)</command> 之间终止，而且进一步的检查被误处理
      </para>
     </listitem>
    </itemizedlist>
    <note>
     <para>
      此程序仅列出使用 TCP 和 UDP 的进程。简而言之，此程序不适用于取证，仅在实验室中辅助构建所有可访问网络的进程的配置文件。
     </para>
    </note>
   </sect3>
   <sect3 xml:id="commandline-profiling-summary-aa-notify">
    <title>aa-notify</title>
    <para>
     <command>aa-notify</command> 是一个便利的实用程序，它可在桌面环境中显示 <phrase>AppArmor</phrase> 通知。如果您不想检查 <phrase>AppArmor</phrase> 日志文件，而仅希望桌面告知您违反策略的事件，此实用程序会非常便捷。要启用 <phrase>AppArmor</phrase> 桌面通知，请运行 <command>aa-notify</command>：
    </para>
<screen><prompt>&gt; </prompt><command>sudo</command> aa-notify -p -u <replaceable>USERNAME</replaceable> --display <replaceable>DISPLAY_NUMBER</replaceable></screen>
    <para>
     其中，<replaceable>USERNAME</replaceable> 是您登录时使用的用户名，<replaceable>DISPLAY_NUMBER</replaceable> 是您当前使用的 X Window 显示编号，例如 <literal>:0</literal>。该进程在后台运行，每当发生拒绝事件时，就会显示通知。
    </para>
    <tip>
     <para>
      活动的 X Window 显示编号保存在 <literal>$DISPLAY</literal> 变量中，因此，您可以使用 <literal>--display $DISPLAY</literal> 来避免查找当前显示编号。
     </para>
    </tip>
    <figure>
     <title><command>aa-notify Message in GNOME</command></title>
     <mediaobject>
      <imageobject role="fo">
       <imagedata fileref="aa-notify.png" width="75%"/>
      </imageobject>
      <imageobject role="html">
       <imagedata fileref="aa-notify.png" width="40%"/>
      </imageobject>
     </mediaobject>
    </figure>
    <para>
     您还可以使用 <option>-s <replaceable>DAYS</replaceable></option> 选项配置 <command>aa-notify</command>，以显示指定的过去几天的通知摘要。有关 <command>aa-notify</command> 的详细信息，请参见其手册页 <command>man 8 aa-notify</command>。
    </para>
   </sect3>
   <sect3 xml:id="sec-apparmor-commandline-profiling-summary-vim">
    <title>apparmor.vim</title>
    <para>
     vim 文本编辑器的语法高亮显示文件会用颜色高亮显示 <phrase>AppArmor</phrase> 配置文件的各种功能。利用 vim 和 vim 的 <phrase>AppArmor</phrase> 语法模式，您可以看到用颜色高亮显示的配置文件的语义含意。要使用 vim 来查看和编辑配置文件，请在终端窗口中输入 vim。
    </para>
    <para>
     在 vim 中编辑 <phrase>AppArmor</phrase> 配置文件时，如要启用语法颜色标记，请使用 <literal>:syntax on</literal> 命令，然后使用 <literal>:set
     syntax=apparmor</literal> 命令。为确保 vim 将编辑的文件类型正确识别为 <phrase>AppArmor</phrase> 配置文件，请将
    </para>
<screen># vim:ft=apparmor</screen>
    <para>
     添加到配置文件的末尾。
    </para>
    <tip>
     <para>
      <command>vim</command> 对 <filename>/etc/apparmor.d/</filename> 中的文件自动启用了 <phrase>AppArmor</phrase> 突出显示。
     </para>
    </tip>
    <para>
     启用此功能时，vim 会对配置文件的行上色：
    </para>
    <variablelist>
     <varlistentry>
      <term>蓝色</term>
      <listitem>
       <para>
        评论
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>白色</term>
      <listitem>
       <para>
        普通读权限的行
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>棕色</term>
      <listitem>
       <para>
        功能语句和“提示”标记
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>黄色</term>
      <listitem>
       <para>
        授予写权限的行
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>环保</term>
      <listitem>
       <para>
        授予执行权限的行（ix 或 px）
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>红色</term>
      <listitem>
       <para>
        授予无限制权限的行 (ux)
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>红色背景</term>
      <listitem>
       <para>
        不会正确装载到 <phrase>AppArmor</phrase> 模块的语法错误
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     要获取有关语法突出显示的更多 vim 帮助，请使用 <systemitem>apparmor.vim</systemitem> 和 <systemitem>vim</systemitem> 手册页以及 vim 编辑器内部的 <option>:help
     syntax</option>。<phrase>AppArmor</phrase> 语法存储在 <filename>/usr/share/vim/current/syntax/apparmor.vim.</filename> 中
    </para>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-apparmor-commandline-filenames">
  <title>重要的文件名和目录</title>

  <para>
   下面的列表包含 <phrase>AppArmor</phrase> 框架使用的最重要的文件和目录。如果您打算手动管理配置文件以及对其查错，请确保您了解这些文件和目录：
  </para>

  <variablelist>
   <varlistentry>
    <term><filename>/sys/kernel/security/apparmor/profiles</filename>
    </term>
    <listitem>
     <para>
      表示当前装载的配置文件集的虚拟化文件。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><filename>/etc/apparmor/</filename>
    </term>
    <listitem>
     <para>
      <phrase>AppArmor</phrase> 配置文件的位置。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><filename>/usr/share/apparmor/extra-profiles</filename>
    </term>
    <listitem>
     <para>
      <phrase>AppArmor</phrase> 随附但默认未启用的本地配置文件储存库。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><filename>/etc/apparmor.d/</filename>
    </term>
    <listitem>
     <para>
      配置文件的位置，采用将路径中的 <literal>/</literal> 替换为 <literal>&#x002E;</literal>（根目录 <literal>/</literal> 无需替换）的命名约定，这样可以更方便地管理配置文件。例如，程序 <filename>/usr/sbin/smbd</filename> 的配置文件命名为 <filename>usr.sbin.smbd</filename>。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><filename>/etc/apparmor.d/abstractions/</filename>
    </term>
    <listitem>
     <para>
      抽象的位置。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><filename>/etc/apparmor.d/program-chunks/</filename>
    </term>
    <listitem>
     <para>
      程序块的位置。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><filename>/proc/*/attr/current</filename>
    </term>
    <listitem>
     <para>
      检查此文件可以查看进程的限制状态以及用于限制该进程的配置文件。<command>ps</command>
      <option>auxZ</option> 命令会自动检索此信息。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
</chapter>
