<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>

<chapter version="5.0" role="General" 
  xml:id="cha-autoyast-control-file"
  xmlns="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2001/XInclude"
  xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>The &ay; Control File</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker></dm:bugtracker>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>

  <sect1 xml:id="Profile-Intro">
   <title>Introduction</title>

   <para>
    The control file is a configuration description for a single
    system. It consists of sets of resources with properties including
    support for complex structures such as lists, records, trees and large
    embedded or referenced objects.
   </para>

   <important>
    <title>Control Files from OS Releases Older Than &slsa; 12&nbsp;GA and &opensuse; 42.0 Are Incompatible</title>
    <para>
     Many major changes were introduced with &slsa; 12 and &opensuse; Leap 42.0,
     such as the switch to systemd and &grub;.
     These changes also required fundamental changes in &ay;
     Therefore you cannot use
     &ay; control files created on &slsa; 11 to install
     &productname; &productnumber; and vice versa.
    </para>
   </important>
  </sect1>
  <sect1 xml:id="Profile-Format">
   <title>Format</title>

   <para>
    The XML configuration format provides a consistent file structure, which
    is easy to learn and to remember when attempting to configure a new
    system.
   </para>

   <para>
    The &ay; control file uses XML to describe the system installation
    and configuration. XML is a commonly used markup, and many users are
    familiar with the concepts of the language and the tools used to process
    XML files. If you edit an existing control file or create a control file
    using an editor from scratch, it is strongly recommended to validate the
    control file. This can be done using a validating XML parser such as
    <literal>xmllint</literal> or <literal>jing</literal>, for example
    (see  <xref linkend="CreateProfile-Manual"/>).
   </para>
   <para>The following example shows a control file in XML format:
   </para>
   <example>
    <title>&ay; Control File (Profile)</title>
<screen>&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE profile&gt;
&lt;profile
  xmlns="http://www.suse.com/1.0/yast2ns"
  xmlns:config="http://www.suse.com/1.0/configns"&gt;
  &lt;partitioning config:type="list"&gt;
    &lt;drive&gt;
      &lt;device&gt;/dev/sda&lt;/device&gt;
      &lt;partitions config:type="list"&gt;
        &lt;partition&gt;
          &lt;filesystem config:type="symbol"&gt;btrfs&lt;/filesystem&gt;
          &lt;size&gt;10G&lt;/size&gt;
          &lt;mount&gt;/&lt;/mount&gt;
        &lt;/partition&gt;
        &lt;partition&gt;
          &lt;filesystem config:type="symbol"&gt;xfs&lt;/filesystem&gt;
          &lt;size&gt;120G&lt;/size&gt;
          &lt;mount&gt;/data&lt;/mount&gt;
        &lt;/partition&gt;
      &lt;/partitions&gt;
    &lt;/drive&gt;
  &lt;/partitioning&gt;
  &lt;scripts&gt;
    &lt;pre-scripts&gt;
      &lt;script&gt;
        &lt;interpreter&gt;shell&lt;/interpreter&gt;
        &lt;filename&gt;start.sh&lt;/filename&gt;
        &lt;source&gt;
        &lt;![CDATA[
#!/bin/sh
echo "Starting installation"
exit 0

]]&gt;

        &lt;/source&gt;
      &lt;/script&gt;
    &lt;/pre-scripts&gt;
  &lt;/scripts&gt;
&lt;/profile&gt;</screen>
   </example>
  </sect1>
  <sect1 xml:id="Profile-Structure">
   <title>Structure</title>

   <para>
    Below is an example of a basic control file container, the actual
    content of which is explained later on in this chapter.
   </para>

   <example>
    <title>Control file container</title>
<screen>&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE profile&gt;
&lt;profile
  xmlns="http://www.suse.com/1.0/yast2ns"
  xmlns:config="http://www.suse.com/1.0/configns"&gt;
  &lt;!-- RESOURCES --&gt;
&lt;/profile&gt;</screen>
   </example>

   <para>
    The <literal>&lt;profile&gt;</literal> element (root node)
    contains one or more distinct resource elements. The permissible
    resource elements are specified in the schema files
   </para>

   <sect2 xml:id="Profile-Format-ressources">
    <title>Resources and Properties</title>
    <para>
     A resource element either contains multiple and distinct property and
     resource elements, or multiple instances of the same resource element,
     or it is empty. The permissible content of a resource element is
     specified in the schema files.
    </para>
    <para>
     A property element is either empty or contains a literal value. The
     permissible property elements and values in each resource element are
     specified in the schema files
    </para>
    <para>
     An element can be either a container of other elements (a resource) or
     it has a literal value (a property); it can never be both. This
     restriction is specified in the schema files. A configuration component
     with more than one value must either be represented as an embedded list in a property value or as a nested resource.
    </para>
    <para>
      An empty element, such as
      <literal>&lt;foo&gt;&lt;/foo&gt;</literal> or
      <literal>&lt;bar/&gt;</literal>, will <emphasis>not</emphasis> be
      present in the parsed data model. Usually this is interpreted as
      wanting a sensible default value. In cases where you need an
      explicitly empty string instead, use a CDATA section:
      <literal>&lt;foo&gt;&lt;![CDATA[]]&gt;&lt;/foo&gt;</literal>.
    </para>
   </sect2>

   <sect2 xml:id="Profile-Format-ressources-nested">
    <title>Nested Resources</title>
    <para>
     Nested resource elements allow a tree-like structure of configuration
     components to be built to any level.
    </para>
    <para>
     There are two kinds of nested resources: maps and lists. Maps, also
     known as associative arrays, hashes, or dictionaries, contain mixed
     contents, identified by their tag names. Lists, or arrays, have all
     items of the same type.
    </para>
    <example>
     <title>Nested Resources</title>
<screen>...
&lt;drive&gt;
  &lt;device&gt;/dev/sda&lt;/device&gt;
  &lt;partitions config:type="list"&gt;
     &lt;partition&gt;
        &lt;size&gt;10G&lt;/size&gt;
        &lt;mount&gt;/&lt;/mount&gt;
     &lt;/partition&gt;
     &lt;partition&gt;
        &lt;size&gt;1G&lt;/size&gt;
        &lt;mount&gt;/tmp&lt;/mount&gt;
     &lt;/partition&gt;
  &lt;/partitions&gt;
&lt;/drive&gt;
....</screen>
    </example>
    <para>
     In the example above, the <literal>drive</literal> resource is a map
     consisting of a <literal>device</literal> property and a
     <literal>partitions</literal> resource. The <literal>partitions</literal>
     resource is a list containing multiple instances of the
     <literal>partition</literal> resource. Each <literal>partition</literal>
     resource is a map containing a <literal>size</literal> and
     <literal>mount</literal> property.
    </para>
    <para>
     The default type of a nested resource is map. Lists must be marked as
     such using the <literal>config:type="list"</literal> attribute.
    </para>
   </sect2>

   <sect2 xml:id="Profile-Format-attributes">
    <title>Attributes</title>
    <para>
     Global attributes are used to define metadata on resources and
     properties. Attributes are used to define context switching. They are
     also used for naming and typing properties as shown in the previous
     sections. Attributes are in a separate namespace so they do not need to
     be treated as reserved words in the default namespace.
    </para>
    <para>
     The <literal>config:type</literal> attribute determines the type of the
     resource or property in the parsed data model. For resources, lists need
     a <literal>list</literal> type whereas a map is the default type that
     does not need an attribute. For properties, <literal>boolean</literal>,
     <literal>symbol</literal>, and <literal>integer</literal> can be used,
     the default being a string.
    </para>
    <para>
     Attributes are not optional. It may appear that attributes are optional,
     because various parts of the schema are not very consistent in their usage
     of data types. In some places an enumeration is represented by a symbol,
     elsewhere a string is required. One resource needs
     <literal>config:type="integer"</literal>, another will parse the number
     from a string property. Some resources use
     <literal>config:type="boolean"</literal>, others want
     <literal>yes</literal> or even <literal>1</literal>. If in doubt, consult
     the schema file.
    </para>
   </sect2>
  </sect1>
 </chapter>
