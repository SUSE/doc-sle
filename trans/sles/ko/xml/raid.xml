<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//Novell//DTD NovDoc XML V1.0//EN" "novdocx.dtd">
<!--
*********************************
Please see LICENSE.txt for this document's license.
*********************************
-->
<sect1 xml:base="raid.xml" id="sec.yast2.system.raid">
 <title>소프트 RAID 구성</title><indexterm> <primary>YaST</primary> <secondary>RAID</secondary></indexterm><indexterm> <primary>RAID</primary> <secondary>YaST</secondary></indexterm><indexterm> <primary>소프트 RAID</primary> <see>RAID</see></indexterm>



 <para>
  RAID(Redundant Array of Independent Disks)의 목적은 여러 개의 하드 디스크 파티션을 하나의 큰 <emphasis>가상</emphasis> 하드 디스크에 결합하여 성능이나 데이터 보안 또는 둘 다를 최적화하는 것입니다. 대부분의 RAID 컨트롤러가 SCSI 프로토콜을 사용하는 이유는 IDE 프로토콜보다 더 효율적인 방법으로 더 많은 하드 디스크를 사용할 수 있기 때문입니다. 또한 이것은 병렬 명령 처리에 보다 적합합니다. IDE 또는 SATA 하드 디스크를 지원하는 몇 가지 RAID 컨트롤러가 있습니다. 소프트 RAID는 하드웨어 RAID 컨트롤러의 추가 비용 없이 RAID 시스템의 이점을 제공합니다. 그러나 CPU 시간이 필요하고 메모리 요구사항이 있어 실제 고성능 컴퓨터에는 적합하지 않습니다.
 </para>

 <para>
  <phrase role="productname"><phrase os="sles">SUSE® Linux Enterprise Server</phrase></phrase>를 사용하면 여러 하드 디스크를 한 개의 소프트 RAID 시스템으로 결합할 수 있습니다. RAID는 각각 다른 목적, 이점 및 특성을 가지는 여러 하드 디스크를 RAID 시스템 하나에 결합하기 위한 여러 가지 전략을 포함합니다. 이와 같이 다양한 특성들이 일반적으로 <emphasis>RAID 수준</emphasis>으로 알려져 있습니다.
 </para>

 <para>
  일반 RAID 수준은 다음과 같습니다.
 </para>

 <variablelist>
  <varlistentry>
   <term>RAID 0</term>
   <listitem>
    <para>
     이 수준은 각 파일 블록을 여러 디스크 드라이브에 분산하여 데이터 액세스의 성능을 향상시킵니다. RAID 0은 데이터 백업을 제공하지 않으며 이 유형의 시스템에 대한 <emphasis>RAID 0</emphasis> 이름이 일반적으로 사용되기 때문에 실제로 RAID가 아닙니다. RAID 0을 사용하면 두 개 이상의 하드 디스크가 함께 풀링됩니다. 성능은 향상되지만 RAID 시스템이 손상되고 하드 디스크 하나가 실패할 경우에도 데이터가 유실됩니다.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>RAID 1</term>
   <listitem>
    <para>
     이 수준은 데이터가 다른 하드 디스크에 1:1로 복사되기 때문에 데이터에 대한 적당한 보안을 제공합니다. RAID 1은 <emphasis>하드 디스크 미러링</emphasis>으로 알려져 있습니다. 디스크가 손상된 경우 디스크 내용의 사본을 다른 디스크에서 사용할 수 있습니다. 하나를 제외하고 모든 디스크가 데이터 위험 없이 손상될 수 있습니다. 그러나 손상이 감지되지 않으면 손상된 데이터는 손상되지 않은 디스크에 미러링할 수 있습니다. 그러면 데이터가 손실될 수 있습니다. 복사 프로세스에서 쓰기 성능은 단일 디스크 액세스 사용과 비교하여 문제가 있었지만(10 ~ 20% 더 느림) 읽기 액세스 속도는 일반적인 물리적 하드 디스크에 비해 훨씬 더 빠릅니다. 그 이유는 중복 데이터를 병렬로 검색할 수 있기 때문입니다. 일반적으로 수준 1의 경우 읽기 트랜잭션 속도는 단일 디스크의 거의 두 배이고 쓰기 트랜잭션 속도는 단일 디스크와 거의 같습니다.
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>RAID 5</term>
   <listitem>
    <para>
     RAID 5는 성능과 중복성 면에서 수준 0과 수준 1을 가장 적절하게 조정한 것입니다. 하드 디스크 공간은 사용된 디스크 수에서 1을 뺀 값입니다. 데이터가 RAID 0에서처럼 하드 디스크로 분산됩니다. <emphasis>패리티 블록</emphasis>은 보안상 이유로 파티션 하나에 생성됩니다. 이들은 XOR로 서로 연결되어 있어, 시스템 장애 발생 시 해당 패리티 블록으로 내용을 재구성할 수 있습니다. RAID 5를 사용하는 경우에는 둘 이상의 하드 디스크가 동시에 실패할 수 없습니다. 하드 디스크 하나가 실패하면 가능한 빨리 교체하여 데이터가 유실될 위험을 방지해야 합니다.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>RAID 6</term>
   <listitem>
    <para>
     RAID 시스템의 안정성을 더욱 높이기 위해 RAID 6을 사용할 수 있습니다. 이 수준에서는 두 개의 디스크가 실패하더라도 배열을 재구성할 수 있습니다. RAID 6을 사용할 때 배열을 실행하려면 최소 4개의 하드 디스크가 필요합니다. 소프트웨어 RAID로 실행할 때 이 구성은 상당량의 CPU 시간 및 메모리가 필요합니다.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>RAID 10(RAID 1+0)</term>
   <listitem>
    <para>
     이 RAID 구현은 RAID 0과 RAID 1의 기능을 결합합니다. 데이터는 먼저 개별 디스크 배열에서 미러링되고, 이 배열은 새 RAID 0; 유형 배열에 삽입됩니다. 각 RAID 1 하위 배열에서는 디스크 하나가 데이터 손상 없이 실패할 수 있습니다. RAID 10을 실행하려면 4개 이상의 짝수 개수 디스크가 필요합니다. 이 RAID 유형은 엄청난 양의 로드가 예상되는 데이터베이스 응용 프로그램에 사용됩니다.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>기타 RAID 수준</term>
   <listitem>
    <para>
     RAID 2, RAID 3, RAID 4, RAIDn, RAID 10, RAID 0+1, RAID 30, RAID 50 등과 같은 여러 RAID 수준이 개발되었으며, 독점적 구현 중인 RAID 수준 중 일부는 하드웨어 제조업체에 의해 생성되었습니다. 이 수준은 일반적으로 많이 사용되지 않으므로, 여기서는 설명하지 않습니다.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>

 <sect2 id="sec.yast2.system.raid.conf">
  <title>YaST로 소프트 RAID 구성</title>
  <para>
   <xref linkend="sec.yast2.i_y2_part_expert"/>에 설명된 YaST 고급 파티션 도구에서 YaST <guimenu>RAID</guimenu> 구성에 액세스할 수 있습니다. 이 파티셔닝 도구를 사용하여 기존 파티션을 편집 및 삭제하고 소프트 RAID와 함께 사용할 새 파티션을 생성할 수 있습니다.
  </para>
  <procedure>
   <step performance="required">
    <para>
     <guimenu>하드 디스크</guimenu>에서 하드 디스크를 선택합니다.
    </para>
   </step>
   <step performance="required">
    <para>
     <guimenu>파티션</guimenu> 탭으로 변경합니다.
    </para>
   </step>
   <step performance="required">
    <para>
     <guimenu>추가</guimenu>를 클릭하고 이 디스크의 원하는 RAID 파티션 크기를 입력합니다.
    </para>
   </step>
   <step performance="required">
    <para>
     <guimenu>파티션을 포맷하지 않음</guimenu>을 사용하고 <guimenu>파일 시스템 ID</guimenu>를 <guimenu>0xFD Linux RAID</guimenu>로 변경합니다. 이 파티션을 탑재하지 않음
    </para>
   </step>
   <step performance="required">
    <para>
     사용 가능한 디스크에 원하는 물리적 볼륨을 모두 정의할 때까지 이 절차를 반복하십시오.
    </para>
   </step>
  </procedure>
  <para>
   RAID 0 및 RAID 1의 경우 최소 두 개의 파티션이 필요하며, RAID 1의 경우 일반적으로 정확히 두 개입니다. RAID 5가 사용되면 3개 이상의 파티션이 필요합니다. RAID 6 및 RAID 10에는 4개 이상의 파티션이 필요합니다. 동일한 크기의 파티션만 사용하는 것이 좋습니다. RAID 파티션은 하나가 손상될 경우 데이터 유실 위험을 줄이고(RAID 1 및 5) RAID 0의 성능을 최적화하기 위해 다른 하드 디스크에 배치해야 합니다. RAID와 함께 사용할 모든 파티션을 생성한 후 <menuchoice><guimenu>RAID</guimenu><guimenu>RAID 추가</guimenu></menuchoice>를 클릭하여 RAID 구성을 시작하십시오.
  </para>
  <para>
   다음 대화 상자에서 RAID 수준 0, 1, 5, 6, 10 중 하나를 선택하십시오. 그런 다음 RAID 시스템에서 사용하는 <quote>Linux RAID</quote> 또는 <quote>Linux 기본</quote> 유형을 포함한 모든 파티션을 선택하십시오. 스왑 또는 DOS 파티션이 표시되지 않습니다.
  </para>
  <tip>
   <para>
    추가되는 디스크 순서가 중요한 RAID 유형의 경우 개별 디스크에 A부터 E까지 문자 중 하나를 표시할 수 있습니다. <guimenu>분류</guimenu> 버튼을 클릭하고 디스크를 선택한 다음 <guimenu>클래스 X</guimenu> 버튼 중 하나를 클릭합니다. 여기서 X는 디스크에 할당한 문자입니다. 사용 가능한 모든 RAID 디스크를 이런 방식으로 할당하고 <guimenu>확인</guimenu>을 클릭하여 확인합니다. <guimenu>정렬됨</guimenu> 또는 <guimenu>인터리브</guimenu> 버튼을 사용하여 분류된 디스크를 쉽게 정렬하거나, <guimenu>패턴 파일</guimenu>을 사용하여 텍스트 파일의 정렬 패턴을 추가할 수 있습니다.
   </para>
  </tip>
  <figure id="fig.yast2.system.raid.conf">
   <title>RAID 파티션</title>
   <mediaobject>
    <imageobject role="fo">
     <imagedata fileref="yast2_raid4.png" width="75%" format="PNG"/>
    </imageobject>
    <imageobject role="html">
     <imagedata fileref="yast2_raid4.png" width="75%" format="PNG"/>
    </imageobject>
   </mediaobject>
  </figure>
  <para>
   이전에 할당되지 않은 파티션을 선택된 RAID 볼륨에 추가하려면 먼저 파티션을 클릭한 다음 <guimenu>추가</guimenu>를 클릭하십시오. RAID에 대해 예약된 모든 파티션을 할당하십시오. 그렇지 않으면, 파티션의 공간이 사용되지 않는 상태로 남아 있습니다. 모든 파티션을 할당한 후 <guimenu>다음</guimenu>을 클릭하여 사용 가능한 <guimenu>RAID 옵션</guimenu>을 선택하십시오.
  </para>
  <para>
   마지막 단계에서 RAID 볼륨에 대한 탑재 지점과 암호화뿐만 아니라 사용할 파일 시스템을 설정하십시오. <guimenu>마침</guimenu>으로 구성을 완료한 후 고급 파티션 도구에서 <filename>/dev/md0</filename> 장치와 <emphasis>RAID</emphasis>로 표시된 기타 장치를 확인하십시오.
  </para>
 </sect2>

 <sect2 id="sec.yast2.system.raid.trouble">
  <title>문제 해결</title>
  <para>
   RAID 파티션이 손상되었는지 여부를 알아보려면 <filename>/proc/mdstat</filename> 파일을 확인하십시오. 시스템 고장이 발생하면 Linux 시스템을 종료하고 결함이 있는 하드 디스크를 동일한 방식으로 파티션된 새 하드 디스크로 바꾸십시오. 그런 다음 시스템을 재시작하고 <command>mdadm /dev/mdX --add /dev/sdX</command> 명령을 입력하십시오. 'X'를 특정 장치 ID로 바꾸십시오. 하드 디스크가 자동으로 RAID 시스템에 통합되고 완전히 재구성됩니다.
  </para>
  <para>
   재구성 중 모든 데이터에 액세스할 수 있더라도, RAID가 완전히 재구성될 때까지 성능 문제가 발생할 수도 있습니다.
  </para>
 </sect2>

 <sect2 id="sec.yast2.system.raid.information">
  <title>추가 정보</title>
  <para>
   소프트 RAID에 대한 구성 지침 및 상세 정보는 다음 문서의 HOWTO에서 찾을 수 있습니다.
  </para>
  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     <filename>/usr/share/doc/packages/mdadm/Software-RAID.HOWTO.html</filename>
    </para>
   </listitem>
   <listitem>
    <para>
     <ulink url="http://raid.wiki.kernel.org"/>
    </para>
   </listitem>
  </itemizedlist>
  <para>
   <ulink url="http://marc.info/?l=linux-raid"/>와 같은 Linux RAID 주소록도 사용할 수 있습니다.
  </para>
 </sect2>
</sect1>
