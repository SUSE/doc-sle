<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>

<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="cha.tuning.systemtap">
<!--taroth 2011-08-18: this chapter documents systemtap 1.0, for SLES 11 SP2
        we ship systemtap 1.5-->
<!--
    http://sourceware.org/systemtap/wiki/

    http://en.wikipedia.org/wiki/Systemtap
    http://sourceware.org/systemtap/
    http://sourceware.org/systemtap/documentation.html
    http://sourceware.org/systemtap/langref/
-->
<!--taroth 2011-10-17: commenting for now (systemtap 1.5), to be updated later-->
<!--<para>
  There are two different setups for using &stap;:
 </para>
 <variablelist>
  <varlistentry>
   <term><xref linkend="sec.tuning.systemtap.setup.classic" xrefstyle="select:title"/>
   </term>
   <listitem>
    <para>
     Have the &stap; script compiled and the resulting kernel modules
     inserted on the same machine. This requires the machine to have the
     kernel debugging information installed.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><xref linkend="sec.tuning.systemtap.setup.client-server" xrefstyle="select:title"/>
   </term>
   <listitem>
    <para>
     If the machine you want to probe does not have any development tools or
     kernel debugging information installed for any reason, you can make use
     of this setup. It allows you to compile a &stap; module on a machine
     other than the one on which it will be run.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>-->
<!--taroth 2013-11-22: http://doccomments.provo.novell.com/admin/viewcomment/14466-->
 <title>&stap;&mdash;Filtering and Analyzing System Data</title>
 <info>
      <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
        <dm:bugtracker>
          </dm:bugtracker>
      </dm:docmanager>
    </info>
    <!--taroth 2011-08-18: this chapter documents systemtap 1.0, for SLES 11 SP2
        we ship systemtap 1.5-->
<!--
    http://sourceware.org/systemtap/wiki/

    http://en.wikipedia.org/wiki/Systemtap
    http://sourceware.org/systemtap/
    http://sourceware.org/systemtap/documentation.html
    http://sourceware.org/systemtap/langref/
-->
 <para>
  &stap; provides a command line interface and a scripting language to
  examine the activities of a running Linux system, particularly the kernel,
  in fine detail. &stap; scripts are written in the &stap; scripting
  language, are then compiled to C-code kernel modules and inserted into the
  kernel. The scripts can be designed to extract, filter and summarize data,
  thus allowing the diagnosis of complex performance problems or functional
  problems. &stap; provides information similar to the output of tools
  like <command>netstat</command>, <command>ps</command>,
  <command>top</command>, and <command>iostat</command>. However, more
  filtering and analysis options can be used for the collected information.
 </para>
<!--taroth 2011-10-17: commenting for now (systemtap 1.5), to be updated later-->
<!--<para>
  There are two different setups for using &stap;:
 </para>
 <variablelist>
  <varlistentry>
   <term><xref linkend="sec.tuning.systemtap.setup.classic" xrefstyle="select:title"/>
   </term>
   <listitem>
    <para>
     Have the &stap; script compiled and the resulting kernel modules
     inserted on the same machine. This requires the machine to have the
     kernel debugging information installed.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><xref linkend="sec.tuning.systemtap.setup.client-server" xrefstyle="select:title"/>
   </term>
   <listitem>
    <para>
     If the machine you want to probe does not have any development tools or
     kernel debugging information installed for any reason, you can make use
     of this setup. It allows you to compile a &stap; module on a machine
     other than the one on which it will be run.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>-->
 <sect1 xml:id="sec.tuning.systemtap.concept">
  <title>Conceptual Overview</title>

  <para>
   Each time you run a &stap; script, a &stap; session is started.
   Several passes are done on the script before it is allowed to run.
   Then, the script is compiled into a kernel module and loaded. If the
   script has been executed before and no system components have changed
   (for example, different compiler or kernel versions, library paths, or
   script contents), &stap; does not compile the script again. Instead,
   it uses the <filename>*.c</filename> and <filename>*.ko</filename> data
   stored in the &stap; cache (<filename>~/.systemtap</filename>).
  </para>
  <para>
   The module is unloaded when the tap has finished running. For an example, see
   the test run in <xref linkend="sec.tuning.systemtap.setup"/> and the
   respective explanation.
<!--taroth 2011-10-17: systemtap 1.5, orginal linkend: sec.tuning.systemtap.setup.classic-->
  </para>

  <sect2 xml:id="sec.tuning.systemtap.concept.scripts">
   <title>&stap; Scripts</title>
   <para>
    &stap; usage is based on &stap; scripts
    (<filename>*.stp</filename>). They tell &stap; which type of
    information to collect, and what to do once that information is
    collected. The scripts are written in the &stap; scripting language
    that is similar to AWK and C. For the language definition, see
    <link xlink:href="http://sourceware.org/systemtap/langref/"/>. A lot of
    useful example scripts are available from
    <link xlink:href="http://www.sourceware.org/systemtap/examples/"/>.
   </para>
   <para>
    The essential idea behind a &stap; script is to name
    <literal>events</literal>, and to give them <literal>handlers</literal>.
    When &stap; runs the script, it monitors for certain events. When an
    event occurs, the Linux kernel runs the handler as a sub-routine, then
    resumes. Thus, events serve as the triggers for handlers to run.
    Handlers can record specified data and print it in a certain manner.
   </para>
   <para>
    The &stap; language only uses a few data types (integers, strings,
    and associative arrays of these), and full control structures (blocks,
    conditionals, loops, functions). It has a lightweight punctuation
    (semicolons are optional) and does not need detailed declarations (types
    are inferred and checked automatically).
   </para>
   <para>
    For more information about &stap; scripts and their syntax, refer to
    <xref linkend="sec.tuning.systemtap.syntax"/> and to the
    <command>stapprobes</command> and <command>stapfuncs</command> man
    pages, that are available with the
    <systemitem class="resource">systemtap-docs</systemitem> package.
   </para>
  </sect2>

  <sect2 xml:id="sec.tuning.systemtap.concept.tapsets">
   <title>Tapsets</title>
   <para>
    <remark>sknorr, 2014-08-21: "tapsets are a library" sounds wrong... to
     me, it would make more sense if there was a "library of tapsets," i.e. a
     collection of systemtap scripts.</remark>
    Tapsets are a library of pre-written probes and functions that can be
    used in &stap; scripts. When a user runs a &stap; script,
    &stap; checks the script's probe events and handlers against the
    tapset library. &stap; then loads the corresponding probes and
    functions before translating the script to C. Like &stap; scripts
    themselves, tapsets use the file name extension
    <filename>*.stp</filename>.
<!--The standard library of tapsets is located in /usr/share/systemtap/tapset/ by default.-->
   </para>
   <para>
    However, unlike &stap; scripts, tapsets are not meant for direct
    execution. They constitute the library from which other scripts can pull
    definitions. Thus, the tapset library is an abstraction layer designed
    to make it easier for users to define events and functions. Tapsets
    provide aliases for functions that users could want to specify as an
    event. Knowing the proper alias is often easier than remembering
    specific kernel functions that might vary between kernel versions.
   </para>
  </sect2>

  <sect2 xml:id="sec.tuning.systemtap.concept.cmd">
   <title>Commands and Privileges</title>
   <para>
    The main commands associated with &stap; are <command>stap</command>
    and <command>staprun</command>. To execute them, you either need
    &rootuser; privileges or must be a member of the
    <systemitem class="groupname">stapdev</systemitem> or
    <systemitem class="groupname">stapusr</systemitem> group.
   </para>
   <variablelist>
    <varlistentry>
     <term><command>stap</command>
     </term>
     <listitem>
      <para>
       &stap; front-end. Runs a &stap; script (either from file, or
       from standard input). It translates the script into C code, compiles
       it, and loads the resulting kernel module into a running Linux
       kernel. Then, the requested system trace or probe functions are
       performed.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><command>staprun</command>
     </term>
     <listitem>
      <para>
       &stap; back-end. Loads and unloads kernel modules produced by the
       &stap; front-end.
<!--runs instrumentation modules-->
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    For a list of options for each command, use <option>--help</option>. For
    details, refer to the <command>stap</command> and the
    <command>staprun</command> man pages.
   </para>
<!--taroth 2011-10-17: commenting for now (systemtap 1.5), to be updated later-->
<!--  <para>
    Apart from the commands above which are used in a setup where you build
    the kernel modules on the same machine that you want to probe, there is
    also a specific set of commands for a client-server setup:
    <remark>taroth 2011-10-07: deprecated, according to systemtap 1.5 RN
     (http://www.sourceware.org/ml/systemtap/2011-q2/msg00218.html)</remark><command>systemtap-client</command> and
    <command>stap-server</command>, the latter containing several
    subcommands. This set of commands allows you to compile a &stap; module
    on a machine other than the one on which it will be run. For more
    information about this specific setup and the commands involved, refer
    to <xref linkend="sec.tuning.systemtap.setup"/> and to the
    <command>stap-server</command> and <command>stap-client</command> man
    pages.
   </para>-->
<para>
 <!-- bsc#992981 -->
    To avoid giving &rootuser; access to users solely to enable them to work
    with &stap;, use one of the following &stap; groups. They are not available
    by default on &productname;, but you can create the groups and modify the
    access rights accordingly.  Also adjust the permissions of the
    <command>staprun</command> command if the security implications are
    appropriate for your environment.
   </para>
   <variablelist>
    <varlistentry>
     <term><systemitem class="groupname">stapdev</systemitem>
     </term>
     <listitem>
      <para>
       Members of this group can run &stap; scripts with
       <command>stap</command>, or run &stap; instrumentation modules
       with <command>staprun</command>. As running <command>stap</command>
       involves compiling scripts into kernel modules and loading them into
       the kernel, members of this group still have effective &rootuser;
       access.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem class="groupname">stapusr</systemitem>
     </term>
     <listitem>
      <para>
       Members of this group are only allowed to run &stap;
       instrumentation modules with <command>staprun</command>. In addition,
       they can only run those modules from
       <filename>/lib/modules/<replaceable>KERNEL_VERSION</replaceable>/systemtap/</filename>.
       This directory must be owned by &rootuser; and must only be
       writable for the &rootuser; user.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="sec.tuning.systemtap.concept.dir">
   <title>Important Files and Directories</title>
   <para>
    The following list gives an overview of the &stap; main files and
    directories.
   </para>
   <variablelist>
    <varlistentry>
     <term><filename>/lib/modules/<replaceable>KERNEL_VERSION</replaceable>/systemtap/</filename>
     </term>
     <listitem>
      <para>
       Holds the &stap; instrumentation modules.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><filename>/usr/share/systemtap/tapset/</filename>
     </term>
     <listitem>
      <para>
       Holds the standard library of tapsets.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><filename>/usr/share/doc/packages/systemtap/examples</filename>
     </term>
     <listitem>
      <para>
       Holds several example &stap; scripts for various purposes.
       Only available if the
       <systemitem class="resource">systemtap-docs</systemitem> package is
       installed.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><filename>~/.systemtap/cache</filename>
     </term>
     <listitem>
      <para>
       Data directory for cached &stap; files.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><filename>/tmp/stap*</filename>
     </term>
     <listitem>
      <para>
       Temporary directory for &stap; files, including translated C code
       and kernel object.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
<!--taroth 2011-10-17: commenting for now (systemtap 1.5), to be updated later-->
<!-- <para>
    If you use the &stap; client-server setup, the following directories are
    also important:
   </para>
   <variablelist>
    <varlistentry>
     <term><filename>/etc/systemtap/ssl/server</filename>
     </term>
     <listitem>
      <para>
       Public &stap; server certificate and key database. Used if the &stap;
       server is set up under &rootuser;'s account.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><filename>/etc/systemtap/ssl/client</filename>
     </term>
     <listitem>
      <para>
       &stap; client-side certificate database. Only located in this
       directory if a &stap; server is authorized as trusted for
       <emphasis>all</emphasis> &stap; clients running on this machine.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><filename>~/.systemtap/ssl/server</filename>
     </term>
     <listitem>
      <para>
       Private &stap; server certificate and key database. Used if the
       &stap; server is not running under a &rootuser; account, but under a
       regular user's account. Usually, a dedicated user named
       <systemitem class="username">stap-server</systemitem> is created for
       that purpose.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><filename>~/.systemtap/ssl/client</filename>
     </term>
     <listitem>
      <para>
       Client-side certificate database, located in a regular user's home
       directory. Only located in this directory if a &stap; server has been
       authorized as trusted for &stap; clients run by this specific user.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><filename>/var/log/stap-server.log
    </filename>
     </term>
     <listitem>
      <para>
       Default &stap; server log file.
      </para>
     </listitem>
    </varlistentry>
    </variablelist>-->
  </sect2>
 </sect1>
 <sect1 xml:id="sec.tuning.systemtap.setup">
  <title>Installation and Setup</title>

  <para>
<!--taroth 2011-10-17: commenting for now (systemtap 1.5), to be updated later-->
<!--Depending on your preferred setup, check the sections below for an
   overview of the packages you need.-->
   As &stap; needs information about the kernel, some additional
   kernel-related packages must be installed. For each kernel you want to
   probe with &stap;, you need to install a set of the following
   packages. This set should exactly match the kernel version and flavor
   (indicated by <literal>*</literal> in the overview below).
  </para>

  <important>
   <title>Repository for Packages with Debugging Information</title>
   <para>
    If you subscribed your system for online updates, you can find
    <quote>debuginfo</quote> packages in the
    <literal>*-Debuginfo-Updates</literal> online installation repository
    relevant for &productname; &productnumber;. Use &yast; to
    enable the repository.
   </para>
  </important>

<!--taroth 2011-10-17: commenting for now (systemtap 1.5): original location of the para-->

<!--<para>
   To get access to the man pages and to a helpful collection of example
   &stap; scripts for various purposes, additionally install the
   <systemitem class="resource"
   >systemtap-docs</systemitem> package.
  </para>-->

<!--taroth 2011-10-17: commenting for now (systemtap 1.5), to be updated later-->

<!--<sect2 id="sec.tuning.systemtap.setup.classic">
   <title>Classic Setup and Initial Test</title>
-->

  <para>
<!--For this setup,...-->
   For the classic &stap; setup, install the following packages (using
   either &yast; or <command>zypper</command>).
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     <systemitem class="resource">systemtap</systemitem>
    </para>
   </listitem>
   <listitem>
    <para>
     <systemitem class="resource">systemtap-server</systemitem>
    </para>
   </listitem>
   <listitem>
    <para>
     <systemitem class="resource">systemtap-docs</systemitem> (optional)
    </para>
   </listitem>
   <listitem>
    <para>
     <systemitem class="resource">kernel-*-base</systemitem>
    </para>
   </listitem>
<!--taroth 2011-10-07: just for the records: debuginfo pkgs are
           internally available from DVD3-->
   <listitem>
    <para>
     <systemitem class="resource">kernel-*-debuginfo</systemitem>
    </para>
   </listitem>
   <listitem>
    <para>
     <systemitem class="resource">kernel-*-devel</systemitem>
    </para>
   </listitem>
   <listitem>
    <para>
     <systemitem class="resource">kernel-source-*</systemitem>
    </para>
   </listitem>
   <listitem>
    <para>
     <systemitem class="resource">gcc</systemitem>
    </para>
   </listitem>
  </itemizedlist>

<!--taroth 2011-10-17: moved para here, change to original location after update
    for systemtap 1.5 is done-->

  <para>
   To get access to the man pages and to a helpful collection of example
   &stap; scripts for various purposes, additionally install the
   <systemitem class="resource">systemtap-docs</systemitem> package.
  </para>

  <para>
   To check if all packages are correctly installed on the machine and if
   &stap; is ready to use, execute the following command as
   &rootuser;.
  </para>

<screen>&prompt.root;stap -v -e 'probe vfs.read {printf("read performed\n"); exit()}'</screen>

  <para>
   It probes the currently used kernel by running a script and returning an
   output. If the output is similar to the following, &stap; is
   successfully deployed and ready to use:
  </para>

<screen><?dbsuse-fo font-size="0.71em"?>Pass <co xml:id="co.tuning.stap.pass1"/>: parsed user script and 59 library script(s) in 80usr/0sys/214real ms.
Pass <co xml:id="co.tuning.stap.pass2"/>: analyzed script: 1 probe(s), 11 function(s), 2 embed(s), 1 global(s) in
 140usr/20sys/412real ms.
Pass <co xml:id="co.tuning.stap.pass3"/>: translated to C into
 "/tmp/stapDwEk76/stap_1856e21ea1c246da85ad8c66b4338349_4970.c" in 160usr/0sys/408real ms.
Pass <co xml:id="co.tuning.stap.pass4"/>: compiled C into "stap_1856e21ea1c246da85ad8c66b4338349_4970.ko" in
 2030usr/360sys/10182real ms.
Pass <co xml:id="co.tuning.stap.pass5"/>: starting run.
 read performed
Pass <xref linkend="co.tuning.stap.pass5"/>: run completed in 10usr/20sys/257real ms. </screen>

  <calloutlist>
   <callout arearefs="co.tuning.stap.pass1">
    <para>
     Checks the script against the existing tapset library in
     <filename>/usr/share/systemtap/tapset/</filename> for any tapsets used.
     Tapsets are scripts that form a library of pre-written probes and
     functions that can be used in &stap; scripts.
    </para>
   </callout>
   <callout arearefs="co.tuning.stap.pass2">
    <para>
     Examines the script for its components.
    </para>
   </callout>
   <callout arearefs="co.tuning.stap.pass3">
    <para>
     Translates the script to C. Runs the system C compiler to create a
     kernel module from it. Both the resulting C code
     (<filename>*.c</filename>) and the kernel module
     (<filename>*.ko</filename>) are stored in the &stap; cache,
     <filename>~/.systemtap</filename>.
    </para>
   </callout>
   <callout arearefs="co.tuning.stap.pass4">
    <para>
     Loads the module and enables all the probes (events and handlers) in
     the script by hooking into the kernel. The event being probed is a
     Virtual File System (VFS) read. As the event occurs on any processor, a
     valid handler is executed (prints the text <literal>read
     performed</literal>) and closed with no errors.
    </para>
   </callout>
   <callout arearefs="co.tuning.stap.pass5">
    <para>
     After the &stap; session is terminated, the probes are disabled, and
     the kernel module is unloaded.
    </para>
   </callout>
  </calloutlist>

  <para>
   In case any error messages appear during the test, check the output for
   hints about any missing packages and make sure they are installed
   correctly. Rebooting and loading the appropriate kernel may also be
   needed.
   <remark>jw 2010-09-23, while I am at it: I have two useful smoke tests,
     to verify if an installation is working, see
     http://docserv.suse.de/HOWTO/systemtap
     If you install systemtap on an older system, the debuginfo and devel
     packages are likely to be newer than your installed kernel. Finding the
     correct versions for a given kernel might be challenging. I usually
     circumvent this by upgrading the kernel.  </remark>
  </para>

<!-- </sect2>-->

<!-- <sect2 id="sec.tuning.systemtap.setup.client-server">
   <title>Client-Server Setup</title>
   <remark>taroth 2011-10-07: argh, this section needs a major revamp with systemtap 1.5... see the
    systemtap 1.5 RN: "The following deprecated tools have been removed: stap-client
    stap-authorize-server-cert stap-authorize-signing-cert stap-find-or-start-server
    stap-find-servers Use the &#8722;&#8722;use-server, &#8722;&#8722;trust-server and &#8722;&#8722;list-servers options of stap
    instead."</remark>
   <para>
    A &stap; compile server listens for connections from &stap; clients on a
    secure SSL network port and accepts requests to run the &stap;
    front-end. The server advertises its presence and configuration on the
    local network using avahi (a free Zeroconf implementation that allows
    programs to publish and discover services and hosts in a local network
    without any specific configuration). The compile server broadcasts its
    IP address, port, and details about the Linux kernel it runs. Thus, the
    &stap; client can automatically detect a compile server on the network
    that is compatible to the client's kernel version.
   </para>
   <para>
    As &stap; exposes kernel internal data structures and potentially
    private user information, it provides several layers of security:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      A separate front-end (<command>stap</command>) and back-end
      (<command>staprun</command>), with only the front-end requiring access
      to kernel information packages for compiling the &stap; script into C
      code and for creating a kernel module. For more information, refer to
      <xref linkend="sec.tuning.systemtap.concept.cmd"/>.
     </para>
    </listitem>
<!-\-taroth 2010-06-01: commenting for this release; based on tonyj's answer-\->
<!-\-<listitem>
     <para>
      <remark>taroth 2010-05-12: tonyj: should we mention this already as it only seems to be fully
      integrated with &stap; 1.1 or higher (SLE 11 SP1 ships with &stap; 1.0) -
       tonyj 2010-05-25: Dunno. Does it work? I've not personally tested it.  If it kinda works you
      could mention it w/ caveat that it is experimental in 1.0 of course I doubt
      this will prevent bug reports</remark>
      A new (experimental) <command>stap</command> option:
      <option>minus minus unprivileged</option> that allows non-&rootuser; users to
      run <command>stap</command> (with certain restrictions).
     </para>
    </listitem>-\->
    <listitem>
     <para>
      An encrypted network connection between &stap; client and server via
      SSL. The SSL connection is based on certificates and key pairs
      consisting of public and private keys.
     </para>
    </listitem>
    <listitem>
     <para>
      Users or system administrators can authorize &stap; servers on the
      network as <quote>trusted</quote>.
     </para>
    </listitem>
    <listitem>
     <para>
      Use of &stap; groups with different privileges. For more information,
      refer to <xref
    linkend="sec.tuning.systemtap.concept.cmd"/>.
     </para>
    </listitem>
   </itemizedlist>
   <sect3 id="sec.tuning.systemtap.setup.inst">
    <title>Installing &stap;</title>
    <para>
     For this setup, install the following packages (using &yast; or
     Zypper):
    </para>
    <variablelist>
     <varlistentry>
      <term>Client</term>
      <listitem>
       <itemizedlist>
        <listitem>
         <para>
          <systemitem class="resource">systemtap</systemitem>
         </para>
        </listitem>
        <listitem>
         <para>
          <systemitem class="resource">systemtap-docs</systemitem> (optional) </para>
        </listitem>
       </itemizedlist>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Server</term>
      <listitem>
       <itemizedlist>
        <listitem>
         <para>
          <systemitem class="resource">systemtap</systemitem>
         </para>
        </listitem>
        <listitem>
         <para>
          <systemitem class="resource">systemtap-server</systemitem>
         </para>
        </listitem>
        <listitem>
         <para>
          <systemitem class="resource">kernel-*-debuginfo</systemitem>
         </para>
        </listitem>
        <listitem>
         <para>
          <systemitem class="resource">kernel-*-devel</systemitem>
         </para>
        </listitem>
        <listitem>
         <para>
          <systemitem class="resource">kernel-source-*</systemitem>
         </para>
        </listitem>
        <listitem>
         <para>
          <systemitem class="resource">gcc</systemitem>
         </para>
        </listitem>
       </itemizedlist>
      </listitem>
     </varlistentry>
    </variablelist>
<!-\-taroth 2010-06-01: commenting for this release; based on tonyj's answer-\->
<!-\-<para> Instead of running the &stap; compile server and client on two individual machines,
     you can also set up both on the same machine. <remark>taroth 2010-05-18: tonyj, would this
      setup also make sense in a real world scenario? or just for testing purposes? - tonyj
      2010-05-25: The only non-testing case I can think of is for minus minus unpriviliged</remark>
      </para>-\->
   </sect3>
   <sect3 id="sec.tuning.systemtap.setup.server">
    <title>Setting Up the Server</title>
    <para>
     You have two choices for setting up the &stap; compile server: you can
     run it as &rootuser; or as non-&rootuser; user. This has implications
     on the certificate management on server- and client-side and on the
     process of establishing a given compile server as trusted by a given
     client. For the SSL connection between the compile server and the
     &stap; client, you need to create a certificate for authentication.
     Depending on how the &stap; compile server is set up (as &rootuser; or
     as non-&rootuser;), the location of the server certificate differs.
     When set up as &rootuser; user, the certificate is stored in a database
     at <filename>/etc/systemtap/ssl/server</filename>. However, when the
     compile server is set up as non-&rootuser; (usually by the user
     <systemitem
      class="username">stap-server</systemitem>), the
     server certificate is stored in a database in the
     <literal>systemtap-server</literal> user's home directory:
     <filename>~/.systemtap/ssl/server</filename>.
    </para>
    <procedure id="pro.tuning.stap.setup.server.non-root">
     <title>Running the Compile Server as Non-&rootuser; User</title>
     <para>
      For this setup, it is advisable to create a dedicated system group and
      user for the compile server.
     </para>
     <step>
      <para>
       Log in as &rootuser;.
      </para>
     </step>
     <step id="step.stap.setup.server.homedir">
      <para>
       Create a home directory for the compile server user, for example:
      </para>
<screen>mkdir /var/lib/stapserver</screen>
     </step>
     <step>
      <para>
       Add a system group for the operation of the compile server. In the
       following example, the group is named <literal>stap-server</literal>
       and the group ID (GID) is <literal>155</literal>, but you can also
       specify a different group name or GID:
      </para>
<screen>groupadd -g 155 -r stap-server</screen>
     </step>
     <step>
      <para>
       Add a user belonging to the group you created before and specify the
       user's home directory:
      </para>
<screen>useradd -c "&stap; Compile Server" -u 155 -g stap-server -d \ /var/lib/stapserver -m -r -s /sbin/nologin stap-server</screen>
      <para>
       The command above will create a user named
       <systemitem class="username"
        >stap-server</systemitem> with
       the user ID <literal>155</literal>. The user's finger information is
       specified with <option>-c</option> and the options
       <option>-g</option> and <literal>-d</literal> specify the user's main
       group (<literal>stap-server</literal>) and his home directory you
       created in <xref linkend="step.stap.setup.server.homedir"/>,
       respectively. The user account will be a system account (specified
       with <option>-r</option>) and the user will not be able to log in, as
       his login shell is set to <filename>/sbin/nologin</filename> with the
       <option>-s</option> option.
      </para>
     </step>
     <step>
      <para>
       Change the owner and the group for the home directory to use:
      </para>
<screen>chown -R stap-server.stap-server /var/lib/stapserver/</screen>
     </step>
     <step>
      <para>
       Run a shell as user
       <systemitem class="username">stap-server</systemitem> and pass the
       <command>stap-gen-cert</command> command to generate a &stap;
       certificate:
      </para>
<screen>su -s /bin/sh - stap-server -c  /usr/bin/stap-gen-cert</screen>
      <para>
       You are prompted to set a password for the &stap; server certificate
       and key database.
      </para>
     </step>
     <step>
      <para>
       Enter a password for the &stap; server certificate and confirm it.
      </para>
      <para>
       This generates a certificate (<filename>stap.cert</filename>) that is
       stored in the <literal>systemtap-server</literal> user's home
       directory&mdash;in this case:
       <filename>/var/lib/stapserver/.systemtap/ssl/server</filename>.
      </para>
     </step>
<!-\-taroth 2010-06-01: if I understodd tonyj correctly, this step is only executed on the
      client, not on the server machine-\->
<!-\-<step>
      <para>
       Add the server certificate to the given client-side certificate
       database:
      </para>
<screen>/usr/bin/stap-authorize-server-cert </screen>
      <para>
       This creates the <filename>/etc/systemtap/ssl/</filename> directory,
       also containing the <filename>client</filename> subdirectory. That makes
       that server a trusted server for clients using that database.
      </para>
     </step>
-\->
     <step>
      <para>
       Start the compile server with:
      </para>
<screen>su -s /bin/sh - stap-server -c /usr/bin/stap-start-server</screen>
      <para>
       Upon first start of the compile server, this creates a client-side
       certificate database in the <literal>systemtap-server</literal>
       user's home directory (<filename>~/.systemtap/ssl/client</filename>)
       to which the server's certificate has now automatically been added.
       Thus, a server started by the user
       <systemitem class="username"
        >stap-server</systemitem> is
       automatically trusted by clients run by that user.
      </para>
     </step>
    </procedure>
    <procedure id="pro.tuning.stap.setup.server.root">
     <title>Running the Compile Server as &rootuser; User</title>
     <para>
      Compared to <xref linkend="pro.tuning.stap.setup.server.non-root"/>,
      this setup is much simpler but it has security implications.
     </para>
     <warning>
      <title>Security Risk</title>
      <para>
       In the following setup, the compile server certificate is stored in
       <filename>/etc/systemtap/ssl/server</filename>, together with the
       client-side database located at
       <filename>/etc/systemtap/ssl/client</filename>. As these files are
       accessible for anyone, anyone can run the
       <command>stap-client</command> command, thus potentially exposing
       kernel internal data structures and private user information.
      </para>
     </warning>
     <step>
      <para>
       Log in as &rootuser;.
      </para>
     </step>
     <step>
      <para>
       Create a &stap; certificate by executing the following command:
      </para>
<screen>/usr/bin/stap-gen-cert</screen>
      <para>
       You are prompted to set a password for the &stap; server certificate
       and key database.
      </para>
     </step>
     <step>
      <para>
       Enter a password and confirm it.
      </para>
      <para>
       The certificate (<filename>stap.cert</filename>) is generated. In
       contrast to the setup as non-&rootuser;, it is stored in a database
       located at <filename>/etc/systemtap/ssl/server</filename>.
      </para>
     </step>
     <step>
      <para>
       Start a &stap; server on the local host by using the following
       command:
      </para>
<screen>/usr/bin/stap-start-server</screen>
      <para>
       At the same time, a client-side certificate database is created at
       <filename>/etc/systemtap/ssl/client</filename>. The server
       certificate is automatically added to the client-side certificate
       database.
      </para>
     </step>
    </procedure>
    <para>
     The client-side certificate database created for &rootuser; is also the
     global client-side database for all clients on the host. Thus, a server
     started by root is automatically trusted by clients run by
     <emphasis>any</emphasis> user on that host: Any user can now compile
     kernel modules on the compile server using the
     <command>stap-client</command> command. For more information about the
     security implications, see the <citetitle>Safety and
     Security</citetitle> section of the <command>stap-server</command> man
     page.
    </para>
   </sect3>
   <sect3 id="sec.tuning.systemtap.setup.client">
    <title>Setting Up the Client</title>
    <para>
     To be able to invoke <command>stap-client</command> from another host,
     you need to copy the certificate that has been created on the server to
     the client and to authorize the compile server as trusted for the
     client. The location of the original server certificate to copy depends
     on how the &stap; compile server has been set up. For the authorization
     process you can choose to either authorize the compile server as
     trusted for <emphasis>all</emphasis> &stap; clients running on that
     machine or only for clients that are run by a
     <emphasis>specific</emphasis> user.
    </para>
    <procedure id="pro.tuning.stap.setup.">
     <step>
      <para>
       Log in to the client machine.
      </para>
     </step>
     <step>
      <para>
       If you have set up the compile server as non-&rootuser;, copy the
       server certificate to the client machine as follows:
      </para>
<screen>scp root@<replaceable>SERVERNAME</replaceable>:~stap-server/.systemtap/ssl/server/stap.cert \ /tmp/stap.cert</screen>
     </step>
     <step>
      <para>
       If you have set up the compile server as &rootuser;, copy the server
       certificate to the client machine as follows:
      </para>
<screen>scp root@<replaceable>SERVERNAME</replaceable>:/etc/systemtap/ssl/server/stap.cert /tmp/stap.cert</screen>
     </step>
     <step>
      <para>
       If you want to authorize the compile server as trusted for all &stap;
       clients running on that machine (no matter by which user), execute
       the following command as &rootuser;:
      </para>
<screen>/usr/bin/stap-authorize-server-cert /tmp/stap.cert</screen>
      <para>
       In this case, the server certificate will be added to the client-side
       certificate database
       (<filename>/etc/systemtap/ssl/client</filename>).
      </para>
     </step>
     <step>
      <para>
       If you want to authorize the compile server only as trusted for
       &stap; clients on that machine that are run by a specific user,
       execute the following command as regular user:
      </para>
<screen>/usr/bin/stap-authorize-server-cert /tmp/stap.cert</screen>
      <para>
       In that case, the server certificate will be added to the client-side
       certificate database for that user (
       <filename>~/.systemtap/ssl/client</filename>).
      </para>
     </step>
     <step>
      <para>
       Remove the copied certificate from the <filename>/tmp</filename>
       directory:
      </para>
<screen> rm /tmp/stap.cert</screen>
     </step>
    </procedure>
   </sect3>
   <sect3 id="sec.tuning.systemtap.setup.use">
    <title>Using the Client</title>
    <para>
     After you have set up the &stap; compile server and client as described
     in the previous sections, you can use the
     <command>stap-client</command> program. It is analogous to the
     <command>stap</command> front-end, except that it tries to find a
     compatible &stap; compile server on the local network. It then uses
     this server for compiling the &stap; script into a module, loading the
     kernel module and enabling the probes (passes 1-4 of a &stap; session).
     If requested, pass 5 actions are performed on the local host using
     <command>staprun</command>. For more information about a &stap; session
     and the individual passes, see
     <xref
     linkend="sec.tuning.systemtap.setup.classic"/>.
    </para>
    <note>
     <title>Executing <command>stap-client</command></title>
     <para>
      You can run <command>stap-client</command> either as &rootuser; or as
      non-&rootuser;. If run as non-&rootuser;, the underlying
      <command>staprun</command> command needs to be <literal>suid</literal>
      and the user executing <command>stap-client</command> must be a member
      of the <systemitem class="groupname"
       >stapdev</systemitem>
      group. For more information, refer to
      <xref
       linkend="sec.tuning.systemtap.concept.cmd"/>.
     </para>
    </note>
    <para>
     Usually, a running &stap; compile server on the local network
     advertises its presence using avahi and is automatically detected by
     the &stap; client. The following procedure illustrates how to make use
     of the &stap; client-server setup and covers the most common commands
     and options needed for that.
    </para>
    <procedure id="pro.tuning.stap.usage">
     <step>
      <para>
       To make sure that a compatible &stap; server is running on your local
       network, execute the following command on the &stap; client:
      </para>
<screen>stap-find-servers</screen>
      <para>
       This invokes avahi-browse to find servers. The details of any servers
       found are echoed to standard output. If this command does not return
       anything, no compatible &stap; server can be found on your network.
      </para>
     </step>
     <step>
      <para>
       In this case, log in to the compile server and run
      </para>
<screen>stap-start-server</screen>
      <para>
       This starts avahi-publish-service in the background. The server
       listens for connections on a random port and advertises its presence
       on the local network using the avahi daemon. If the server is started
       successfully, the process ID of the server is echoed to standard
       output.
      </para>
      <para>
       Note that <command>stap-start-server</command> does not work for the
       initial setup as described in
       <xref linkend="pro.tuning.stap.setup.server.root"/>, where
       <command>/usr/bin/stap-serverd</command> is used instead.
       <command>stap-start-server</command> puts the server in the
       background&mdash;thus, you would not see the prompt asking for the
       server certificate password.
      </para>
<screen>ps -ef | grep avahi</screen>
      <para>
       should now return an output similar to the following:
      </para>
<screen><?dbsuse-fo font-size="0.63em"?>avahi 3300     1  0 15:14 ?      00:00:00 avahi-daemon: running [linux-48zp.local]
root  4687  4655  0 18:03 ttyS0  00:00:00 avahi-publish-service Systemtap Compile Se
root  4700  4160  0 18:05 ttyS0  00:00:00 grep avahi</screen>
     </step>
     <step>
      <para>
       To run a simple test, execute the following command on the &stap;
       client:
      </para>
<screen>stap-client -e 'probe begin { printf("Hello"); exit(); }'</screen>
      <para>
       This compiles and executes a simple example on any compatible &stap;
       server found on the local network. If the test is successful, it
       prints <quote>Hello</quote> to standard output.
      </para>
     </step>
    </procedure>
    <para>
     Instead of using any compatible server found on the network, you can
     also determine which &stap; server to contact and use. To do so, run
     the <command>stap-client</command> command with the
     <option>&#8722;&#8722;server</option> option. It lets you specify the host name or
     IP address of the &stap; server, optionally also a port (which is
     useful fore connecting to non-local servers). For more information and
     details about the other available commands and options, refer to the
     <command>stap-server</command> and <command>stap-client</command> man
     pages.
    </para>
    <remark>taroth 2010-05-18: avoiding to mention the usage of &#8722;&#8722;unprivileged here as this is only
    in experimental state for stap version 1.0 (included in SLE 11 SP1) and adds additional layer of
    complexity...</remark>
<!-\- You might be asking why the client cert exists at all on the server, why
   not just run stap directly.  Because of &dash;&dash;unpriviliged

   # /usr/bin/stap-authorize-signing-cert ~stap-server/.systemtap/ssl/server/stap.cert

   or

   # /usr/bin/stap-authorize-signing-cert /etc/systemtap/ssl/server/stap.cert

   In both cases this creates the /etc/systemtap/staprun directory.

   Members of the group stapusr are limited (by stapdev) to scripts in
   /lib/modules/VERSION/systemtap (see stap man page).  You've mentioned this
   already in your doc. However, members of the stapusr group can run
   stap-client &dahs;&dash;unpriviliged and if the script doesn't use any priviliged
   features it will sign it (using what you generated when you executed
   /usr/bin/stap-authorize-signing-cert result) and stap will load it.

   See "UNPRIVILEGED USERS" in the stap-client man page.-\->
   </sect3>
   <sect3 id="sec.tuning.systemtap.setup.trouble">
    <title>Troubleshooting</title>
    <para>
     There are several things that can go wrong when using the &stap;
     client-server setup. If you have difficulties establishing a connection
     between &stap; client and server or running
     <command>stap-client</command>, proceed according to the following
     list.
    </para>
    <variablelist>
     <varlistentry>
      <term>Compatible &stap; Compile Server Available?</term>
      <listitem>
       <para>
        If <command>stap-client</command> reports that it is unable to find
        a server, check if a compatible &stap; compile server is available:
       </para>
<screen>stap-find-servers</screen>
       <para>
        If this command does not return anything, no compatible &stap;
        server can be found on your network.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>&stap; Compile Server Running?</term>
      <listitem>
       <para>
        To make sure that the &stap; compile server is running, log in to
        the server and run
       </para>
<screen>stap-server-start</screen>
       <para>
        If the server is started successfully, the process ID of the server
        is echoed to standard output.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Avahi Installed?</term>
      <listitem>
       <para>
        The &stap; client-server setup depends on avahi for automatically
        announcing the presence and configuration of any &stap; servers in
        the network and on client-side for automatically detecting a
        compatible server. As a consequence, the following packages are
        usually automatically installed together with the
        <systemitem class="resource"
        >systemtap-server</systemitem>
        and
        <systemitem class="resource"
        >systemtap-client</systemitem>
        packages:
       </para>
       <itemizedlist>
        <listitem>
         <para>
          <systemitem class="resource">avahi</systemitem>
         </para>
        </listitem>
        <listitem>
         <para>
          <systemitem class="resource">avahi-utils</systemitem>
         </para>
        </listitem>
       </itemizedlist>
       <para>
        Check if the packages are installed with
       </para>
<screen>rpm -qa | grep avahi</screen>
       <para>
        If not, install them with &yast; or Zypper.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Avahi Daemon Running?</term>
      <listitem>
       <para>
        Check if the avahi daemon is running:
       </para>
<screen>/etc/init.d/avahi-daemon status</screen>
       <para>
        If not, start it with
       </para>
<screen>/etc/init.d/avahi-daemon start</screen>
       <para>
        Also check if the avahi daemon was configured to be started
        automatically at runlevels 3 and 5:
       <remark>taroth 2014-03-07: FIXME - systemd</remark></para>
<screen>chkconfig -l avahi-daemon</screen>
       <para>
        This should return the following output:
       </para>
<screen>avahi-daemon              0:off  1:off  2:off  3:on   4:off  5:on   6:off</screen>
       <para>
        If not, configure this option with
        <remark>taroth 2014-03-07: FIXME - systemd</remark> </para>
<screen>chkconfig avahi-daemon 35</screen>
       <para/>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Virtual Machine: Bridged Network?</term>
      <listitem>
       <para>
        If you are running &stap; in a virtual machine setup, make sure the
        network has been bridged, otherwise broadcasting via avahi will not
        work.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Certificate Not Found?</term>
      <listitem>
       <para>
        If running an <command>stap-client</command> command fails because
        the certificate database was not found, check if you have set up the
        &stap; client correctly. For details, refer to
        <xref linkend="sec.tuning.systemtap.setup.client"/>.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
  </sect2>-->
 </sect1>
 <sect1 xml:id="sec.tuning.systemtap.syntax">
  <title>Script Syntax</title>

  <para>
   &stap; scripts consist of the following two components:
  </para>

  <variablelist>
   <varlistentry>
    <term><xref linkend="sec.tuning.systemtap.syntax.events" xrefstyle="select:title"/>
    </term>
    <listitem>
     <para>
      Name the kernel events at the associated handler should be executed.
      Examples for events are entering or exiting a certain function, a
      timer expiring, or starting or terminating a session.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><xref linkend="sec.tuning.systemtap.syntax.handlers" xrefstyle="select:title"/>
    </term>
    <listitem>
     <para>
      Series of script language statements that specify the work to be done
      whenever a certain event occurs. This normally includes extracting
      data from the event context, storing them into internal variables, or
      printing results.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   An event and its corresponding handler is collectively called a
   <literal>probe</literal>. &stap; events are also called <literal>probe
   points</literal>. A probe's handler is also called a <literal>probe
   body</literal>.
  </para>

  <para>
   Comments can be inserted anywhere in the &stap; script in various
   styles: using either <literal>#</literal>, <literal>/* */</literal>, or
   <literal>//</literal> as marker.
  </para>

  <sect2 xml:id="sec.tuning.systemtap.syntax.probe">
   <title>Probe Format</title>
   <para>
    A &stap; script can have multiple probes. They must be written in the
    following format:
   </para>
<screen>probe <replaceable>EVENT</replaceable> {<replaceable>STATEMENTS</replaceable>}</screen>
   <para>
    Each probe has a corresponding statement block. This statement block
    must be enclosed in <literal>{ }</literal> and contains the statements
    to be executed per event.
   </para>
   <example xml:id="ex.tuning.stap.simple">
    <title>Simple &stap; Script</title>
    <para>
     The following example shows a simple &stap; script.
    </para>
<screen>probe<co xml:id="co.tuning.stap.probe"/> begin<co xml:id="co.tuning.stap.event.begin"/>
{<co xml:id="co.tuning.stap.handler.start"/>
   printf<co xml:id="co.tuning.stap.handler.function.printf"/> ("hello world\n")<co xml:id="co.tuning.stap.handler.string"/>
   exit ()<co xml:id="co.tuning.stap.handler.function.exit"/>
}<co xml:id="co.tuning.stap.handler.end"/></screen>
    <calloutlist>
     <callout arearefs="co.tuning.stap.probe">
      <para>
       Start of the probe.
      </para>
     </callout>
     <callout arearefs="co.tuning.stap.event.begin">
      <para>
       Event <literal>begin</literal> (the start of the &stap; session).
      </para>
     </callout>
     <callout arearefs="co.tuning.stap.handler.start">
      <para>
       Start of the handler definition, indicated by <literal>{</literal>.
      </para>
     </callout>
     <callout arearefs="co.tuning.stap.handler.function.printf">
      <para>
       First function defined in the handler: the <literal>printf</literal>
       function.
      </para>
     </callout>
     <callout arearefs="co.tuning.stap.handler.string">
      <para>
       String to be printed by the <literal>printf</literal> function,
       followed by a line break (<literal>/n</literal>).
      </para>
     </callout>
     <callout arearefs="co.tuning.stap.handler.function.exit">
      <para>
       Second function defined in the handler: the <literal>exit()</literal>
       function. Note that the &stap; script will continue to run until
       the <literal>exit()</literal> function executes. If you want to stop
       the execution of the script before, stop it manually by pressing
       <keycombo> <keycap function="control"/> <keycap>C</keycap>
       </keycombo>.
      </para>
     </callout>
     <callout arearefs="co.tuning.stap.handler.end">
      <para>
       End of the handler definition, indicated by <literal>}</literal>.
      </para>
     </callout>
    </calloutlist>
    <para>
     The event <literal>begin</literal>
     <xref linkend="co.tuning.stap.event.begin" xrefstyle="select:label nopage"/>
     (the start of the &stap; session) triggers the handler enclosed in
     <literal>{ }</literal>. Here, that is the <literal>printf</literal>
     function
     <xref linkend="co.tuning.stap.handler.function.printf" xrefstyle="select:label nopage"/>.
     In this case, it prints <literal>hello world</literal> followed by a
     new line
     <xref linkend="co.tuning.stap.handler.string" xrefstyle="select:label nopage"/>.
     Then, the script exits.
    </para>
   </example>
   <para>
    If your statement block holds several statements, &stap; executes
    these statements in sequence&mdash;you do not need to insert special
    separators or terminators between multiple statements. A statement block
    can also be nested within another statement blocks. Generally, statement
    blocks in &stap; scripts use the same syntax and semantics as in the
    C programming language.
   </para>
  </sect2>

  <sect2 xml:id="sec.tuning.systemtap.syntax.events">
   <title>&stap; Events (Probe Points)</title>
   <para>
    &stap; supports several built-in events.
   </para>
   <para>
    The general event syntax is a dotted-symbol sequence. This allows a
    breakdown of the event namespace into parts. Each component identifier
    may be parameterized by a string or number literal, with a syntax like a
    function call. A component may include a <literal>*</literal> character,
    to expand to other matching probe points. A probe point may be followed
    by a <literal>?</literal> character, to indicate that it is optional,
    and that no error should result if it fails to expand.
    <remark>tonyj 2010-05-8: Maybe an example? There are lots of them in
     syscalls.stp tapset (/usr/share/ systemptap/tapset/syscalls.stp). - taroth
     2010-05-10: for next revision, no time left now</remark>
    Alternately, a probe point may be followed by a <literal>!</literal>
    character to indicate that it is both optional and sufficient.
   </para>
   <para>
    &stap; supports multiple events per probe&mdash;they need to be
    separated by a comma (<literal>,</literal>). If multiple events are
    specified in a single probe, &stap; will execute the handler when any
    of the specified events occur.
   </para>
   <para>
    In general, events can be classified into the following categories:
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>
      Synchronous events: Occur when any process executes an instruction at
      a particular location in kernel code. This gives other events a
      reference point (instruction address) from which more contextual data
      may be available.
     </para>
     <para>
      An example for a synchronous event is
      <literal>vfs.<replaceable>FILE_OPERATION</replaceable></literal>: The
      entry to the <replaceable>FILE_OPERATION</replaceable> event for
      Virtual File System (VFS). For example, in
      <xref linkend="sec.tuning.systemtap.setup"/>, <literal>read</literal>
      is the <replaceable>FILE_OPERATION</replaceable> event used for VFS.
<!--taroth 2011-10-17: sysemtap 1.5, original linkend-->
<!-- <xref  linkend="sec.tuning.systemtap.setup.classic"/>-->
<!--If you also
      want to monitor the exit of the <replaceable>FILE_OPERATION</replaceable>
      operation, append a <literal>.return</literal> to the event (for example,
       <literal>vfs.read.return</literal>).-->
     </para>
    </listitem>
    <listitem>
     <para>
      Asynchronous events: Not tied to a particular instruction or location
      in code. This family of probe points consists mainly of counters,
      timers, and similar constructs.
     </para>
     <para>
      Examples for asynchronous events are: <literal>begin</literal> (start
      of a &stap; session&mdash;when a &stap; script is run,
      <literal>end</literal> (end of a &stap; session), or timer events.
      Timer events specify a handler to be executed periodically, like
      <literal>example
      timer.s(<replaceable>SECONDS</replaceable>)</literal>, or
      <literal>timer.ms(<replaceable>MILLISECONDS</replaceable>)</literal>.
     </para>
     <para>
      When used together with other probes that collect information,
      timer events allow you to print periodic updates and see how that
      information changes over time.
     </para>
    </listitem>
   </itemizedlist>
   <example xml:id="ex.tuning.stap.async">
    <title>Probe with Timer Event</title>
    <para>
     For example, the following probe would print the text <quote>hello
     world</quote> every 4 seconds:
    </para>
<screen>probe timer.s(4)
{
   printf("hello world\n")
}</screen>
   </example>
   <para>
    For detailed information about supported events, refer to the
    <command>stapprobes</command> man page. The <citetitle>See
    Also</citetitle> section of the man page also contains links to other
    man pages that discuss supported events for specific subsystems and
    components.
   </para>
  </sect2>

  <sect2 xml:id="sec.tuning.systemtap.syntax.handlers">
   <title>&stap; Handlers (Probe Body)</title>
   <para>
    Each &stap; event is accompanied by a corresponding handler defined
    for that event, consisting of a statement block.
   </para>
   <sect3 xml:id="sec.tuning.systemtap.syntax.handlers.functions">
    <title>Functions</title>
    <para>
     If you need the same set of statements in multiple probes, you can
     place them in a function for easy reuse. Functions are defined by the
     keyword <literal>function</literal> followed by a name. They take any
     number of string or numeric arguments (by value) and may return a
     single string or number.
    </para>
<screen>function <replaceable>FUNCTION_NAME</replaceable>(<replaceable>ARGUMENTS</replaceable>) {<replaceable>STATEMENTS</replaceable>}
probe <replaceable>EVENT</replaceable> {<replaceable>FUNCTION_NAME</replaceable>(<replaceable>ARGUMENTS</replaceable>)}</screen>
    <para>
     The statements in <replaceable>FUNCTION_NAME</replaceable> are executed
     when the probe for <replaceable>EVENT</replaceable> executes. The
     <replaceable>ARGUMENTS</replaceable> are optional values passed into
     the function.
    </para>
    <para>
     Functions can be defined anywhere in the script. They may take any
    </para>
    <para>
     One of the functions needed very often was already introduced in
     <xref linkend="ex.tuning.stap.simple"/>: the <literal>printf</literal>
     function for printing data in a formatted way. When using the
     <literal>printf</literal> function, you can specify how arguments
     should be printed by using a format string. The format string is
     included in quotation marks and can contain further format specifiers,
     introduced by a <literal>%</literal> character.
    </para>
    <para>
     Which format strings to use depends on your list of arguments. Format
     strings can have multiple format specifiers&mdash;each matching a
     corresponding argument. Multiple arguments can be separated by a comma.
    </para>
    <example xml:id="ex.tuning.stap.printf.formatspec">
     <title><literal>printf</literal> Function with Format Specifiers</title>
<screen>printf ("<co xml:id="co.tuning.stap.formatstring.start"/>%s<co xml:id="co.tuning.stap.string.spec"/>(%d<co xml:id="co.tuning.stap.int.spec"/>) open\n<co xml:id="co.tuning.stap.formatstring.end"/>", execname(), pid())</screen>
     <calloutlist>
      <callout arearefs="co.tuning.stap.formatstring.start">
       <para>
        Start of the format string, indicated by <literal>"</literal>.
       </para>
      </callout>
      <callout arearefs="co.tuning.stap.string.spec">
       <para>
        String format specifier.
       </para>
      </callout>
      <callout arearefs="co.tuning.stap.int.spec">
       <para>
        Integer format specifier.
       </para>
      </callout>
      <callout arearefs="co.tuning.stap.formatstring.end">
       <para>
        End of the format string, indicated by <literal>"</literal>.
       </para>
      </callout>
     </calloutlist>
    </example>
    <para>
     The example above prints the current executable name
     (<literal>execname()</literal>) as a string and the process ID
     (<literal>pid()</literal>) as an integer in brackets. Then, a space,
     the word <literal>open</literal> and a line break follow:
    </para>
<screen>[...]
vmware-guestd(2206) open
hald(2360) open
[...]
   </screen>
    <para>
     Apart from the two functions <literal>execname()</literal>and
     <literal>pid()</literal>) used in
     <xref linkend="ex.tuning.stap.printf.formatspec"/>, a variety of other
     functions can be used as <literal>printf</literal> arguments.
    </para>
    <para>
     Among the most commonly used &stap; functions are the following:
    </para>
    <variablelist>
     <varlistentry>
      <term>tid()</term>
      <listitem>
       <para>
        ID of the current thread.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>pid()</term>
      <listitem>
       <para>
        Process ID of the current thread.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>uid()</term>
      <listitem>
       <para>
        ID of the current user.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>cpu()</term>
      <listitem>
       <para>
        Current CPU number.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>execname()</term>
      <listitem>
       <para>
        Name of the current process.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>gettimeofday_s()</term>
      <listitem>
       <para>
        Number of seconds since Unix epoch (January 1, 1970).
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>ctime()</term>
      <listitem>
       <para>
        Convert time into a string.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>pp()</term>
      <listitem>
       <para>
        String describing the probe point currently being handled.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>thread_indent()</term>
      <listitem>
       <para>
        Useful function for organizing print results. It (internally) stores
        an indentation counter for each thread (<literal>tid()</literal>).
        The function takes one argument, an indentation delta, indicating
        how many spaces to add or remove from the thread's indentation
        counter. It returns a string with some generic trace data along with
        an appropriate number of indentation spaces. The generic data
        returned includes a time stamp (number of microseconds since the
        initial indentation for the thread), a process name, and the thread
        ID itself. This allows you to identify what functions were called,
        who called them, and how long they took.
       </para>
       <para>
        Call entries and exits often do not immediately precede each other
        (otherwise it would be easy to match them). In between a first call
        entry and its exit, usually other call entries and exits
        are made. The indentation counter helps you match an entry with its
        corresponding exit as it indents the next function call in case it
        is <emphasis>not</emphasis> the exit of the previous one. For an
        example &stap; script using <literal>thread_indent()</literal>
        and the respective output, refer to the <citetitle>&stap;
        Tutorial</citetitle>:
        <link xlink:href="http://sourceware.org/systemtap/tutorial/Tracing.html#fig:socket-trace"/>.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     For more information about supported &stap; functions, refer to the
     <command>stapfuncs</command> man page.
    </para>
   </sect3>
   <sect3 xml:id="sec.tuning.systemtap.syntax.handlers.others">
    <title>Other Basic Constructs</title>
    <para>
     Apart from functions, you can use other common constructs in
     &stap; handlers, including variables, conditional statements (like
     <literal>if</literal>/<literal>else</literal>, <literal>while</literal>
     loops, <literal>for</literal> loops, arrays or command line arguments.
    </para>
    <sect4 xml:id="sec.tuning.systemtap.syntax.handlers.others.variables">
     <title>Variables</title>
     <para>
      Variables may be defined anywhere in the script. To define one, simply
      choose a name and assign a value from a function or expression to it:
     </para>
<screen>foo = gettimeofday( )</screen>
     <para>
      Then you can use the variable in an expression. From the type of
      values assigned to the variable, &stap; automatically infers the
      type of each identifier (string or number). Any inconsistencies will
      be reported as errors. In the example above, <literal>foo</literal>
      would automatically be classified as a number and could be printed via
      <literal>printf()</literal> with the integer format specifier
      (<literal>%d</literal>).
     </para>
     <para>
      However, by default, variables are local to the probe they are used
      in: They are initialized, used and disposed of at each handler
      evocation. To share variables between probes, declare them global
      anywhere in the script. To do so, use the <literal>global</literal>
      keyword outside of the probes:
     </para>
     <example>
      <title>Using Global Variables</title>
<screen>global count_jiffies, count_ms
probe timer.jiffies(100) { count_jiffies ++ }
probe timer.ms(100) { count_ms ++ }
probe timer.ms(12345)
{
  hz=(1000*count_jiffies) / count_ms
  printf ("jiffies:ms ratio %d:%d =&gt; CONFIG_HZ=%d\n",
    count_jiffies, count_ms, hz)
  exit ()
  }</screen>
      <para>
       This example script computes the CONFIG_HZ setting of the kernel by
       using timers that count jiffies and milliseconds, then computing
       accordingly. (A jiffy is the duration of one tick of the system timer
       interrupt. It is not an absolute time interval unit, since its
       duration depends on the clock interrupt frequency of the particular
       hardware platform). With the <literal>global</literal> statement it
       is possible to use the variables <literal>count_jiffies</literal> and
       <literal>count_ms</literal> also in the probe
       <literal>timer.ms(12345)</literal>. With <literal>++</literal> the
       value of a variable is incremented by <literal>1</literal>.
      </para>
     </example>
    </sect4>
    <sect4 xml:id="sec.tuning.systemtap.syntax.handlers.others.conditional">
     <title>Conditional Statements</title>
     <para>
      There are several conditional statements that you can use in
      &stap; scripts. The following are probably the most common:
     </para>
     <variablelist>
      <varlistentry>
       <term>If/Else Statements</term>
       <listitem>
        <para>
         They are expressed in the following format:
        </para>
<screen>if (<replaceable>CONDITION</replaceable>)<co xml:id="co.tuning.systemtap.cond.if"/><replaceable>STATEMENT1</replaceable><co xml:id="co.tuning.systemtap.cond.if.statement1"/>
else<co xml:id="co.tuning.systemtap.cond.else"/><replaceable>STATEMENT2</replaceable><co xml:id="co.tuning.systemtap.cond.if.statement2"/></screen>
        <para>
         The <literal>if</literal> statement compares an integer-valued
         expression to zero. If the condition expression
         <xref linkend="co.tuning.systemtap.cond.if" xrefstyle="select:label nopage"/>
         is non-zero, the first statement
         <xref linkend="co.tuning.systemtap.cond.if.statement1" xrefstyle="select:label nopage"/>
         is executed. If the condition expression is zero, the second
         statement
         <xref linkend="co.tuning.systemtap.cond.if.statement2" xrefstyle="select:label nopage"/>
         is executed. The else clause
         (<xref linkend="co.tuning.systemtap.cond.else" xrefstyle="select:label nopage"/>
         and
         <xref linkend="co.tuning.systemtap.cond.if.statement2" xrefstyle="select:label nopage"/>)
         is optional. Both
         <xref linkend="co.tuning.systemtap.cond.if.statement1" xrefstyle="select:label nopage"/>
         and
         <xref linkend="co.tuning.systemtap.cond.if.statement2" xrefstyle="select:label nopage"/>
         can also be statement blocks.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>While Loops</term>
       <listitem>
        <para>
         They are expressed in the following format:
        </para>
<screen>while (<replaceable>CONDITION</replaceable>)<co xml:id="co.tuning.systemtap.cond.while"/><replaceable>STATEMENT</replaceable><co xml:id="co.tuning.systemtap.cond.while.statement"/></screen>
        <para>
         As long as <literal>condition</literal> is non-zero, the statement
         <xref linkend="co.tuning.systemtap.cond.while.statement" xrefstyle="select:label nopage"/>
         is executed.
         <xref linkend="co.tuning.systemtap.cond.while.statement" xrefstyle="select:label nopage"/>
         can also be a statement block. It must change a value so
         <literal>condition</literal> will eventually be zero.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>For Loops</term>
       <listitem>
        <para>
         They are a shortcut for <literal>while</literal> loops and are
         expressed in the following format:
        </para>
<screen>for (<replaceable>INITIALIZATION</replaceable><co xml:id="co.tuning.systemtap.cond.for.init"/>; <replaceable>CONDITIONAL</replaceable><co xml:id="co.tuning.systemtap.cond.for.cond"/>; <replaceable>INCREMENT</replaceable><co xml:id="co.tuning.systemtap.cond.for.increment"/>) statement</screen>
        <para>
         The expression specified in
         <xref linkend="co.tuning.systemtap.cond.for.init" xrefstyle="select:label nopage"/>
         is used to initialize a counter for the number of loop iterations
         and is executed before execution of the loop starts. The execution
         of the loop continues until the loop condition
         <xref linkend="co.tuning.systemtap.cond.for.cond" xrefstyle="select:label nopage"/>
         is false. (This expression is checked at the beginning of each loop
         iteration). The expression specified in
         <xref linkend="co.tuning.systemtap.cond.for.increment" xrefstyle="select:label nopage"/>
         is used to increment the loop counter. It is executed at the end of
         each loop iteration.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Conditional Operators</term>
       <listitem>
        <para>
         The following operators can be used in conditional statements:
        </para>
        <formalpara>
         <title>==:</title>
         <para>
          Is equal to
         </para>
        </formalpara>
        <formalpara>
         <title>!=:</title>
         <para>
          Is not equal to
         </para>
        </formalpara>
        <formalpara>
         <title>&gt;=:</title>
         <para>
          Is greater than or equal to
         </para>
        </formalpara>
        <formalpara>
         <title>&lt;=:</title>
         <para>
          Is less than or equal to
         </para>
        </formalpara>
       </listitem>
      </varlistentry>
     </variablelist>
    </sect4>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.tuning.systemtap.example">
  <title>Example Script</title>

  <para>
   If you have installed the
   <systemitem class="resource">systemtap-docs</systemitem> package, you can
   find several useful &stap; example scripts in
   <filename>/usr/share/doc/packages/systemtap/examples</filename>.
  </para>

  <para>
   This section describes a rather simple example script in more detail:
   <filename>/usr/share/doc/packages/systemtap/examples/network/tcp_connections.stp</filename>.
  </para>

  <example>
   <title>Monitoring Incoming TCP Connections with <literal>tcp_connections.stp</literal></title>
<screen>#! /usr/bin/env stap

probe begin {
  printf("%6s %16s %6s %6s %16s\n",
         "UID", "CMD", "PID", "PORT", "IP_SOURCE")
}

probe kernel.function("tcp_accept").return?,
      kernel.function("inet_csk_accept").return? {
  sock = $return
  if (sock != 0)
    printf("%6d %16s %6d %6d %16s\n", uid(), execname(), pid(),
           inet_get_local_port(sock), inet_get_ip_source(sock))
}</screen>
  </example>

  <para>
   This &stap; script monitors the incoming TCP connections and helps to
   identify unauthorized or unwanted network access requests in real time.
   It shows the following information for each new incoming TCP connection
   accepted by the computer:
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     User ID (<literal>UID</literal>)
    </para>
   </listitem>
   <listitem>
    <para>
     Command accepting the connection (<literal>CMD</literal>)
    </para>
   </listitem>
   <listitem>
    <para>
     Process ID of the command (<literal>PID</literal>)
    </para>
   </listitem>
   <listitem>
    <para>
     Port used by the connection (<literal>PORT</literal>)
    </para>
   </listitem>
   <listitem>
    <para>
     IP address from which the TCP connection originated
     (<literal>IP_SOUCE</literal>)
    </para>
   </listitem>
  </itemizedlist>

  <para>
   To run the script, execute
  </para>

<screen>stap&nbsp;/usr/share/doc/packages/systemtap/examples/network/tcp_connections.stp</screen>

  <para>
   and follow the output on the screen. To manually stop the script, press
   <keycombo> <keycap function="control"/> <keycap>C</keycap> </keycombo>.
  </para>
 </sect1>
<!--taroth 2013-11-22: http://doccomments.provo.novell.com/admin/viewcomment/14466-->
 <sect1 xml:id="sec.tuning.systemtap.userspace">
  <title>User Space Probing</title>

  <para>
   <remark>taroth 2013-12-05: this will need adjustment for SLE 12 where user-space probes
   will use uprobes/uretprobes instead (which are in mainline) - according to tonyj everything
   except itrace is supposed to work</remark>
   For debugging user space applications (like DTrace can do),
   &productname; &productnumber; supports user space probing with
   &stap;: Custom probe points can be inserted in any user space
   application. Thus, &stap; lets you use both kernel space and user space
   probes to debug the behavior of the whole system.
  </para>

  <para>
   To get the required utrace infrastructure and the uprobes kernel module
   for user space probing, you need to install the
   <systemitem class="resource">kernel-trace</systemitem> package in
   addition to the packages listed in
   <xref linkend="sec.tuning.systemtap.setup"/>.
  </para>

  <para>
   <command>utrace</command> implements a framework for controlling
   user space tasks. It provides an interface that can be used by various
   tracing <quote>engines</quote>, implemented as loadable kernel modules.
   The engines register callback functions for specific events, then attach
   to whichever thread they want to trace. As the callbacks are made from
   <quote>safe</quote> places in the kernel, this allows for great leeway in
   the kinds of processing the functions can do. Various events can be
   watched via utrace, for example, system call entry and exit, fork(),
   signals being sent to the task, etc. More details about the utrace
   infrastructure are available at
   <link xlink:href="http://sourceware.org/systemtap/wiki/utrace"/>.
  </para>

  <para>
   &stap; includes support for probing the entry into and return from a
   function in user space processes, probing predefined markers in
   user space code, and monitoring user-process events.
  </para>

  <para>
   To check if the currently running kernel provides the needed utrace
   support, use the following command:
  </para>

<screen>&prompt.sudo;grep CONFIG_UTRACE /boot/config-`uname -r`</screen>

  <para>
   For more details about user space probing, refer to
   <link xlink:href="https://sourceware.org/systemtap/SystemTap_Beginners_Guide/userspace-probing.html"/>.
  </para>
 </sect1>
 <sect1 xml:id="sec.tuning.systemtap.more">
  <title>For More Information</title>

  <para>
   This chapter only provides a short &stap; overview. Refer to the
   following links for more information about &stap;:
  </para>

  <variablelist>
   <varlistentry>
    <term><link xlink:href="http://sourceware.org/systemtap/"/>
    </term>
    <listitem>
     <para>
      &stap; project home page.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><link xlink:href="http://sourceware.org/systemtap/wiki/"/>
    </term>
    <listitem>
     <para>
      Huge collection of useful information about &stap;, ranging from
      detailed user and developer documentation to reviews and comparisons
      with other tools, or Frequently Asked Questions and tips. Also
      contains collections of &stap; scripts, examples and usage stories
      and lists recent talks and papers about &stap;.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><link xlink:href="http://sourceware.org/systemtap/documentation.html"/>
    </term>
    <listitem>
     <para>
      Features a <citetitle>&stap; Tutorial</citetitle>, a
      <citetitle>&stap; Beginner's Guide</citetitle>, a <citetitle>Tapset
      Developer's Guide</citetitle>, and a <citetitle>&stap; Language
      Reference</citetitle> in PDF and HTML format. Also lists the relevant
      man pages.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   You can also find the &stap; language reference and &stap; tutorial
   in your installed system under
   <filename>/usr/share/doc/packages/systemtap</filename>. Example &stap;
   scripts are available from the <filename>example</filename> subdirectory.
  </para>

<!--http://sourceware.org/systemtap/wiki/
    http://en.wikipedia.org/wiki/Systemtap
    http://sourceware.org/systemtap/
    http://sourceware.org/systemtap/documentation.html
    http://sourceware.org/systemtap/langref/-->
 </sect1>
</chapter>
