<?xml version="1.0" encoding="UTF-8"?>
<sect1 xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="security_ldap_replication.xml" version="5.0" xml:id="sec-security-ldap-replication">
 <info>
  <title>设置复制</title>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>
 <para>
  389 Directory Server 支持在多个服务器之间复制其数据库内容。根据复制类型，389 Directory Server 提供：
 </para>

 <itemizedlist>
  <listitem>
   <para>
    更好的性能和更短的响应时间
   </para>
  </listitem>
  <listitem>
   <para>
    容错和故障转移
   </para>
  </listitem>
  <listitem>
   <para>
    负载平衡
   </para>
  </listitem>
  <listitem>
   <para>
    高可用性
   </para>
  </listitem>
 </itemizedlist>

 <para>
   数据库是可复制的最小目录单位。您可以复制整个数据库，但无法复制数据库中的子树。一个数据库必须对应于一个后缀。无法复制分布在两个或更多个数据库之间的后缀。
 </para>
 <para>
   将数据发送到另一个复本的复本是提供者。从提供者接收数据的复本是使用者。复制始终由提供者发起，单个提供者可以向多个使用者发送数据。提供者通常是一个读写复本，而使用者是只读的，在进行多提供者复制的情况下除外。在多提供者复制中，提供者既是数据的提供者，也是相同数据的使用者。
 </para>

 <sect2 xml:id="sec-security-ldap-replication-async">
  <title>异步写入</title>
  <para>
   389 DS 管理复制的方式不同于其他数据库。复制是异步的，但最终会保持一致。也就是说：
  </para>
  <itemizedlist>
   <listitem>
    <para>
     会立即接受对单个服务器的任何写入或更改。
    </para>
   </listitem>
   <listitem>
    <para>
     在一台服务器上完成写入后，需要经过一定的延迟，写入内容才会复制到其他服务器并显示在其中。
    </para>
   </listitem>
   <listitem>
    <para>
     如果该写入操作与其他服务器上的写入操作冲突，该写入操作在将来的某个时间点可能回滚。
    </para>
   </listitem>
   <listitem>
    <para>
     由于存在复制延迟，并非所有服务器都可以同时显示相同的内容。
    </para>
   </listitem>
  </itemizedlist>
  <para>
   一般情况下，由于 LDAP 属于“小规模写入”，这些因素意味着所有服务器至少符合已知一致状态的公共基线。在此基线的基础上只会发生轻微的变化，因此延迟复制的上述许多特征在日常使用中不会被察觉到。
  </para>
 </sect2>

 <sect2 xml:id="sec-security-ldap-replication-topology">
  <title>设计拓扑</title>
  <para>
   在设计复制拓扑时请考虑以下因素。
  </para>
  <itemizedlist>
   <listitem>
    <para>
     复制需求：高可用性、地理位置、读取缩放或所有这些因素的组合。
    </para>
   </listitem>
   <listitem>
    <para>
     您打算在拓扑中使用多少个复本（节点、服务器）。
    </para>
   </listitem>
   <listitem>
    <para>
     数据流的方向，这包括拓扑内部的数据，以及流入拓扑的数据。
    </para>
   </listitem>
   <listitem>
    <para>
     客户端如何在拓扑节点之间根据其请求进行平衡（多个 LDAP URI、SRV 记录、负载平衡器）。
    </para>
   </listitem>
  </itemizedlist>
  <para>
   这些因素都会影响您创建拓扑的方式。（有关一些拓扑示例，请参见<xref linkend="sec-security-ldap-replication-topologies"/>。）
  </para>
 </sect2>

 <sect2 xml:id="sec-security-ldap-replication-topologies">
  <title>复制拓扑示例</title>
  <para>
   以下章节提供了使用两到六个 389 Directory Server 节点的复制拓扑示例。拓扑中支持的最大提供者复本数量为 20 个。操作经验表明，实现高效复制的最佳数量最多为 8 个。
  </para>

  <sect3 xml:id="sec-security-ldap-replication-two-replicas">
   <title>两个复本</title>
   <example xml:id="ex-ldap-replication-two-replicas">
    <title>两个提供者复本</title>
<screen>
┌────┐       ┌────┐
│ S1 │◀─────▶│ S2 │
└────┘       └────┘
</screen>
   </example>
   <para>
    <xref linkend="ex-ldap-replication-two-replicas"/>中有两个复本（S1 和 S2），它们在彼此之间双向复制，因此它们既是提供者也是使用者。S1 和 S2 可位于不同的数据中心，也可位于同一个数据中心。客户端可以使用 LDAP URI、负载平衡器或 DNS SRV 记录在服务器之间进行平衡。这是可实现高可用性的最简单拓扑。请注意，每个服务器需要能够提供 100% 的客户端负载，以防其他服务器出于任何原因脱机。双节点复制一般不足以实现横向读取缩放，因为如果另一个节点脱机，单个节点将处理所有读取请求。
   </para>
   <note>
     <title>默认拓扑</title>
     <para>
       应将双节点拓扑视为默认拓扑，因为它最容易管理。随着时间的推移，您可以根据需要扩展拓扑。
     </para>
   </note>
  </sect3>

  <sect3 xml:id="sec-security-ldap-replication-four-replicas">
   <title>四个提供者复本</title>
   <example xml:id="ex-ldap-replication-four-replicas">
    <title>四个提供者复本</title>
<screen>
┌────┐       ┌────┐
│ S1 │◀─────▶│ S2 │
└────┘       └────┘
   ▲            ▲
   │            │
   ▼            ▼
┌────┐       ┌────┐
│ S3 │◀─────▶│ S4 │
└────┘       └────┘
</screen>
   </example>
   <para>
    <xref linkend="ex-ldap-replication-four-replicas"/>中有四个相互同步的提供者复本。这些复本可以位于四个数据中心，或者每个数据中心包含两个服务器。在每个数据中心包含一个节点的情况下，每个节点应该能够支持 100% 的客户端负载。如果每个数据中心包含两个节点，每个节点只需缩放到 50% 的客户端负载。
   </para>
  </sect3>

  <sect3 xml:id="sec-security-ldap-replication-six-replicas">
   <title>六个复本</title>
   <example xml:id="ex-ldap-replication-six-replicas">
    <title>六个复本</title>
<screen>
                  ┌────┐       ┌────┐
                  │ S1 │◀─────▶│ S2 │
                  └────┘       └────┘
                     ▲            ▲
                     │            │
   ┌────────────┬────┴────────────┴─────┬────────────┐
   │            │                       │            │
   ▼            ▼                       ▼            ▼
┌────┐       ┌────┐                  ┌────┐       ┌────┐
│ S3 │◀─────▶│ S4 │                  │ S5 │◀─────▶│ S6 │
└────┘       └────┘                  └────┘       └────┘
</screen>
   </example>
   <para>
    在<xref linkend="ex-ldap-replication-six-replicas"/>中，每个对位于不同的位置。S1 和 S2 是提供者，S3、S4、S5 和 S6 是 S1 和 S2 的使用者。每一对服务器相互复制。S3、S4、S5 和 S6 可接受写入，不过，大部分复制工作是通过 S1 和 S2 完成的。此设置提供地理隔离来实现高可用性和缩放。
   </para>
  </sect3>

  <sect3 xml:id="sec-security-ldap-replication-six-replicas-read-only">
   <title>具有只读使用者的六个复本</title>
   <example xml:id="ex-ldap-replication-six-replicas-read-only">
    <title>具有只读使用者的六个复本</title>
<screen>
             ┌────┐       ┌────┐
             │ S1 │◀─────▶│ S2 │
             └────┘       └────┘
                │            │
                │            │
   ┌────────────┼────────────┼────────────┐
   │            │            │            │
   ▼            ▼            ▼            ▼
┌────┐       ┌────┐       ┌────┐       ┌────┐
│ S3 │       │ S4 │       │ S5 │       │ S6 │
└────┘       └────┘       └────┘       └────┘
</screen>
   </example>
   <para>
    在<xref linkend="ex-ldap-replication-six-replicas-read-only"/>中，S1 和 S2 是提供者，其他四个服务器是只读使用者。所有更改在 S1 和 S2 上发生，并传播到四个复本。只读使用者可以配置为仅储存数据库的子集或部分项，以限制数据透露。例如，您可以在 DMZ 中部署一个不完整的只读服务器，这样，如果数据透露，更改就无法传播回其他复本。
   </para>
  </sect3>
 </sect2>

 <sect2 xml:id="sec-security-ldap-replication-terminology">
  <title>术语</title>
  <para>
   在示例拓扑中可以看到，389 DS 可以在拓扑中充当多个角色。以下列表阐明了术语。
  </para>
  <variablelist>
   <varlistentry>
    <term>复本</term>
    <listitem>
     <para>
      包含附加数据库的 389 DS 实例。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>读写复本</term>
    <listitem>
     <para>
      包含数据库完整复本的复本，接受读取和写入操作。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>只读复本</term>
    <listitem>
     <para>
      包含数据库完整复本的复本，仅接受读取操作。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>不完整的只读复本</term>
    <listitem>
     <para>
      包含数据库部分复本的复本，仅接受只读操作。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>提供者</term>
    <listitem>
     <para>
      将其数据库中的数据提供给另一个复本的复本。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>使用者</term>
    <listitem>
     <para>
      从另一个复本接收数据以写入自身数据库的复本。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>复制协议</term>
    <listitem>
     <para>
      用于定义其提供者和使用者与另一个复本的关系的服务器配置。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>拓朴</term>
    <listitem>
     <para>
      通过复制协议连接的一组复本。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>复本 ID</term>
    <listitem>
     <para>
      389 Directory Server 实例在复制拓扑中的唯一标识符。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>复制管理者</term>
    <listitem>
     <para>
      在目录中拥有复制权限的帐户。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2 xml:id="sec-security-ldap-replication-configuration">
  <title>配置复制</title>
  <para>
   第一个示例使用单个只读服务器设置双节点双向复制，这是一个极简的起点示例。在以下示例中，两个读写节点的主机名分别为 RW1 和 RW2，只读服务器为 RO1。（当然，您必须使用自己的主机名。）
   </para>
  <para>
   所有服务器应有一个后缀相同的后端。只有一个服务器 (RW1) 需要数据库的初始副本。
  </para>

 <sect3 xml:id="sec-security-ldap-replication-two-nodes">
   <title>配置双节点复制</title>
  <para>
    以下命令使用主机名 RW1 和 RW2 在双节点设置 (<xref linkend="ex-ldap-replication-two-replicas"/>) 中配置读写复本。（请记得使用您自己的主机名。）
  </para>

  <warning>
  <title>创建强复制管理者口令</title>
  <para>
    在安全性和访问权限方面，应以等同于目录管理者的方式来对待复制管理者，应为其创建极强的口令。
  </para>
  <para>
    如果您为每个服务器创建不同的复制管理者口令，请务必跟踪哪个口令属于哪个服务器。例如，在 RW1 的复制协议中配置出站连接时，需要将复制管理者口令设置为 RW2 复制管理者口令。
  </para>
</warning>

<para>
首先配置 RW1：
</para>

<screen><prompt>&gt; </prompt><command>sudo</command> <command>dsconf <replaceable>INSTANCE-NAME</replaceable> replication create-manager</command>
<prompt>&gt; </prompt><command>sudo</command> <command>dsconf <replaceable>INSTANCE-NAME</replaceable> replication enable</command> \
<command>--suffix <replaceable>dc=example,dc=com</replaceable></command> \
<command>--role supplier --replica-id <replaceable>1</replaceable> --bind-dn "cn=replication manager,cn=config"</command>
</screen>
  <para>
   配置 RW2：
  </para>
<screen><prompt>&gt; </prompt><command>sudo</command> <command>dsconf <replaceable>INSTANCE-NAME</replaceable> replication create-manager</command>
<prompt>&gt; </prompt><command>sudo</command> <command>dsconf <replaceable>INSTANCE-NAME</replaceable> replication enable</command> \
<command>--suffix <replaceable>dc=example,dc=com</replaceable></command> \
<command>--role supplier --replica-id <replaceable>2</replaceable> --bind-dn "cn=replication manager,cn=config"</command>
</screen>
  <para>
   这会创建 RW1 和 RW2 中所需的复制元数据。请注意两个服务器的<option>复本 ID</option> 的差异。这还会创建复制管理者帐户，该帐户拥有复制权限，可以在两个节点之间进行身份验证。
  </para>
  <para>
   RW1 和 RW2 现在都已配置为包含复制元数据。下一步是为从 RW1 流向 RW2 的出站数据创建第一个协议。
  </para>
<screen>
<prompt>&gt; </prompt><command>sudo</command> <command>dsconf <replaceable>INSTANCE-NAME</replaceable> repl-agmt create</command> \
<command>--suffix <replaceable>dc=example,dc=com</replaceable></command> \
<command>--host=<replaceable>RW2</replaceable> --port=636 --conn-protocol LDAPS --bind-dn "cn=replication manager,cn=config"</command> \
<command>--bind-passwd <replaceable>PASSWORD</replaceable> --bind-method SIMPLE <replaceable>RW1_to_RW2</replaceable></command>
</screen>
  <para>
   只有在完全同步数据库之后，数据才会从 RW1 流向 RW2，这称为初始化或重新初始化。这会重置 RW2 上的所有数据库内容，以便与 RW1 的内容匹配。运行以下命令来触发数据重新初始化：
  </para>
<screen>
<prompt>&gt; </prompt><command>sudo</command> <command>dsconf <replaceable>INSTANCE-NAME</replaceable> repl-agmt init</command> \
<command>--suffix <replaceable>dc=example,dc=com</replaceable> <replaceable>RW1_to_RW2</replaceable></command>
</screen>
  <para>
   在 RW1 上运行以下命令来检查状态：
  </para>
<screen>
<prompt>&gt; </prompt><command>sudo</command> <command>dsconf <replaceable>INSTANCE-NAME</replaceable> repl-agmt init-status</command> \
<command>--suffix <replaceable>dc=example,dc=com</replaceable> <replaceable>RW1_to_RW2</replaceable></command>
</screen>
  <para>
   完成后，您应会看到“协议已成功初始化”消息。如果收到错误消息，请检查错误日志。否则，应会在 RW2 上看到与 RW1 中相同的内容。
  </para>
  <para>
   最后，为了将这种复制设置为双向复制，请配置一个从 RW2 出站复制到 RW1 的复制协议：
  </para>
<screen>
<prompt>&gt; </prompt><command>sudo</command> <command>dsconf <replaceable>INSTANCE-NAME</replaceable> repl-agmt create</command> \
<command>--suffix <replaceable>dc=example,dc=com</replaceable></command> \
<command>--host=<replaceable>RW1</replaceable> --port=636 --conn-protocol LDAPS</command> \
<command>--bind-dn "cn=replication manager,cn=config" --bind-passwd <replaceable>PASSWORD</replaceable></command> \
<command>--bind-method SIMPLE <replaceable>RW2_to_RW1</replaceable></command>
</screen>
  <para>
   现在，在 RW1 或 RW2 上做出的更改将复制到另一个节点。使用以下命令检查任一服务器上的复制状态：
  </para>
<screen>
<prompt>&gt; </prompt><command>sudo</command> <command>dsconf <replaceable>INSTANCE-NAME</replaceable> repl-agmt status</command> \
<command>--suffix <replaceable>dc=example,dc=com</replaceable></command> \
<command>--bind-dn "cn=replication manager,cn=config"</command> \
<command>--bind-passwd <replaceable>PASSWORD</replaceable> <replaceable>RW2_to_RW1</replaceable></command>
</screen>
</sect3>

 <sect3 xml:id="sec-security-ldap-replication-four-nodes">
 <title>配置只读节点</title>
 <para>
   要创建只读节点，首先请创建复制管理者帐户和元数据。示例服务器的主机名为 RO3：
 </para>

  <warning>
  <title>创建强复制管理者口令</title>
  <para>
    在安全性和访问权限方面，应以等同于目录管理者的方式来对待复制管理者，应为其创建极强的口令。
  </para>
  <para>
    如果您为每个服务器创建不同的复制管理者口令，请务必跟踪哪个口令属于哪个服务器。例如，在 RW1 的复制协议中配置出站连接时，需要将复制管理者口令设置为 RW2 复制管理者口令。
  </para>
</warning>

 <screen><prompt>&gt; </prompt><command>sudo</command> <command>dsconf <replaceable>INSTANCE_NAME</replaceable> replication create-manager</command>
<prompt>&gt; </prompt><command>sudo</command> <command> dsconf <replaceable>INSTANCE_NAME</replaceable></command> \
<command>replication enable --suffix <replaceable>dc=EXAMPLE,dc=COM</replaceable></command> \
<command>--role consumer --bind-dn "cn=replication manager,cn=config"</command></screen>

<para>
  请注意，对于只读复本，请不要提供复本 ID，并将角色设置为<literal>使用者</literal>。这会为所有只读复本分配一个特殊的只读复本 ID。创建只读复本后，将 RW1 和 RW2 中的复制协议添加到只读实例。以下示例在 RW1 上运行：
 </para>
 <screen>
<prompt>&gt; </prompt><command>sudo</command> <command>dsconf <replaceable>INSTANCE_NAME</replaceable></command> \
<command>repl-agmt create --suffix <replaceable>dc=EXAMPLE,dc=COM</replaceable></command> \
<command>--host=<replaceable>RO3</replaceable> --port=636 --conn-protocol LDAPS</command> \
<command>--bind-dn "cn=replication manager,cn=config" --bind-passwd <replaceable>PASSWORD</replaceable></command>
<command>--bind-method SIMPLE <replaceable>RW1_to_RO3</replaceable></command></screen>
<para>
  以下示例在 RW2 上配置 RW2 与 RO3 之间的复制协议：
</para>
<screen>
<prompt>&gt; </prompt><command>sudo</command> <command>dsconf <replaceable>INSTANCE_NAME</replaceable> repl-agmt create</command> \
<command>--suffix <replaceable>dc=EXAMPLE,dc=COM</replaceable></command> \
<command>--host=<replaceable>RO3</replaceable> --port=636 --conn-protocol LDAPS</command> \
<command>--bind-dn "cn=replication manager,cn=config" --bind-passwd <replaceable>PASSWORD</replaceable></command> \
<command>--bind-method SIMPLE <replaceable>RW2_to_RO3</replaceable></command>
</screen>
<para>
  完成这些步骤后，可以使用 RW1 或 RW2 在 RO3 上执行数据库初始化。以下示例从 RW2 初始化 RO3：
</para>
<screen>
<prompt>&gt; </prompt><command>sudo</command> <command>dsconf <replaceable>INSTANCE_NAME</replaceable> repl-agmt init</command>
<command>--suffix dc=<replaceable>EXAMPLE,dc=COM</replaceable> <replaceable>RW2_to_RO3</replaceable></command>
</screen>
</sect3>
</sect2>

<sect2 xml:id="sec-security-ldap-replication-monitoring-healthcheck">
  <title>监视和状态检查</title>
<para>
  <command>dsconf</command> 命令包括一个监视选项。您可以直接在复本上或者从其他主机检查每个复本的状态。以下示例命令在 RW1 上运行，检查两个远程复本的状态，然后检查 RW1 自身的状态：
</para>
<screen>
<prompt>&gt; </prompt><command>sudo</command> <command>dsconf -D "cn=Directory Manager" ldap://<replaceable>RW2</replaceable> replication monitor</command>
<prompt>&gt; </prompt><command>sudo</command> <command>dsconf -D "cn=Directory Manager" ldap://<replaceable>RO3</replaceable> replication monitor</command>
<prompt>&gt; </prompt><command>sudo</command> <command>dsconf -D "cn=Directory Manager" ldap://<replaceable>RW1</replaceable> replication monitor</command>
</screen>

<para>
  <command>dsctl</command> 命令有一个 <option>healthcheck</option> 选项。以下示例在本地 389 DS 实例上运行复制状态检查：
</para>
<screen>
<prompt>&gt; </prompt><command>sudo</command> <command>dsctl <replaceable>INSTANCE_NAME</replaceable> healthcheck --check replication</command>
</screen>
<para>
  使用 <option>-v</option>（详细程度）选项查看状态检查所检查的内容：
</para>
<screen>
<prompt>&gt; </prompt><command>sudo</command> <command>dsctl -v <replaceable>INSTANCE_NAME</replaceable> healthcheck --check replication</command>
</screen>

<para>
  不结合任何选项运行 <command>dsctl <replaceable>INSTANCE_NAME</replaceable> healthcheck</command> 可进行一般性的状态检查。
</para>
<para>
  运行以下命令查看状态检查执行的检查列表：
</para>
<screen>
<prompt>&gt; </prompt><command>sudo</command> <command>dsctl <replaceable>INSTANCE_NAME</replaceable> healthcheck --list-checks</command>
config:hr_timestamp
config:passwordscheme
backends:userroot:cl_trimming
backends:userroot:mappingtree
backends:userroot:search
backends:userroot:virt_attrs
encryption:check_tls_version
fschecks:file_perms
[...]
</screen>
<para>
  可以运行一项或多项独立检查：
</para>
<screen>
<prompt>&gt; </prompt><command>sudo</command> <command>dsctl <replaceable>INSTANCE_NAME</replaceable> healthcheck</command> \
<command>--check monitor-disk-space:disk_space tls:certificate_expiration</command>
</screen>
</sect2>

  <sect2 xml:id="sec-security-ldap-replication-backups">
    <title>创建备份</title>
  <para>
   启用复制后，需要调整 389 Directory Server 备份策略（请参见<xref linkend="sec-security-ldap-backup"/>了解如何创建备份）。如果使用 <command>db2ldif</command>，则必须添加 <option>--replication</option> 标志，以确保备份复制元数据。应备份拓扑中的所有服务器。从备份恢复时，请先恢复拓扑的单个节点，然后将所有其他节点重新初始化为新实例。
 </para>
</sect2>

<sect2 xml:id="sec-security-ldap-replication-pause-resume">
  <title>暂停和继续复制</title>
  <para>
    可以在维护时段暂停复制，或者在所需的任何时间停止复制。拓扑的节点最多只能在不超过更改日志限制的最大天数内保持脱机（请参见<xref linkend="sec-security-ldap-replication-changelog"/>）。
  </para>
  <para>
    使用 <command>repl-agmt</command> 命令暂停复制。以下示例在 RW2 上运行：
  </para>
  <screen>
<prompt>&gt; </prompt><command>sudo</command> <command>dsconf <replaceable>INSTANCE_NAME</replaceable> repl-agmt disable</command> \
<command>--suffix <replaceable>dc=EXAMPLE,dc=COM</replaceable> <replaceable>RW2_to_RW1</replaceable></command>
</screen>
<para>
  以下示例重新启用复制：
</para>
  <screen>
<prompt>&gt; </prompt><command>sudo</command> <command>dsconf <replaceable>INSTANCE_NAME</replaceable> repl-agmt enable</command> \
<command>--suffix <replaceable>dc=EXAMPLE,dc=COM</replaceable> <replaceable>RW2_to_RW1</replaceable></command>
</screen>
</sect2>

<sect2 xml:id="sec-security-ldap-replication-changelog">
  <title> 更改日志 max-age</title>
  <para>
   复本可以在更改日志 <option>max-age</option> 选项定义的最大时长内保持脱机。<option>max-age</option> 定义更改日志中任何项的最长期限。系统会自动去除超过 <option>max-age</option> 值的任何项目。
 </para>
 <para>
   复本恢复联机后，将与其他复本同步。如果脱机时间超过 <option>max-age</option> 值，则复本需要重新初始化，并且会拒绝接受更改或拒绝向其他节点提供更改，因为这些更改可能不一致。以下示例将 <option>max-age</option> 设置为七天：
 </para>
 <screen>
<prompt>&gt; </prompt><command>sudo</command> <command>dsconf <replaceable>INSTANCE_NAME</replaceable></command> \
<command>replication set-changelog --max-age 7d</command> \
<command>--suffix <replaceable>dc=EXAMPLE,dc=COM</replaceable></command>
</screen>
</sect2>

<sect2 xml:id="sec-security-ldap-replication-remove-replica">
  <title>去除复本</title>
  <para>
   要去除复本，首先请屏蔽节点，以防止任何传入的更改或读取。然后，找到与要去除的节点建立了传入复制协议的所有服务器并将其去除。以下示例去除 RW2。首先禁用 RW1 上的出站复制协议：
 </para>
 <screen>
<prompt>&gt; </prompt><command>sudo</command> <command>dsconf <replaceable>INSTANCE_NAME</replaceable> repl-agmt delete</command> \
<command>--suffix <replaceable>dc=EXAMPLE,dc=COM</replaceable> <replaceable>RW1_to_RW2</replaceable></command>
</screen>
<para>
  在要去除的复本（在以下示例中为 RW2）上，去除所有出站协议：
</para>
<screen>
<prompt>&gt; </prompt><command>sudo</command> <command>dsconf <replaceable>INSTANCE_NAME</replaceable> repl-agmt delete</command> \
<command>--suffix <replaceable>dc=EXAMPLE,dc=COM</replaceable> <replaceable>RW2_to_RW1</replaceable></command>
<prompt>&gt; </prompt><command>sudo</command> <command>dsconf <replaceable>INSTANCE_NAME</replaceable> repl-agmt delete</command> \
<command>--suffix <replaceable>dc=EXAMPLE,dc=COM</replaceable> <replaceable>RW2_to_RO3</replaceable></command>
</screen>
<para>
  停止 RW2 上的实例：
</para>
<screen>
<prompt>&gt; </prompt><command>sudo</command> <command>systemctl stop dirsrv@<replaceable>INSTANCE_NAME</replaceable>.service</command>
</screen>
<para>
  然后运行 <command>cleanallruv</command> 命令以从拓扑中去除复本 ID。以下示例在 RW1 上运行：
</para>
<screen>
<prompt>&gt; </prompt><command>sudo</command> <command>dsconf <replaceable>INSTANCE_NAME</replaceable> repl-tasks cleanallruv</command> \
<command>--suffix <replaceable>dc=EXAMPLE,dc=COM</replaceable> --replica-id <replaceable>2</replaceable></command>
<prompt>&gt; </prompt><command>sudo</command> <command>dsconf <replaceable>INSTANCE_NAME</replaceable> repl-tasks list-cleanruv-tasks</command>
</screen>
 </sect2>
</sect1>
