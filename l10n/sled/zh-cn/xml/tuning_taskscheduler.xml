<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="tuning_taskscheduler.xml" version="5.0" xml:id="cha-tuning-taskscheduler">
 <title>微调任务调度程序</title>
 <info>
      <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
        <dm:bugtracker>
        </dm:bugtracker>
	<dm:translation>yes</dm:translation>
      </dm:docmanager>
    </info>
    <para>
  新式操作系统（例如 <phrase role="productname"><phrase os="sled">SUSE® Linux Enterprise Desktop</phrase></phrase>）往往会同时运行许多任务。例如，您可以在搜索文本文件的同时接收电子邮件以及将大型文件复制到外部硬盘。这些简单任务要求系统运行许多额外的进程。为了给每个任务提供所需的系统资源，Linux 内核需要使用一种工具向各个任务分发可用系统资源。这恰恰是<emphasis>任务调度程序</emphasis>的作用所在。
 </para>
 <para>
  下列章节解释了与进程调度相关的最重要术语。其中还介绍了有关任务调度程序策略和调度算法的信息，描述了 <phrase role="productname"><phrase os="sled">SUSE Linux Enterprise Desktop</phrase></phrase> 使用的任务调度程序，并提供了其他相关信息来源的参考。
 </para>
 <sect1 xml:id="sec-tuning-taskscheduler-intro">
  <title>简介</title>

  <para>
   Linux 内核用于控制在系统上管理任务（或进程）的方式。任务调度程序（有时称作<emphasis>进程调度程序</emphasis>）是决定下一次要运行哪个任务的内核组件。它负责以最佳方式使用系统资源，以保证能够同时执行多个任务。因此，它是任何多任务操作系统的核心组件。
  </para>

  <sect2 xml:id="sec-tuning-taskscheduler-intro-preemption">
   <title>抢占</title>
   <para>
    任务调度背后的理论非常简单。如果系统中存在多个可运行的进程，必须始终至少有一个进程正在运行。如果可运行进程的数目超过了系统中处理器的数目，则并非所有进程都能始终运行。
   </para>
   <para>
    因此，某些进程需要暂时停止（或<emphasis>挂起</emphasis>），使其他进程能够再次运行。由调度程序决定下一次运行队列中的哪个进程。
   </para>
   <para>
    如前所述，与其他所有 Unix 变体类似，Linux 也是<emphasis>多任务</emphasis>操作系统。即，多个任务可以同时运行。Linux 提供所谓的<emphasis>抢占式</emphasis>多任务，让调度程序决定何时挂起某个进程。这种强制挂起称为<emphasis>抢占</emphasis>。从一开始就为所有 Unix 风格提供了抢占式多任务。
   </para>
  </sect2>

  <sect2 xml:id="sec-tuning-taskscheduler-intro-timeslice">
   <title>时间片</title>
   <para>
    提前定义某个进程在被<emphasis>抢占</emphasis>之前的运行时长。此时长称为进程的<emphasis>时间片</emphasis>，表示提供给每个进程的处理器时间长短。通过指派时间片，调度程序可以针对运行中的系统做出全局决策，并防止单个进程占据处理器资源。
    <remark>sknorr, 2014-08-22: "dominate over" sounds weird, not sure if just
     "dominate" would be better, though.</remark>
   </para>
  </sect2>

  <sect2 xml:id="sec-tuning-taskscheduler-intro-priority">
   <title>进程优先级</title>
   <para>
    调度程序基于进程的优先级评估进程。任务调度程序使用复杂算法计算进程的当前优先级。最后会为每个进程指定一个值，根据该值<quote>允许</quote>进程在处理器上运行。
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-tuning-taskscheduler-policy-class">
  <title>进程分类</title>

  <para>
   通常根据进程的用途和行为对进程分类。尽管有时界线区分不够清晰，但一般会采用两条准则进行分类。这两条准则彼此独立，但并非互不包容。
  </para>

  <para>
   一种方法是将进程分类为 <emphasis>I/O 密集型</emphasis>或<emphasis>处理器密集型</emphasis>。
  </para>

  <variablelist>
   <varlistentry>
    <term>I/O 密集型</term>
    <listitem>
     <para>
      I/O 代表输入/输出设备，例如键盘、鼠标或者光盘和硬盘。<emphasis>I/O 密集型进程</emphasis>将大部分时间花费在提交和等待请求上。它们的运行频率极高，但时间间隔较短，不会阻塞等待 I/O 请求的其他进程。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>处理器密集型</term>
    <listitem>
     <para>
      相比之下，<emphasis>处理器密集型</emphasis>任务将时间用在执行代码上，通常会运行到被调度程序抢占为止。它们不会阻塞等待 I/O 请求的进程，因此其运行频率可以更低，但时间间隔更长。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   另一种方法是按类型将进程划分为<emphasis>交互式</emphasis>、<emphasis>批处理</emphasis>和<emphasis>实时</emphasis>进程。
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     <emphasis>交互式</emphasis>进程将大量时间花费在等待 I/O 请求（例如键盘或鼠标操作）上。调度程序必须按用户请求快速唤醒此类进程，否则用户会发现环境无响应。典型延迟大约为 100 毫秒。办公应用程序、文本编辑器或图像处理程序都是典型的交互式进程。
    </para>
   </listitem>
   <listitem>
    <para>
     <emphasis>批处理</emphasis>进程通常在后台运行，不需要做出响应。调度程序往往会为它们分配较低的优先级。多媒体转换器、数据库搜索引擎或日志文件分析器都是批处理进程的典型示例。
    </para>
   </listitem>
   <listitem>
    <para>
     <emphasis>实时</emphasis>进程永远不可被低优先级进程阻塞，调度程序需保证这些进程在很短时间获得响应。用于编辑多媒体内容的应用程序就是实时进程的典型示例。
    </para>
   </listitem>
  </itemizedlist>
 </sect1>

 <sect1 xml:id="sec-tuning-taskscheduler-cfs">
  <title>完全公平调度程序</title>

  <para>
   从 Linux 内核版本 2.6.23 开始，采用了一种新方法来调度可运行的进程。完全公平调度程序 (CFS) 成为了默认 Linux 内核调度程序。自此以后发生了重大变化和改进。本章中的信息适用于采用 2.6.32 和更高内核版本（包括 3.x 内核）的 <phrase role="productname"><phrase os="sled">SUSE Linux Enterprise Desktop</phrase></phrase>。调度程序环境分为多个部分，引入了三项主要新功能：
  </para>

  <variablelist>
   <varlistentry>
    <term>模块化调度程序核心</term>
    <listitem>
     <para>
      调度程序的核心已通过<emphasis>调度类</emphasis>得以增强。这些类是模块化的，代表调度策略。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>完全公平调度程序</term>
    <listitem>
     <para>
      在内核 2.6.23 中引入并在 2.6.24 中进行了扩展的 CFS 尝试确保每个进程获得其<quote>公平</quote>份额的处理器时间。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>组安排</term>
    <listitem>
     <para>
      例如，如果您根据运行进程的用户将进程分组，则 CFS 会尝试为其中每个组提供等量的处理器时间。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   因此，CFS 能够针对服务器和桌面优化调度。
  </para>

  <sect2 xml:id="sec-tuning-taskscheduler-cfs-howitworks">
   <title>CFS 的工作原理</title>
   <para>
    CFS 尝试为每个可运行的任务保证公平性。为了找出最平衡的任务调度方式，它使用了<emphasis>红黑树</emphasis>的概念。红黑树是一种自我平衡式数据搜索树，能够以合理方式提供插入项和去除项，使其自身保持适当的平衡。
   </para>
   <para>
    当 CFS 调度任务时，它会累加<quote>虚拟运行时</quote> (<emphasis>vruntime</emphasis>)。选择运行的下一个任务始终是迄今为止累加 vruntime 最小的那个任务。在将任务插入<emphasis>运行队列</emphasis>（下次要执行的进程的规划时间线）时通过平衡红黑树，可保证 vruntime 最小的任务始终是红黑树中的第一个项。
   </para>
   <para>
    任务的累计 vruntime 与该任务的优先级相关。高优先级任务的 vruntime 的累加速度比低优先级任务要慢，导致更频繁地选择在处理器上运行高优先级任务。
   </para>
  </sect2>

  <sect2 xml:id="sec-tuning-taskscheduler-cfs-grouping">
   <title>将进程分组</title>
   <para>
    从 Linux 内核版本 2.6.24 开始，可对 CFS 进行微调，以保证为组而不仅仅是任务提供公平性。为此，将可运行的任务分组以构成实体，而 CFS 会尝试为这些实体而不是各个可运行的任务提供公平性。调度程序还会尝试为这些实体中的各个任务提供公平性。
   </para>
   <para>
    内核调度程序可让您使用控制组将可运行的任务分组。有关更多信息，请参见<xref linkend="cha-tuning-cgroups"/>。
   </para>
  </sect2>

  <sect2 xml:id="sec-tuning-taskscheduler-cfs-kernelconfig">
   <title>内核配置选项</title>
   <para>
    您可以通过内核配置选项来设置任务调度程序行为的基本方面。设置这些选项属于内核编译过程的一部分。由于内核编译过程是一个复杂任务，超出了本文档的讨论范畴，因此请参考相关的信息来源。
   </para>
   <warning>
    <title>内核编译</title>
    <para>
     如果您在并非 <phrase role="productname"><phrase os="sled">SUSE Linux Enterprise Desktop</phrase></phrase> 随附的内核上运行该系统（例如，在自我编译的内核上运行），您会失去全部支持权利。
    </para>
   </warning>
  </sect2>

  <sect2 xml:id="sec-tuning-taskscheduler-cfs-terms">
   <title>术语</title>
   <para>
    有关任务调度策略的文档经常会使用一些技术术语，您需要熟悉这些术语才能正确理解文档中的信息。下面是其中的一些术语：
   </para>
   <variablelist>
    <varlistentry>
     <term>延迟</term>
     <listitem>
      <para>
       调度要运行的进程与实际执行该进程之间的延迟。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>粒度</term>
     <listitem>
      <para>
       可通过以下公式表达粒度与延迟之间的关系：
      </para>
<screen>gran = ( lat / rtasks ) - ( lat / rtasks / rtasks )</screen>
      <para>
       其中 <emphasis>gran</emphasis> 表示粒度，<emphasis>lat</emphasis> 表示延迟，<emphasis>rtasks</emphasis> 是正在运行的任务数。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <sect3 xml:id="kernel-tasksched-policies">
    <title>调度策略</title>
    <para>
     Linux 内核支持以下调度策略：
    </para>
    <variablelist>
     <varlistentry>
      <term>SCHED_FIFO</term>
      <listitem>
       <para>
        适用于特殊时间关键型应用程序的调度策略。它使用“先进先出”调度算法。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>SCHED_BATCH</term>
      <listitem>
       <para>
        适用于 CPU 密集型任务的调度策略。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>SCHED_IDLE</term>
      <listitem>
       <para>
        适用于<emphasis>极</emphasis>低优先级任务的调度策略。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>SCHED_OTHER</term>
      <listitem>
       <para>
        大部分进程使用的默认 Linux 分时调度策略。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>SCHED_RR</term>
      <listitem>
       <para>
        与 <systemitem>SCHED_FIFO</systemitem> 类似，但使用循环复用调度算法。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-tuning-taskscheduler-cfs-chrt">
   <title>使用 <command>chrt</command> 更改进程的实时属性</title>
   <para>
    <command>chrt</command> 命令设置或检索运行中进程的实时调度属性，或者使用指定的属性运行某个命令。您可以获取或检索进程的调度策略和优先级。
   </para>
   <para>
    在以下示例中，使用了 PID 为 16244 的进程。
   </para>
   <para>
    要<emphasis>检索</emphasis>现有任务的实时属性，请执行以下命令：
   </para>
<screen><prompt role="root"># </prompt>chrt -p 16244
pid 16244's current scheduling policy: SCHED_OTHER
pid 16244's current scheduling priority: 0
</screen>
   <para>
    在对进程设置新的调度策略之前，需要找出每个调度算法的最小和最大有效优先级：
   </para>
<screen><prompt role="root"># </prompt>chrt -m
SCHED_SCHED_OTHER min/max priority : 0/0
SCHED_SCHED_FIFO min/max priority : 1/99
SCHED_SCHED_RR min/max priority : 1/99
SCHED_SCHED_BATCH min/max priority : 0/0
SCHED_SCHED_IDLE min/max priority : 0/0
</screen>
   <para>
    在以上示例中，SCHED_OTHER、SCHED_BATCH、SCHED_IDLE 策略仅允许优先级 0，而 SCHED_FIFO 和 SCHED_RR 的优先级可为 1 到 99。
   </para>
   <para>
    要设置 SCHED_BATCH 调度策略，请执行以下命令：
   </para>
<screen><prompt role="root"># </prompt>chrt -b -p 0 16244
pid 16244's current scheduling policy: SCHED_BATCH
pid 16244's current scheduling priority: 0
</screen>
   <para>
    有关 <command>chrt</command> 的详细信息，请参见其手册页 (<command>man 1 chrt</command>)。
   </para>
  </sect2>

  <sect2 xml:id="sec-tuning-taskscheduler-cfs-tuning">
   <title>使用 <command>sysctl</command> 进行运行时微调</title>
   <para>
    用于在运行时检查和更改内核参数的 <command>sysctl</command> 接口引入了重要的变量，您可以通过这些变量更改任务调度程序的默认行为。<command>sysctl</command> 的语法非常简单。必须以 <systemitem class="username">root</systemitem> 身份在命令行上输入所有以下命令。
   </para>
   <para>
    要从内核变量读取值，请输入
   </para>
<screen><prompt role="root"># </prompt><command>sysctl <replaceable>VARIABLE</replaceable></command></screen>
   <para>
    要赋值，请输入
   </para>
<screen><prompt role="root"># </prompt><command>sysctl <replaceable>VARIABLE</replaceable>=<replaceable>VALUE</replaceable></command></screen>
   <para>
    要获取与调度程序相关的所有变量的列表，请运行 <command>sysctl</command> 命令，并使用 <command>grep</command> 过滤输出：
   </para>
   <screen><prompt role="root"># </prompt><command>sysctl -A | grep "sched" | grep -v "domain"</command>
kernel.sched_cfs_bandwidth_slice_us = 5000
kernel.sched_child_runs_first = 0
kernel.sched_compat_yield = 0
kernel.sched_latency_ns = 24000000
kernel.sched_migration_cost_ns = 500000
kernel.sched_min_granularity_ns = 8000000
kernel.sched_nr_migrate = 32
kernel.sched_rr_timeslice_ms = 25
kernel.sched_rt_period_us = 1000000
kernel.sched_rt_runtime_us = 950000
kernel.sched_schedstats = 0
kernel.sched_shares_window_ns = 10000000
kernel.sched_time_avg_ms = 1000
kernel.sched_tunable_scaling = 1
kernel.sched_wakeup_granularity_ns = 10000000</screen>
   <para>
    请注意，以 <quote>_ns</quote> 和 <quote>_us</quote> 结尾的变量分别接受以纳秒和微秒为单位的值。
   </para>

   <para>
    下面提供了最重要任务调度程序 <command>sysctl</command> 微调变量的列表（位于 <filename>/proc/sys/kernel/</filename> 中）和简短说明：
   </para>
   <variablelist>
    <varlistentry>
     <term><systemitem>sched_cfs_bandwidth_slice_us</systemitem>
     </term>
     <listitem>
      <para>
       使用 CFS 带宽控制时，此参数会控制从任务的控制组带宽池传送到运行队列的运行时间长短（带宽）。指定较小值可以在任务之间精细共享全局带宽，指定较大值可减少传送开销。请参见<link xlink:href="https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt"/>。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>sched_child_runs_first</systemitem>
     </term>
     <listitem>
      <para>
       新派生的子项在父项继续执行之前运行。将此参数设置为 <literal>1</literal> 有利于其中的子项在派生后完成执行的应用程序。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>sched_compat_yield</systemitem>
     </term>
     <listitem>
      <para>
       通过将放弃的任务移到可运行队列的末尾（红黑树中的最右边），启用旧 <emphasis>O(1)</emphasis> 调度程序的主动 CPU 放弃行为。出现严重的资源争用（例如锁定）时，通过给予其他进程运行机会，依赖 <option>sched_yield(2)</option> syscall 行为的应用程序可能会获得性能提高。另一方面，假设这种调用是在环境切换时发生的，滥用调用可能会给工作负载造成损害。请仅当您发现性能下降时，才使用此变量。默认值为 <literal>0</literal>。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>sched_migration_cost_ns</systemitem>
     </term>
     <listitem>
      <para>
       自上次执行后经过多长时间，会在迁移决策中将某个任务视为<quote>缓存热点</quote>。<quote>热点</quote>任务不太可能被迁移到另一 CPU，因此增大此变量可以减少任务迁移。默认值为 <literal>500000</literal>（纳秒）。
      </para>
      <para>
       如果存在可运行进程时 CPU 空闲时间超过预期，请尝试减小此值。如果任务过于频繁地在 CPU 或节点之间弹跳，请尝试增大此值。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>sched_latency_ns</systemitem>
     </term>
     <listitem>
      <para>
       CPU 密集型任务的目标抢占延迟。增大此变量会增加 CPU 密集型任务的时间片。任务的时间片是其调度时段的加权公平份额：
      </para>
      <para>
       时间片 = 调度时段 * (任务的权重/任务在运行队列中的总权重)
      </para>
      <para>
       任务的权重取决于任务的 nice 级别和调度策略。SCHED_OTHER 任务的最小任务权重为 15，对应于 nice 19。最大任务权重为 88761，对应于 nice -20。
      </para>
      <para>
       时间片随着负载增加而变小。当可运行任务的数目超过 <systemitem>sched_latency_ns</systemitem>/<systemitem>sched_min_granularity_ns</systemitem> 时，切片将变为 number_of_running_tasks * <systemitem>sched_min_granularity_ns</systemitem>。在此之前，切片等于 <systemitem>sched_latency_ns</systemitem>。
      </para>
      <para>
       此值还指定在权利计算中将某个休眠任务视为正在运行的最长时间量。增大此变量会增加抢占某个唤醒任务之前该任务可能消耗的时间，因此会增加 CPU 密集型任务的调度程序延迟。默认值为 <literal>6000000</literal>（纳秒）。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>sched_min_granularity_ns</systemitem>
     </term>
     <listitem>
      <para>
       CPU 密集型任务的最小抢占粒度。有关详细信息，请参见<systemitem>sched_latency_ns</systemitem>。默认值为 <literal>4000000</literal>（纳秒）。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>sched_wakeup_granularity_ns</systemitem>
     </term>
     <listitem>
      <para>
       唤醒抢占粒度。增大此变量会减小唤醒抢占，从而减轻计算密集型任务的干扰。减小此变量可改善延迟关键型任务的唤醒延迟和吞吐量，尤其是当短工作周期负载组件必须与 CPU 密集型组件竞争时。默认值为 <literal>2500000</literal>（纳秒）。
      </para>
      <warning>
       <title>设置适当的唤醒粒度值</title>
       <para>
        设置值超过 <systemitem>sched_latency_ns</systemitem> 的一半将导致不会发生唤醒抢占。短工作周期任务将无法有效与 CPU 资源霸占者竞争。
       </para>
      </warning>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>sched_rr_timeslice_ms</systemitem>
     </term>
     <listitem>
      <para>
       在 SCHED_RR 任务被抢占并置于任务列表末尾之前可运行的量子。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>sched_rt_period_us</systemitem>
     </term>
     <listitem>
      <para>
       测量实时任务带宽强制的时间段。默认值为 <literal>1000000</literal>（微秒）。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>sched_rt_runtime_us</systemitem>
     </term>
     <listitem>
      <para>
       在 sched_rt_period_us 时间段分配给实时任务的量子。设置为 -1 会禁用 RT 带宽强制。默认情况下，RT 任务每秒可能消耗 95%CPU，因而剩下 5%CPU/秒（或 0.05 秒）供 SCHED_OTHER 任务使用。默认值为 <literal>950000</literal>（微秒）。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>sched_nr_migrate</systemitem>
     </term>
     <listitem>
      <para>
       控制为实现负载平衡可跨处理器迁移的任务数。由于平衡机制在禁用中断 (softirq) 的情况下迭代运行队列，它可能造成实时任务的 IRQ 延迟。因此，增大此值可能会提升大型 SCHED_OTHER 线程的性能，代价是会增加实时任务的 IRQ 延迟。默认值为 <literal>32</literal>。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>sched_time_avg_ms</systemitem>
     </term>
     <listitem>
      <para>
      此参数用于设置计算实时任务运行时间的平均值所依据的时间段。该平均值可帮助 CFS 做出负载平衡决策，并指示 CPU 处理高优先级实时任务的繁忙程度。
      </para>
      <para>
      此参数的最佳设置在很大程度上与工作负载相关，并取决于实时任务的运行频率和运行时长等因素。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>



  <sect2 xml:id="sec-tuning-taskscheduler-cfs-debug">
   <title>调试界面和调度程序统计</title>
   <para>
    CFS 随附了新的增强型调试界面，并提供运行时统计信息。相关文件已添加到 <filename>/proc</filename> 文件系统，使用 <command>cat</command> 或 <command>less</command> 命令即可检查这些文件。下面提供了相关 <filename>/proc</filename> 文件的列表及其简短说明：
   </para>
   <variablelist>
    <varlistentry>
     <term><filename>/proc/sched_debug</filename>
     </term>
     <listitem>
      <para>
       包含影响任务调度程序行为的所有可调变量（请参见<xref linkend="sec-tuning-taskscheduler-cfs-tuning"/>）的当前值、CFS 统计，以及有关所有可用处理器上的运行队列的信息（CFS、RT 和最后期限）。此外还会显示每个处理器上运行的任务摘要、任务名称和 PID，以及调度程序特定的统计。最先显示的是 <option>tree-key</option> 列，其中指示了任务的虚拟运行时及其在内核中的名称，在红黑树中可按此键对所有可运行任务进行排序。<option>switches</option> 列表示切换总次数（无论强制还是自愿），<option>prio</option> 显然指的是进程优先级。<option>wait-time</option> 值表示任务等待调度的时间。最后，<option>sum-exec</option> 和 <option>sum-sleep</option> 分别统计了任务在处理器上运行或者处于休眠状态的总时间（以纳秒为单位）。
      </para>
<screen><prompt role="root"># </prompt>cat /proc/sched_debug
Sched Debug Version: v0.11, 4.4.21-64-default #1
ktime                                   : 23533900.395978
sched_clk                               : 23543587.726648
cpu_clk                                 : 23533900.396165
jiffies                                 : 4300775771
sched_clock_stable                      : 0

sysctl_sched
  .sysctl_sched_latency                    : 6.000000
  .sysctl_sched_min_granularity            : 2.000000
  .sysctl_sched_wakeup_granularity         : 2.500000
  .sysctl_sched_child_runs_first           : 0
  .sysctl_sched_features                   : 154871
  .sysctl_sched_tunable_scaling            : 1 (logarithmic)

cpu#0, 2666.762 MHz
  .nr_running                    : 1
  .load                          : 1024
  .nr_switches                   : 1918946
[...]

cfs_rq[0]:/
  .exec_clock                    : 170176.383770
  .MIN_vruntime                  : 0.000001
  .min_vruntime                  : 347375.854324
  .max_vruntime                  : 0.000001
[...]

rt_rq[0]:/
  .rt_nr_running                 : 0
  .rt_throttled                  : 0
  .rt_time                       : 0.000000
  .rt_runtime                    : 950.000000

dl_rq[0]:
  .dl_nr_running                 : 0

  task   PID         tree-key  switches  prio     wait-time        [...]
------------------------------------------------------------------------
R  cc1 63477     98876.717832       197   120      0.000000         ...</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><filename>/proc/schedstat</filename>
     </term>
     <listitem>
      <para>
       显示与当前运行队列相关的统计。另外还显示所有已连接处理器的 SMP 系统域特定统计。由于输出格式不太直观，请阅读 <filename>/usr/src/linux/Documentation/scheduler/sched-stats.txt</filename> 的内容来了解详细信息。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><filename>/proc/<replaceable>PID</replaceable>/sched</filename>
     </term>
     <listitem>
      <para>
       显示有关进程的调度信息及其 ID (<replaceable>PID</replaceable>)。
      </para>
<screen><prompt role="root"># </prompt>cat /proc/$(pidof gdm)/sched
gdm (744, #threads: 3)
-------------------------------------------------------------------
se.exec_start                                :          8888.758381
se.vruntime                                  :          6062.853815
se.sum_exec_runtime                          :             7.836043
se.statistics.wait_start                     :             0.000000
se.statistics.sleep_start                    :          8888.758381
se.statistics.block_start                    :             0.000000
se.statistics.sleep_max                      :          1965.987638
[...]
se.avg.decay_count                           :                 8477
policy                                       :                    0
prio                                         :                  120
clock-delta                                  :                  128
mm-&gt;numa_scan_seq                            :                    0
numa_migrations, 0
numa_faults_memory, 0, 0, 1, 0, -1
numa_faults_memory, 1, 0, 0, 0, -1
</screen>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>
 </sect1>
 <sect1 xml:id="cha-tuning-taskscheduler-moreinfo">
  <title>更多信息</title>

  <para>
   要获得有关 Linux 内核任务调度的简要介绍，需浏览多个信息来源。下面是其中一些资源：
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     有关任务调度程序系统调用的介绍，请参见相关手册页（例如 <command>man 2 sched_setaffinity</command>）。
    </para>
   </listitem>
   <listitem>
    <para>
     <link xlink:href="http://www.inf.fu-berlin.de/lehre/SS01/OS/Lectures/Lecture08.pdf"/> 中提供了有关 Linux 调度程序策略和算法的有用讲座。
    </para>
   </listitem>
   <listitem>
    <para>
     由 Robert Love 发布的 <citetitle>Linux Kernel Development</citetitle>（ISBN-10：0-672-32512-8）很好地概述了 Linux 进程调度。请参见 <link xlink:href="https://www.informit.com/articles/article.aspx?p=101760"/>。
    </para>
   </listitem>
   <listitem>
    <para>
     由 Daniel P. Bovet 和 Marco Cesati 发布的 <citetitle>Understanding the Linux Kernel</citetitle> (ISBN 978-0-596-00565-8) 中非常全面地概述了 Linux 内核的内部结构。
    </para>
   </listitem>
   <listitem>
    <para>
     <filename>/usr/src/linux/Documentation/scheduler</filename> 下的文件介绍了有关任务调度程序的技术信息。
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
</chapter>
