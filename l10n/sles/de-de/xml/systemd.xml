<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="systemd.xml" version="5.0" xml:id="cha-systemd">
 <title>Der Daemon <systemitem class="daemon">systemd</systemitem></title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>
 <para>
  <systemitem class="daemon">systemd</systemitem> ist für die Initialisierung des Systems verantwortlich und trägt die Prozess-ID 1. <systemitem class="daemon">systemd</systemitem> wird direkt vom Kernel gestartet und widersteht dem Signal 9, das in der Regel Prozesse beendet. Alle anderen Programme werden entweder direkt von <systemitem class="daemon">systemd</systemitem> oder von einem seiner untergeordneten Prozesse gestartet. <systemitem class="daemon">systemd</systemitem> ersetzt den System-V-init-Daemon und ist (durch die Unterstützung von init-Skripten) uneingeschränkt mit System-V-init kompatibel.
 </para>
 <para>
  Der wichtigste Vorteil von <systemitem class="daemon">systemd</systemitem> ist der erheblich schnellere Systemstart durch die Parallelisierung der Dienststarts. Darüber hinaus startet <systemitem class="daemon">systemd</systemitem> einen Dienst nur dann, wenn er tatsächlich benötigt wird. Deamons werden nicht in jedem Fall beim Booten gestartet, sondern erst dann, wenn sie erstmalig benötigt werden. <systemitem class="daemon">systemd</systemitem> unterstützt außerdem Kernel-Steuergruppen (cgroups), das Erstellen von Snapshots und das Wiederherstellen des Systemstatus. Weitere Einzelheiten finden Sie unter <link xlink:href="http://www.freedesktop.org/wiki/Software/systemd/"/>.
 </para>
   
 <sect1 xml:id="sec-boot-systemd-concept">
  <title>Das Konzept von <systemitem class="daemon">systemd</systemitem></title>
  <para>
   Im folgenden Abschnitt wird das Konzept hinter <systemitem class="daemon">systemd</systemitem> erläutert.
  </para>
  <para>
    <systemitem class="daemon">systemd</systemitem> ist ein System- und Sitzungsmanager für Linux und ist mit System V- und LSB-init-Skripts kompatibel. Die wichtigsten Funktionen von <systemitem class="daemon">systemd</systemitem>:
  </para>
    <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>
      Parallelisierungsfunktionen
     </para>
    </listitem>
    <listitem>
     <para>
      Socket- und D-Bus-Aktivierung zum Starten von Diensten
     </para>
    </listitem>
    <listitem>
     <para>
      Starten der Daemons bei Bedarf
     </para>
    </listitem>
    <listitem>
     <para>
      Verfolgen von Prozessen mithilfe von Linux-cgroups
     </para>
    </listitem>
    <listitem>
     <para>
      Erstellen von Snapshots und Wiederherstellen des Systemstatus
     </para>
    </listitem>
    <listitem>
     <para>
      Einhängepunkte und Automount-Punkte
     </para>
    </listitem>
    <listitem>
     <para>
      Ausgereifte Dienststeuerlogik auf der Basis der Transaktionsabhängigkeiten
     </para>
    </listitem>
   </itemizedlist>

   <sect2 xml:id="sec-boot-systemd-unitfile">
   <title>Unit-Datei</title>
   <para>
    Eine Unit-Konfigurationsdatei enthält Informationen zu einem Dienst, Socket, Gerät, Einhängepunkt, Automount-Punkt, einer Auslagerungsdatei oder Partition, einem Startziel, einem überwachten Dateisystempfad, einem von <systemitem class="daemon">systemd</systemitem> gesteuerten und überwachten Zeitgeber, einem Snapshot eines temporären Systemstatus, einem Ressourcenverwaltungs-Slice oder einer Gruppe extern erstellter Prozesse.
   </para>
   <para>
    <quote>Unit-Datei</quote><systemitem class="daemon">systemd</systemitem> ist in ein generischer Term für Folgendes:
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <formalpara>
      <title>Dienst</title>
      <para>
       Informationen zu einem Prozess (z. B. Ausführung eines Daemon); Datei endet auf .service
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Zielgruppen</title>
      <para>
       Fassen Units zu Gruppen zusammen bzw. fungieren als Synchronisierungspunkte beim Starten; Datei endet auf .target
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Sockets</title>
      <para>
       Informationen zu einem IPC- oder Netzwerk-Socket oder einem Dateisystem-FIFO, für die socketbasierte Aktivierung (wie <systemitem class="daemon">inetd</systemitem>); Datei endet auf .socket
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Path</title>
      <para>
       Dient als Auslöser von anderen Units (z. B. Ausführen eines Dienstes, wenn Dateien geändert werden); Datei endet auf .path
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Zeitgeber</title>
      <para>
       Informationen zu einem gesteuerten Zeitgeber für die zeitgeberbasierte Aktivierung; Datei endet auf .timer
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Einhängepunkt</title>
      <para>
       In der Regel automatisch durch den fstab-Generator erzeugt; Datei endet auf .mount
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Automount-Punkt</title>
      <para>
       Informationen zu einem Dateisystem-Automount-Punkt; Datei endet auf .automount
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Swap</title>
      <para>
       Informationen zu einem Auslagerungsgerät oder einer Auslagerungsdatei für das Arbeitsspeicher-Paging; Datei endet auf .swap
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Gerät</title>
      <para>
       Informationen zu einer Geräte-Unit in der Geräte-Baumstruktur sysfs/udev(7); Datei endet auf .device
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Bereich/Slice</title>
      <para>
       Konzept für die hierarchische Verwaltung von Ressourcen einer Prozessgruppe; Datei endet auf .scope/.slice
      </para>
     </formalpara>
    </listitem>
   </itemizedlist>
     
   <para>
    Weitere Informationen zu <systemitem class="daemon">systemd</systemitem>-Unit-Dateien finden Sie in <link xlink:href="http://www.freedesktop.org/software/systemd/man/systemd.unit.html"/>
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-boot-systemd-basics">
  <title>Grundlegende Verwendung</title>

  <para>
   Im System V-init-System werden Dienste mit mehreren Kommandos verarbeitet – mit init-Skripten, <command>insserv</command>, <command>telinit</command> und anderen. <systemitem class="daemon">systemd</systemitem> erleichtert die Dienstverwaltung, da ein einziges Kommando die meisten Dienstverarbeitungsaufgaben abdeckt: <command>systemctl</command>. Hierbei gilt die Syntax <quote>Kommando plus Subkommando</quote> wie bei <command>git</command> oder <command>zypper</command>:
  </para>

<screen>systemctl <replaceable>GENERAL OPTIONS</replaceable> <replaceable>SUBCOMMAND</replaceable> <replaceable>SUBCOMMAND OPTIONS</replaceable></screen>

  <para>
   Vollständige Anweisungen finden Sie in <command>man 1 systemctl</command>.
  </para>

  <tip>
   <title>Terminalausgabe und Bash-Vervollständigung</title>
   <para>
    Wenn die Ausgabe an ein Terminal geht (und nicht an eine Pipe oder Datei usw.), senden die <systemitem class="daemon">systemd</systemitem>-Kommandos standardmäßig eine ausführliche Ausgabe an einen Pager. Mit der Option <option>--no-pager</option> deaktivieren Sie den Paging-Modus.
   </para>
   <para>
    <systemitem class="daemon">systemd</systemitem> unterstützt außerdem die Bash-Vervollständigung. Hierbei geben Sie die ersten Buchstaben eines Subkommandos ein und drücken dann <keycap function="tab"/>. Diese Funktion ist nur in der <systemitem>bash</systemitem>-Shell verfügbar und das Paket <systemitem class="resource">bash-completion</systemitem> muss installiert sein.
   </para>
  </tip>

  <sect2 xml:id="sec-boot-systemd-basics-services">
   <title>Verwalten von Diensten auf einem laufenden System</title>
   <para>
    Die Subkommandos zum Verwalten der Dienste sind mit den entsprechenden Kommandos in System V-init identisch (<command>start</command>, <command>stop</command> usw.). Die allgemeine Syntax für Dienstverwaltungskommandos lautet wie folgt:
   </para>
   <variablelist>
    <varlistentry>
     <term><systemitem class="daemon">systemd</systemitem></term>
     <listitem>
<screen>systemctl reload|restart|start|status|stop|<replaceable>...</replaceable> <replaceable>MY_SERVICE(S)</replaceable></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>System V-init</term>
     <listitem>
<screen>rc<replaceable>MY_SERVICE(S)</replaceable> reload|restart|start|status|stop|<replaceable>...</replaceable></screen>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Mit <systemitem class="daemon">systemd</systemitem> können Sie mehrere Dienste gleichzeitig verwalten. Im Gegensatz zu System V-init, bei dem die init-Skripts einzeln nacheinander ausgeführt werden, führen Sie ein einziges Kommando aus, beispielsweise:
   </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl start <replaceable>MY_1ST_SERVICE</replaceable> <replaceable>MY_2ND_SERVICE</replaceable></screen>
   <para>
    So rufen Sie eine Liste aller auf dem System verfügbaren Dienste ab:
   </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl list-unit-files --type=service</screen>
   <para>
    Die folgende Tabelle zeigt die wichtigsten Dienstverwaltungskommandos für <systemitem class="daemon">systemd</systemitem> und System V-init:
   </para>
   <table rowsep="1">
    <title>Kommandos zur Dienstverwaltung</title>
    <tgroup cols="3">
     <colspec colnum="1" colname="1" colwidth="50*"/>
     <colspec colnum="2" colname="2" colwidth="30*"/>
     <colspec colnum="3" colname="3" colwidth="20*"/>
     <thead>
      <row>
       <entry colname="1">
        <para>
         Aufgabe
        </para>
       </entry>
       <entry colname="2">
        <para>
         <systemitem class="daemon">systemd</systemitem> Befehl
        </para>
       </entry>
       <entry colname="3">
        <para>
         System V-init-Kommando
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Starten</title>
         <para/>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>start</screen>
       </entry>
       <entry colname="3">
<screen>start</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Stoppen</title>
         <para/>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>stop</screen>
       </entry>
       <entry colname="3">
<screen>stop</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Neu starten</title>
         <para>
          Fährt Dienste herunter und startet sie dann neu. Wenn ein Dienst noch nicht ausgeführt wird, wird er gestartet.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>restart</screen>
       </entry>
       <entry colname="3">
<screen>restart</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Bedingt neu starten</title>
         <para>
          Startet Dienste neu, wenn sie derzeit ausgeführt werden. Keine Auswirkung bei Diensten, die nicht ausgeführt werden.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>try-restart</screen>
       </entry>
       <entry colname="3">
<screen>try-restart</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Neu laden</title>
         <para>
          Weist die Dienste an, die Konfigurationsdateien neu zu laden ohne die laufenden Vorgänge zu unterbrechen. Anwendungsbeispiel: Weisen Sie Apache an, eine bearbeitete Konfigurationsdatei <filename>httpd.conf</filename> neu zu laden. Nicht alle Dienste unterstützen das Neuladen.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>reload</screen>
       </entry>
       <entry colname="3">
<screen>reload</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Neu laden oder neu starten</title>
         <para>
          Lädt Dienste neu, wenn das Neuladen unterstützt wird; ansonsten werden die Dienste neu gestartet. Wenn ein Dienst noch nicht ausgeführt wird, wird er gestartet.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>reload-or-restart</screen>
       </entry>
       <entry colname="3">
<screen>n/a</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Bedingt neu laden oder neu starten</title>
         <para>
          Lädt Dienste neu, wenn das Neuladen unterstützt wird; ansonsten werden die Dienste neu gestartet, wenn sie derzeit ausgeführt werden. Keine Auswirkung bei Diensten, die nicht ausgeführt werden.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>reload-or-try-restart</screen>
       </entry>
       <entry colname="3">
<screen>n/a</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Ausführliche Statusinformationen abrufen</title>
         <para>
          Zeigt Informationen zum Dienststatus. Das Kommando <systemitem class="daemon">systemd</systemitem> bietet Details wie Beschreibung, ausführbare Datei, Status, cgroup und zuletzt durch den Dienst ausgegebene Meldungen (siehe <xref linkend="sec-boot-systemd-basics-services-debugging"/>). Die Detailtiefe bei System V-init ist von Dienst zu Dienst unterschiedlich.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>status</screen>
       </entry>
       <entry colname="3">
<screen>status</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Kurze Statusinformationen abrufen</title>
         <para>
          Gibt an, ob Dienste aktiv sind oder nicht.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>is-active</screen>
       </entry>
       <entry colname="3">
<screen>status</screen>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-basics-services-enabling">
   <title>Dienste dauerhaft aktivieren/deaktivieren</title>
   <para>
    Mit den Dienstverwaltungskommandos im vorangegangenen Abschnitt können Sie die Dienste für die aktuelle Sitzung bearbeiten. <systemitem class="daemon">systemd</systemitem>Mit können Sie Dienste außerdem dauerhaft aktivieren oder deaktivieren, so dass sie entweder automatisch bei Bedarf gestartet werden oder gar nicht verfügbar sind. Sie können dies mithilfe von YaST oder über die Kommandozeile tun.
   </para>
   <sect3 xml:id="sec-boot-systemd-basics-services-enabling-cmd">
    <title>Aktivieren/Deaktivieren von Diensten über die Kommandozeile</title>
    <para>
     Die folgende Tabelle zeigt die wichtigsten Aktivierungs- und Deaktivierungskommandos für <systemitem class="daemon">systemd</systemitem> und System V-init:
    </para>
    <important>
     <title>Dienststart</title>
     <para>
      Wenn ein Dienst über die Kommandozeile aktiviert wird, wird er nicht automatisch gestartet. Der Dienst wird beim nächsten Systemstart oder bei der nächsten Änderung des Runlevels/Ziels gestartet. Soll ein Dienst nach dem Aktivieren sofort gestartet werden, führen Sie explizit <command>systemctl start <replaceable>MEIN_DIENST</replaceable></command> oder <command>rc <replaceable>MEIN_DIENST</replaceable> start</command> aus.
     </para>
    </important>
    <table rowsep="1">
     <title>Kommandos zum Aktivieren und Deaktivieren von Diensten</title>
     <tgroup cols="3">
      <colspec colnum="1" colname="1" colwidth="32*"/>
      <colspec colnum="2" colname="2" colwidth="40*"/>
      <colspec colnum="3" colname="3" colwidth="28*"/>
      <thead>
       <row>
        <entry colname="1">
         <para>
          Aufgabe
         </para>
        </entry>
        <entry colname="2">
         <para>
          <systemitem class="daemon">systemd</systemitem> Befehl
         </para>
        </entry>
        <entry colname="3">
         <para>
          System V-init-Kommando
         </para>
        </entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Aktivieren von</title>
          <para/>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl enable <replaceable>MEIN(E)_DIENST(E)</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>insserv <replaceable>MEIN(E)_DIENST(E)</replaceable></command>, <command>chkconfig -a <replaceable>MEIN(E)_DIENST(E)</replaceable></command>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Deaktivieren</title>
          <para/>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl disable <replaceable>MEIN(E)_DIENST(E)</replaceable>.service</command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>insserv -r <replaceable>MEIN(E)_DIENST(E)</replaceable></command>, <command>chkconfig -d <replaceable>MEIN(E)_DIENST(E)</replaceable></command>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Überprüfen</title>
          <para>
           Zeigt an, ob ein Dienst aktiviert ist oder nicht.
          </para>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl is-enabled <replaceable>MEIN_DIENST</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>chkconfig <replaceable>MEIN_DIENST</replaceable></command>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Erneut aktivieren</title>
          <para>
           Ähnlich wie beim Neustarten eines Diensts, deaktiviert dieses Kommando einen Dienst und aktiviert ihn dann wieder. Nützlich, wenn ein Dienst mit den Standardeinstellungen erneut aktiviert werden soll.
          </para>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl reenable <replaceable>MEIN_DIENST</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/v
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Maskierung</title>
          <para>
           Nach dem <quote>Deaktivieren</quote> eines Dienstes kann er weiterhin manuell aktiviert werden. Soll ein Dienst vollständig deaktiviert werden, maskieren Sie ihn. Mit Vorsicht verwenden.
          </para>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl mask <replaceable>MEIN_DIENST</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/v
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Demaskieren</title>
          <para>
           Ein maskierter Dienst kann erst dann wieder genutzt werden, wenn er demaskiert wurde.
          </para>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl unmask <replaceable>MEIN_DIENST</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/v
         </para>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-boot-systemd-boot">
  <title>Systemstart und Zielverwaltung</title>

  <para>
   Der gesamte Vorgang des Startens und Herunterfahrens des Systems wird von <systemitem class="daemon">systemd</systemitem> verwaltet. Von diesem Gesichtspunkt aus kann der Kernel als Hintergrundprozess betrachtet werden, der alle anderen Prozesse verwaltet und die CPU-Zeit sowie den Hardwarezugriff entsprechend den Anforderungen anderer Programme anpasst.
  </para>

  <sect2 xml:id="sec-boot-systemd-targets">
   <title>Ziele im Vergleich zu Runlevels</title>
   <para>
    Bei System V-init wurde das System in ein sogenanntes <quote>Runlevel</quote> gebootet. Ein Runlevel definiert, wie das System gestartet wird und welche Dienste im laufenden System verfügbar sind. Die Runlevels sind numeriert. Die bekanntesten Runlevels sind <literal>0</literal> (System herunterfahren), <literal>3</literal> (Mehrbenutzermodus mit Netzwerk) und <literal>5</literal> (Mehrbenutzermodus mit Netzwerk und Anzeigemanager).
   </para>
   <para>
    <systemitem class="daemon">systemd</systemitem> führt mit den sogenannten <quote>Ziel-Units ein neues Konzept ein</quote>. Dennoch bleibt die Kompatibilität mit dem Runlevel-Konzept uneingeschränkt erhalten. Die Ziel-Units tragen Namen statt Zahlen und erfüllen bestimmte Zwecke. Mit den Zielen <systemitem>local-fs.target</systemitem> und <systemitem>swap.target</systemitem> werden beispielsweise lokale Dateisysteme und Auslagerungsbereiche eingehängt.
   </para>
   <para>
    Das Ziel <systemitem>graphical.target</systemitem> stellt ein Mehrbenutzersystem mit Netzwerk sowie Anzeigemanager-Funktionen bereit und entspricht Runlevel 5. Komplexe Ziele wie <systemitem>graphical.target</systemitem> fungieren als <quote>Metaziele</quote>, in denen eine Teilmenge anderer Ziele vereint ist. Mit <systemitem class="daemon">systemd</systemitem> können Sie problemlos vorhandene Ziele kombinieren und so benutzerdefinierte Ziele bilden. Damit bietet dieses Kommando eine hohe Flexibilität.
   </para>
   <para>
    Die nachfolgende Liste zeigt die wichtigsten <systemitem class="daemon">systemd</systemitem>-Ziel-Units. Eine vollständige Liste finden Sie in <command>man 7 systemd.special</command>.
   </para>
   <variablelist>
    <title>Ausgewählte <systemitem class="daemon">systemd</systemitem>-Ziel-Units</title>
    <varlistentry>
     <term><systemitem>default.target</systemitem></term>
     <listitem>
      <para>
       Das Ziel, das standardmäßig gebootet wird. Kein <quote>reales</quote> Ziel, sondern ein symbolischer Link zu einem anderen Ziel wie <systemitem>graphic.target</systemitem>. Kann über YaST dauerhaft geändert werden (siehe <xref linkend="sec-boot-runlevel-edit"/>). Soll das Ziel für eine einzige Sitzung geändert werden, geben Sie den Kernel-Parameter <literal>systemd.unit=<replaceable>MEIN_ZIEL.target</replaceable></literal> am Bootprompt ein.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>emergency.target</systemitem></term>
     <listitem>
      <para>
       Startet eine Notfall-Shell über die Konsole. Dieses Kommando darf nur an der Boot-Eingabeaufforderung im Format <literal>systemd.unit=emergency.target</literal> verwendet werden.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>graphical.target</systemitem></term>
     <listitem>
      <para>
       Startet ein System mit Netzwerk, Mehrbenutzerunterstützung und Anzeigemanager.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>halt.target</systemitem></term>
     <listitem>
      <para>
       Fährt das System herunter.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mail-transfer-agent.target</systemitem></term>
     <listitem>
      <para>
       Startet alle Dienste, die zum Senden und Empfangen von Mails erforderlich sind.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>multi-user.target</systemitem></term>
     <listitem>
      <para>
       Startet ein Mehrbenutzersystem mit Netzwerk.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>reboot.target</systemitem></term>
     <listitem>
      <para>
       Bootet das System neu.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>rescue.target</systemitem></term>
     <listitem>
      <para>
       Startet ein Einzelbenutzersystem ohne Netzwerk.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Damit die Kompatibilität mit dem Runlevel-System von System V-init gewährleistet bleibt, bietet <systemitem class="daemon">systemd</systemitem> besondere Ziele mit der Bezeichnung <literal>runlevel<replaceable>X</replaceable>.target</literal>, denen die entsprechenden, mit <replaceable>X</replaceable> nummerierten Runlevels zugeordnet sind.
   </para>
   <para>
    Mit dem Kommando <command>systemctl get-default</command> ermitteln Sie das aktuelle Ziel.
   </para>
   <table rowsep="1">
    <title>System V-Runlevels und <systemitem class="daemon">systemd</systemitem>-Ziel-Units</title>
    <tgroup cols="3">
     <colspec colnum="1" colname="1" colwidth="20*"/>
     <colspec colnum="2" colname="2" colwidth="40*"/>
     <colspec colnum="3" colname="3" colwidth="40*"/>
     <thead>
      <row>
       <entry>
        <para>
         System V-Runlevel
        </para>
       </entry>
       <entry>
        <para>
         <systemitem class="daemon">systemd</systemitem> Ziel
        </para>
       </entry>
       <entry>
        <para>
         Beschreibung
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         0
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel0.target</systemitem>, <systemitem>halt.target</systemitem>, <systemitem>poweroff.target</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         System herunterfahren
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         1, S
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel1.target</systemitem>, <systemitem>rescue.target</systemitem>,
        </para>
       </entry>
       <entry>
        <para>
         Einzelbenutzermodus
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         2
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel2.target</systemitem>, <systemitem>multi-user.target</systemitem>,
        </para>
       </entry>
       <entry>
        <para>
         Lokaler Mehrbenutzermodus ohne entferntes Netzwerk
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         3
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel3.target</systemitem>, <systemitem>multi-user.target</systemitem>,
        </para>
       </entry>
       <entry>
        <para>
         Mehrbenutzer-Vollmodus mit Netzwerk
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         4
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel4.target</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         Nicht verwendet/benutzerdefiniert
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         5
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel5.target</systemitem>, <systemitem>graphical.target</systemitem>,
        </para>
       </entry>
       <entry>
        <para>
         Mehrbenutzer-Vollmodus mit Netzwerk und Anzeige-Manager
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         6
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel6.target</systemitem>, <systemitem>reboot.target</systemitem>,
        </para>
       </entry>
       <entry>
        <para>
         Systemneustart
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <important>
    <title><systemitem class="daemon">systemd</systemitem> ignoriert <filename>/etc/inittab</filename></title>
    <para>
     Die Runlevels in einem System V-init-System werden in <filename>/etc/inittab</filename> konfiguriert. Bei <systemitem class="daemon">systemd</systemitem> wird diese Konfiguration <emphasis>nicht</emphasis> verwendet. Weitere Anweisungen zum Erstellen eines bootfähigen Ziels finden Sie unter <xref linkend="sec-boot-systemd-custom-targets"/>.
    </para>
   </important>
   <sect3 xml:id="sec-boot-systemd-targets-commands">
    <title>Kommandos zum Ändern von Zielen</title>
    <para>
     Mit den folgenden Kommandos arbeiten Sie mit den Ziel-Units:
    </para>
    <informaltable rowsep="1">
     <tgroup cols="3">
      <colspec colnum="1" colname="1" colwidth="20*"/>
      <colspec colnum="2" colname="2" colwidth="50*"/>
      <colspec colnum="3" colname="3" colwidth="30*"/>
      <thead>
       <row>
        <entry colname="1">
         <para>
          Aufgabe
         </para>
        </entry>
        <entry colname="2">
         <para>
          <systemitem class="daemon">systemd</systemitem> Befehl
         </para>
        </entry>
        <entry colname="3">
         <para>
          System V-init-Kommando
         </para>
        </entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry colname="1">
         <para>
          Aktuelles Ziel/Runlevel ändern
         </para>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl isolate</command> <replaceable>MEIN_ZIEL</replaceable>.target
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>telinit</command> <replaceable> X</replaceable>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          Zum standardmäßigen Ziel/Runlevel wechseln
         </para>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl default</command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/v
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          Aktuelles Ziel/Runlevel abrufen
         </para>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl list-units --type=target</command>
         </para>
         <para>
          Bei <systemitem class="daemon">systemd</systemitem> sind in der Regel mehrere Ziele aktiv. Mit diesem Kommando werden alle derzeit aktiven Ziele aufgelistet.
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>who -r</command>
         </para>
         <para>
          oder
         </para>
         <para>
          <command>runlevel</command>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          Standard-Runlevel dauerhaft ändern
         </para>
        </entry>
        <entry colname="2">
         <para>
          Verwenden Sie die Dienste-Verwaltung, oder führen Sie das folgende Kommando aus:
         </para>
         <para>
          <command>ln -sf /usr/lib/systemd/system/</command> <replaceable>MEIN_ZIEL</replaceable>.target /etc/systemd/system/default.target
         </para>
        </entry>
        <entry colname="3">
         <para>
          Verwenden Sie die Dienste-Verwaltung, oder ändern Sie die Zeile
         </para>
         <para>
          <command>id:</command> <replaceable>X</replaceable>:initdefault:
         </para>
         <para>
          in <filename>/etc/inittab</filename>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          Standard-Runlevel für den aktuellen Bootprozess ändern
         </para>
        </entry>
        <entry colname="2">
         <para>
          Geben Sie an der Boot-Eingabeaufforderung die folgende Option ein:
         </para>
         <para>
          <command>systemd.unit=</command> <replaceable>MEIN_ZIEL</replaceable>.target
         </para>
        </entry>
        <entry colname="3">
         <para>
          Geben Sie an der Boot-Eingabeaufforderung die gewünschte Runlevel-Nummer ein.
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          Abhängigkeiten für ein Ziel/Runlevel anzeigen
         </para>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl show -p &quot;Requires&quot; </command> <replaceable>MEIN_ZIEL</replaceable>.target
         </para>
         <para>
          <command>systemctl show -p &quot;Wants&quot; </command> <replaceable>MEIN_ZIEL</replaceable>.target
         </para>
         <para>
          <quote>Requires</quote> (Benötigt) zeigt eine Liste der harten Abhängigkeiten (die in jedem Fall aufgelöst werden müssen), <quote>Wants</quote> (Erwünscht) dagegen eine Liste der weichen Abhängigkeiten (die nach Möglichkeit aufgelöst werden).
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/v
         </para>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-debug">
   <title>Fehlersuche beim Systemstart</title>
   <para>
    <systemitem class="daemon">systemd</systemitem> bietet eine Möglichkeit, den Systemstartvorgang zu analysieren. Sie können die Liste der Services mit dem jeweiligen Status prüfen (ohne durch <filename>/var/log/</filename> blättern zu müssen). Mit <systemitem class="daemon">systemd</systemitem> können Sie zudem den Startvorgang scannen und so ermitteln, wie lang das Starten der einzelnen Dienste dauert.
   </para>
   <sect3 xml:id="sec-boot-systemd-debug-review">
    <title>Prüfen des Startvorgangs der Dienste</title>
    <para>
     Mit dem Kommando <command>systemctl</command> erzeugen Sie eine Liste aller Dienste, die seit dem Booten des Systems gestartet wurden. Hier werden alle aktiven Dienste wie im nachstehenden (gekürzten) Beispiel aufgeführt. Mit <command>systemctl status <replaceable>MEIN_DIENST</replaceable></command> erhalten Sie weitere Informationen zu einem bestimmten Dienst.
    </para>
    <example>
     <title>Liste der aktiven Dienste</title>
<screen><prompt role="root"># </prompt>systemctl
UNIT                        LOAD   ACTIVE SUB       JOB DESCRIPTION
[...]
iscsi.service               loaded active exited    Login and scanning of iSC+
kmod-static-nodes.service   loaded active exited    Create list of required s+
libvirtd.service            loaded active running   Virtualization daemon
nscd.service                loaded active running   Name Service Cache Daemon
chronyd.service             loaded active running   NTP Server Daemon
polkit.service              loaded active running   Authorization Manager
postfix.service             loaded active running   Postfix Mail Transport Ag+
rc-local.service            loaded active exited    /etc/init.d/boot.local Co+
rsyslog.service             loaded active running   System Logging Service
[...]
LOAD   = Reflects whether the unit definition was properly loaded.
ACTIVE = The high-level unit activation state, i.e. generalization of SUB.
SUB    = The low-level unit activation state, values depend on unit type.

161 loaded units listed. Pass --all to see loaded but inactive units, too.
To show all installed unit files use 'systemctl list-unit-files'.</screen>
    </example>
    <para>
     Soll die Ausgabe auf Dienste beschränkt werden, die nicht gestartet werden konnten, geben Sie die Option <option>--failed</option> an:
    </para>
    <example>
     <title>Liste der fehlerhaften Dienste</title>
<screen><prompt role="root"># </prompt>systemctl --failed
UNIT                   LOAD   ACTIVE SUB    JOB DESCRIPTION
apache2.service        loaded failed failed     apache
NetworkManager.service loaded failed failed     Network Manager
plymouth-start.service loaded failed failed     Show Plymouth Boot Screen

[...]</screen>
    </example>
   </sect3>
   <sect3 xml:id="sec-boot-systemd-debug-time">
    <title>Fehlersuche für die Startzeit</title>
    <para>
     Mit dem Kommando <command>systemd-analyze</command> in <systemitem class="daemon">systemd</systemitem> führen Sie die Fehlersuche für die Startzeit durch. Hiermit werden der Gesamtzeitaufwand für den Startvorgang sowie eine Liste der beim Starten angeforderten Dienste angezeigt. Auf Wunsch kann auch eine SVG-Grafik erstellt werden, aus der hervorgeht, wie lange der Start der Dienste im Vergleich zu den anderen Diensten dauerte.
    </para>
    <variablelist>
     <varlistentry>
      <term>Auflisten der Startzeit des Systems</term>
      <listitem>
<screen><prompt role="root"># </prompt>systemd-analyze
Startup finished in 2666ms (kernel) + 21961ms (userspace) = 24628ms</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Auflisten der Startzeit der Dienste</term>
      <listitem>
<screen><prompt role="root"># </prompt>systemd-analyze blame
    15.000s backup-rpmdb.service
    14.879s mandb.service
     7.646s backup-sysconfig.service
     4.940s postfix.service
     4.921s logrotate.service
     4.640s libvirtd.service
     4.519s display-manager.service
     3.921s btrfsmaintenance-refresh.service
     3.466s lvm2-monitor.service
     2.774s plymouth-quit-wait.service
     2.591s firewalld.service
     2.137s initrd-switch-root.service
     1.954s ModemManager.service
     1.528s rsyslog.service
     1.378s apparmor.service
    [...]
</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Grafische Darstellung der Startzeit der Dienste</term>
      <listitem>
<screen><prompt role="root"># </prompt>systemd-analyze plot &gt; jupiter.example.com-startup.svg</screen>
       <informalfigure>
        <mediaobject>
         <imageobject role="fo">
          <imagedata fileref="systemd_startup.svg" width="75%"/>
         </imageobject>
         <imageobject role="html">
          <imagedata fileref="systemd_startup.png" width="75%"/>
         </imageobject>
        </mediaobject>
       </informalfigure>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3 xml:id="sec-boot-systemd-debug-complete">
    <title>Prüfen des gesamten Startvorgangs</title>
    <para>
     Mit den obigen Kommandos werden die gestarteten Dienste und ihre Startzeiten aufgelistet. Eine detailliertere Übersicht erhalten Sie, wenn Sie folgende Parameter an der Boot-Eingabeaufforderung angeben, damit <systemitem class="daemon">systemd</systemitem> ein ausführliches Protokoll des gesamten Startvorgangs erstellt.
    </para>
<screen>systemd.log_level=debug systemd.log_target=kmsg</screen>
    <para>
     <systemitem class="daemon">systemd</systemitem> schreibt die Protokollmeldungen nunmehr in den Kernel-Ringpuffer. Diesen Puffer zeigen Sie mit <command>dmesg</command> an:
    </para>
<screen><prompt>&gt; </prompt>dmesg -T | less</screen>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-sysv-compatibility">
   <title>System V-Kompatibilität</title>
   <para>
    <systemitem class="daemon">systemd</systemitem> ist mit System V kompatibel, sodass Sie vorhandene System V-init-Skripte weiterhin nutzen können. Es gibt allerdings mindestens ein bekanntes Problem, bei dem ein System V-init-Skript nicht ohne Weiteres mit <systemitem class="daemon">systemd</systemitem> zusammenarbeitet: Wenn Sie einen Dienst als ein anderer Benutzer über <command>su</command> oder <command>sudo</command> in init-Skripten starten, tritt der Fehler <quote>Access denied</quote> (Zugriff verweigert) auf.
   </para>
   <para>
    Wenn Sie den Benutzer mit <command>su</command> oder <command>sudo</command> ändern, wird eine PAM-Sitzung gestartet. Diese Sitzung wird beendet, sobald das init-Skript abgeschlossen ist. Als Folge wird auch der Service, der durch das init-Skript gestartet wurde, beendet. Als Workaround für diesen Fehler gehen Sie wie folgt vor:
   </para>
   <procedure>
    <step>
     <para>
      Erstellen Sie einen Service-Datei-Wrapper mit demselben Namen wie das init-Skript und der Dateinamenerweiterung <filename>.service</filename>:
     </para>
<screen>[Unit]
Description=<replaceable>DESCRIPTION</replaceable>
After=network.target

[Service]
User=<replaceable>USER</replaceable>
Type=forking<co xml:id="co-service-wrapper-type"/>
PIDFile=<replaceable>PATH TO PID FILE</replaceable><xref linkend="co-service-wrapper-type" xrefstyle="select:label nopage"/>
ExecStart=<replaceable>PATH TO INIT SCRIPT</replaceable> start
ExecStop=<replaceable>PATH TO INIT SCRIPT</replaceable> stop
ExecStopPost=/usr/bin/rm -f <replaceable>PATH TO PID FILE</replaceable><xref linkend="co-service-wrapper-type" xrefstyle="select:label nopage"/>

[Install]
WantedBy=multi-user.target<co xml:id="co-service-wrapper-target"/></screen>
     <para>
      Ersetzen Sie alle Werte in <replaceable>GROSSBUCHSTABEN</replaceable> durch die entsprechenden Werte.
     </para>
     <calloutlist>
      <callout arearefs="co-service-wrapper-type">
       <para>
        Optional; nur zu verwenden, wenn mit dem init-Skript ein Daemon gestartet wird.
       </para>
      </callout>
      <callout arearefs="co-service-wrapper-target">
       <para>
        <literal>multi-user.target</literal> startet ebenfalls das init-Skript, wenn Sie in <literal>graphical.target</literal> booten. Falls der Start nur beim Booten in den Display-Manager erfolgen soll, verwenden Sie hier <literal>graphical.target</literal>.
       </para>
      </callout>
     </calloutlist>
    </step>
    <step>
     <para>
      Starten Sie den Daemon mit <command>systemctl start <replaceable>ANWENDUNG</replaceable></command>.
     </para>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-boot-runlevel-edit">
  <title>Verwalten von Diensten mit YaST</title>

  <para>
   Grundlegende Aufgaben können auch mit dem YaST-Modul Dienste-Verwaltung ausgeführt werden. Hiermit werden das Starten, Stoppen, Aktivieren und Deaktivieren von Diensten unterstützt. Darüber hinaus können Sie den Status eines Dienstes abrufen und das Standardziel ändern. Starten Sie das YaST-Modul mit <menuchoice> <guimenu>YaST</guimenu> <guimenu>System</guimenu> <guimenu>Dienste-Verwaltung</guimenu> </menuchoice>.
  </para>

  <figure xml:id="fig-yast2-runlevel">
   <title>Services Manager</title>
   <mediaobject>
    <imageobject role="fo">
     <imagedata fileref="yast2_runlevel.png" width="75%"/>
    </imageobject>
    <imageobject role="html">
     <imagedata fileref="yast2_runlevel.png" width="75%"/>
    </imageobject>
   </mediaobject>
  </figure>

  <variablelist>
   <varlistentry>
    <term>Ändern des <guimenu>Standard-Systemziels</guimenu></term>
    <listitem>
     <para>
      Zum Ändern des Ziels, in das das System gebootet wird, wählen Sie ein Ziel in der Dropdown-Liste <guimenu>Default System Target</guimenu> aus. Die häufigsten Ziele sind <guimenu>Graphical Interface</guimenu> (Grafische Oberfläche; öffnet einen grafischen Anmeldebildschirm) und <guimenu>Multi-User</guimenu> (Mehrbenutzer; startet das System im Kommandozeilenmodus).
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Starten oder Stoppen eines Dienstes</term>
    <listitem>
     <para>
      Wählen Sie einen Dienst in der Tabelle aus. Die Spalte <guimenu>Aktiv</guimenu> zeigt, ob er derzeit ausgeführt wird (<guimenu>Aktiv</guimenu>) oder nicht (<guimenu>Inaktiv</guimenu>). Mit <guimenu>Starten</guimenu> bzw. <guimenu>Stoppen</guimenu> schalten Sie den Status um.
     </para>
     <para>
      Durch das Starten und Stoppen eines Dienstes wird sein Status für die aktuelle Sitzung geändert. Soll der Status beim Neubooten geändert werden, müssen Sie den Dienst aktivieren oder deaktivieren.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Definieren des Verhaltens beim Starten von Diensten</term>
    <listitem>
     <para>
      Dienste können entweder automatisch bei Booten oder manuell gestartet werden. Wählen Sie einen Dienst in der Tabelle aus. Die Spalte <guimenu>Start</guimenu> zeigt, ob er derzeit gestartet ist <guimenu>Manuell</guimenu> oder <guimenu>Beim Booten</guimenu>. Mit <guimenu>Startmodus</guimenu> schalten Sie den Status um.
     </para>
     <para>
      Um den Status eines Dienstes in der aktuellen Sitzung zu ändern, müssen Sie ihn wie oben beschrieben starten oder stoppen.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Anzeigen von Statusmeldungen</term>
    <listitem>
     <para>
      Zum Anzeigen der Statusmeldungen für einen Dienst wählen Sie den gewünschten Dienst in der Liste aus und wählen Sie <guimenu>Details anzeigen</guimenu>. Die Ausgabe ist mit der Ausgabe des Befehls <command>systemctl</command> <option>-l</option> status <replaceable>MEIN_DIENST</replaceable> identisch.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 xml:id="sec-boot-systemd-custom">
  <title>Anpassen <systemitem>systemd</systemitem></title>

  <para>
   In den folgenden Abschnitten finden Sie einige Beispiele, wie Sie <systemitem>systemd</systemitem> individuell anpassen.
  </para>

  <warning>
   <title>Verhindern des Überschreibens Ihrer Anpassung</title>
   <para>
    Wenn Sie <systemitem class="daemon">systemd</systemitem> anpassen, verwenden Sie stets das Verzeichnis <filename>/etc/systemd/</filename>, <emphasis>nie</emphasis> das Verzeichnis <filename>/usr/lib/systemd/</filename>. Ansonsten werden Ihre Änderungen bei der nächsten Aktualisierung von <systemitem class="daemon">systemd</systemitem> überschrieben.
   </para>
  </warning>

  <sect2 xml:id="sec-boot-systemd-custom-service">
   <title>Anpassen von Unit-Dateien</title>
   <para>
    Zum Anpassen von Unit-Dateien wird das Kommando <command>systemctl edit <replaceable>DIENST</replaceable></command> empfohlen. Dieses Kommando startet den Standardtexteditor und erstellt ein Verzeichnis mit der Datei <filename>override.conf</filename> file unter <filename>/etc/systemd/system/<replaceable>NAME</replaceable>.service.d/</filename>. Das Kommando benachrichtigt außerdem den laufenden <systemitem class="daemon">systemd</systemitem>-Vorgang über die Änderungen.
   </para>
   <para>
    Alternativ können Sie mit dem Kommando <command>systemctl edit --full <replaceable>DIENST</replaceable></command> eine Kopie der Originaldatei zum Bearbeiten anstelle einer leeren Datei öffnen. Achten Sie beim Bearbeiten der Datei darauf, alle vorhandenen Abschnitte beizubehalten.
   </para>
   <para>
    Ändern Sie als Übung den Zeitraum, den das System auf den Start von MariaDB warten soll. Führen Sie als root das Kommando <command>systemctl edit --full mariadb.service</command> aus. Die geöffnete Datei ist in etwa wie folgt aufgebaut:
   </para>
<screen>
[Unit]
Description=MySQL server
Wants=basic.target
Conflicts=mariadb.target
After=basic.target network.target

[Install]
WantedBy=multi-user.target
Alias=mysql.service

[Service]
Restart=on-abort
Type=notify
ExecStartPre=/usr/lib/mysql/mysql-systemd-helper  install
ExecStartPre=/usr/lib/mysql/mysql-systemd-helper  upgrade
ExecStart=/usr/lib/mysql/mysql-systemd-helper     start

# Configures the time to wait for start-up/stop
TimeoutSec=300

# Prevent writes to /usr, /boot, and /etc
ProtectSystem=full

# Prevent accessing /home, /root and /run/user
ProtectHome=true

UMask=007</screen>
   <para>
    Passen Sie den Wert für <literal>TimeoutSec</literal> an und speichern Sie die Änderungen. Zum Aktivieren der Änderungen führen Sie als root das Kommando <command>systemctl daemon-reload</command> aus.
   </para>
   <para>
    Weitere Informationen finden Sie auf den man-Seiten, die Sie mit dem Kommando <command>man 1 systemctl</command> aufrufen können.
   </para>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-custom-drop-in">
   <title>Erstellen von Drop-in-Dateien</title>
   <para>
    Bei kleineren Änderungen an einer Konfigurationsdatei verwenden Sie sogenannte Drop-in-Dateien. Mit den Drop-in-Dateien erweitern Sie die Konfiguration von Unit-Dateien, ohne die Unit-Dateien selbst bearbeiten oder überschreiben zu müssen.
   </para>
   <para>
    Um beispielsweise einen einzigen Wert für den Dienst <replaceable>foobar</replaceable> in <filename>/usr/lib/systemd/system/ <replaceable>foobar.service</replaceable></filename> zu ändern, gehen Sie wie folgt vor:
   </para>
   <procedure>
    <step>
     <para>
      Erstellen Sie ein Verzeichnis mit dem Namen <filename>/etc/systemd/system/<replaceable>FOOBAR</replaceable>.service.d/</filename>.
     </para>
     <para>
      Beachten Sie das Suffix <literal>.d</literal>. Ansonsten muss der Name des Verzeichnisses mit dem Namen des Dienstes übereinstimmen, der mit der Drop-in-Datei gepatcht werden soll.
     </para>
    </step>
    <step>
     <para>
      Erstellen Sie in diesem Verzeichnis eine Datei mit dem Namen <filename><replaceable>your_modification</replaceable>.conf</filename>.
     </para>
     <para>
      Diese Datei darf nur eine Zeile mit dem zu ändernden Wert enthalten.
     </para>
    </step>
    <step>
     <para>
      Speichern Sie Ihre Änderungen in die Datei.
     </para>
    </step>
   </procedure>
   
   <note>
    <title>Vermeiden von Namenskonflikten</title>
    <para>
    Um Namenskonflikte zwischen Ihren Drop-in-Dateien und den von SUSE bereitgestellten Dateien zu vermeiden, wird empfohlen, allen Drop-in-Dateinamen eine zweistellige Zahl und einen Bindestrich voranzustellen, beispielsweise <filename>80-override.conf</filename>.
    </para>
    <para>
     Die folgenden Bereiche sind reserviert:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <literal>0-19</literal> ist für <systemitem class="daemon">systemd</systemitem>-Upstream reserviert
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>20-25</literal> ist für <systemitem class="daemon">systemd</systemitem> reserviert (von SUSE bereitgestellt)
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>26-29</literal> ist für SUSE-Pakete reserviert (außer systemd)
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>50</literal> ist für Drop-in-Dateien reserviert, die mit <command>systemctl set-property</command> erstellt werden.
      </para>
     </listitem>
    </itemizedlist>
    <para>
    Geben Sie eine zweistellige Zahl oberhalb dieses Bereichs an, damit die von SUSE bereitgestellten Drop-in-Dateien Ihre eigenen Drop-in-Dateien nicht überschreiben.
    </para>
    <para>
    Mit <command>systemctl cat $UNIT</command> können Sie die Dateien auflisten und überprüfen, die in der Unit-Konfiguration berücksichtigt werden.
    </para>
   </note>
  </sect2>

  <sect2 xml:id="systemd-xinetd-conversion">
   <title>Konvertieren von <systemitem>xinetd</systemitem>-Diensten in <systemitem class="daemon">systemd</systemitem></title>
   <para>
    Seit der Version <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 15 wurde die <systemitem>xinetd</systemitem>-Infrastruktur entfernt. In diesem Abschnitt wird beschrieben, wie Sie vorhandene benutzerdefinierte <systemitem>xinetd</systemitem>-Dienstdateien in <systemitem class="daemon">systemd</systemitem>-Sockets konvertieren.
   </para>
   <para>
    Für jede <systemitem>xinetd</systemitem>-Dienstdatei benötigen Sie mindestens zwei <systemitem class="daemon">systemd</systemitem>-Unit-Dateien: die Socket-Datei (<filename>*.socket</filename>) und eine zugehörige Dienstdatei (<filename>*.service</filename>). Die Socket-Datei weist <systemitem class="daemon">systemd</systemitem> an, welcher Socket erstellt werden soll, und die Dienstdatei weist <systemitem class="daemon">systemd</systemitem> an, welche ausführbare Datei gestartet werden soll.
   </para>
   <para>
    Betrachten Sie das folgende Beispiel für eine <systemitem>xinetd</systemitem>-Dienstdatei:
   </para>
<screen><prompt role="root"># </prompt>cat /etc/xinetd.d/example
service example
{
  socket_type = stream
  protocol = tcp
  port = 10085
  wait = no
  user = user
  group = users
  groups = yes
  server = /usr/libexec/example/exampled
  server_args = -auth=bsdtcp exampledump
  disable = no
}</screen>
   <para>
    Zum Konvertieren in <systemitem class="daemon">systemd</systemitem> benötigen Sie die folgenden beiden Dateien:
   </para>
<screen><prompt role="root"># </prompt>cat /usr/lib/systemd/system/example.socket
[Socket]
ListenStream=0.0.0.0:10085
Accept=false

[Install]
WantedBy=sockets.target</screen>
<screen><prompt role="root"># </prompt>cat /usr/lib/systemd/system/example.service
[Unit]
Description=example

[Service]
ExecStart=/usr/libexec/example/exampled -auth=bsdtcp exampledump
User=user
Group=users
StandardInput=socket
</screen>
   <para>
    Eine vollständige Liste der Socket- und Dienstdateioptionen für <systemitem class="daemon">systemd</systemitem> finden Sie auf den man-Seiten zu systemd.socket und systemd.service (<command>man 5 systemd.socket</command>, <command>man 5 systemd.service</command>).
   </para>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-custom-targets">
   <title>Erstellen von benutzerdefinierten Zielen</title>
   <para>
    Auf SUSE-Systemen mit System V-init wird Runlevel 4 nicht genutzt, so dass die Administratoren eine eigene Runlevel-Konfiguration erstellen können. Mit <systemitem class="daemon">systemd</systemitem> können Sie beliebig viele benutzerdefinierte Ziele erstellen. Zum Einstieg sollten Sie ein vorhandenes Ziel anpassen, beispielsweise <systemitem>graphical.target</systemitem>.
   </para>
   <procedure>
    <step>
     <para>
      Kopieren Sie die Konfigurationsdatei <filename>/usr/lib/systemd/system/graphical.target</filename> in <filename>/etc/systemd/system/<replaceable>MEIN_ZIEL</replaceable>.target</filename> und passen Sie sie nach Bedarf an.
     </para>
    </step>
    <step>
     <para>
      Die im vorangegangenen Schritt kopierte Konfigurationsdatei enthält bereits die erforderlichen (<quote>harten</quote>) Abhängigkeiten für das Ziel. Um auch die erwünschten (<quote>weichen</quote>) Abhängigkeiten abzudecken, erstellen Sie ein Verzeichnis mit dem Namen <filename>/etc/systemd/system/<replaceable>MEIN_ZIEL</replaceable>.target.wants</filename>.
     </para>
    </step>
    <step>
     <para>
      Legen Sie für jeden erwünschten Dienst einen symbolischen Link von <filename>/usr/lib/systemd/system</filename> in <filename>/etc/systemd/system/<replaceable>MEIN_ZIEL</replaceable>.target.wants</filename> an.
     </para>
    </step>
    <step>
     <para>
      Sobald Sie alle Einstellungen für das Ziel festgelegt haben, laden Sie die <systemitem class="daemon">systemd</systemitem>-Konfiguration neu. Damit wird das neue Ziel verfügbar:
     </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl daemon-reload</screen>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-boot-systemd-advanced">
  <title>Erweiterte Nutzung</title>

  <para>
   In den nachfolgenden Abschnitten finden Sie weiterführende Themen für Systemadministratoren. Eine noch eingehendere Dokumentation zu <systemitem class="daemon">systemd</systemitem> finden Sie in der Serie von Lennart Pöttering zu <systemitem class="daemon">systemd</systemitem> für Administratoren unter <link xlink:href="http://0pointer.de/blog/projects"/>.
  </para>

  <sect2 xml:id="sec-boot-systemd-advanced-tmp">
   <title>Bereinigen von temporären Verzeichnissen</title>
   <para>
    <systemitem class="daemon">systemd</systemitem> unterstützt das regelmäßige Bereinigen der temporären Verzeichnisse. Die Konfiguration aus der bisherigen Systemversion wird automatisch migriert und ist aktiv. <literal>tmpfiles.d</literal> (verwaltet temporäre Dateien) liest die Konfiguration aus den Dateien <filename>/etc/tmpfiles.d/*.conf</filename>, <filename>/run/tmpfiles.d/*.conf</filename> und <filename>/usr/lib/tmpfiles.d/*.conf</filename> aus. Die Konfiguration in <filename>/etc/tmpfiles.d/*.conf</filename> hat Vorrang vor ähnlichen Konfigurationen in den anderen beiden Verzeichnissen. (In <filename>/usr/lib/tmpfiles.d/*.conf</filename> speichern die Pakete die Konfigurationsdateien.)
   </para>
   <para>
    Im Konfigurationsformat ist eine Zeile pro Pfad vorgeschrieben, wobei diese Zeile die Aktion und den Pfad enthalten muss und optional Felder für Modus, Eigentümer, Alter und Argument (je nach Aktion) enthalten kann. Im folgenden Beispiel wird die Verknüpfung der X11-Sperrdateien aufgehoben:
   </para>
<screen>Type Path               Mode UID  GID  Age Argument
r    /tmp/.X[0-9]*-lock</screen>
   <para>
    So rufen Sie den Status aus dem tmpfile-Zeitgeber ab:
   </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl status systemd-tmpfiles-clean.timer
systemd-tmpfiles-clean.timer - Daily Cleanup of Temporary Directories
 Loaded: loaded (/usr/lib/systemd/system/systemd-tmpfiles-clean.timer; static)
 Active: active (waiting) since Tue 2018-04-09 15:30:36 CEST; 1 weeks 6 days ago
   Docs: man:tmpfiles.d(5)
         man:systemd-tmpfiles(8)

Apr 09 15:30:36 jupiter systemd[1]: Starting Daily Cleanup of Temporary Directories.
Apr 09 15:30:36 jupiter systemd[1]: Started Daily Cleanup of Temporary Directories.</screen>
   <para>
    Weitere Informationen zum Arbeiten mit temporären Dateien finden Sie unter <command>man 5 tmpfiles.d</command>.
   </para>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-advanced-logging">
   <title>Systemprotokoll</title>
   <para>
    In <xref linkend="sec-boot-systemd-basics-services-debugging"/> wird erläutert, wie Sie Protokollmeldungen für einen bestimmten Dienst anzeigen. Die Anzeige von Protokollmeldungen ist allerdings nicht auf Dienstprotokolle beschränkt. Sie können auch auf das gesamte von <systemitem class="daemon">systemd</systemitem> geschriebene Protokoll (das sogenannte <quote>Journal</quote>) zugreifen und Abfragen darauf ausführen. Mit dem Befehl <command>journalctl</command> zeigen Sie das gesamte Protokoll an, beginnend mit den ältesten Einträgen. Informationen zu weiteren Optionen, beispielsweise zum Anwenden von Filtern oder zum Ändern des Ausgabeformats, finden Sie unter <command>man 1 journalctl</command>.
   </para>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-advanced-snapshots">
   <title>Aufnahmen</title>
   <para>
    Mit dem Subkommando <systemitem class="daemon">systemd</systemitem> können Sie den aktuellen Status von <command>isolate</command> als benannten Snapshot speichern und später wiederherstellen. Dies ist beim Testen von Diensten oder benutzerdefinierten Zielen hilfreich, weil Sie jederzeit zu einem definierten Status zurückkehren können. Ein Snapshot ist nur in der aktuellen Sitzung verfügbar; beim Neubooten wird er automatisch gelöscht. Der Snapshot-Name muss auf <filename>.snapshot</filename> enden.
   </para>
   <variablelist>
    <varlistentry>
     <term>Erstellen eines Snapshots</term>
     <listitem>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl snapshot <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Löschen eines Snapshots</term>
     <listitem>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl delete <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Anzeigen eines Snapshots</term>
     <listitem>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl show <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Aktivieren eines Snapshots</term>
     <listitem>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl isolate <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  

  

  <sect2 xml:id="sec-boot-systemd-advanced-kernel-modules">
   <title>Laden der Kernelmodule</title>
   <para>
    Mit <systemitem class="daemon">systemd</systemitem> können Kernel-Module automatisch zum Bootzeitpunkt geladen werden, und zwar über die Konfigurationsdatei in <filename>/etc/modules-load.d</filename>. Die Datei sollte den Namen <replaceable>MODUL</replaceable>.conf haben und den folgenden Inhalt aufweisen:
   </para>
<screen># load module <replaceable>MODULE</replaceable> at boot time
<replaceable>MODULE</replaceable></screen>
   <para>
    Falls ein Paket eine Konfigurationsdatei zum Laden eines Kernel-Moduls installiert, wird diese Datei unter <filename>/usr/lib/modules-load.d</filename> installiert. Wenn zwei Konfigurationsdateien mit demselben Namen vorhanden sind, hat die Datei unter <filename>/etc/modules-load.d</filename> Vorrang.
   </para>
   <para>
    Weitere Informationen finden Sie auf der man-Seite zu <systemitem>modules-load.d(5)</systemitem>.
   </para>
  </sect2>

  

  <sect2 xml:id="sec-boot-systemd-advanced-before-local">
   <title>Ausführen von Aktionen vor dem Laden eines Dienstes</title>
   <para>
    Bei System V mussten init-Aktionen, die vor dem Laden eines Diensts ausgeführt werden müssen, in <filename>/etc/init.d/before.local</filename> festgelegt werden. Dieses Verfahren wird in <systemitem class="daemon">systemd</systemitem> nicht mehr unterstützt. Wenn Aktionen vor dem Starten von Diensten ausgeführt werden müssen, gehen Sie wie folgt vor:
   </para>
   <variablelist>
    <varlistentry>
     <term>Laden der Kernelmodule</term>
     <listitem>
      <para>
       Erstellen Sie eine Drop-in-Datei im Verzeichnis <filename>/etc/modules-load.d</filename> (Syntax siehe <command>man modules-load.d</command>).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Erstellen von Dateien oder Verzeichnissen, Bereinigen von Verzeichnissen, Ändern des Eigentümers</term>
     <listitem>
      <para>
       Erstellen Sie eine Drop-in-Datei in <filename>/etc/tmpfiles.d</filename> (Syntax siehe <command>man tmpfiles.d</command>).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Weitere Aufgaben</term>
     <listitem>
      <para>
       Erstellen Sie eine Systemdienstdatei (beispielsweise <filename>/etc/systemd/system/before.service</filename>) anhand der folgenden Schablone:
      </para>
<screen>[Unit]
Before=<replaceable>NAME OF THE SERVICE YOU WANT THIS SERVICE TO BE STARTED BEFORE</replaceable>
[Service]
Type=oneshot
RemainAfterExit=true
ExecStart=<replaceable>YOUR_COMMAND</replaceable>
# beware, executable is run directly, not through a shell, check the man pages
# systemd.service and systemd.unit for full syntax
[Install]
# target in which to start the service
WantedBy=multi-user.target
#WantedBy=graphical.target</screen>
      <para>
       Sobald die Dienstdatei erstellt ist, führen Sie die folgenden Kommandos aus (als <systemitem class="username">root</systemitem>):
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl daemon-reload
<prompt>&gt; </prompt><command>sudo</command> systemctl enable before</screen>
      <para>
       Bei jedem Bearbeiten der Dienstdatei müssen Sie Folgendes ausführen:
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl daemon-reload</screen>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  

  <sect2 xml:id="sec-boot-systemd-advanced-cgroups">
   <title>Kernel-Steuergruppen (cgroups)</title>
   <para>
    Auf einem traditionellen System-V-init-System kann ein Prozess nicht immer eindeutig dem Dienst zugeordnet werden, durch den er erzeugt wurde. Einige Dienste (z. B. Apache) erzeugen zahlreiche externe Prozesse (z. B. CGI- oder Java-Prozesse), die wiederum weitere Prozesse erzeugen. Eindeutige Zuweisungen sind damit schwierig oder völlig unmöglich. Wenn ein Dienst nicht ordnungsgemäß beendet wird, bleiben zudem ggf. einige untergeordnete Dienste weiterhin aktiv.
   </para>
   <para>
    Bei <systemitem class="daemon">systemd</systemitem> wird jeder Dienst in eine eigene cgroup aufgenommen, womit dieses Problem gelöst ist. cgroups sind eine Kernel-Funktion, mit der die Prozesse mit allen ihren untergeordneten Prozessen in hierarchisch strukturierten Gruppen zusammengefasst werden. <systemitem class="daemon">systemd</systemitem> benennt die cgroups dabei nach dem jeweiligen Dienst. Da ein nicht privilegierter Dienst seine cgroup nicht <quote>verlassen</quote> darf, ist es damit möglich, alle von einem Dienst erzeugten Prozesse mit dem Namen dieses Dienstes zu versehen.
   </para>
   <para>
    Mit dem Kommando <command>systemd-cgls</command> erhalten Sie eine Liste aller Prozesse, die zu einem Dienst gehören. (Gekürztes) Beispiel für die Ausgabe:
   </para>
   <example>
    <title>Auflisten aller Prozesse, die zu einem Dienst gehören</title>
<screen><prompt role="root"># </prompt>systemd-cgls --no-pager
├─1 /usr/lib/systemd/systemd --switched-root --system --deserialize 20
├─user.slice
│ └─user-1000.slice
│   ├─session-102.scope
│   │ ├─12426 gdm-session-worker [pam/gdm-password]
│   │ ├─15831 gdm-session-worker [pam/gdm-password]
│   │ ├─15839 gdm-session-worker [pam/gdm-password]
│   │ ├─15858 /usr/lib/gnome-terminal-server

[...]

└─system.slice
  ├─systemd-hostnamed.service
  │ └─17616 /usr/lib/systemd/systemd-hostnamed
  ├─cron.service
  │ └─1689 /usr/sbin/cron -n
  ├─postfix.service
  │ ├─ 1676 /usr/lib/postfix/master -w
  │ ├─ 1679 qmgr -l -t fifo -u
  │ └─15590 pickup -l -t fifo -u
  ├─sshd.service
  │ └─1436 /usr/sbin/sshd -D

[...]</screen>
   </example>
   <para>
    Weitere Informationen zu cpgroups finden Sie im <xref linkend="cha-tuning-cgroups"/>.
   </para>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-advanced-kill">
   <title>Beenden von Diensten (Senden von Signalen)</title>
   <para>
    Wie in <xref linkend="sec-boot-systemd-advanced-cgroups"/> erläutert, kann ein Prozess in einem System-V-init-System nicht immer eindeutig seinem übergeordneten Dienstprozess zugeordnet werden. Das erschwert das Beenden eines Dienstes und seiner untergeordneten Dienste. Untergeordnete Prozesse, die nicht ordnungsgemäß beendet wurden, bleiben als &quot;Zombie-Prozess&quot; zurück.
   </para>
   <para>
    Durch das Konzept von <systemitem class="daemon">systemd</systemitem>, mit dem jeder Dienst in einer eigenen cgroup abgegrenzt wird, können alle untergeordneten Prozesse eines Dienstes eindeutig erkannt werden, sodass Sie ein Signal zu diesen Prozessen senden können. Mit Use <command>systemctl kill</command> senden Sie die Signale an die Dienste. Eine Liste der verfügbaren Signale finden Sie in <command>man 7 signals</command>.
   </para>
   <variablelist>
    <varlistentry>
     <term>Senden von <systemitem>SIGTERM</systemitem> an einen Dienst</term>
     <listitem>
      <para>
       <systemitem>SIGTERM</systemitem> ist das standardmäßig gesendete Signal.
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl kill <replaceable>MY_SERVICE</replaceable></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Senden von <replaceable>SIGNAL</replaceable> an einen Dienst</term>
     <listitem>
      <para>
       Mit der Option <option>-s</option> legen Sie das zu sendende Signal fest.
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl kill -s <replaceable>SIGNAL</replaceable> <replaceable>MY_SERVICE</replaceable></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Auswählen von Prozessen</term>
     <listitem>
      <para>
       Standardmäßig sendet das Kommando <command>kill</command> das Signal an <option>alle</option> Prozesse der angegebenen cgroup. Sie können dies jedoch auf den Prozess <option>control</option> oder <option>main</option> beschränken. Damit können Sie beispielsweise das Neuladen der Konfiguration eines Dienstes mit dem Signal <systemitem>SIGHUP</systemitem> erzwingen:
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl kill -s SIGHUP --kill-who=main <replaceable>MY_SERVICE</replaceable></screen>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-dbus">
   <title>Wichtige Hinweise zum D-Bus-Dienst</title>
   <para>
    Der D-Bus-Dienst fungiert als Meldungsbus für die Kommunikation zwischen den <systemitem class="daemon">systemd</systemitem>-Clients und dem systemd-Manager, der als PID 1 ausgeführt wird. <systemitem class="daemon">dbus</systemitem> ist zwar ein eigenständiger Dämon, bildet jedoch auch einen wesentlichen Bestandteil der init-Infrastruktur.
   </para>
   <para>
    Das Beenden von <systemitem class="daemon">dbus</systemitem> oder das Neustarten im laufenden System entspricht dem Versuch, PID 1 zu beenden oder neu zu starten. Hiermit wird die <systemitem class="daemon">systemd</systemitem>-Client/Server-Kommunikation unterbrochen, sodass die meisten <systemitem class="daemon">systemd</systemitem>-Funktionen unbrauchbar werden.
   </para>
   <para>
    Das Beenden oder Neustarten von <systemitem class="daemon">dbus</systemitem> wird daher weder empfohlen noch unterstützt.
   </para>
   <para>
    Nach einer Aktualisierung von <systemitem>dbus</systemitem> oder <systemitem>dbus</systemitem>-Paketen fällt ein Neustart an. Wenn Sie sich nicht sicher sind, ob ein Neustart erforderlich ist, führen Sie den Befehl <command>sudo zypper ps -s</command> aus. Ist <literal>dbus</literal> unter den aufgelisteten Diensten zu finden, müssen Sie das System neu starten.
   </para>
   <para>
    Beachten Sie, dass <systemitem>dbus</systemitem> selbst dann aktualisiert wird, wenn in der Konfiguration der automatischen Aktualisierungen festgelegt ist, dass die Pakete, die einen Neustart erfordern, übersprungen werden sollen.
   </para>
  </sect2>

  

  <sect2 xml:id="sec-boot-systemd-basics-services-debugging">
   <title>Fehlersuche für Dienste</title>
   <para>
    Standardmäßig ist die Ausgabe von <systemitem class="daemon">systemd</systemitem> auf ein Minimum beschränkt. Wenn ein Dienst ordnungsgemäß gestartet wurde, erfolgt keine Ausgabe. Bei einem Fehler wird eine kurze Fehlermeldung angezeigt. Mit <command>systemctl status</command> können Sie jedoch die Fehlersuche für den Start und die Ausführung eines Dienstes vornehmen.
   </para>
   <para>
    <systemitem class="daemon">systemd</systemitem> umfasst einen Protokollierungsmechanismus (<quote>Journal</quote>), mit dem die Systemmeldungen protokolliert werden. Auf diese Weise können Sie die Dienstmeldungen zusammen mit den Statusmeldungen abrufen. Das Kommando <command>status</command> hat eine ähnliche Funktion wie <command>tail</command> und kann zudem die Protokollmeldungen in verschiedenen Formaten anzeigen, ist also ein wirksames Hilfsmittel für die Fehlersuche.
   </para>
   <variablelist>
    <varlistentry>
     <term>Anzeigen von Fehlern beim Starten von Diensten</term>
     <listitem>
      <para>
       Wenn ein Dienst nicht gestartet wird, erhalten Sie mit <command>systemctl status <replaceable>MEIN_DIENST</replaceable></command> eine ausführliche Fehlermeldung:
      </para>
<screen><prompt role="root"># </prompt>systemctl start apache2
Job failed. See system journal and 'systemctl status' for details.
<prompt role="root"># </prompt>systemctl status apache2
   Loaded: loaded (/usr/lib/systemd/system/apache2.service; disabled)
   Active: failed (Result: exit-code) since Mon, 04 Apr 2018 16:52:26 +0200; 29s ago
   Process: 3088 ExecStart=/usr/sbin/start_apache2 -D SYSTEMD -k start (code=exited, status=1/FAILURE)
   CGroup: name=systemd:/system/apache2.service

Apr 04 16:52:26 g144 start_apache2[3088]: httpd2-prefork: Syntax error on line
205 of /etc/apache2/httpd.conf: Syntax error on li...alHost&gt;</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Anzeigen der letzten <replaceable>n</replaceable> Dienstmeldungen</term>
     <listitem>
      <para>
       Standardmäßig zeigt das Subkommando <command>status</command> die letzten zehn Meldungen an, die ein Dienst ausgegeben hat. Mit dem Parameter <option>--lines=<replaceable>n</replaceable></option> legen Sie eine andere Anzahl fest:
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl status chronyd
<prompt>&gt; </prompt><command>sudo</command> systemctl --lines=20 status chronyd</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Anzeigen von Dienstmeldungen im Anhängemodus</term>
     <listitem>
      <para>
       Mit der Option <quote>--follow</quote> erhalten Sie einen <option>Live-Stream</option> mit Dienstmeldungen; diese Option entspricht <command>tail </command> <option>-f</option>:
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl --follow status chronyd</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Ausgabeformat der Meldungen</term>
     <listitem>
      <para>
       Mit dem Parameter <option>--output=<replaceable>mode</replaceable></option> legen Sie das Ausgabeformat für die Dienstmeldungen fest. Die wichtigsten Modi sind:
      </para>
      <variablelist>
       <varlistentry>
        <term><option>short</option></term>
        <listitem>
         <para>
          Das Standardformat. Zeigt die Protokollmeldungen mit einem Zeitstempel in Klartext an.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><option>verbose</option></term>
        <listitem>
         <para>
          Vollständige Ausgabe mit sämtlichen Feldern.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><option>cat</option></term>
        <listitem>
         <para>
          Kurze Ausgabe ohne Zeitstempel.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-boot-systemd-timer-units">
  <title><systemitem class="daemon">systemd</systemitem>-Zeitgeber-Units</title>

  <para>
   Ähnlich wie Cron bieten <systemitem class="daemon">systemd</systemitem>-Zeitgeber-Units einen Mechanismus für die Planung von Aufträgen unter Linux. Die <systemitem class="daemon">systemd</systemitem>-Zeitgeber-Units dienen zwar demselben Zweck wie Cron, eröffnen allerdings mehrere Vorteile.
  </para>

  <itemizedlist>
   <listitem>
    <para>
     Aufträge, die mit einer Zeitgeber-Unit geplant werden, können von anderen <systemitem class="daemon">systemd</systemitem>-Diensten abhängig sein.
    </para>
   </listitem>
   <listitem>
    <para>
     Zeitgeber-Units werden wie normale <systemitem class="daemon">systemd</systemitem>-Dienste behandelt und können daher mit <command>systemctl</command> verwaltet werden.
    </para>
   </listitem>
   <listitem>
    <para>
     Die Zeitgeber können in Echtzeit und monoton sein.
    </para>
   </listitem>
   <listitem>
    <para>
     Die Zeit-Units werden im <systemitem class="daemon">systemd</systemitem>-Journal protokolliert, wodurch ihre Verwaltung und Fehlerbehebung vereinfacht werden.
    </para>
   </listitem>
  </itemizedlist>

  <para>
   <systemitem class="daemon">systemd</systemitem>-Zeitgeber-Units sind mit der Dateinamenerweiterung <literal>.timer</literal> gekennzeichnet.
  </para>

  <sect2 xml:id="sec-boot-systemd-timer-types">
   <title><systemitem class="daemon">systemd</systemitem>-Zeitgebertypen</title>
   <para>
    Zeitgeber-Units können monotone Zeitgeber und Echtzeit-Zeitgeber nutzen.
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Ähnlich wie Cronjobs werden Echtzeit-Zeitgeber durch Kalenderereignisse ausgelöst. Echtzeit-Zeitgeber werden mit der Option <option>OnCalendar</option> definiert.
     </para>
    </listitem>
    <listitem>
     <para>
      Monotone Zeitgeber werden ausgelöst, sobald ein angegebener Zeitraum nach einem bestimmten Startpunkt vergangen ist. Dies ist beispielsweise ein Systemstart-Ereignis oder ein System-Unit-Aktivierungsereignis. Für die Definition von monotonen Zeitgebern stehen mehrere Optionen zur Auswahl, u. a. <option>OnBootSec</option>, <option>OnUnitActiveSec</option> und <option>OnTypeSec</option>. Monotone Zeitgeber sind nicht permanent und werden nach jedem Neustart zurückgesetzt.
     </para>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-timer-service-units">
   <title><systemitem class="daemon">systemd</systemitem>-Zeitgeber und Dienst-Units</title>
   <para>
    Für jede Zeitgeber-Unit muss eine entsprechende <systemitem class="daemon">systemd</systemitem>-Unit-Datei vorliegen, die durch die Zeitgeber-Unit gesteuert wird. Anders gesagt, eine <filename>.timer</filename>-Datei aktiviert und verwaltet die zugehörige <filename>.service</filename>-Datei. Wird eine <filename>.service</filename>-Datei mit einem Zeitgeber verwendet, muss die Datei keinen Abschnitt <literal>[Install]</literal> enthalten, da der Dienst durch den Zeitgeber verwaltet wird.
   </para>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-timer-example">
   <title>Beispiel aus der Praxis</title>
   <para>
    Zur Veranschaulichung der Grundlagen von <systemitem class="daemon">systemd</systemitem>-Zeitgeber-Units soll ein Zeitgeber eingerichtet werden, der das Shell-Skript <filename>foo.sh</filename> auslöst.
   </para>
   <para>
    Im ersten Schritt erstellen Sie eine <systemitem class="daemon">systemd</systemitem>-Dienst-Unit, die das Shell-Skript steuert. Öffnen Sie hierzu eine neue Textdatei zum Bearbeiten und fügen Sie folgende Dienst-Unit-Definition hinzu:
   </para>
<screen>[Unit]
Description="Foo shell script"

[Service]
ExecStart=/usr/local/bin/foo.sh</screen>
   <para>
    Speichern Sie die Datei unter dem Namen <filename>foo.service</filename> im Verzeichnis <filename>/etc/systemd/system/</filename>.
   </para>
   <para>
    Öffnen Sie dann eine neue Textdatei zum Bearbeiten und fügen Sie folgende Zeitgeberdefinition hinzu:
   </para>
<screen>[Unit]
Description="Run foo shell script"

[Timer]
OnBootSec=5min
OnUnitActiveSec=24h
Unit=foo.service

[Install]
WantedBy=multi-user.target</screen>
   <para>
    Der Abschnitt <literal>[Timer]</literal> im obigen Beispiel gibt an, welcher Dienst (<literal>foo.service</literal>) zu welchem Zeitpunkt ausgelöst werden soll. In diesem Fall gibt die Option <option>OnBootSec</option> einen monotonen Zeitgeber an, der den Dienst fünf Minuten nach Systemstart auslöst, während die Option <option>OnUnitActiveSec</option> den Dienst 24 Stunden nach Aktivierung des Dienstes auslöst (der Zeitgeber löst den Dienst also einmal täglich aus). Die Option <option>WantedBy</option> gibt schließlich an, dass der Zeitgeber gestartet werden soll, sobald das System das Mehrbenutzerziel erreicht hat.
   </para>
   <para>
    Anstelle eines monotonen Zeitgebers können Sie mit der Option <option>OnCalendar</option> einen Echtzeit-Zeitgeber angeben. Die folgende Echtzeit-Zeitgeberdefinition löst die zugehörige Dienst-Unit einmal wöchentlich aus, beginnend am Montag um 12:00 Uhr.
   </para>
<screen>[Timer]
OnCalendar=weekly
Persistent=true</screen>
   <para>
    Die Option <option>Persistent=true</option> gibt an, dass der Dienst sofort nach Aktivierung des Zeitgebers ausgelöst wird, falls der Zeitgeber die letzte Startzeit versäumt hat (z. B. weil das System ausgeschaltet war).
   </para>
   <para>
    Mit der Option <option>OnCalendar</option> können außerdem bestimmte Zeitpunkte (Datum und Uhrzeit) für die Auslösung eines Dienstes im folgenden Format definiert werden: <literal>Wochentag Jahr-Monat-Tag Stunde:Minute:Sekunde</literal>. Im folgenden Beispiel wird ein Dienst täglich um 5:00 Uhr gestartet:
   </para>
<screen>OnCalendar=*-*-* 5:00:00</screen>
   <para>
    Ein Sternchen bezeichnet einen beliebigen Wert und mögliche Werte können durch Komma getrennt aufgelistet werden. Verwenden Sie zwei durch .. getrennte Werte, um einen zusammenhängenden Bereich anzugeben. Im folgenden Beispiel wird ein Dienst an jedem Freitag
im Monat um 18:00 Uhr gestartet:
   </para>
<screen>OnCalendar=Fri *-*-1..7 18:00:00</screen>
   <para>
    Soll ein Dienst zu verschiedenen Zeiten ausgelöst werden, können Sie mehrere <option>OnCalendar</option>-Einträge angeben:
   </para>
<screen>OnCalendar=Mon..Fri 10:00
OnCalendar=Sat,Sun 22:00</screen>
   <para>
    Im obigen Beispiel wird ein Dienst an Wochentagen um 10:00 Uhr und am Wochenende um 22:00 Uhr ausgelöst.
   </para>
   <para>
    Wenn Sie die Zeitgeber-Unit-Datei bearbeitet haben, speichern Sie sie unter dem Namen <filename>foo.timer</filename> im Verzeichnis <filename>/etc/systemd/system/</filename>. Prüfen Sie die erstellten Unit-Dateien mit folgendem Kommando:
   </para>
<screen><prompt>&gt; </prompt><command>sudo</command>  systemd-analyze verify /etc/systemd/system/foo.*</screen>
   <para>
    Wenn das Kommando keine Ausgabe zurückgibt, haben die Dateien die Überprüfung erfolgreich bestanden.
   </para>
   <para>
    Starten Sie den Zeitgeber mit dem Kommando <command>sudo systemctl start foo.timer</command>. Soll der Zeitgeber beim Starten aktiviert werden, führen Sie das Kommando <command>sudo systemctl enable foo.timer</command> aus.
   </para>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-timer-manage">
   <title>Verwalten von <systemitem class="daemon">systemd</systemitem>-Zeitgebern</title>
   <para>
    Da Zeitgeber wie normale <systemitem class="daemon">systemd</systemitem>-Units behandelt werden, können Sie sie mit <command>systemctl</command> verwalten. Sie können einen Zeitgeber mit <command>systemctl start</command> starten, mit <command>systemctl enable</command> aktivieren usw. Außerdem können Sie mit dem Kommando <command>systemctl list-timers</command> alle aktiven Zeitgeber auflisten. Mit dem Kommando <command>systemctl list-timers --all</command> werden alle Zeitgeber aufgelistet, auch wenn sie inaktiv sind.
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-boot-systemd-info">
  <title>Weitere Informationen</title>

  <para>
   Weitere Informationen zu <systemitem class="daemon">systemd</systemitem> finden Sie in folgenden Online-Quellen:
  </para>

  <variablelist>
   <varlistentry>
    <term>Startseite</term>
    <listitem>
     <para>
      <link xlink:href="http://www.freedesktop.org/wiki/Software/systemd"/>
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><systemitem class="daemon">systemd</systemitem> für Administratoren</term>
    <listitem>
     <para>
      Lennart Pöttering, einer der <systemitem class="daemon">systemd</systemitem>-Autoren, hat eine Serie von Blogeinträgen verfasst. (Zum Zeitpunkt, als dieses Kapitel verfasst wurde, standen bereits 13 Einträge zur Verfügung.) Diese sind unter <link xlink:href="http://0pointer.de/blog/projects"/> zu finden.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
</chapter>
