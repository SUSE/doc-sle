<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>

<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="cha.network">
 <title>Basic Networking</title>
 <info>
  <abstract>
   <para>
    Linux offers the necessary networking tools and features for integration
    into all types of network structures. Network access using a network card
    can be configured with &yast;. Manual configuration is also possible. In
    this chapter only the fundamental mechanisms and the relevant network
    configuration files are covered.
   </para>
  </abstract>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker></dm:bugtracker>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>
 <para>
  Linux and other Unix operating systems use the TCP/IP protocol. It is not a
  single network protocol, but a family of network protocols that offer various
  services. The protocols listed in <xref linkend="tab.net.basic.tcpproto"/>,
  are provided for exchanging data between two machines via TCP/IP. Networks
  combined by TCP/IP, comprising a worldwide network, are also called
  <quote>the Internet.</quote>
 </para>
 <para>
  RFC stands for <emphasis>Request for Comments</emphasis>. RFCs are documents
  that describe various Internet protocols and implementation procedures for
  the operating system and its applications. The RFC documents describe the
  setup of Internet protocols. For more information about RFCs, see
  <link xlink:href="http://www.ietf.org/rfc.html"/>.
 </para>
 <variablelist xml:id="tab.net.basic.tcpproto">
  <title>Several Protocols in the TCP/IP Protocol Family</title>
  <varlistentry>
   <term>TCP</term>
   <listitem>
    <para>
     Transmission Control Protocol: a connection-oriented secure protocol. The
     data to transmit is first sent by the application as a stream of data and
     converted into the appropriate format by the operating system. The data
     arrives at the respective application on the destination host in the
     original data stream format it was initially sent. TCP determines whether
     any data has been lost or jumbled during the transmission. TCP is
     implemented wherever the data sequence matters.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>UDP</term>
   <listitem>
    <para>
     User Datagram Protocol: a connectionless, insecure protocol. The data to
     transmit is sent in the form of packets generated by the application. The
     order in which the data arrives at the recipient is not guaranteed and
     data loss is possible. UDP is suitable for record-oriented applications.
     It features a smaller latency period than TCP.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>ICMP</term>
   <listitem>
    <para>
     Internet Control Message Protocol: This is not a protocol for
     the end user, but a special control protocol that issues error reports and
     can control the behavior of machines participating in TCP/IP data
     transfer. In addition, it provides a special echo mode that can be viewed
     using the program ping.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>IGMP</term>
   <listitem>
    <para>
     Internet Group Management Protocol: This protocol controls machine
     behavior when implementing IP multicast.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
 <para>
  As shown in <xref linkend="fig.net.basic.OSI"/>, data exchange takes place in
  different layers. The actual network layer is the insecure data transfer via
  IP (Internet protocol). On top of IP, TCP (transmission control protocol)
  guarantees, to a certain extent, security of the data transfer. The IP layer
  is supported by the underlying hardware-dependent protocol, such as Ethernet.
 </para>
 <figure xml:id="fig.net.basic.OSI">
  <title>Simplified Layer Model for TCP/IP</title>
  <mediaobject>
   <imageobject role="fo">
    <imagedata width="100%" fileref="net_basic_osi.svg" format="SVG"/>
   </imageobject>
   <imageobject role="html">
    <imagedata width="75%" fileref="net_basic_osi.png" format="PNG"/>
   </imageobject>
  </mediaobject>
 </figure>
 <para>
  The diagram provides one or two examples for each layer. The layers are
  ordered according to <emphasis>abstraction levels</emphasis>. The lowest
  layer is very close to the hardware. The uppermost layer, however, is almost
  a complete abstraction from the hardware. Every layer has its own special
  function. The special functions of each layer are mostly implicit in their
  description. The data link and physical layers represent the physical network
  used, such as Ethernet.
 </para>
 <para>
  Almost all hardware protocols work on a packet-oriented basis. The data to
  transmit is collected into <emphasis>packets</emphasis> (it cannot be sent
  all at once). The maximum size of a TCP/IP packet is approximately 64 KB.
  Packets are normally quite smaller, as the network hardware can be a limiting
  factor. The maximum size of a data packet on an Ethernet is about fifteen
  hundred bytes. The size of a TCP/IP packet is limited to this amount when the
  data is sent over an Ethernet. If more data is transferred, more data packets
  need to be sent by the operating system.
 </para>
 <para>
  For the layers to serve their designated functions, additional information
  regarding each layer must be saved in the data packet. This takes place in
  the <emphasis>header</emphasis> of the packet. Every layer attaches a small
  block of data, called the protocol header, to the front of each emerging
  packet. A sample TCP/IP data packet traveling over an Ethernet cable is
  illustrated in <xref linkend="fig.net.basic.TCPPaket"/>. The proof sum is
  located at the end of the packet, not at the beginning. This simplifies
  things for the network hardware.
 </para>
 <figure xml:id="fig.net.basic.TCPPaket">
  <title>TCP/IP Ethernet Packet</title>
  <mediaobject>
   <imageobject role="fo">
    <imagedata width="80%" fileref="net_basic_tcppacket.svg" format="SVG"/>
   </imageobject>
   <imageobject role="html">
    <imagedata width="75%" fileref="net_basic_tcppacket.png" format="PNG"/>
   </imageobject>
  </mediaobject>
 </figure>
 <para>
  When an application sends data over the network, the data passes through each
  layer, all implemented in the Linux kernel except the physical layer. Each
  layer is responsible for preparing the data so it can be passed to the next
  layer. The lowest layer is ultimately responsible for sending the data. The
  entire procedure is reversed when data is received. Like the layers of an
  onion, in each layer the protocol headers are removed from the transported
  data. Finally, the transport layer is responsible for making the data
  available for use by the applications at the destination. In this manner, one
  layer only communicates with the layer directly above or below it. For
  applications, it is irrelevant whether data is transmitted via a 100 Mbit/s
  FDDI network or via a 56-Kbit/s modem line. Likewise, it is irrelevant for
  the data line which kind of data is transmitted, as long as packets are in
  the correct format.
 </para>
 <sect1 xml:id="sec.network.addresses">
  <title>IP Addresses and Routing</title>

  <para>
   The discussion in this section is limited to IPv4 networks. For information
   about IPv6 protocol, the successor to IPv4, refer to
   <xref linkend="sec.network.ipv6"/>.
  </para>

  <sect2 xml:id="sec.network.addresses.ip">
   <title>IP Addresses</title>
   <para>
    Every computer on the Internet has a unique 32-bit address. These 32 bits
    (or 4 bytes) are normally written as illustrated in the second row in
    <xref linkend="aus.net.basic.ipaddress"/>.
   </para>
   <example xml:id="aus.net.basic.ipaddress">
    <title>Writing IP Addresses</title>
<screen>IP Address (binary):  11000000 10101000 00000000 00010100
IP Address (decimal):      192.     168.       0.      20</screen>
   </example>
   <para>
    In decimal form, the four bytes are written in the decimal number system,
    separated by periods. The IP address is assigned to a host or a network
    interface. It can be used only once throughout the world. There are
    exceptions to this rule, but these are not relevant to the following
    passages.
   </para>
   <para>
    The points in IP addresses indicate the hierarchical system. Until the
    1990s, IP addresses were strictly categorized in classes. However, this
    system proved too inflexible and was discontinued. Now, <emphasis>classless
    routing</emphasis> (CIDR, classless interdomain routing) is used.
   </para>
  </sect2>

  <sect2 xml:id="sec.network.addresses.route">
   <title>Netmasks and Routing</title>
   <para>
    Netmasks are used to define the address range of a subnet. If two hosts are
    in the same subnet, they can reach each other directly. If they are not in
    the same subnet, they need the address of a gateway that handles all the
    traffic for the subnet. To check if two IP addresses are in the same
    subnet, simply <quote>AND</quote> both addresses with the netmask. If the
    result is identical, both IP addresses are in the same local network. If
    there are differences, the remote IP address, and thus the remote
    interface, can only be reached over a gateway.
   </para>
   <para>
    To understand how the netmask works, look at
    <xref linkend="tab.net.basic.netmask"/>. The netmask consists of 32 bits
    that identify how much of an IP address belongs to the network. All those
    bits that are <literal>1</literal> mark the corresponding bit in the IP
    address as belonging to the network. All bits that are <literal>0</literal>
    mark bits inside the subnet. This means that the more bits are
    <literal>1</literal>, the smaller the subnet is. Because the netmask always
    consists of several successive <literal>1</literal> bits, it is also
    possible to count the number of bits in the netmask. In
    <xref linkend="tab.net.basic.netmask"/> the first net with 24 bits could
    also be written as <literal>192.168.0.0/24</literal>.
   </para>
   <example xml:id="tab.net.basic.netmask">
    <title>Linking IP Addresses to the Netmask</title>
<screen>IP address (192.168.0.20):  11000000 10101000 00000000 00010100
Netmask   (255.255.255.0):  11111111 11111111 11111111 00000000
---------------------------------------------------------------
Result of the link:         11000000 10101000 00000000 00000000
In the decimal system:           192.     168.       0.       0

IP address (213.95.15.200): 11010101 10111111 00001111 11001000
Netmask    (255.255.255.0): 11111111 11111111 11111111 00000000
---------------------------------------------------------------
Result of the link:         11010101 10111111 00001111 00000000
In the decimal system:           213.      95.      15.       0</screen>
   </example>
   <para>
    To give another example: all machines connected with the same Ethernet
    cable are usually located in the same subnet and are directly accessible.
    Even when the subnet is physically divided by switches or bridges, these
    hosts can still be reached directly.
   </para>
   <para>
    IP addresses outside the local subnet can only be reached if a gateway is
    configured for the target network. In the most common case, there is only
    one gateway that handles all traffic that is external. However, it is also
    possible to configure several gateways for different subnets.
   </para>
   <para>
    If a gateway has been configured, all external IP packets are sent to the
    appropriate gateway. This gateway then attempts to forward the packets in
    the same manner&mdash;from host to host&mdash;until it reaches the
    destination host or the packet's TTL (time to live) expires.
   </para>
   <variablelist xml:id="net.basic.spezial.net">
    <title>Specific Addresses</title>
    <varlistentry>
     <term>
      Base Network Address
     </term>
     <listitem>
      <para>
       This is the netmask AND any address in the network, as shown in
       <xref linkend="tab.net.basic.netmask"/> under <literal>Result</literal>.
       This address cannot be assigned to any hosts.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      Broadcast Address
     </term>
     <listitem>
      <para>
       This could be paraphrased as: <quote>Access all hosts in this
       subnet.</quote> To generate this, the netmask is inverted in binary form
       and linked to the base network address with a logical OR. The above
       example therefore results in 192.168.0.255. This address cannot be
       assigned to any hosts.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      Local Host
     </term>
     <listitem>
      <para>
       The address <systemitem class="ipaddress">127.0.0.1</systemitem> is
       assigned to the <quote>loopback device</quote> on each host. A
       connection can be set up to your own machine with this address and with
       all addresses from the complete
       <systemitem class="ipaddress">127.0.0.0/8</systemitem> loopback network
       as defined with IPv4. With IPv6 there is only one loopback address
       (<systemitem class="ipaddress">::1</systemitem>).
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Because IP addresses must be unique all over the world, you cannot select
    random addresses. There are three address domains to use if you want to set
    up a private IP-based network. These cannot get any connection from the
    rest of the Internet, because they cannot be transmitted over the Internet.
    These address domains are specified in RFC&nbsp;1597 and listed in
    <xref linkend="tab.net.basic.privat.net"/>.
   </para>
   <table xml:id="tab.net.basic.privat.net">
    <title>Private IP Address Domains</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>
        <para>
         Network/Netmask
        </para>
       </entry>
       <entry>
        <para>
         Domain
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         <systemitem class="ipaddress">10.0.0.0</systemitem>/<systemitem class="netmask">255.0.0.0</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         <systemitem class="ipaddress">10.x.x.x</systemitem>
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <systemitem class="ipaddress">172.16.0.0</systemitem>/<systemitem class="netmask">255.240.0.0</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         <systemitem class="ipaddress">172.16.x.x</systemitem> &ndash;
         <systemitem class="ipaddress">172.31.x.x</systemitem>
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <systemitem class="ipaddress">192.168.0.0</systemitem>/<systemitem class="netmask">255.255.0.0</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         <systemitem class="ipaddress">192.168.x.x</systemitem>
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.network.ipv6">
  <title>IPv6&mdash;The Next Generation Internet</title>

  <important arch="zseries" os="sles">
<!--FIXME check-->
   <title>IBM &zseries;: IPv6 Support</title>
   <para>
    IPv6 is not supported by the CTC and IUCV network connections of the IBM
    &zseries; hardware.
   </para>
  </important>

  <para>
   Due to the emergence of the World Wide Web (WWW), the Internet has
   experienced explosive growth, with an increasing number of computers
   communicating via TCP/IP in the past fifteen years. Since Tim Berners-Lee at
   CERN (<link xlink:href="http://public.web.cern.ch"/>) invented the WWW in
   1990, the number of Internet hosts has grown from a few thousand to about a
   hundred million.
  </para>

  <para>
   As mentioned, an IPv4 address consists of only 32 bits. Also, quite a few
   IP addresses are lost&mdash;they cannot be used because of the way in which
   networks are organized. The number of addresses available in your subnet is
   two to the power of the number of bits, minus two. A subnet has, for
   example, 2, 6, or 14 addresses available. To connect 128 hosts to the
   Internet, for example, you need a subnet with 256 IP addresses, from which
   only 254 are usable, because two IP addresses are needed for the structure
   of the subnet itself: the broadcast and the base network address.
  </para>

  <para>
   Under the current IPv4 protocol, DHCP or NAT (network address translation)
   are the typical mechanisms used to circumvent the potential address
   shortage. Combined with the convention to keep private and public address
   spaces separate, these methods can certainly mitigate the shortage. The
   problem with them lies in their configuration, which is a chore to set up
   and a burden to maintain. To set up a host in an IPv4 network, you need
   several address items, such as the host's own IP address, the subnetmask,
   the gateway address and maybe a name server address. All these items need to
   be known and cannot be derived from somewhere else.
  </para>

  <para>
   With IPv6, both the address shortage and the complicated configuration
   should be a thing of the past. The following sections tell more about the
   improvements and benefits brought by IPv6 and about the transition from the
   old protocol to the new one.
  </para>

  <sect2 xml:id="sec.network.ipv6.adv">
   <title>Advantages</title>
   <para>
    The most important and most visible improvement brought by the new protocol
    is the enormous expansion of the available address space. An IPv6 address
    is made up of 128 bit values instead of the traditional 32 bits. This
    provides for as many as several quadrillion IP addresses.
   </para>
   <para>
    However, IPv6 addresses are not only different from their predecessors with
    regard to their length. They also have a different internal structure that
    may contain more specific information about the systems and the networks to
    which they belong. More details about this are found in
    <xref linkend="sec.network.ipv6.address"/>.
   </para>
   <para>
    The following is a list of other advantages of the new protocol:
   </para>
   <variablelist>
    <varlistentry>
     <term>Autoconfiguration</term>
     <listitem>
      <para>
       IPv6 makes the network <quote>plug and play</quote> capable, which means
       that a newly set up system integrates into the (local) network without
       any manual configuration. The new host uses its automatic configuration
       mechanism to derive its own address from the information made available
       by the neighboring routers, relying on a protocol called the
       <emphasis>neighbor discovery</emphasis> (ND) protocol. This method does
       not require any intervention on the administrator's part and there is no
       need to maintain a central server for address allocation&mdash;an
       additional advantage over IPv4, where automatic address allocation
       requires a DHCP server.
      </para>
      <para>
       Nevertheless if a router is connected to a switch, the router should
       send periodic advertisements with flags telling the hosts of a network
       how they should interact with each other. For more information, see
       RFC 2462 and the <systemitem>radvd.conf(5)</systemitem> man page, and
       RFC 3315.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Mobility</term>
     <listitem>
      <para>
       IPv6 makes it possible to assign several addresses to one network
       interface at the same time. This allows users to access several networks
       easily, something that could be compared with the international roaming
       services offered by mobile phone companies. When you take your mobile
       phone abroad, the phone automatically logs in to a foreign service when
       it enters the corresponding area, so you can be reached under the same
       number everywhere and can place an outgoing call, as you would in your
       home area.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Secure Communication</term>
     <listitem>
      <para>
       With IPv4, network security is an add-on function. IPv6 includes IPsec
       as one of its core features, allowing systems to communicate over a
       secure tunnel to avoid eavesdropping by outsiders on the Internet.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Backward Compatibility</term>
     <listitem>
      <para>
       Realistically, it would be impossible to switch the entire Internet from
       IPv4 to IPv6 at one time. Therefore, it is crucial that both protocols
       can coexist not only on the Internet, but also on one system. This is
       ensured by compatible addresses (IPv4 addresses can easily be translated
       into IPv6 addresses) and by using several tunnels. See
       <xref linkend="sec.network.ipv6.coexist"/>. Also, systems can rely on a
       <emphasis>dual stack IP</emphasis> technique to support both protocols
       at the same time, meaning that they have two network stacks that are
       completely separate, such that there is no interference between the two
       protocol versions.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Custom Tailored Services through Multicasting</term>
     <listitem>
      <para>
       With IPv4, some services, such as SMB, need to broadcast their packets
       to all hosts in the local network. IPv6 allows a much more fine-grained
       approach by enabling servers to address hosts through
       <emphasis>multicasting</emphasis>, that is by addressing several hosts as
       parts of a group. This is different from addressing all hosts through
       <emphasis>broadcasting</emphasis> or each host individually through
       <emphasis>unicasting</emphasis>). Which hosts are addressed as a group
       may depend on the concrete application. There are some predefined groups
       to address all name servers (the <emphasis>all name servers multicast
       group</emphasis>), for example, or all routers (the <emphasis>all
       routers multicast group</emphasis>).
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="sec.network.ipv6.address">
   <title>Address Types and Structure</title>
   <para>
    As mentioned, the current IP protocol has two major limitations:
    there is an increasing shortage of IP addresses, and configuring the network
    and maintaining the routing tables is becoming a more complex and
    burdensome task. IPv6 solves the first problem by expanding the address
    space to 128 bits. The second one is mitigated by introducing a
    hierarchical address structure combined with sophisticated techniques to
    allocate network addresses, and <emphasis>multihoming</emphasis> (the
    ability to assign several addresses to one device, giving access to several
    networks).
   </para>
   <para>
    When dealing with IPv6, it is useful to know about three different types of
    addresses:
   </para>
   <variablelist>
    <varlistentry>
     <term>Unicast</term>
     <listitem>
      <para>
       Addresses of this type are associated with exactly one network
       interface. Packets with such an address are delivered to only one
       destination. Accordingly, unicast addresses are used to transfer packets
       to individual hosts on the local network or the Internet.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Multicast</term>
     <listitem>
      <para>
       Addresses of this type relate to a group of network interfaces. Packets
       with such an address are delivered to all destinations that belong to
       the group. Multicast addresses are mainly used by certain network
       services to communicate with certain groups of hosts in a well-directed
       manner.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Anycast</term>
     <listitem>
      <para>
       Addresses of this type are related to a group of interfaces. Packets
       with such an address are delivered to the member of the group that is
       closest to the sender, according to the principles of the underlying
       routing protocol. Anycast addresses are used to make it easier for hosts
       to find out about servers offering certain services in the given network
       area. All servers of the same type have the same anycast address.
       Whenever a host requests a service, it receives a reply from the server
       with the closest location, as determined by the routing protocol. If
       this server should fail for some reason, the protocol automatically
       selects the second closest server, then the third one, and so forth.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    An IPv6 address is made up of eight four-digit fields, each representing 16
    bits, written in hexadecimal notation. They are separated by colons
    (<literal>:</literal>). Any leading zero bytes within a given field may be
    dropped, but zeros within the field or at its end may not. Another
    convention is that more than four consecutive zero bytes may be collapsed
    into a double colon. However, only one such <literal>::</literal> is
    allowed per address. This kind of shorthand notation is shown in
    <xref linkend="aus.netz.ipv6.add"/>, where all three lines represent the
    same address.
   </para>
   <example xml:id="aus.netz.ipv6.add">
    <title>Sample IPv6 Address</title>
<screen>fe80 : 0000 : 0000 : 0000 : 0000 : 10 : 1000 : 1a4
fe80 :    0 :    0 :    0 :    0 : 10 : 1000 : 1a4
fe80 :                           : 10 : 1000 : 1a4</screen>
   </example>
   <para>
    Each part of an IPv6 address has a defined function. The first bytes form
    the prefix and specify the type of address. The center part is the network
    portion of the address, but it may be unused. The end of the address forms
    the host part. With IPv6, the netmask is defined by indicating the length
    of the prefix after a slash at the end of the address. An address, as shown
    in <xref linkend="aus.netz.ipv6.addpre"/>, contains the information that
    the first 64 bits form the network part of the address and the last 64 form
    its host part. In other words, the <literal>64</literal> means that the
    netmask is filled with 64 1-bit values from the left. As with IPv4, the IP
    address is combined with AND with the values from the netmask to determine
    whether the host is located in the same subnet or in another one.
   </para>
   <example xml:id="aus.netz.ipv6.addpre">
    <title>IPv6 Address Specifying the Prefix Length</title>
<screen>fe80::10:1000:1a4/64</screen>
   </example>
   <para>
    IPv6 knows about several predefined types of prefixes. Some are shown in
    <xref linkend="list.net.basic.ipv6.prefix"/>.
   </para>
   <variablelist xml:id="list.net.basic.ipv6.prefix">
    <title>Various IPv6 Prefixes</title>
    <varlistentry>
     <term><systemitem class="ipaddress">00</systemitem>
     </term>
     <listitem>
      <para>
       IPv4 addresses and IPv4 over IPv6 compatibility addresses. These are
       used to maintain compatibility with IPv4. Their use still requires a
       router able to translate IPv6 packets into IPv4 packets. Several special
       addresses, such as the one for the loopback device, have this prefix as
       well.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem class="ipaddress">2</systemitem> or
      <systemitem class="ipaddress">3</systemitem> as the
      first digit
     </term>
     <listitem>
      <para>
       Aggregatable global unicast addresses. As is the case with IPv4, an
       interface can be assigned to form part of a certain subnet. Currently,
       there are the following address spaces:
       <systemitem class="ipaddress">2001::/16</systemitem> (production quality
       address space) and <systemitem class="ipaddress">2002::/16</systemitem>
       (6to4 address space).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem class="ipaddress">fe80::/10</systemitem>
     </term>
     <listitem>
      <para>
       Link-local addresses. Addresses with this prefix should not be routed
       and should therefore only be reachable from within the same subnet.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem class="ipaddress">fec0::/10</systemitem>
     </term>
     <listitem>
      <para>
       Site-local addresses. These may be routed, but only within the network
       of the organization to which they belong. In effect, they are the IPv6
       equivalent of the current private network address space, such as
       <systemitem class="ipaddress">10.x.x.x</systemitem>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem class="ipaddress">ff</systemitem>
     </term>
     <listitem>
      <para>
       These are multicast addresses.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    A unicast address consists of three basic components:
   </para>
   <variablelist>
    <varlistentry>
     <term>Public Topology</term>
     <listitem>
      <para>
       The first part (which also contains one of the prefixes mentioned above)
       is used to route packets through the public Internet. It includes
       information about the company or institution that provides the Internet
       access.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Site Topology</term>
     <listitem>
      <para>
       The second part contains routing information about the subnet to which
       to deliver the packet.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Interface ID</term>
     <listitem>
      <para>
       The third part identifies the interface to which to deliver the packet.
       This also allows for the MAC to form part of the address. Given that the
       MAC is a globally unique, fixed identifier coded into the device by the
       hardware maker, the configuration procedure is substantially simplified.
       In fact, the first 64 address bits are consolidated to form the
       <literal>EUI-64</literal> token, with the last 48 bits taken from the
       MAC, and the remaining 24 bits containing special information about the
       token type. This also makes it possible to assign an
       <literal>EUI-64</literal> token to interfaces that do not have a MAC,
       such as those based on PPP.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    On top of this basic structure, IPv6 distinguishes between five different
    types of unicast addresses:
   </para>
   <variablelist>
    <varlistentry>
     <term><systemitem class="ipaddress">::</systemitem> (unspecified) </term>
     <listitem>
      <para>
       This address is used by the host as its source address when the
       interface is initialized for the first time (at which point, the address
       cannot yet be determined by other means).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem class="ipaddress">::1</systemitem> (loopback) </term>
     <listitem>
      <para>
       The address of the loopback device.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>IPv4 Compatible Addresses</term>
     <listitem>
      <para>
       The IPv6 address is formed by the IPv4 address and a prefix consisting
       of 96 zero bits. This type of compatibility address is used for
       tunneling (see <xref linkend="sec.network.ipv6.coexist"/>) to allow
       IPv4 and IPv6 hosts to communicate with others operating in a pure IPv4
       environment.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>IPv4 Addresses Mapped to IPv6</term>
     <listitem>
      <para>
       This type of address specifies a pure IPv4 address in IPv6 notation.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Local Addresses</term>
     <listitem>
      <para>
       There are two address types for local use:
      </para>
      <variablelist>
       <varlistentry>
        <term>link-local</term>
        <listitem>
         <para>
          This type of address can only be used in the local subnet. Packets
          with a source or target address of this type should not be routed to
          the Internet or other subnets. These addresses contain a special
          prefix (<systemitem class="ipaddress">fe80::/10</systemitem>) and the
          interface ID of the network card, with the middle part consisting of
          zero bytes. Addresses of this type are used during automatic
          configuration to communicate with other hosts belonging to the same
          subnet.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>site-local</term>
        <listitem>
         <para>
          Packets with this type of address may be routed to other subnets, but
          not to the wider Internet&mdash;they must remain inside the
          organization's own network. Such addresses are used for intranets and
          are an equivalent of the private address space defined by IPv4. They
          contain a special prefix
          (<systemitem class="ipaddress">fec0::/10</systemitem>), the interface
          ID, and a 16 bit field specifying the subnet ID. Again, the rest is
          filled with zero bytes.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    As a completely new feature introduced with IPv6, each network interface
    normally gets several IP addresses, with the advantage that several
    networks can be accessed through the same interface. One of these networks
    can be configured completely automatically using the MAC and a known prefix
    with the result that all hosts on the local network can be reached when
    IPv6 is enabled (using the link-local address). With the MAC forming part
    of it, any IP address used in the world is unique. The only variable parts
    of the address are those specifying the <emphasis>site topology</emphasis>
    and the <emphasis>public topology</emphasis>, depending on the actual
    network in which the host is currently operating.
   </para>
   <para>
    For a host to go back and forth between different networks, it needs at
    least two addresses. One of them, the <emphasis>home address</emphasis>,
    not only contains the interface ID but also an identifier of the home
    network to which it normally belongs (and the corresponding prefix). The
    home address is a static address and, as such, it does not normally change.
    Still, all packets destined to the mobile host can be delivered to it,
    regardless of whether it operates in the home network or somewhere outside.
    This is made possible by the completely new features introduced with IPv6,
    such as <emphasis>stateless autoconfiguration</emphasis> and
    <emphasis>neighbor discovery</emphasis>. In addition to its home address, a
    mobile host gets one or more additional addresses that belong to the
    foreign networks where it is roaming. These are called
    <emphasis>care-of</emphasis> addresses. The home network has a facility
    that forwards any packets destined to the host when it is roaming outside.
    In an IPv6 environment, this task is performed by the <emphasis>home
    agent</emphasis>, which takes all packets destined to the home address and
    relays them through a tunnel. On the other hand, those packets destined to
    the care-of address are directly transferred to the mobile host without any
    special detours.
   </para>
  </sect2>

  <sect2 xml:id="sec.network.ipv6.coexist">
   <title>Coexistence of IPv4 and IPv6</title>
   <para>
    The migration of all hosts connected to the Internet from IPv4 to IPv6 is a
    gradual process. Both protocols will coexist for some time to come. The
    coexistence on one system is guaranteed where there is a <emphasis>dual
    stack</emphasis> implementation of both protocols. That still leaves the
    question of how an IPv6 enabled host should communicate with an IPv4 host
    and how IPv6 packets should be transported by the current networks, which
    are predominantly IPv4-based. The best solutions offer tunneling and
    compatibility addresses (see <xref linkend="sec.network.ipv6.address"/>).
   </para>
   <para>
    IPv6 hosts that are more or less isolated in the (worldwide) IPv4 network
    can communicate through tunnels: IPv6 packets are encapsulated as IPv4
    packets to move them across an IPv4 network. Such a connection between two
    IPv4 hosts is called a <emphasis>tunnel</emphasis>. To achieve this,
    packets must include the IPv6 destination address (or the corresponding
    prefix) and the IPv4 address of the remote host at the receiving end of the
    tunnel. A basic tunnel can be configured manually according to an agreement
    between the hosts' administrators. This is also called <emphasis>static
    tunneling</emphasis>.
   </para>
   <para>
    However, the configuration and maintenance of static tunnels is often too
    labor-intensive to use them for daily communication needs. Therefore, IPv6
    provides for three different methods of <emphasis>dynamic
    tunneling</emphasis>:
   </para>
   <variablelist>
    <varlistentry>
     <term>6over4</term>
     <listitem>
      <para>
       IPv6 packets are automatically encapsulated as IPv4 packets and sent
       over an IPv4 network capable of multicasting. IPv6 is tricked into
       seeing the whole network (Internet) as a huge local area network (LAN).
       This makes it possible to determine the receiving end of the IPv4 tunnel
       automatically. However, this method does not scale very well and is also
       hampered because IP multicasting is far from widespread on the Internet.
       Therefore, it only provides a solution for smaller corporate or
       institutional networks where multicasting can be enabled. The
       specifications for this method are laid down in RFC 2529.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>6to4</term>
     <listitem>
      <para>
       With this method, IPv4 addresses are automatically generated from IPv6
       addresses, enabling isolated IPv6 hosts to communicate over an IPv4
       network. However, several problems have been reported regarding the
       communication between those isolated IPv6 hosts and the Internet. The
       method is described in RFC 3056.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>IPv6 Tunnel Broker</term>
     <listitem>
      <para>
       This method relies on special servers that provide dedicated tunnels for
       IPv6 hosts. It is described in RFC 3053.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="sec.network.ipv6.config">
   <title>Configuring IPv6</title>
<!--
-    To disable or enable IPv6 on an installed system, start &yast;, open the
-    <menuchoice><guimenu>System</guimenu><guimenu>Network
-      Settings</guimenu></menuchoice> dialog and in the <guimenu>Global
-     Options</guimenu> tab, check or uncheck <guimenu>Enable IPv6</guimenu>.
-    <remark>TODO: Find out what the "disable autoload of the kernel module for
-     ipv6" means - is this a required manual step to be done outside of network
-    configuration?</remark>
+    To disable or enable IPv6 on an installed system, use &yast;
+    <guimenu>Network Card</guimenu>. Do not change the method and click
+    <guimenu>Next</guimenu>.
+    Then select a card and click <menuchoice>
+     <guimenu>Advanced</guimenu>
+     <guimenu>IPv6</guimenu></menuchoice>
+    in the <guimenu>Address</guimenu> tab.

-->
   <para>
    To configure IPv6, you normally do not need to make any changes on the
    individual workstations. IPv6 is enabled by default. To disable or enable
    IPv6 on an installed system, use the &yast; <guimenu>Network
    Settings</guimenu> module. On the <guimenu>Global Options</guimenu> tab,
    check or uncheck the <guimenu>Enable IPv6</guimenu> option as necessary.
<!--To enable or disable IPv6 manually, edit
    <filename>/etc/modprobe.d/50-ipv6.conf</filename> and restart the
    system.-->
    To enable it temporarily until the next reboot, enter
    <command>modprobe</command> <option>-i ipv6</option> as
    <systemitem class="username">root</systemitem>. It is impossible to unload
    the IPv6 module after it has been loaded.
   </para>
   <para>
    Because of the autoconfiguration concept of IPv6, the network card is
    assigned an address in the <emphasis>link-local</emphasis> network.
    Normally, no routing table management takes place on a workstation. The
    network routers can be queried by the workstation, using the
    <emphasis>router advertisement protocol</emphasis>, for what prefix and
    gateways should be implemented. The radvd program can be used to set up an
    IPv6 router. This program informs the workstations which prefix to use for
    the IPv6 addresses and which routers. Alternatively, use zebra/quagga for
    automatic configuration of both addresses and routing.
   </para>
<!-- 2014-04-15, ke: Karol will add this man page to the wicked
   package as well -->
   <para>
    For information about how to set up various types of tunnels using the
    <filename>/etc/sysconfig/network</filename> files, see the man page of
    <literal>ifcfg-tunnel</literal> (<command>man ifcfg-tunnel</command>).
   </para>
  </sect2>

  <sect2 xml:id="sec.network.ipv6.moreinfo">
   <title>For More Information</title>
   <para>
    The above overview does not cover the topic of IPv6 comprehensively. For a
    more in-depth look at the new protocol, refer to the following online
    documentation and books:
   </para>
   <variablelist>
    <varlistentry>
     <term><link xlink:href="http://www.ipv6.org/"/>
     </term>
     <listitem>
      <para>
       The starting point for everything about IPv6.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link xlink:href="http://www.ipv6day.org"/>
     </term>
     <listitem>
      <para>
       All information needed to start your own IPv6 network.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link xlink:href="http://www.ipv6-to-standard.org/"/>
     </term>
     <listitem>
      <para>
       The list of IPv6-enabled products.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link xlink:href="http://www.bieringer.de/linux/IPv6/"/>
     </term>
     <listitem>
      <para>
       Here, find the Linux IPv6-HOWTO and many links related to the topic.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>RFC 2460</term>
     <listitem>
      <para>
       The fundamental RFC about IPv6.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>IPv6 Essentials</term>
     <listitem>
      <para>
       A book describing all the important aspects of the topic is
       <emphasis>IPv6 Essentials</emphasis> by Silvia Hagen (ISBN
       0-596-00125-8).
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.network.nameres">
  <title>Name Resolution</title>

  <para>
   DNS assists in assigning an IP address to one or more names and assigning a
   name to an IP address. In Linux, this conversion is usually carried out by a
   special type of software known as bind. The machine that takes care of this
   conversion is called a <emphasis>name server</emphasis>. The names make up a
   hierarchical system in which each name component is separated by a period.
   The name hierarchy is, however, independent of the IP address hierarchy
   described above.
  </para>

  <para>
   Consider a complete name, such as
   <systemitem class="fqdomainname">&wsIname;</systemitem>, written in the
   format <systemitem class="fqdomainname">hostname.domain</systemitem>. A full
   name, called a <emphasis>fully qualified domain name</emphasis> (FQDN),
   consists of a host name and a domain name
   (<systemitem class="domainname">&exampledomain;</systemitem>). The latter
   also includes the <emphasis>top level domain</emphasis> or TLD
   (<systemitem class="domainname">com</systemitem>).
  </para>

  <para>
   TLD assignment has become quite confusing for historical reasons.
   Traditionally, three-letter domain names are used in the USA. In the rest of
   the world, the two-letter ISO national codes are the standard. In addition
   to that, longer TLDs were introduced in 2000 that represent certain spheres
   of activity (for example, <systemitem class="domainname">.info</systemitem>,
   <systemitem class="domainname">.name</systemitem>,
   <systemitem class="domainname">.museum</systemitem>).
  </para>

  <para>
   In the early days of the Internet (before 1990), the file
   <filename>/etc/hosts</filename> was used to store the names of all the
   machines represented over the Internet. This quickly proved to be
   impractical in the face of the rapidly growing number of computers connected
   to the Internet. For this reason, a decentralized database was developed to
   store the host names in a widely distributed manner. This database, similar
   to the name server, does not have the data pertaining to all hosts in the
   Internet readily available, but can dispatch requests to other name servers.
  </para>

  <para>
   The top of the hierarchy is occupied by <emphasis>root name
   servers</emphasis>. These root name servers manage the top level domains and
   are run by the Network Information Center (NIC). Each root name server knows
   about the name servers responsible for a given top level domain. Information
   about top level domain NICs is available at
   <link xlink:href="http://www.internic.net"/>.
  </para>

  <para>
   DNS can do more than resolve host names. The name server also knows which
   host is receiving e-mails for an entire domain&mdash;the <emphasis>mail
   exchanger (MX)</emphasis>.
  </para>

  <para>
   For your machine to resolve an IP address, it must know about at least one
   name server and its IP address. Easily specify such a name server using
   &yast;. <phrase os="sles;osuse">The configuration of name server access with
   &productnamereg; is described in
   <xref
   linkend="sec.network.yast.change.host"/>. Setting up your own name
   server is described in <xref linkend="cha.dns"/>.</phrase>
  </para>

  <para>
   The protocol <literal>whois</literal> is closely related to DNS. With this
   program, quickly find out who is responsible for a given domain.
  </para>

<!-- bug 349467 -->

  <note>
   <title>MDNS and .local Domain Names</title>
   <para>
    The <literal>.local</literal> top level domain is treated as link-local
    domain by the resolver. DNS requests are send as multicast DNS requests
    instead of normal DNS requests. If you already use the
    <literal>.local</literal> domain in your name server configuration, you
    must switch this option off in <filename>/etc/host.conf</filename>. For
    more information, see the <filename>host.conf</filename> manual page.
   </para>
   <para>
    If you want to switch off MDNS during installation, use
    <literal>nomdns=1</literal> as a boot parameter.
   </para>
   <para>
    For more information on multicast DNS, see
    <link xlink:href="http://www.multicastdns.org"/>.
   </para>
  </note>
 </sect1>
 <xi:include href="net_yast.xml"/>
 <xi:include os="sled;osuse" href="networkmanager.xml"/>
 <xi:include href="net_wicked.xml"/>
 <xi:include os="sles;osuse" href="net_router.xml"/>
 <xi:include href="net_bonding.xml"/>
 <xi:include href="net_teaming.xml"/>
 <xi:include os="sles;osuse" href="net_sdn.xml"/>
</chapter>
