<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="net_basic.xml" version="5.0" xml:id="cha.basicnet">
 <title>Grundlegendes zu Netzwerken</title>
 <info>
  <abstract>
   <para>
    Linux stellt die erforderlichen Netzwerkwerkzeuge und -funktionen für die Integration in alle Arten von Netzwerkstrukturen zur Verfügung. Der Netzwerkzugriff über eine Netzwerkkarte kann mit YaST konfiguriert werden. Die manuelle Konfiguration ist ebenfalls möglich. In diesem Kapitel werden nur die grundlegenden Mechanismen und die relevanten Netzwerkkonfigurationsdateien behandelt.
   </para>
  </abstract>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>Ja</dm:translation>
  </dm:docmanager>
 </info>
 <para>
  Linux und andere Unix-Betriebssysteme verwenden das TCP/IP-Protokoll. Hierbei handelt es sich nicht um ein einzelnes Netzwerkprotokoll, sondern um eine Familie von Netzwerkprotokollen, die unterschiedliche Dienste zur Verfügung stellen. Die in <xref linkend="tab.net.basic.tcpproto"/> aufgelisteten Protokolle dienen dem Datenaustausch zwischen zwei Computern über TCP/IP. Über TCP/IP verbundene Netzwerke bilden zusammen ein weltweites Netzwerk, das auch als <quote>das Internet</quote> bezeichnet wird.
 </para>
 <para>
  RFC ist das Akronym für <emphasis>Request for Comments</emphasis>. RFCs sind Dokumente, die unterschiedliche Internetprotokolle und Implementierungsverfahren für das Betriebssystem und seine Anwendungen beschreiben. Die RFC-Dokumente beschreiben das Einrichten der Internetprotokolle. Weitere Informationen zu RFCs finden Sie unter <link xlink:href="http://www.ietf.org/rfc.html"/>.
 </para>
 <variablelist xml:id="tab.net.basic.tcpproto">
  <title>Verschiedene Protokolle aus der TCP/IP-Familie</title>
  <varlistentry>
   <term>TCP</term>
   <listitem>
    <para>
     Transmission Control Protocol: Ein verbindungsorientiertes sicheres Protokoll. Die zu übertragenden Daten werden zuerst von der Anwendung als Datenstrom gesendet und vom Betriebssystem in das passende Format konvertiert. Die entsprechende Anwendung auf dem Zielhost empfängt die Daten im ursprünglichen Datenstromformat, in dem sie anfänglich gesendet wurden. TCP ermittelt, ob Daten bei der Übertragung verloren gegangen sind oder beschädigt wurden. TCP wird immer dann implementiert, wenn die Datensequenz eine Rolle spielt.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>UDP</term>
   <listitem>
    <para>
     User Datagram Protocol: Ein verbindungsloses, nicht sicheres Protokoll. Die zu übertragenden Daten werden in Form von anwendungsseitig generierten Paketen gesendet. Es ist nicht garantiert, in welcher Reihenfolge die Daten beim Empfänger eingehen, und ein Datenverlust ist immer möglich. UDP ist geeignet für datensatzorientierte Anwendungen. Es verfügt über eine kürzere Latenzzeit als TCP.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>ICMP</term>
   <listitem>
    <para>
     Internet Control Message Protocol: Dies ist im Wesentlichen kein Protokoll für den Endbenutzer, sondern ein spezielles Steuerungsprotokoll, das Fehlerberichte ausgibt und das Verhalten von Computern, die am TCP/IP-Datentransfer teilnehmen, steuern kann. Außerdem bietet es einen speziellen Echomodus, der mit dem Programm „ping“ angezeigt werden kann.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>IGMP</term>
   <listitem>
    <para>
     Internet Group Management Protocol: Dieses Protokoll steuert das Verhalten des Computers beim Implementieren von IP Multicast.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
 <para>
  Der Datenaustausch findet wie in <xref linkend="fig.net.basic.OSI"/> dargestellt in unterschiedlichen Schichten statt. Die eigentliche Netzwerkschicht ist der unsichere Datentransfer über IP (Internet Protocol). Oberhalb von IP gewährleistet TCP (Transmission Control Protocol) bis zu einem gewissen Grad die Sicherheit des Datentransfers. Die IP-Schicht wird vom zugrunde liegenden hardwareabhängigen Protokoll, z. B. Ethernet, unterstützt.
 </para>
 <figure xml:id="fig.net.basic.OSI">
  <title>Vereinfachtes Schichtmodell für TCP/IP</title>
  <mediaobject>
   <imageobject role="fo">
    <imagedata width="100%" fileref="net_basic_osi.svg" format="SVG"/>
   </imageobject>
   <imageobject role="html">
    <imagedata width="75%" fileref="net_basic_osi.png" format="PNG"/>
   </imageobject>
  </mediaobject>
 </figure>
 <para>
  Dieses Diagramm bietet für jede Schicht ein oder zwei Beispiele. Die Schichten sind nach <emphasis>Abstraktionsstufen</emphasis> sortiert. Die unterste Schicht ist sehr Hardware-nah. Die oberste Schicht ist beinahe vollständig von der Hardware losgelöst. Jede Schicht hat ihre eigene spezielle Funktion. Die speziellen Funktionen der einzelnen Schichten gehen bereits aus ihrer Bezeichnung hervor. Die Datenverbindungs- und die physische Schicht repräsentieren das verwendete physische Netzwerk, z. B. das Ethernet.
 </para>
 <para>
  Fast alle Hardwareprotokolle arbeiten auf einer paketorientierten Basis. Die zu übertragenden Daten werden in <emphasis>Paketen</emphasis> gesammelt (sie können nicht alle auf einmal gesendet werden). Die maximale Größe eines TCP/IP-Pakets beträgt ca. 64 KB. Die Pakete sind in der Regel jedoch sehr viel kleiner, da die Netzwerkhardware ein einschränkender Faktor sein kann. Die maximale Größe eines Datenpakets in einem Ethernet beträgt ca. 1500 Byte. Die Größe eines TCP/IP-Pakets ist auf diesen Wert begrenzt, wenn die Daten über ein Ethernet gesendet werden. Wenn mehr Daten übertragen werden, müssen vom Betriebssystem mehr Datenpakete gesendet werden.
 </para>
 <para>
  Damit die Schichten ihre vorgesehenen Funktionen erfüllen können, müssen im Datenpaket zusätzliche Informationen über die einzelnen Schichten gespeichert sein. Diese Informationen werden im <emphasis>Header</emphasis> des Pakets gespeichert. Jede Schicht stellt jedem ausgehenden Paket einen kleinen Datenblock voran, den so genannten Protokoll-Header. Ein Beispiel für ein TCP/IP-Datenpaket, das über ein Ethernetkabel gesendet wird, ist in <xref linkend="fig.net.basic.TCPPaket"/> dargestellt. Die Prüfsumme befindet sich am Ende des Pakets, nicht am Anfang. Dies erleichtert die Arbeit für die Netzwerkhardware.
 </para>
 <figure xml:id="fig.net.basic.TCPPaket">
  <title>TCP/IP-Ethernet-Paket</title>
  <mediaobject>
   <imageobject role="fo">
    <imagedata width="80%" fileref="net_basic_tcppacket.svg" format="SVG"/>
   </imageobject>
   <imageobject role="html">
    <imagedata width="75%" fileref="net_basic_tcppacket.png" format="PNG"/>
   </imageobject>
  </mediaobject>
 </figure>
 <para>
  Wenn eine Anwendung Daten über das Netzwerk sendet, werden diese Daten durch alle Schichten geleitet, die mit Ausnahme der physischen Schicht alle im Linux-Kernel implementiert sind. Jede Schicht ist für das Vorbereiten der Daten zur Weitergabe an die nächste Schicht verantwortlich. Die unterste Schicht ist letztendlich für das Senden der Daten verantwortlich. Bei eingehenden Daten erfolgt die gesamte Prozedur in umgekehrter Reihenfolge. Die Protokoll-Header werden von den transportierten Daten in den einzelnen Schichten wie die Schalen einer Zwiebel entfernt. Die Transportschicht ist schließlich dafür verantwortlich, die Daten den Anwendungen am Ziel zur Verfügung zu stellen. Auf diese Weise kommuniziert eine Schicht nur mit der direkt darüber bzw. darunter liegenden Schicht. Für Anwendungen ist es irrelevant, ob die Daten über ein 100 MBit/s schnelles FDDI-Netzwerk oder über eine 56-KBit/s-Modemleitung übertragen werden. Ähnlich spielt es für die Datenverbindung keine Rolle, welche Art von Daten übertragen wird, solange die Pakete das richtige Format haben.
 </para>
 <sect1 xml:id="sec.basicnet.addresses">
  <title>IP-Adressen und Routing</title>

  <para>
   Die in diesem Abschnitt enthaltenen Informationen beziehen sich nur auf IPv4-Netzwerke. Informationen zum IPv6-Protokoll, dem Nachfolger von IPv4, finden Sie in <xref linkend="sec.basicnet.ipv6"/>.
  </para>

  <sect2 xml:id="sec.basicnet.addresses.ip">
   <title>IP-Adressen</title>
   <para>
    Jeder Computer im Internet verfügt über eine eindeutige 32-Bit-Adresse. Diese 32 Bit (oder 4 Byte) werden in der Regel wie in der zweiten Zeile in <xref linkend="aus.net.basic.ipaddress"/> dargestellt geschrieben.
   </para>
   <example xml:id="aus.net.basic.ipaddress">
    <title>IP-Adressen schreiben</title>
<screen>IP Address (binary):  11000000 10101000 00000000 00010100
IP Address (decimal):      192.     168.       0.      20</screen>
   </example>
   <para>
    Im Dezimalformat werden die vier Byte in Dezimalzahlen geschrieben und durch Punkte getrennt. Die IP-Adresse wird einem Host oder einer Netzwerkschnittstelle zugewiesen. Sie kann weltweit nur einmal verwendet werden. Es gibt zwar Ausnahmen zu dieser Regel, diese sind jedoch für die folgenden Abschnitte nicht relevant.
   </para>
   <para>
    Die Punkte in IP-Adressen geben das hierarchische System an. Bis in die 1990er-Jahre wurden IP-Adressen strikt in Klassen organisiert. Dieses System erwies sich jedoch als zu wenig flexibel und wurde eingestellt. Heute wird das <emphasis>klassenlose Routing</emphasis> (CIDR, Classless Interdomain Routing) verwendet.
   </para>
  </sect2>

  <sect2 xml:id="sec.basicnet.addresses.route">
   <title>Netzmasken und Routing</title>
   <para>
    Mit Netzmasken werden die Adressräume eines Subnetzes definiert. Wenn sich in einem Subnetz zwei Hosts befinden, können diese direkt aufeinander zugreifen. Wenn sie sich nicht im selben Subnetz befinden, benötigen sie die Adresse eines Gateways, das den gesamten Verkehr für das Subnetz verarbeitet. Um zu prüfen, ob sich zwei IP-Adressen im selben Subnetz befinden, wird jede Adresse bitweise mit der Netzmaske <quote>UND</quote>-verknüpft. Sind die Ergebnisse identisch, befinden sich beide IP-Adressen im selben lokalen Netzwerk. Wenn unterschiedliche Ergebnisse ausgegeben werden, kann die entfernte IP-Adresse, und somit die entfernte Schnittstelle, nur über ein Gateway erreicht werden.
   </para>
   <para>
    Weitere Informationen zur Funktionsweise von Netzmasken finden Sie in <xref linkend="tab.net.basic.netmask"/>. Die Netzmaske besteht aus 32 Bit, die festlegen, welcher Teil einer IP-Adresse zum Netzwerk gehört. Alle Bits mit dem Wert <literal>1</literal> kennzeichnen das entsprechende Bit in der IP-Adresse als zum Netzwerk gehörend. Alle Bits mit dem Wert <literal>0</literal> kennzeichnen Bits innerhalb des Subnetzes. Je mehr Bits den Wert <literal>1</literal> haben, desto kleiner ist also das Netzwerk. Da die Netzmaske immer aus mehreren aufeinander folgenden Bits mit dem Wert <literal>1</literal> besteht, ist es auch möglich, die Anzahl der Bits in der Netzmaske zu zählen. In <xref linkend="tab.net.basic.netmask"/> könnte das erste Netz mit 24 Bit auch als <literal>192.168.0.0/24 </literal> geschrieben werden.
   </para>
   <example xml:id="tab.net.basic.netmask">
    <title>Verknüpfung von IP-Adressen mit der Netzmaske</title>
<screen>IP address (192.168.0.20):  11000000 10101000 00000000 00010100
Netmask   (255.255.255.0):  11111111 11111111 11111111 00000000
---------------------------------------------------------------
Result of the link:         11000000 10101000 00000000 00000000
In the decimal system:           192.     168.       0.       0

IP address (213.95.15.200): 11010101 10111111 00001111 11001000
Netmask    (255.255.255.0): 11111111 11111111 11111111 00000000
---------------------------------------------------------------
Result of the link:         11010101 10111111 00001111 00000000
In the decimal system:           213.      95.      15.       0</screen>
   </example>
   <para>
    Ein weiteres Beispiel: Alle Computer, die über dasselbe Ethernetkabel angeschlossen sind, befinden sich in der Regel im selben Subnetz und sind direkt zugreifbar. Selbst wenn das Subnetz physisch durch Switches oder Bridges unterteilt ist, können diese Hosts weiter direkt erreicht werden.
   </para>
   <para>
    IP-Adressen außerhalb des lokalen Subnetzes können nur erreicht werden, wenn für das Zielnetzwerk ein Gateway konfiguriert ist. In den meisten Fällen wird der gesamte externe Verkehr über lediglich ein Gateway gehandhabt. Es ist jedoch auch möglich, für unterschiedliche Subnetze mehrere Gateways zu konfigurieren.
   </para>
   <para>
    Wenn ein Gateway konfiguriert wurde, werden alle externen IP-Pakete an das entsprechende Gateway gesendet. Dieses Gateway versucht anschließend, die Pakete auf dieselbe Weise – von Host zu Host – weiterzuleiten, bis sie den Zielhost erreichen oder ihre TTL-Zeit (Time to Live) abgelaufen ist.
   </para>
   <variablelist xml:id="net.basic.spezial.net">
    <title>Spezifische Adressen</title>
    <varlistentry>
     <term>
      Netzwerkbasisadresse
     </term>
     <listitem>
      <para>
       Dies ist die Netzmaske, die durch UND mit einer Netzwerkadresse verknüpft ist, wie in <xref linkend="tab.net.basic.netmask"/> unter <literal>Result</literal> dargestellt. Diese Adresse kann keinem Host zugewiesen werden.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      Rundrufadresse
     </term>
     <listitem>
      <para>
       Dies lässt sich auch wie folgt beschreiben: <quote>Zugriff auf alle Hosts in diesem Subnetz.</quote> Um die Broadcast-Adresse zu generieren, wird die Netzmaske in die binäre Form invertiert und mit einem logischen ODER mit der Netzwerkbasisadresse verknüpft. Das obige Beispiel ergibt daher die Adresse 192.168.0.255. Diese Adresse kann keinem Host zugeordnet werden.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      Lokaler Host
     </term>
     <listitem>
      <para>
       Die Adresse <systemitem class="ipaddress">127.0.0.1</systemitem> ist auf jedem Host dem <quote>Loopback-Device</quote> zugewiesen. Mit dieser Adresse und mit allen Adressen des vollständigen <systemitem class="ipaddress">127.0.0.0/8</systemitem>-Loopback-Netzwerks (wie bei IPv4 beschrieben) kann eine Verbindung zu Ihrem Computer eingerichtet werden. Bei IPv6 gibt es nur eine Loopback-Adresse (<systemitem class="ipaddress">::1</systemitem>).
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Da IP-Adressen weltweit eindeutig sein müssen, können Sie keine Adresse nach dem Zufallsprinzip wählen. Zum Einrichten eines privaten IP-basierten Netzwerks stehen drei Adressdomänen zur Verfügung. Diese können keine Verbindung zum Internet herstellen, da sie nicht über das Internet übertragen werden können. Diese Adressdomänen sind in RFC 1597 festgelegt und werden in <xref linkend="tab.net.basic.privat.net"/> aufgelistet.
   </para>
   <table xml:id="tab.net.basic.privat.net">
    <title>Private IP-Adressdomänen</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>
        <para>
         Netzwerk/Netzmaske
        </para>
       </entry>
       <entry>
        <para>
         Domäne
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         <systemitem class="ipaddress">10.0.0.0</systemitem>/<systemitem class="netmask">255.0.0.0</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         <systemitem class="ipaddress">10.x.x.x</systemitem>
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <systemitem class="ipaddress">172.16.0.0</systemitem>/<systemitem class="netmask">255.240.0.0</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         <systemitem class="ipaddress">172.16.x.x</systemitem> – <systemitem class="ipaddress">172.31.x.x</systemitem>
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <systemitem class="ipaddress">192.168.0.0</systemitem>/<systemitem class="netmask">255.255.0.0</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         <systemitem class="ipaddress">192.168.x.x</systemitem>
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.basicnet.ipv6">
  <title>IPv6 – Das Internet der nächsten Generation</title>

  

  <para>
   Aufgrund der Entstehung des WWW (World Wide Web) hat das Internet in den letzten 15 Jahren ein explosives Wachstum mit einer immer größer werdenden Anzahl von Computern erfahren, die über TCP/IP kommunizieren. Seit Tim Berners-Lee bei CERN (<link xlink:href="http://public.web.cern.ch"/>) 1990 das WWW erfunden hat, ist die Anzahl der Internethosts von ein paar tausend auf ca. 100 Millionen angewachsen.
  </para>

  <para>
   Wie bereits erwähnt, besteht eine IPv4-Adresse nur aus 32 Bit. Außerdem gehen zahlreiche IP-Adressen verloren, da sie aufgrund der organisatorischen Bedingtheit der Netzwerke nicht verwendet werden können. Die Anzahl der in Ihrem Subnetz verfügbaren Adressen ist zwei hoch der Anzahl der Bits minus zwei. Ein Subnetz verfügt also beispielsweise über 2, 6 oder 14 Adressen. Um beispielsweise 128 Hosts mit dem Internet zu verbinden, benötigen Sie ein Subnetz mit 256 IP-Adressen, von denen nur 254 verwendbar sind, da zwei IP-Adressen für die Struktur des Subnetzes selbst benötigt werden: die Broadcast- und die Basisnetzwerkadresse.
  </para>

  <para>
   Unter dem aktuellen IPv4-Protokoll sind DHCP oder NAT (Network Address Translation) die typischen Mechanismen, um einem potenziellen Adressmangel vorzubeugen. Kombiniert mit der Konvention, private und öffentliche Adressräume getrennt zu halten, können diese Methoden den Adressmangel sicherlich mäßigen. Das Problem liegt in der Konfiguration der Adressen, die schwierig einzurichten und zu verwalten ist. Um einen Host in einem IPv4-Netzwerk einzurichten, benötigen Sie mehrere Adressen, z. B. die IP-Adresse des Hosts, die Subnetzmaske, die Gateway-Adresse und möglicherweise die Adresse des Nameservers. Alle diese Einträge müssen bekannt sein und können nicht von anderer Stelle her abgeleitet werden.
  </para>

  <para>
   Mit IPv6 gehören sowohl der Adressmangel als auch die komplizierte Konfiguration der Vergangenheit an. Die folgenden Abschnitte enthalten weitere Informationen zu den Verbesserungen und Vorteilen von IPv6 sowie zum Übergang vom alten zum neuen Protokoll.
  </para>

  <sect2 xml:id="sec.basicnet.ipv6.adv">
   <title>Vorteile</title>
   <para>
    Die wichtigste und augenfälligste Verbesserung durch das neue Protokoll ist der enorme Zuwachs des verfügbaren Adressraums. Eine IPv6-Adresse besteht aus 128-Bit-Werten und nicht aus den herkömmlichen 32 Bit. Dies ermöglicht mehrere Billiarden IP-Adressen.
   </para>
   <para>
    IPv6-Adressen unterscheiden sich nicht nur hinsichtlich ihrer Länge gänzlich von ihren Vorgängern. Sie verfügen auch über eine andere interne Struktur, die spezifischere Informationen zu den Systemen und Netzwerken enthalten kann, zu denen sie gehören. Weitere Informationen hierzu finden Sie in <xref linkend="sec.basicnet.ipv6.address"/>.
   </para>
   <para>
    In der folgenden Liste werden andere Vorteile des neuen Protokolls aufgeführt:
   </para>
   <variablelist>
    <varlistentry>
     <term>Automatische Konfiguration</term>
     <listitem>
      <para>
       IPv6 macht das Netzwerk <quote>Plug-and-Play</quote>-fähig, d. h., ein neu eingerichtetes System wird ohne jegliche manuelle Konfiguration in das (lokale) Netzwerk integriert. Der neue Host verwendet die automatischen Konfigurationsmechanismen, um seine eigene Adresse aus den Informationen abzuleiten, die von den benachbarten Routern zur Verfügung gestellt werden. Dabei nutzt er ein Protokoll, das als <emphasis>ND-Protokoll</emphasis> (Neighbor Discovery) bezeichnet wird. Diese Methode erfordert kein Eingreifen des Administrators und für die Adresszuordnung muss kein zentraler Server verfügbar sein. Dies ist ein weiterer Vorteil gegenüber IPv4, bei dem für die automatische Adresszuordnung ein DHCP-Server erforderlich ist.
      </para>
      <para>
       Wenn ein Router mit einem Switch verbunden ist, sollte der Router jedoch trotzdem periodische Anzeigen mit Flags senden, die den Hosts eines Netzwerks mitteilen, wie sie miteinander interagieren sollen. Weitere Informationen finden Sie im Artikel RFC 2462, auf der man-Seite <systemitem>radvd.conf(5)</systemitem> und im Artikel RFC 3315.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Mobilität</term>
     <listitem>
      <para>
       IPv6 ermöglicht es, einer Netzwerkschnittstelle gleichzeitig mehrere Adressen zuzuordnen. Benutzer können daher einfach auf mehrere Netzwerke zugreifen. Dies lässt sich mit den internationalen Roaming-Diensten vergleichen, die von Mobilfunkunternehmen angeboten werden: Wenn Sie das Mobilfunkgerät ins Ausland mitnehmen, meldet sich das Telefon automatisch bei einem ausländischen Dienst an, der sich im entsprechenden Bereich befindet. Sie können also überall unter der gleichen Nummer erreicht werden und können telefonieren, als wären Sie zu Hause.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Sichere Kommunikation</term>
     <listitem>
      <para>
       Bei IPv4 ist die Netzwerksicherheit eine Zusatzfunktion. IPv6 umfasst IPSec als eine seiner Kernfunktionen und ermöglicht es Systemen, über einen sicheren Tunnel zu kommunizieren, um das Ausspionieren durch Außenstehende über das Internet zu verhindern.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Abwärtskompatibilität</term>
     <listitem>
      <para>
       Realistisch gesehen, ist es unmöglich, das gesamte Internet auf einmal von IPv4 auf IPv6 umzustellen. Daher ist es wichtig, dass beide Protokolle nicht nur im Internet, sondern auf einem System koexistieren können. Dies wird durch kompatible Adressen (IPv4-Adressen können problemlos in IPv6-Adressen konvertiert werden) und die Verwendung von Tunnels gewährleistet. Weitere Informationen hierzu finden Sie unter <xref linkend="sec.basicnet.ipv6.coexist"/>. Außerdem können Systeme eine <emphasis>Dual-Stack-IP</emphasis>-Technik verwenden, um beide Protokolle gleichzeitig unterstützen zu können. Dies bedeutet, dass sie über zwei Netzwerk-Stacks verfügen, die vollständig unabhängig voneinander sind, sodass zwischen den beiden Protokollversionen keine Konflikte auftreten.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Bedarfsgerechte Dienste über Multicasting</term>
     <listitem>
      <para>
       Mit IPv4 müssen einige Dienste, z. B. SMB, ihre Pakete via Broadcast an alle Hosts im lokalen Netzwerk verteilen. IPv6 erlaubt einen sehr viel feineren Ansatz, indem es Servern ermöglicht, Hosts über <emphasis>Multicasting</emphasis> anzusprechen, d. h., sie sprechen mehrere Hosts als Teile einer Gruppe an. (Dies unterscheidet sich von der Adressierung aller Hosts über <emphasis>Broadcasting</emphasis> oder der Einzeladressierung der Hosts über <emphasis>Unicasting</emphasis>.) Welche Hosts als Gruppe adressiert werden, kann je nach Anwendung unterschiedlich sein. Es gibt einige vordefinierte Gruppen, mit der beispielsweise alle Namenserver (die <emphasis>Multicast-Gruppe „all name servers“</emphasis>) oder alle Router (die <emphasis>Multicast-Gruppe „all routers“</emphasis>) angesprochen werden können.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="sec.basicnet.ipv6.address">
   <title>Adresstypen und -struktur</title>
   <para>
    Wie bereits erwähnt hat das aktuelle IP-Protokoll zwei wichtige Nachteile: Es stehen zunehmend weniger IP-Adressen zur Verfügung und das Konfigurieren des Netzwerks und Verwalten der Routing-Tabellen wird komplexer und aufwändiger. IPv6 löst das erste Problem durch die Erweiterung des Adressraums auf 128 Bit. Das zweite Problem wird durch die Einführung einer hierarchischen Adressstruktur behoben, die mit weiteren hoch entwickelten Techniken zum Zuordnen von Netzwerkadressen sowie mit dem <emphasis>Multihoming</emphasis> (der Fähigkeit, einem Gerät mehrere Adressen zuzuordnen und so den Zugriff auf mehrere Netzwerke zu ermöglichen) kombiniert wird.
   </para>
   <para>
    Bei der Arbeit mit IPv6 ist es hilfreich, die drei unterschiedlichen Adresstypen zu kennen:
   </para>
   <variablelist>
    <varlistentry>
     <term>Unicast</term>
     <listitem>
      <para>
       Adressen dieses Typs werden genau einer Netzwerkschnittstelle zugeordnet. Pakete mit derartigen Adressen werden nur einem Ziel zugestellt. Unicast-Adressen werden dementsprechend zum Übertragen von Paketen an einzelne Hosts im lokalen Netzwerk oder im Internet verwendet.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Multicast</term>
     <listitem>
      <para>
       Adressen dieses Typs beziehen sich auf eine Gruppe von Netzwerkschnittstellen. Pakete mit derartigen Adressen werden an alle Ziele zugestellt, die dieser Gruppe angehören. Multicast-Adressen werden hauptsächlich von bestimmten Netzwerkdiensten für die Kommunikation mit bestimmten Hostgruppen verwendet, wobei diese gezielt adressiert werden.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Anycast</term>
     <listitem>
      <para>
       Adressen dieses Typs beziehen sich auf eine Gruppe von Schnittstellen. Pakete mit einer derartigen Adresse werden gemäß den Prinzipien des zugrunde liegenden Routing-Protokolls dem Mitglied der Gruppe gesendet, das dem Absender am nächsten ist. Anycast-Adressen werden verwendet, damit Hosts Informationen zu Servern schneller abrufen können, die im angegebenen Netzwerkbereich bestimmte Dienste anbieten. Sämtliche Server desselben Typs verfügen über dieselbe Anycast-Adresse. Wann immer ein Host einen Dienst anfordert, erhält er eine Antwort von dem vom Routing-Protokoll ermittelten nächstgelegenen Server. Wenn dieser Server aus irgendeinem Grund nicht erreichbar ist, wählt das Protokoll automatisch den zweitnächsten Server, dann den dritten usw. aus.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Eine IPv6-Adresse besteht aus acht vierstelligen Feldern, wobei jedes 16 Bit repräsentiert, und wird in hexadezimaler Notation geschrieben. Sie werden durch Doppelpunkte (<literal>:</literal>) getrennt. Alle führenden Null-Byte innerhalb eines bestimmten Felds können ausgelassen werden, alle anderen Nullen jedoch nicht. Eine weitere Konvention ist, dass mehr als vier aufeinander folgenden Null-Byte mit einem doppelten Doppelpunkt zusammengefasst werden können. Jedoch ist pro Adresse nur ein solcher doppelter Doppelpunkt (<literal>::</literal>) zulässig. Diese Art der Kurznotation wird in <xref linkend="aus.netz.ipv6.add"/> dargestellt, in dem alle drei Zeilen derselben Adresse entsprechen.
   </para>
   <example xml:id="aus.netz.ipv6.add">
    <title>Beispiel einer IPv6-Adresse</title>
<screen>fe80 : 0000 : 0000 : 0000 : 0000 : 10 : 1000 : 1a4
fe80 :    0 :    0 :    0 :    0 : 10 : 1000 : 1a4
fe80 :                           : 10 : 1000 : 1a4</screen>
   </example>
   <para>
    Jeder Teil einer IPv6-Adresse hat eine festgelegte Funktion. Die ersten Byte bilden das Präfix und geben den Typ der Adresse an. Der mittlere Teil ist der Netzwerkteil der Adresse, der möglicherweise nicht verwendet wird. Das Ende der Adresse bildet der Hostteil. Bei IPv6 wird die Netzmaske definiert, indem die Länge des Präfixes nach einem Schrägstrich am Ende der Adresse angegeben wird. Adressen wie in <xref linkend="aus.netz.ipv6.addpre"/> enthalten Informationen zum Netzwerk (die ersten 64 Bit) und zum Hostteil (die letzten 64 Bit). Die <literal>64</literal> bedeutet, dass die Netzmaske mit 64 1-Bit-Werten von links gefüllt wird. Wie bei IPv4 wird die IP-Adresse mit den Werten aus der Netzmaske durch UND verknüpft, um zu ermitteln, ob sich der Host im selben oder einem anderen Subnetz befindet.
   </para>
   <example xml:id="aus.netz.ipv6.addpre">
    <title>IPv6-Adressen mit Angabe der Präfix-Länge</title>
<screen>fe80::10:1000:1a4/64</screen>
   </example>
   <para>
    IPv6 kennt mehrere vordefinierte Präfixtypen. Einige sind unter <xref linkend="list.net.basic.ipv6.prefix"/> aufgeführt.
   </para>
   <variablelist xml:id="list.net.basic.ipv6.prefix">
    <title>Unterschiedliche IPv6-Präfixe</title>
    <varlistentry>
     <term><systemitem class="ipaddress">00</systemitem>
     </term>
     <listitem>
      <para>
       IPv4-über-IPv6-Kompatibilitätsadressen. Diese werden zur Erhaltung der Kompatibilität mit IPv4 verwendet. Für diesen Adresstyp wird ein Router benötigt, der IPv6-Pakete in IPv4-Pakete konvertieren kann. Mehrere spezielle Adressen, z. B. die für das Loopback-Device, verfügen ebenfalls über dieses Präfix.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem class="ipaddress">2</systemitem> oder <systemitem class="ipaddress">3</systemitem> als erste Stelle
     </term>
     <listitem>
      <para>
       Aggregierbare globale Unicast-Adressen. Wie bei IPv4 kann eine Schnittstelle zugewiesen werden, um einen Teil eines bestimmten Subnetzes zu bilden. Aktuell stehen die folgenden Adressräume zur Verfügung: <systemitem class="ipaddress">2001::/16</systemitem> (Adressraum Produktionsqualität) und <systemitem class="ipaddress">2002::/16</systemitem> (6to4-Adressraum).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem class="ipaddress">fe80::/10</systemitem>
     </term>
     <listitem>
      <para>
       Link-local-Adressen. Adressen mit diesem Präfix dürfen nicht geroutet werden und können daher nur im gleichen Subnetz erreicht werden.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem class="ipaddress">fec0::/10</systemitem>
     </term>
     <listitem>
      <para>
       Site-local-Adressen. Diese Adressen dürfen zwar geroutet werden, aber nur innerhalb des Organisationsnetzwerks, dem sie angehören. Damit entsprechen diese Adressen den bisherigen privaten Netzen (beispielsweise <systemitem class="ipaddress">10.x.x.x</systemitem>).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem class="ipaddress">ff</systemitem>
     </term>
     <listitem>
      <para>
       Dies sind Multicast-Adressen.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Eine Unicast-Adresse besteht aus drei grundlegenden Komponenten:
   </para>
   <variablelist>
    <varlistentry>
     <term>Öffentliche Topologie</term>
     <listitem>
      <para>
       Der erste Teil, der unter anderem auch eines der oben erwähnten Präfixe enthält, dient dem Routing des Pakets im öffentlichen Internet. Hier sind Informationen zum Provider oder der Institution kodiert, die den Netzwerkzugang bereitstellen.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Site-Topologie</term>
     <listitem>
      <para>
       Der zweite Teil enthält Routing-Informationen zu dem Subnetz, in dem das Paket zugestellt werden soll.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Schnittstellen-ID</term>
     <listitem>
      <para>
       Der dritte Teil identifiziert eindeutig die Schnittstelle, an die das Paket gerichtet ist. Dies erlaubt, die MAC-Adresse als Adressbestandteil zu verwenden. Da diese weltweit nur einmal vorhanden und zugleich vom Hardwarehersteller fest vorgegeben ist, vereinfacht sich die Konfiguration auf diese Weise sehr. Die ersten 64 Bit werden zu einem so genannten <literal>EUI-64</literal>-Token zusammengefasst. Dabei werden die letzten 48 Bit der MAC-Adresse entnommen und die restlichen 24 Bit enthalten spezielle Informationen, die etwas über den Typ des Tokens aussagen. Das ermöglicht dann auch, Geräten ohne MAC-Adresse (z. B. PPP-Verbindungen) ein <literal>EUI-64</literal>-Token zuzuweisen.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Abgeleitet aus diesem Grundaufbau werden bei IPv6 fünf verschiedene Typen von Unicast-Adressen unterschieden:
   </para>
   <variablelist>
    <varlistentry>
     <term><systemitem class="ipaddress">::</systemitem> (nicht spezifiziert) </term>
     <listitem>
      <para>
       Diese Adresse verwendet ein Host als Quelladresse, wenn seine Netzwerkschnittstelle zum ersten Mal initialisiert wird und die Adresse noch nicht anderweitig ermittelt werden kann.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem class="ipaddress">::1</systemitem> (Loopback) </term>
     <listitem>
      <para>
       Adresse des Loopback-Device.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>IPv4-kompatible Adressen</term>
     <listitem>
      <para>
       Die IPv6-Adresse setzt sich aus der IPv4-Adresse und einem Präfix von 96 0-Bits zusammen. Dieser Typ der Kompatibilitätsadresse wird beim Tunneling verwendet (siehe <xref linkend="sec.basicnet.ipv6.coexist"/>). IPv4/IPv6-Hosts können so mit anderen kommunizieren, die sich in einer reinen IPv4-Umgebung befinden.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>IPv6-gemappte IPv4-Adressen</term>
     <listitem>
      <para>
       Dieser Adresstyp gibt die Adresse in IPv6-Notation an.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Lokale Adressen</term>
     <listitem>
      <para>
       Es gibt zwei Typen von Adressen zum rein lokalen Gebrauch:
      </para>
      <variablelist>
       <varlistentry>
        <term>link-local</term>
        <listitem>
         <para>
          Dieser Adresstyp ist ausschließlich für den Gebrauch im lokalen Subnetz bestimmt. Router dürfen Pakete mit einer solchen Ziel- oder Quelladresse nicht an das Internet oder andere Subnetze weiterreichen. Diese Adressen zeichnen sich durch ein spezielles Präfix (<systemitem class="ipaddress">fe80::/10</systemitem>) und die Schnittstellen-ID der Netzwerkkarte aus. Der Mittelteil der Adresse besteht aus Null-Bytes. Diese Art Adresse wird von den Autokonfigurationsmethoden verwendet, um Hosts im selben Subnetz anzusprechen.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>site-local</term>
        <listitem>
         <para>
          Pakete mit diesem Adresstyp dürfen zwischen einzelnen Subnetzen geroutet werden, aber nicht außerhalb einer Organisation ins Internet gelangen. Solche Adressen werden für Intranets eingesetzt und sind ein Äquivalent zu den privaten IPv4-Adressen. Sie bestehen aus einem besonderen Präfix (<systemitem class="ipaddress">fec0::/10</systemitem>), der Schnittstellen-ID und einem 16-Bit-Feld mit der Subnetz-ID. Die restlichen Stellen werden wieder mit Null-Bytes gefüllt.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Zusätzlich gibt es in IPv6 eine grundsätzlich neue Funktion: Einer Netzwerkschnittstelle werden in der Regel mehrere IP-Adressen zugewiesen. Das hat den Vorteil, dass mehrere verschiedene Netzwerke zur Verfügung stehen. Eines dieser Netzwerke kann mit der MAC-Adresse und einem bekannten Präfix vollautomatisch konfiguriert werden, sodass nach der Aktivierung von IPv6 alle Hosts im lokalen Netz über Link-local-Adressen erreichbar sind. Durch die MAC-Adresse als Bestandteil der IP-Adresse ist jede dieser Adressen global eindeutig. Einzig die Teile der <emphasis>Site-Topologie</emphasis> und der <emphasis>öffentlichen Topologie</emphasis> können variieren, je nachdem in welchem Netz dieser Host aktuell zu erreichen ist.
   </para>
   <para>
    Bewegt sich ein Host zwischen mehreren Netzen hin und her, braucht er mindestens zwei Adressen. Die eine, seine <emphasis>Home-Adresse</emphasis>, beinhaltet neben der Schnittstellen-ID die Informationen zu dem Heimatnetz, in dem der Computer normalerweise betrieben wird, und das entsprechende Präfix. Die Home-Adresse ist statisch und wird in der Regel nicht verändert. Alle Pakete, die für diesen Host bestimmt sind, werden ihm sowohl im eigenen als auch in fremden Netzen zugestellt. Möglich wird die Zustellung im Fremdnetz über wesentliche Neuerungen des IPv6-Protokolls, z. B. <emphasis>Stateless Autoconfiguration</emphasis> und <emphasis>Neighbor Discovery</emphasis>. Der mobile Rechner hat neben seiner Home-Adresse eine oder mehrere weitere Adressen, die zu den fremden Netzen gehören, in denen er sich bewegt. Diese Adressen heißen <emphasis>Care-of</emphasis>-Adressen. Im Heimatnetz des mobilen Rechners muss eine Instanz vorhanden sein, die an seine Home-Adresse gerichtete Pakete nachsendet, sollte er sich in einem anderen Netz befinden. Diese Funktion wird in einer IPv6-Umgebung vom <emphasis>Home-Agenten</emphasis> übernommen. Er stellt alle Pakete, die an die Home-Adresse des mobilen Rechners gerichtet sind, über einen Tunnel zu. Pakete, die als Zieladresse die Care-of-Adresse tragen, können ohne Umweg über den Home-Agenten zugestellt werden.
   </para>
  </sect2>

  <sect2 xml:id="sec.basicnet.ipv6.coexist">
   <title>Koexistenz von IPv4 und IPv6</title>
   <para>
    Die Migration aller mit dem Internet verbundenen Hosts von IPv4 auf IPv6 wird nicht auf einen Schlag geschehen. Vielmehr werden das alte und das neue Protokoll noch eine ganze Weile nebeneinanderher existieren. Die Koexistenz auf einem Rechner ist dann möglich, wenn beide Protokolle im <emphasis>Dual Stack</emphasis>-Verfahren implementiert sind. Es bleibt aber die Frage, wie IPv6-Rechner mit IPv4-Rechnern kommunizieren können und wie IPv6-Pakete über die momentan noch vorherrschenden IPv4-Netze transportiert werden sollen. Tunneling und die Verwendung von Kompatibilitätsadressen (siehe <xref linkend="sec.basicnet.ipv6.address"/>) sind hier die besten Lösungen.
   </para>
   <para>
    IPv6-Hosts, die im (weltweiten) IPv4-Netzwerk mehr oder weniger isoliert sind, können über Tunnel kommunizieren: IPv6-Pakete werden als IPv4-Pakete gekapselt und so durch ein ein IPv4-Netzwerk übertragen. Ein <emphasis>Tunnel</emphasis> ist definiert als die Verbindung zwischen zwei IPv4-Endpunkten. Hierbei müssen die Pakete die IPv6-Zieladresse (oder das entsprechende Präfix) und die IPv4-Adresse des entfernten Hosts am Tunnelendpunkt enthalten. Einfache Tunnel können von den Administratoren zwischen ihren Netzwerken manuell und nach Absprache konfiguriert werden. Ein solches Tunneling wird <emphasis>statisches Tunneling</emphasis> genannt.
   </para>
   <para>
    Trotzdem reicht manuelles Tunneling oft nicht aus, um die Menge der zum täglichen vernetzten Arbeiten nötigen Tunnel aufzubauen und zu verwalten. Aus diesem Grund wurden für IPv6 drei verschiedene Verfahren entwickelt, die das <emphasis>dynamische Tunneling</emphasis> erlauben:
   </para>
   <variablelist>
    <varlistentry>
     <term>6over4</term>
     <listitem>
      <para>
       IPv6-Pakete werden automatisch in IPv4-Pakete verpackt und über ein IPv4-Netzwerk versandt, in dem Multicasting aktiviert ist. IPv6 wird vorgespiegelt, das gesamte Netzwerk (Internet) sei ein einziges, riesiges LAN (Local Area Network). So wird der IPv4-Endpunkt des Tunnel automatisch ermittelt. Nachteile dieser Methode sind die schlechte Skalierbarkeit und die Tatsache, dass IP-Multicasting keineswegs im gesamten Internet verfügbar ist. Diese Lösung eignet sich für kleinere Netzwerke, die die Möglichkeit von IP-Multicasting bieten. Die zugrunde liegenden Spezifikationen sind in RFC 2529 enthalten.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>6to4</term>
     <listitem>
      <para>
       Bei dieser Methode werden automatisch IPv4-Adressen aus IPv6-Adressen generiert. So können isolierte IPv6-Hosts über ein IPv4-Netz miteinander kommunizieren. Allerdings gibt es einige Probleme, die die Kommunikation zwischen den isolierten IPv6-Hosts und dem Internet betreffen. Diese Methode wird in RFC 3056 beschrieben.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>IPv6 Tunnel Broker</term>
     <listitem>
      <para>
       Dieser Ansatz sieht spezielle Server vor, die für IPv6 automatisch dedizierte Tunnel anlegen. Diese Methode wird in RFC 3053 beschrieben.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="sec.basicnet.ipv6.config">
   <title>IPv6 konfigurieren</title>

   <para>
    Um IPv6 zu konfigurieren, müssen Sie auf den einzelnen Arbeitsstationen in der Regel keine Änderungen vornehmen. IPv6 ist standardmäßig aktiviert. Um IPv6 auf einem installierten System zu deaktivieren oder zu aktivieren, verwenden Sie das Modul YaST-<guimenu>Netzwerkeinstellungen</guimenu>. Aktivieren oder deaktivieren Sie auf dem Karteireiter <guimenu>Globale Optionen</guimenu> die Option <guimenu>IPv6 aktivieren</guimenu>, falls nötig. Wenn Sie es bis zum nächsten Neustart vorübergehend aktivieren möchten, geben Sie <command>modprobe </command> <option>-i ipv6</option> als <systemitem class="username">root</systemitem> ein. Nach dem Laden des IPv6-Moduls kann es nicht mehr entladen werden.
   </para>
   <para>
    Aufgrund des Konzepts der automatischen Konfiguration von IPv6 wird der Netzwerkkarte eine Adresse im <emphasis>Link-local</emphasis>-Netzwerk zugewiesen. In der Regel werden Routing-Tabellen nicht auf Arbeitsstationen verwaltet. Bei Netzwerkroutern kann von der Arbeitsstation unter Verwendung des <emphasis>Router-Advertisement-Protokolls</emphasis> abgefragt werden, welches Präfix und welche Gateways implementiert werden sollen. Zum Einrichten eines IPv6-Routers kann das radvd-Programm verwendet werden. Dieses Programm informiert die Arbeitsstationen darüber, welches Präfix und welche Router für die IPv6-Adressen verwendet werden sollen. Alternativ können Sie die Adressen und das Routing auch mit zebra/quagga automatisch konfigurieren.
   </para>

   <para>
    Weitere Informationen zum Einrichten verschiedneer Tunnel mit den Dateien in <filename>/etc/sysconfig/network</filename> finden Sie auf der man-Seite zu <literal>ifcfg-tunnel</literal> (<command>man ifcfg-tunnel</command>).
   </para>
  </sect2>

  <sect2 xml:id="sec.basicnet.ipv6.moreinfo">
   <title>Weiterführende Informationen</title>
   <para>
    Das komplexe IPv6-Konzept wird im obigen Überblick nicht vollständig abgedeckt. Weitere ausführliche Informationen zu dem neuen Protokoll finden Sie in den folgenden Online-Dokumentationen und -Büchern:
   </para>
   <variablelist>
    <varlistentry>
     <term><link xlink:href="http://www.ipv6.org/"/>
     </term>
     <listitem>
      <para>
       Alles rund um IPv6.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link xlink:href="http://www.ipv6day.org"/>
     </term>
     <listitem>
      <para>
       Alle Informationen, die Sie benötigen, um Ihr eigenes IPv6-Netzwerk zu starten.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link xlink:href="http://www.ipv6-to-standard.org/"/>
     </term>
     <listitem>
      <para>
       Die Liste der IPv6-fähigen Produkte.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link xlink:href="http://www.bieringer.de/linux/IPv6/"/>
     </term>
     <listitem>
      <para>
       Hier finden Sie den Beitrag „Linux IPv6 HOWTO“ und viele verwandte Links zum Thema.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>RFC 2640</term>
     <listitem>
      <para>
       Die grundlegenden IPv6-Spezifikationen.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>IPv6 Essentials</term>
     <listitem>
      <para>
       Ein Buch, in dem alle wichtigen Aspekte zum Thema enthalten sind, ist <emphasis>IPv6 Essentials</emphasis> von Silvia Hagen (ISBN 0-596-00125-8).
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.basicnet.nameres">
  <title>Namensauflösung</title>

  <para>
   Mithilfe von DNS kann eine IP-Adresse einem oder sogar mehreren Namen zugeordnet werden und umgekehrt auch ein Name einer IP-Adresse. Unter Linux erfolgt diese Umwandlung üblicherweise durch eine spezielle Software namens bind. Der Computer, der diese Umwandlung dann erledigt, nennt sich <emphasis>Namenserver</emphasis>. Dabei bilden die Namen wieder ein hierarchisches System, in dem die einzelnen Namensbestandteile durch Punkte getrennt sind. Die Namenshierarchie ist aber unabhängig von der oben beschriebenen Hierarchie der IP-Adressen.
  </para>

  <para>
   Ein Beispiel für einen vollständigen Namen wäre <systemitem class="fqdomainname">jupiter.example.com</systemitem>, geschrieben im Format <systemitem class="fqdomainname">Hostname.Domäne</systemitem>. Ein vollständiger Name, der als <emphasis>Fully Qualified Domain Name</emphasis> oder kurz als FQDN bezeichnet wird, besteht aus einem Host- und einem Domänennamen (<systemitem class="domainname">example.com</systemitem>). Ein Bestandteil des Domänennamens ist die <emphasis>Top Level Domain</emphasis> oder TLD (<systemitem class="domainname">com</systemitem>).
  </para>

  <para>
   Aus historischen Gründen ist die Zuteilung der TLDs etwas verwirrend. So werden in den USA traditionell dreibuchstabige TLDs verwendet, woanders aber immer die aus zwei Buchstaben bestehenden ISO-Länderbezeichnungen. Seit 2000 stehen zusätzliche TLDs für spezielle Sachgebiete mit zum Teil mehr als drei Buchstaben zur Verfügung (z. B. <systemitem class="domainname">.info</systemitem>, <systemitem class="domainname">.name</systemitem>, <systemitem class="domainname">.museum</systemitem>).
  </para>

  <para>
   In der Frühzeit des Internets (vor 1990) gab es die Datei<filename>/etc/hosts</filename>, in der die Namen aller im Internet vertretenen Rechner gespeichert waren. Dies erwies sich bei der schnell wachsenden Menge der mit dem Internet verbundenen Computer als unpraktikabel. Deshalb wurde eine dezentralisierte Datenbank entworfen, die die Hostnamen verteilt speichern kann. Diese Datenbank, eben jener oben erwähnte Namenserver, hält also nicht die Daten aller Computer im Internet vorrätig, sondern kann Anfragen an ihm nachgeschaltete, andere Namenserver weiterdelegieren.
  </para>

  <para>
   An der Spitze der Hierarchie befinden sich die <emphasis>Root-Namenserver</emphasis>. Die root-Namenserver verwalten die Domänen der obersten Ebene (Top Level Domains) und werden vom Network Information Center (NIC) verwaltet. Der Root-Namenserver kennt die jeweils für eine Top Level Domain zuständigen Namenserver. Weitere Informationen zu TLD-NICs finden Sie unter <link xlink:href="http://www.internic.net"/>.
  </para>

  <para>
   Der DNS bietet viel mehr Möglichkeiten als die bloße Namensauflösung. Der Namenserver weiß auch, welcher Host für eine ganze Domäne E-Mails annimmt, der so genannte <emphasis>Mail Exchanger (MX)</emphasis>.
  </para>

  <para>
   Damit auch Ihr Computer einen Namen in eine IP-Adresse auflösen kann, muss ihm mindestens ein Nameserver mit einer IP-Adresse bekannt sein. Ein Namensserver kann einfach mithilfe von YaST angegeben werden.  
  </para>

  <para>
   Eng verwandt mit DNS ist das Protokoll <literal>whois</literal>. Mit dem gleichnamigen Programm können Sie schnell ermitteln, wer für eine bestimmte Domäne verantwortlich ist.
  </para>



  <note>
   <title>MDNS- und .local-Domänennamen</title>
   <para>
    Die Domäne <literal>.local</literal> der obersten Stufe wird vom Resolver als link-local-Domäne behandelt. DNS-Anforderungen werden als Multicast-DNS-Anforderungen anstelle von normalen DNS-Anforderungen gesendet. Wenn Sie in Ihrer Nameserver-Konfiguration die Domäne <literal>.local</literal> verwenden, müssen Sie diese Option in <filename>/etc/host.conf</filename> ausschalten. Weitere Informationen finden Sie auf der man-Seite <filename>host.conf</filename>. 
   </para>
   <para>
    Wenn Sie MDNS während der Installation ausschalten möchten, verwenden Sie <literal>nomdns=1</literal> als Boot-Parameter.
   </para>
   <para>
    Weitere Informationen zum Multicast-DNS finden Sie unter <link xlink:href="http://www.multicastdns.org"/>.
   </para>
  </note>
 </sect1>
 <xi:include href="net_yast.xml"/>
 <xi:include href="networkmanager.xml"/>
 <xi:include href="net_wicked.xml"/>
 
 <xi:include href="net_bonding.xml"/>
 <xi:include href="net_teaming.xml"/>
 
</chapter>
