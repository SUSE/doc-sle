<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "generic-entities.ent">
    %entities;
]>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0"
 xmlns:xi="http://www.w3.org/2001/XInclude"
 xmlns:xlink="http://www.w3.org/1999/xlink"
 xml:id="cha-ulp" xml:lang="en">
  <title>User space live patching</title>
  <info>
    <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
      <dm:bugtracker></dm:bugtracker>
      <dm:translation>yes</dm:translation>
    </dm:docmanager>
    <abstract>
      <para>
        This chapter describes the basic principles and usage of &ulp;.
      </para>
    </abstract>
  </info>
  <sect1 xml:id="sec-ulp">
    <title>About &ulp;</title>

    <important os="slemicro">
      <title>&ulp; technical preview</title>
      <para>
        On &slema;, &ulpa; is a technical preview only.
      </para>
    </important>

    <note os="slemicro">
      <title>Live patching on &slema;</title>
      <para>
        Only the currently running processes are affected by the live patches.
        As the libraries are changed in the new snapshot and
        <emphasis role="bold">not</emphasis> in the current one, new processes
        started in the current snapshot still use the non-patched libraries
        until you reboot. After the reboot, the system switches to the new
        snapshot and all started processes will use the patched libraries.
      </para>
    </note>

    <para>
      User space live patching (&ulpa;) refers to the process of applying
      patches to the libraries used by a running process, without interrupting
      it. This means that once a security fix is available as a livepatch,
      then customer services will be secured without restart through a livepatch apply.
    </para>
    <para>
      Live patching operations are performed using the
      <systemitem>ulp</systemitem> tool that is part of the
      <systemitem>libpulp</systemitem>.
    </para>

    <para>
      <systemitem>libpulp</systemitem> is a framework that enables &ulp;. It
      consists of the <systemitem>libpulp.so</systemitem> library and tools for
      making libraries live-patchable and applying live patches (the
      <systemitem>ulp</systemitem> binary).
    </para>

    <sect2 xml:id="sec-ulp-prereqs">
      <title>Prerequisites</title>
      <para>
        For &ulpa; to work, two requirements must be met.
      </para>
      <itemizedlist>
        <listitem os="slemicro">
          <para>
            Install the &ulpa; on your system by running:
          </para>
<screen>&prompt.root;transactional-update pkg in libpulp0 libpulp-tools</screen>
          <para>
            After successful installation, reboot your system.
          </para>
        </listitem>
        <listitem os="sles;sled">
          <para>
            Install the &ulpa; on your system by running:
          </para>
<screen>&prompt.sudo;zypper in libpulp0 libpulp-tools</screen>
        </listitem>
        <listitem>
          <para>
            Applications with desired livepatch support must be
            launched preloading <systemitem>libpulp.so.0</systemitem>. See <xref linkend="sec-ulp-libpulp"/> for more details.
          </para>
        </listitem>
      </itemizedlist>
    </sect2>
    <sect2 xml:id="sec-ulp-supported-libs">
      <title> Supported Libraries</title>
      <para>
        Currently, only glibc and openssl (openssl1_1) are supported. To receive glibc
        and openssl live patches, install both <systemitem>glibc-livepatches</systemitem> and <systemitem>openssl-livepatches</systemitem> packages:
        <screen>> zypper install glibc-livepatches openssl-livepatches</screen>
        And more packages will be available as components are prepared for livepatching.
      </para>
    </sect2>

    <sect2 xml:id="sec-ulp-libpulp">
      <title>Using libpulp</title>
      <para>
        To use <systemitem>libpulp</systemitem> with an application, you must
        preload <systemitem>libpulp.so.0</systemitem>:
        <screen>> LD_PRELOAD=/usr/lib64/libpulp.so.0 <replaceable>APPLICATION</replaceable></screen>
        This is enough to enable livepatching support on it.
      </para>
      <sect3 xml:id="sec-ulp-livepatch-check">
        <title>Checking if a library is live-patchable</title>
        <para>
          To check whether a library is live-patchable, use the following
          command:
        </para>
<screen>> ulp livepatchable <replaceable>LIBRARY</replaceable></screen>
      </sect3>
      <sect3 xml:id="sec-ulp-livepatch-container-check">
        <title>Checking if a <filename>.so</filename> file is a live patch container</title>
        <para>
          A shared object (<filename>.so</filename>) is a live patch container
          if it contains the ULP patch description embedded into it. You can
          verify it with the following command:
        </para>
<screen>&prompt.user;readelf -S <replaceable>SHARED_OBJECT</replaceable> | grep .ulp</screen>
        <para>
          If the output shows that there are both <literal>.ulp</literal> and
          <literal>.ulp.rev</literal> sections in the shared object, then it is
          a live patch container.
        </para>
      </sect3>
      <sect3 xml:id="sec-ulp-apply-livepatch">
        <title>Applying live patches</title>
        <para>
          Live patches are applied using the <systemitem>ulp
          trigger</systemitem> command, for example:
        </para>
<screen>> ulp trigger -p <replaceable>PID</replaceable> <replaceable>LIVEPATCH</replaceable>.so</screen>
        <para>
          In this example, <literal>PID</literal> is the PID of the running
          process that uses the library to be patched and
          <literal>LIVEPATCH.so</literal> is the actual live patch file.
        </para>
        <para>
          The <literal>SUCCESS</literal> status message indicates that
          the live-patching operation was successful. The <literal>SKIPPED</literal>
          message indicates that the patch was skipped because it was not designed
          for any library that is loaded in the process. The <literal>ERROR</literal>
          message indicates an error, and more information can be retrieved by
          inspectioning the libpulp internal message buffer. See <xref linkend="sec-ulp-internal-messages"/> for more information.
        </para>
        <para>
          It is also possible to apply multiple live patches by using
          wildcards. For example:
        </para>
<screen>&prompt.user;ulp trigger '*.so'</screen>
        <para>
          This command will try to apply every patch in the current folder to
          every process that have libpulp loaded. If the patch is not suitable for
          the process, it will be automatically skipped. In the end, the tool will
          show how many patches it successfully applied to how many processes.
        </para>
      </sect3>
      <sect3 xml:id="sec-ulp-revert-livepatch">
        <title>Reverting live patches</title>
        <para>
          <command>ulp trigger</command> can be used to revert live patches.
          There are two ways to revert live patches. You can revert a live
          patch by using the <option>--revert</option> switch and passing the
          live patch container:
        </para>
<screen>&prompt.user;ulp trigger -p <replaceable>PID</replaceable> --revert <replaceable>LIVEPATCH</replaceable>.so</screen>
        <para>
          Alternatively, it is possible to remove all patches associated with a
          particular library. For example:
        </para>
<screen>> ulp trigger -p <replaceable>PID</replaceable> --revert-all=<replaceable>LIBRARY</replaceable></screen>
        <para>
          In the example above, <replaceable>LIBRARY</replaceable> refers to
          the actual library, for example:
          <systemitem>libcrypto.so.1.1</systemitem>.
        </para>
        <para>
          The latter approach can be useful when the source code of the
          original live patch is not available, or you want to remove a
          specific old patch and apply a new one, without the target
          application running potentially unsecured code. For example:
        </para>
<screen>&prompt.user;ulp trigger -p <replaceable>PID</replaceable>  --revert-all=libcrypto.so.1.1 new_livepatch2.so</screen>
      </sect3>
      <sect3 xml:id="sec-ulp-verify-patches">
        <title>View applied patches</title>
        <para>
          It is possible to verify which applications has livepatches applied by running:
        </para>
        <screen>> sudo ulp patches</screen>
        <para>
          sudo is only necessary to see patches of other users processes.
          The output will show which libraries are livepatchable and
          patches loaded in programs, as well which bugs the patch
          addresses:
        </para>
        <screen>
PID: 10636, name: test
  Livepatchable libraries:
    in /lib64/libc.so.6:
      livepatch: libc_livepatch1.so
        bug labels: jsc#SLE-0000
    in /usr/lib64/libpulp.so.0:
        </screen>
        <para>
          It is also possible to see which functions are patched by the livepatch:
        </para>
        <screen>> ulp dump <replaceable>LIVEPATCH.so</replaceable>
        </screen>
      </sect3>

      <sect3 xml:id="sec-ulp-internal-messages">
        <title>View internal message queue</title>
        <para>
          Log messages from libpulp.so are stored in a buffer inside the library
          and are not displayed unless requested by the user. To show these messages,
          run:
        </para>
        <screen>> ulp messages -p <replaceable>PID</replaceable></screen>
      </sect3>
    </sect2>
  </sect1>
  <sect1 xml:id="sec-ulp-info">
    <title>More information</title>

    <para>
      Further information about <systemitem>libpulp</systemitem> is available
      in the project's <link xlink:href="https://github.com/SUSE/libpulp">Git
      repository</link>.
    </para>
  </sect1>
</chapter>
