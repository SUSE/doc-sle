<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="systemd.xml" version="5.0" xml:id="cha-systemd">
 <title>Daemon <systemitem class="daemon">systemd</systemitem></title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>
 <para>
  O <systemitem class="daemon">systemd</systemitem> é responsável pela inicialização do sistema e tem o ID de processo 1. O <systemitem class="daemon">systemd</systemitem> é iniciado diretamente pelo kernel e resiste ao sinal 9, que normalmente termina os processos. Todos os outros programas são iniciados diretamente pelo <systemitem class="daemon">systemd</systemitem> ou por um de seus processos filho. O <systemitem class="daemon">systemd</systemitem> é um substituto do daemon init do System V e é totalmente compatível com o init do System V (por meio do suporte a scripts init).
 </para>
 <para>
  A principal vantagem do <systemitem class="daemon">systemd</systemitem> é que ele acelera consideravelmente o tempo de boot ao paralelizar as inicializações de serviços. Além disso, o <systemitem class="daemon">systemd</systemitem> apenas inicia um serviço quando é realmente necessário. Os daemons não são iniciados incondicionalmente no momento da inicialização, mas quando são solicitados pela primeira vez. O <systemitem class="daemon">systemd</systemitem> também suporta Grupos de Controle de Kernel (cgroups), criando instantâneos e restaurando o estado do sistema. Para obter mais detalhes, consulte <link xlink:href="http://www.freedesktop.org/wiki/Software/systemd/"/>.
 </para>
   
 <sect1 xml:id="sec-boot-systemd-concept">
  <title>Conceito do <systemitem class="daemon">systemd</systemitem></title>
  <para>
   A seção a seguir explica o conceito por trás do <systemitem class="daemon">systemd</systemitem>.
  </para>
  <para>
    O <systemitem class="daemon">systemd</systemitem> é um gerenciador de sistema e sessão para Linux, compatível com os scripts init do System V e do LSB. Os principais recursos do <systemitem class="daemon">systemd</systemitem> são:
  </para>
    <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>
      recursos de paralelização
     </para>
    </listitem>
    <listitem>
     <para>
      ativação de soquete e D-Bus para iniciar serviços
     </para>
    </listitem>
    <listitem>
     <para>
      iniciar daemons sob demanda
     </para>
    </listitem>
    <listitem>
     <para>
      monitoramento de processos usando cgroups do Linux
     </para>
    </listitem>
    <listitem>
     <para>
      criação de instantâneos e restauração do estado do sistema
     </para>
    </listitem>
    <listitem>
     <para>
      manutenção dos pontos de montagem e automount
     </para>
    </listitem>
    <listitem>
     <para>
      implementação de uma lógica elaborada de controle de serviço baseada em dependência transacional
     </para>
    </listitem>
   </itemizedlist>

   <sect2 xml:id="sec-boot-systemd-unitfile">
   <title>Arquivo unit</title>
   <para>
    O arquivo de configuração unit contém informações sobre serviço, soquete, dispositivo, ponto de montagem, ponto de automount, arquivo de troca (swap) ou partição, destino de inicialização, caminho do sistema de arquivos monitorado, temporizador controlado e supervisionado pelo <systemitem class="daemon">systemd</systemitem>, instantâneo de estado do sistema temporário, fração de gerenciamento de recursos ou grupo de processos criados externamente.
   </para>
   <para>
    O <quote>arquivo unit</quote> é um termo genérico usado pelo <systemitem class="daemon">systemd</systemitem> para o seguinte:
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <formalpara>
      <title>Serviço</title>
      <para>
       Informações sobre um processo (por exemplo, a execução de um daemon); o arquivo termina com .service
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Destinos</title>
      <para>
       Usado para agrupar unidades e como pontos de sincronização durante a inicialização; o arquivo termina com .target
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Soquetes</title>
      <para>
       Informações sobre um soquete de rede, IPC ou FIFO do sistema de arquivos, para ativação baseada em soquete (como <systemitem class="daemon">inetd</systemitem>); o arquivo termina com .socket
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Caminho</title>
      <para>
       Usado para acionar outras unidades (por exemplo, executar um serviço quando houver mudanças nos arquivos); o arquivo termina com .path
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Timer</title>
      <para>
       Informações sobre um temporizador controlado, para ativação baseada em temporizador; o arquivo termina com .timer
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Ponto de montagem</title>
      <para>
       Normalmente, gerado de forma automática pelo gerador fstab; o arquivo termina com .mount
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Ponto de automount</title>
      <para>
       Informações sobre um ponto de automount do sistema de arquivos; o arquivo termina com .automount
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Swap</title>
      <para>
       Informações sobre um dispositivo ou arquivo de troca para paginação de memória; o arquivo termina com .swap
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Dispositivo</title>
      <para>
       Informações sobre uma unidade de dispositivo conforme exposta na árvore de dispositivos do sysfs/udev(7); o arquivo termina com .device
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Escopo/Fração</title>
      <para>
       Um conceito de gerenciamento hierárquico de recursos de um grupo de processos; o arquivo termina com .scope/.slice
      </para>
     </formalpara>
    </listitem>
   </itemizedlist>
     
   <para>
    Para obter mais informações sobre arquivos de unidade do <systemitem class="daemon">systemd</systemitem>, acesse <link xlink:href="http://www.freedesktop.org/software/systemd/man/systemd.unit.html"/>
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-boot-systemd-basics">
  <title>Uso básico</title>

  <para>
   O sistema init do System V usa vários comandos para gerenciar serviços: scripts init, <command>insserv</command>, <command>telinit</command> e outros. O <systemitem class="daemon">systemd</systemitem> facilita gerenciar serviços, já que existe apenas um comando para ser memorizado para a maioria das tarefas de gerenciamento de serviços: <command>systemctl</command>. Ele usa a notação <quote>command plus subcommand</quote>, como <command>git</command> ou <command>zypper</command>:
  </para>

<screen>systemctl <replaceable>GENERAL OPTIONS</replaceable> <replaceable>SUBCOMMAND</replaceable> <replaceable>SUBCOMMAND OPTIONS</replaceable></screen>

  <para>
   Consulte <command>man 1 systemctl</command> para obter o manual completo.
  </para>

  <tip>
   <title>Saída de terminal e complementação do bash</title>
   <para>
    Se a saída chegar a um terminal (e não a um pipe ou arquivo, por exemplo), por padrão, os comandos <systemitem class="daemon">systemd</systemitem> enviarão uma saída extensa para um pager. Use a opção <option>--no-pager</option> para desativar o modo de paginação.
   </para>
   <para>
    O <systemitem class="daemon">systemd</systemitem> também suporta a complementação do bash, que permite digitar as primeiras letras de um subcomando e pressionar <keycap function="tab"/>. Esse recurso está disponível apenas no shell <systemitem>bash</systemitem> e requer a instalação do pacote <systemitem class="resource">bash-completion</systemitem>.
   </para>
  </tip>

  <sect2 xml:id="sec-boot-systemd-basics-services">
   <title>Gerenciando serviços em um sistema em execução</title>
   <para>
    Os subcomandos de gerenciamento de serviços são os mesmos usados para gerenciar um serviço com o init do System V (<command>start</command>, <command>stop</command>, etc.). A sintaxe geral dos comandos de gerenciamento de serviços é a seguinte:
   </para>
   <variablelist>
    <varlistentry>
     <term><systemitem class="daemon">systemd</systemitem></term>
     <listitem>
<screen>systemctl reload|restart|start|status|stop|<replaceable>...</replaceable> <replaceable>MY_SERVICE(S)</replaceable></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Init do System V</term>
     <listitem>
<screen>rc<replaceable>MY_SERVICE(S)</replaceable> reload|restart|start|status|stop|<replaceable>...</replaceable></screen>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    O <systemitem class="daemon">systemd</systemitem> permite gerenciar vários serviços de uma só vez. Em vez de executar os scripts init um após o outro como acontece com o init do System V, execute um comando da seguinte forma:
   </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl start <replaceable>MY_1ST_SERVICE</replaceable> <replaceable>MY_2ND_SERVICE</replaceable></screen>
   <para>
    Para listar todos os serviços disponíveis no sistema:
   </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl list-unit-files --type=service</screen>
   <para>
    A tabela a seguir lista os comandos de gerenciamento de serviços mais importantes para o <systemitem class="daemon">systemd</systemitem> e o init do System V:
   </para>
   <table rowsep="1">
    <title>Comandos de gerenciamento de serviços</title>
    <tgroup cols="3">
     <colspec colnum="1" colname="1" colwidth="50*"/>
     <colspec colnum="2" colname="2" colwidth="30*"/>
     <colspec colnum="3" colname="3" colwidth="20*"/>
     <thead>
      <row>
       <entry colname="1">
        <para>
         Tarefa
        </para>
       </entry>
       <entry colname="2">
        <para>
         Comando <systemitem class="daemon">systemd</systemitem>
        </para>
       </entry>
       <entry colname="3">
        <para>
         Comando init do System V
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Iniciando</title>
         <para/>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>start</screen>
       </entry>
       <entry colname="3">
<screen>start</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Parar</title>
         <para/>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>stop</screen>
       </entry>
       <entry colname="3">
<screen>stop</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Reiniciar</title>
         <para>
          Encerra os serviços e os inicia na sequência. Se algum serviço ainda não estiver em execução, ele será iniciado.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>restart</screen>
       </entry>
       <entry colname="3">
<screen>restart</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Reiniciar condicionalmente</title>
         <para>
          Reinicia os serviços se já estiverem em execução. Não faz nada para os serviços que não estão em execução.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>try-restart</screen>
       </entry>
       <entry colname="3">
<screen>try-restart</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Recarregar</title>
         <para>
          Instrui os serviços a recarregarem seus arquivos de configuração sem interromper a operação. Caso de uso: Instruir o Apache a recarregar um arquivo de configuração <filename>httpd.conf</filename> modificado. Observe que nem todos os serviços suportam recarregamento.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>reload</screen>
       </entry>
       <entry colname="3">
<screen>reload</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Recarregar ou reiniciar</title>
         <para>
          Recarrega os serviços quando o recarregamento é suportado; do contrário, reinicia-os. Se algum serviço ainda não estiver em execução, ele será iniciado.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>reload-or-restart</screen>
       </entry>
       <entry colname="3">
<screen>n/a</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Recarregar ou reiniciar condicionalmente</title>
         <para>
          Recarrega os serviços se o recarregamento for suportado; do contrário reinicia-os, se estiverem em execução. Não faz nada para os serviços que não estão em execução.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>reload-or-try-restart</screen>
       </entry>
       <entry colname="3">
<screen>n/a</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Obter informações detalhadas sobre status</title>
         <para>
          Lista as informações sobre o status dos serviços. O comando <systemitem class="daemon">systemd</systemitem> mostra detalhes, como descrição, executável, status, cgroup e as últimas mensagens emitidas por um serviço (consulte a <xref linkend="sec-boot-systemd-basics-services-debugging"/>). O nível dos detalhes exibidos com o init do System V varia de acordo com cada serviço.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>status</screen>
       </entry>
       <entry colname="3">
<screen>status</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Obter informações resumidas sobre status</title>
         <para>
          Mostra se os serviços estão ou não ativos.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>is-active</screen>
       </entry>
       <entry colname="3">
<screen>status</screen>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-basics-services-enabling">
   <title>Habilitando/Desabilitando serviços permanentemente</title>
   <para>
    Os comandos de gerenciamento de serviços mencionados na seção anterior permitem manipular serviços na seção atual. O <systemitem class="daemon">systemd</systemitem> também permite habilitar ou desabilitar serviços permanentemente para serem iniciados automaticamente quando solicitados ou para ficarem sempre indisponíveis. É possível fazer isso com o YaST ou por linha de comando.
   </para>
   <sect3 xml:id="sec-boot-systemd-basics-services-enabling-cmd">
    <title>Habilitando/Desabilitando serviços na linha de comando</title>
    <para>
     A tabela a seguir lista os comandos de habilitação e desabilitação pelo <systemitem class="daemon">systemd</systemitem> e pelo init do System V:
    </para>
    <important>
     <title>Inicialização de serviço</title>
     <para>
      Ao habilitar um serviço na linha de comando, ele não é iniciado automaticamente. Ele é programado para iniciar na próxima inicialização do sistema ou mudança de nível de execução/destino. Para iniciar um serviço logo após habilitá-lo, execute explicitamente <command>systemctl start <replaceable>MEU_SERVIÇO</replaceable></command> ou <command>rc <replaceable>MEU_SERVIÇO</replaceable> start</command>.
     </para>
    </important>
    <table rowsep="1">
     <title>Comandos para habilitar e desabilitar serviços</title>
     <tgroup cols="3">
      <colspec colnum="1" colname="1" colwidth="32*"/>
      <colspec colnum="2" colname="2" colwidth="40*"/>
      <colspec colnum="3" colname="3" colwidth="28*"/>
      <thead>
       <row>
        <entry colname="1">
         <para>
          Tarefa
         </para>
        </entry>
        <entry colname="2">
         <para>
          Comando <systemitem class="daemon">systemd</systemitem>
         </para>
        </entry>
        <entry colname="3">
         <para>
          Comando init do System V
         </para>
        </entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Habilitar</title>
          <para/>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl enable <replaceable>MEU(S)_SERVIÇO(S)</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>insserv <replaceable>MEU(S)_SERVIÇO(S)</replaceable></command>, <command>chkconfig -a <replaceable>MEU(S)_SERVIÇO(S)</replaceable></command>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Desabilitar</title>
          <para/>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl disable <replaceable>MEU(S)_SERVIÇO(S)</replaceable>.service</command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>insserv -r <replaceable>MEU(S)_SERVIÇO(S)</replaceable></command>, <command>chkconfig -d <replaceable>MEU(S)_SERVIÇO(S)</replaceable></command>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Verificar</title>
          <para>
           Mostra se um serviço está ou não habilitado.
          </para>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl is-enabled <replaceable>MEU_SERVIÇO</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>chkconfig <replaceable>MEU_SERVIÇO</replaceable></command>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Reabilitar</title>
          <para>
           Semelhante a reiniciar um serviço, este comando primeiro desabilita e depois habilita um serviço. Útil para restaurar um serviço aos seus padrões.
          </para>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl reenable <replaceable>MEU_SERVIÇO</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/d
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Mascarar</title>
          <para>
           Após <quote>desabilitar</quote> um serviço, ele ainda poderá ser iniciado manualmente. Para desabilitar um serviço completamente, é necessário mascará-lo. Use com cuidado.
          </para>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl mask <replaceable>MEU_SERVIÇO</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/d
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Desmascarar</title>
          <para>
           Só será possível usar novamente um serviço mascarado depois que ele for desmascarado.
          </para>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl unmask <replaceable>MEU_SERVIÇO</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/d
         </para>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-boot-systemd-boot">
  <title>Inicialização do sistema e gerenciamento de destino</title>

  <para>
   Todo o processo de inicialização e encerramento do sistema é mantido pelo <systemitem class="daemon">systemd</systemitem>. Desse ponto de vista, o kernel pode ser considerado um processo em segundo plano para manter todos os outros processos e ajustar o horário da CPU e o acesso ao hardware de acordo com as solicitações de outros programas.
  </para>

  <sect2 xml:id="sec-boot-systemd-targets">
   <title>Comparação entre destinos e níveis de execução</title>
   <para>
    Com o init do System V, o sistema era inicializado no chamado <quote>Nível de execução</quote>. O nível de execução define como o sistema é iniciado e quais serviços estão disponíveis no sistema em execução. Os níveis de execução são numerados: os mais conhecidos são <literal>0</literal> (encerramento do sistema), <literal>3</literal> (multiusuário com rede) e <literal>5</literal> (multiusuário com rede e gerenciador de exibição).
   </para>
   <para>
    O <systemitem class="daemon">systemd</systemitem> apresenta um novo conceito usando as chamadas <quote>unidades de destino</quote>. No entanto, ele continua totalmente compatível com o conceito de nível de execução. As unidades de destino são nomeadas, e não numeradas, e possuem finalidades específicas. Por exemplo, os destinos <systemitem>local-fs.target</systemitem> e <systemitem>swap.target</systemitem> montam sistemas de arquivos locais e espaços de troca.
   </para>
   <para>
    O destino <systemitem>graphical.target</systemitem> oferece recursos de sistema multiusuário com rede e gerenciador de exibição e equivale ao nível de execução 5. Destinos complexos, como <systemitem>graphical.target</systemitem>, agem como destinos <quote>meta</quote>, combinando um subconjunto de outros destinos. Como o <systemitem class="daemon">systemd</systemitem> facilita criar destinos personalizados combinando destinos existentes, ele oferece excelente flexibilidade.
   </para>
   <para>
    A lista a seguir mostra as unidades de destino mais importantes do <systemitem class="daemon">systemd</systemitem>. Para ver a lista completa, consulte <command>man 7 systemd.special</command>.
   </para>
   <variablelist>
    <title>Unidades de destino selecionadas do <systemitem class="daemon">systemd</systemitem></title>
    <varlistentry>
     <term><systemitem>default.target</systemitem></term>
     <listitem>
      <para>
       O destino que é inicializado por padrão. Não um destino <quote>real</quote>, mas um link simbólico para outro destino, como <systemitem>graphic.target</systemitem>. Pode ser modificado permanentemente pelo YaST (consulte a <xref linkend="sec-boot-runlevel-edit"/>). Para mudá-lo em uma sessão, use o parâmetro do kernel <literal>systemd.unit=<replaceable>MEU_DESTINO.destino</replaceable></literal> no prompt de boot.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>emergency.target</systemitem></term>
     <listitem>
      <para>
       Inicia o shell de emergência no console. Use-o apenas no prompt de boot como <literal>systemd.unit=emergency.target</literal>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>graphical.target</systemitem></term>
     <listitem>
      <para>
       Inicia um sistema com suporte a rede multiusuário e um gerenciador de exibição.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>halt.target</systemitem></term>
     <listitem>
      <para>
       Encerra o sistema.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mail-transfer-agent.target</systemitem></term>
     <listitem>
      <para>
       Inicia todos os serviços necessários para enviar e receber e-mails.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>multi-user.target</systemitem></term>
     <listitem>
      <para>
       Inicia um sistema multiusuário com rede.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>reboot.target</systemitem></term>
     <listitem>
      <para>
       Reinicializa o sistema.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>rescue.target</systemitem></term>
     <listitem>
      <para>
       Inicia um sistema de usuário único sem rede.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Para continuar compatível com o sistema de nível de execução init do System V, o <systemitem class="daemon">systemd</systemitem> oferece destinos especiais chamados <literal>runlevel<replaceable>X</replaceable>.target</literal> que mapeiam os níveis de execução correspondentes numerados <replaceable>X</replaceable>.
   </para>
   <para>
    Para saber o destino atual, use o comando: <command>systemctl get-default</command>
   </para>
   <table rowsep="1">
    <title>Níveis de execução do System V e unidades de destino do <systemitem class="daemon">systemd</systemitem></title>
    <tgroup cols="3">
     <colspec colnum="1" colname="1" colwidth="20*"/>
     <colspec colnum="2" colname="2" colwidth="40*"/>
     <colspec colnum="3" colname="3" colwidth="40*"/>
     <thead>
      <row>
       <entry>
        <para>
         Nível de execução do System V
        </para>
       </entry>
       <entry>
        <para>
         <systemitem class="daemon">systemd</systemitem> destino
        </para>
       </entry>
       <entry>
        <para>
         Finalidade
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         0
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel0.target</systemitem>, <systemitem>halt.target</systemitem>, <systemitem>poweroff.target</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         Encerramento do sistema
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         1, S
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel1.target</systemitem>, <systemitem>rescue.target</systemitem>,
        </para>
       </entry>
       <entry>
        <para>
         Modo de usuário único
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         2
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel2.target</systemitem>, <systemitem>multi-user.target</systemitem>,
        </para>
       </entry>
       <entry>
        <para>
         Multiusuário local sem rede remota
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         3
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel3.target</systemitem>, <systemitem>multi-user.target</systemitem>,
        </para>
       </entry>
       <entry>
        <para>
         Multiusuário completo com rede
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         4
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel4.target</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         Não usado/Definido pelo usuário
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         5
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel5.target</systemitem>, <systemitem>graphical.target</systemitem>,
        </para>
       </entry>
       <entry>
        <para>
         Multiusuário completo com rede e gerenciador de exibição
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         6
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel6.target</systemitem>, <systemitem>reboot.target</systemitem>,
        </para>
       </entry>
       <entry>
        <para>
         Reinicialização do sistema
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <important>
    <title>O <systemitem class="daemon">systemd</systemitem> ignora o <filename>/etc/inittab</filename></title>
    <para>
     Os níveis de execução em um sistema init do System V são configurados em <filename>/etc/inittab</filename>. O <systemitem class="daemon">systemd</systemitem> <emphasis>não</emphasis> usa essa configuração. Consulte a <xref linkend="sec-boot-systemd-custom-targets"/> para obter instruções sobre como criar seu próprio destino inicializável.
    </para>
   </important>
   <sect3 xml:id="sec-boot-systemd-targets-commands">
    <title>Comandos para mudar os destinos</title>
    <para>
     Use os seguintes comandos para operar com unidades de destino:
    </para>
    <informaltable rowsep="1">
     <tgroup cols="3">
      <colspec colnum="1" colname="1" colwidth="20*"/>
      <colspec colnum="2" colname="2" colwidth="50*"/>
      <colspec colnum="3" colname="3" colwidth="30*"/>
      <thead>
       <row>
        <entry colname="1">
         <para>
          Tarefa
         </para>
        </entry>
        <entry colname="2">
         <para>
          Comando <systemitem class="daemon">systemd</systemitem>
         </para>
        </entry>
        <entry colname="3">
         <para>
          Comando init do System V
         </para>
        </entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry colname="1">
         <para>
          Mudar o destino/nível de execução atual
         </para>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl isolate</command> <replaceable> MEU_DESTINO</replaceable>.target
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>telinit</command> <replaceable> X</replaceable>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          Mudar para o destino/nível de execução padrão
         </para>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl default</command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/d
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          Obter o destino/nível de execução atual
         </para>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl list-units --type=target</command>
         </para>
         <para>
          Com o <systemitem class="daemon">systemd</systemitem>, normalmente há mais de um destino ativo. O comando lista todos os destinos que estão ativos.
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>who -r</command>
         </para>
         <para>
          ou
         </para>
         <para>
          <command>runlevel</command>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          Mudar o nível de execução padrão de forma persistente
         </para>
        </entry>
        <entry colname="2">
         <para>
          Use o Gerenciador de Serviços ou execute o seguinte comando:
         </para>
         <para>
          <command>Em -sf /usr/lib/systemd/system/</command> <replaceable> MEU_DESTINO</replaceable>.target /etc/systemd/system/default.target
         </para>
        </entry>
        <entry colname="3">
         <para>
          Use o Gerenciador de Serviços ou mude a linha
         </para>
         <para>
          <command>id:</command> <replaceable>X</replaceable>:initdefault:
         </para>
         <para>
          em <filename>/etc/inittab</filename>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          Mudar o nível de execução padrão para o processo de boot atual
         </para>
        </entry>
        <entry colname="2">
         <para>
          Digite a seguinte opção no prompt de boot
         </para>
         <para>
          <command>systemd.unit=</command> <replaceable> MEU_DESTINO</replaceable>.target
         </para>
        </entry>
        <entry colname="3">
         <para>
          Digite o número do nível de execução desejado no prompt de boot.
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          Mostrar as dependências de um destino/nível de execução
         </para>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl show -p &quot;Requires&quot;</command> <replaceable> MEU_DESTINO</replaceable>.target
         </para>
         <para>
          <command>systemctl show -p &quot;Wants&quot;</command> <replaceable> MEU_DESTINO</replaceable>.target
         </para>
         <para>
          <quote>Requires</quote> lista as dependências obrigatórias (hard) (aquelas que devem ser resolvidas), enquanto <quote>Wants</quote> lista as dependências desejadas (soft) (aquelas que são resolvidas quando possível).
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/d
         </para>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-debug">
   <title>Depurando a inicialização do sistema</title>
   <para>
    O <systemitem class="daemon">systemd</systemitem> oferece os meios para a análise dos processos de inicialização do sistema. É possível revisar a lista de todos os serviços e os respectivos status (em vez de analisar o <filename>/var/log/</filename>). O <systemitem class="daemon">systemd</systemitem> permite também explorar o procedimento de inicialização para descobrir quanto tempo leva para inicializar cada serviço.
   </para>
   <sect3 xml:id="sec-boot-systemd-debug-review">
    <title>Revisar inicialização dos serviços</title>
    <para>
     Para revisar a lista completa dos serviços que foram iniciados desde a inicialização do sistema, digite o comando <command>systemctl</command>. Ele lista todos os serviços ativos, conforme mostrado a seguir (resumidamente). Para obter mais informações sobre determinado serviço, use <command>systemctl status <replaceable>MEU_SERVIÇO</replaceable></command>.
    </para>
    <example>
     <title>Listar serviços ativos</title>
<screen><prompt role="root"># </prompt>systemctl
UNIT                        LOAD   ACTIVE SUB       JOB DESCRIPTION
[...]
iscsi.service               loaded active exited    Login and scanning of iSC+
kmod-static-nodes.service   loaded active exited    Create list of required s+
libvirtd.service            loaded active running   Virtualization daemon
nscd.service                loaded active running   Name Service Cache Daemon
chronyd.service             loaded active running   NTP Server Daemon
polkit.service              loaded active running   Authorization Manager
postfix.service             loaded active running   Postfix Mail Transport Ag+
rc-local.service            loaded active exited    /etc/init.d/boot.local Co+
rsyslog.service             loaded active running   System Logging Service
[...]
LOAD   = Reflects whether the unit definition was properly loaded.
ACTIVE = The high-level unit activation state, i.e. generalization of SUB.
SUB    = The low-level unit activation state, values depend on unit type.

161 loaded units listed. Pass --all to see loaded but inactive units, too.
To show all installed unit files use 'systemctl list-unit-files'.</screen>
    </example>
    <para>
     Para restringir o resultado a serviços com falha na inicialização, use a opção <option>--failed</option>:
    </para>
    <example>
     <title>Listar serviços com falha</title>
<screen><prompt role="root"># </prompt>systemctl --failed
UNIT                   LOAD   ACTIVE SUB    JOB DESCRIPTION
apache2.service        loaded failed failed     apache
NetworkManager.service loaded failed failed     Network Manager
plymouth-start.service loaded failed failed     Show Plymouth Boot Screen

[...]</screen>
    </example>
   </sect3>
   <sect3 xml:id="sec-boot-systemd-debug-time">
    <title>Depurar o tempo de inicialização</title>
    <para>
     Para depurar o tempo de inicialização do sistema, o <systemitem class="daemon">systemd</systemitem> oferece o comando <command>systemd-analyze</command>. Ele mostra o tempo total de inicialização, uma lista dos serviços solicitados por tempo de inicialização e também gera um gráfico SVG mostrando o tempo que os serviços levaram para serem iniciados em relação a outros serviços.
    </para>
    <variablelist>
     <varlistentry>
      <term>Listando o tempo de inicialização do sistema</term>
      <listitem>
<screen><prompt role="root"># </prompt>systemd-analyze
Startup finished in 2666ms (kernel) + 21961ms (userspace) = 24628ms</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Listando o tempo de inicialização dos serviços</term>
      <listitem>
<screen><prompt role="root"># </prompt>systemd-analyze blame
    15.000s backup-rpmdb.service
    14.879s mandb.service
     7.646s backup-sysconfig.service
     4.940s postfix.service
     4.921s logrotate.service
     4.640s libvirtd.service
     4.519s display-manager.service
     3.921s btrfsmaintenance-refresh.service
     3.466s lvm2-monitor.service
     2.774s plymouth-quit-wait.service
     2.591s firewalld.service
     2.137s initrd-switch-root.service
     1.954s ModemManager.service
     1.528s rsyslog.service
     1.378s apparmor.service
    [...]
</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Gráficos do tempo de inicialização dos serviços</term>
      <listitem>
<screen><prompt role="root"># </prompt>systemd-analyze plot &gt; jupiter.example.com-startup.svg</screen>
       <informalfigure>
        <mediaobject>
         <imageobject role="fo">
          <imagedata fileref="systemd_startup.svg" width="75%" format="SVG"/>
         </imageobject>
         <imageobject role="html">
          <imagedata fileref="systemd_startup.png" width="75%" format="PNG"/>
         </imageobject>
        </mediaobject>
       </informalfigure>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3 xml:id="sec-boot-systemd-debug-complete">
    <title>Revisar o processo de inicialização completo</title>
    <para>
     Os comandos acima listam os serviços que são iniciados e os respectivos tempos de inicialização. Para obter uma visão geral mais detalhada, especifique os parâmetros a seguir no prompt de boot para instruir o <systemitem class="daemon">systemd</systemitem> a criar um registro verboso do procedimento completo de inicialização.
    </para>
<screen>systemd.log_level=debug systemd.log_target=kmsg</screen>
    <para>
     Agora o <systemitem class="daemon">systemd</systemitem> grava suas mensagens de registro no buffer de anel do kernel. Veja esse buffer com <command>dmesg</command>:
    </para>
<screen><prompt>&gt; </prompt>dmesg -T | less</screen>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-sysv-compatibility">
   <title>Compatibilidade com o System V</title>
   <para>
    O <systemitem class="daemon">systemd</systemitem> é compatível com o System V, o que ainda permite usar os scripts init existentes do System V. Entretanto, há pelo menos um problema conhecido em que o script init do System V não funciona com o <systemitem class="daemon">systemd</systemitem> out-of-the-box: iniciar um serviço como outro usuário por meio de <command>su</command> ou <command>sudo</command> nos scripts init resulta em falha do script, gerando um erro de <quote>Acesso negado</quote>.
   </para>
   <para>
    Ao mudar o usuário com <command>su</command> ou <command>sudo</command>, é iniciada uma sessão PAM. Essa sessão será terminada após a conclusão do script init. Como consequência, o serviço que foi iniciado pelo script init também será terminado. Para solucionar esse erro, faça o seguinte:
   </para>
   <procedure>
    <step>
     <para>
      Crie um agrupador de arquivo de serviço com o mesmo nome do script init e mais a extensão de nome de arquivo <filename>.service</filename>:
     </para>
<screen>[Unit]
Description=<replaceable>DESCRIPTION</replaceable>
After=network.target

[Service]
User=<replaceable>USER</replaceable>
Type=forking<co xml:id="co-service-wrapper-type"/>
PIDFile=<replaceable>PATH TO PID FILE</replaceable><xref linkend="co-service-wrapper-type" xrefstyle="select:label nopage"/>
ExecStart=<replaceable>PATH TO INIT SCRIPT</replaceable> start
ExecStop=<replaceable>PATH TO INIT SCRIPT</replaceable> stop
ExecStopPost=/usr/bin/rm -f <replaceable>PATH TO PID FILE</replaceable><xref linkend="co-service-wrapper-type" xrefstyle="select:label nopage"/>

[Install]
WantedBy=multi-user.target<co xml:id="co-service-wrapper-target"/></screen>
     <para>
      Substitua todos os valores gravados em <replaceable>LETRAS MAIÚSCULAS</replaceable> pelos valores apropriados.
     </para>
     <calloutlist>
      <callout arearefs="co-service-wrapper-type">
       <para>
        Opcional: use apenas se o script init iniciar um daemon.
       </para>
      </callout>
      <callout arearefs="co-service-wrapper-target">
       <para>
        O <literal>multi-user.target</literal> também inicia o script init ao inicializar no <literal>graphical.target</literal>. Se ele tiver que ser iniciado apenas ao inicializar no gerenciador de exibição, use o <literal>graphical.target</literal> aqui.
       </para>
      </callout>
     </calloutlist>
    </step>
    <step>
     <para>
      Inicie o daemon com <command>systemctl start <replaceable>APLICATIVO</replaceable></command>.
     </para>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-boot-runlevel-edit">
  <title>Gerenciando serviços com o YaST</title>

  <para>
   O gerenciamento básico de serviços também pode ser feito com o módulo Gerenciador de Serviços do YaST. Ele permite iniciar, parar, habilitar e desabilitar serviços. Ele permite também mostrar o status e mudar o destino padrão de um serviço. Inicie o módulo do YaST em <menuchoice> <guimenu> YaST</guimenu> <guimenu> Sistema</guimenu> <guimenu> Services Manager</guimenu> </menuchoice>  (Gerenciador de Serviços).
  </para>

  <figure xml:id="fig-yast2-runlevel">
   <title>Gerenciador de Serviços</title>
   <mediaobject>
    <imageobject role="fo">
     <imagedata fileref="yast2_runlevel.png" width="75%" format="PNG"/>
    </imageobject>
    <imageobject role="html">
     <imagedata fileref="yast2_runlevel.png" width="75%" format="PNG"/>
    </imageobject>
   </mediaobject>
  </figure>

  <variablelist>
   <varlistentry>
    <term>Mudando o <guimenu>destino padrão do sistema</guimenu></term>
    <listitem>
     <para>
      Para mudar o destino de inicialização do sistema, escolha o destino na caixa suspensa <guimenu>Default System Target</guimenu> (Destino Padrão do Sistema). Os destinos mais usados são <guimenu>Graphical Interface</guimenu> (Interface Gráfica) (iniciando uma tela gráfica de login) e <guimenu>Multiusuário</guimenu> (iniciando o sistema no modo de linha de comando).
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Iniciando ou parando um serviço</term>
    <listitem>
     <para>
      Selecione um serviço da tabela. A coluna <guimenu>Estado</guimenu> mostra se ele está em execução (<guimenu>Ativo</guimenu>) ou não (<guimenu>Inativo</guimenu>). Para alternar o status, escolha <guimenu>Iniciar</guimenu> ou <guimenu>Parar</guimenu>.
     </para>
     <para>
      Quando um serviço é iniciado ou parado, seu status muda na sessão que está em execução. Para mudar seu status em todas as reinicializações, é necessário habilitá-lo ou desabilitá-lo.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Definindo o comportamento de inicialização dos serviços</term>
    <listitem>
     <para>
      Os serviços podem ser iniciados automaticamente no momento da inicialização ou manualmente. Selecione um serviço da tabela. A coluna <guimenu>Início</guimenu> mostra se ele foi iniciado <guimenu>Manualmente</guimenu> ou <guimenu>Na inicialização</guimenu>. Para alternar o status, escolha <guimenu>Modo de início</guimenu>.
     </para>
     <para>
      Para mudar o status de um serviço na sessão atual, você precisa iniciá-lo ou interrompê-lo conforme descrito acima.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Ver uma mensagem de status</term>
    <listitem>
     <para>
      Para ver a mensagem de status de um serviço, selecione-o na lista e escolha <guimenu>Mostrar Detalhes</guimenu>. A saída exibida será idêntica a que foi gerada pelo comando <command>systemctl</command> <option>-l</option> status <replaceable>MEU_SERVIÇO</replaceable>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 xml:id="sec-boot-systemd-custom">
  <title>Personalizando <systemitem>systemd</systemitem></title>

  <para>
   As seções a seguir mostram alguns exemplos de personalização do <systemitem>systemd</systemitem>.
  </para>

  <warning>
   <title>Impedindo que sua personalização seja sobregravada</title>
   <para>
    Ao personalizar o <systemitem class="daemon">systemd</systemitem>, use sempre o diretório <filename>/etc/systemd/</filename>, <emphasis>nunca</emphasis> use o <filename>/usr/lib/systemd/</filename>. Do contrário, as mudanças serão sobregravadas na próxima atualização do <systemitem class="daemon">systemd</systemitem>.
   </para>
  </warning>

  <sect2 xml:id="sec-boot-systemd-custom-service">
   <title>Personalizando os arquivos unit</title>
   <para>
    A maneira recomendada de personalizar arquivos unit é usar o comando <command>systemctl edit <replaceable>SERVICE</replaceable></command>. Esse comando inicia o editor de texto padrão e cria um diretório com o arquivo <filename>override.conf</filename> em <filename>/etc/systemd/system/<replaceable>NAME</replaceable>.service.d/</filename>. O comando também garante que o processo <systemitem class="daemon">systemd</systemitem> em execução seja notificado sobre as mudanças.
   </para>
   <para>
    Se preferir, você poderá abrir uma cópia do arquivo original para edição em vez de um arquivo em branco executando <command>systemctl edit --full <replaceable>SERVICE</replaceable></command>. Ao editar o arquivo, não remova nenhuma das seções existentes.
   </para>
   <para>
    Como exercício, mude por quanto tempo o sistema aguarda pela inicialização do MariaDB. Como root, execute <command>systemctl edit --full mariadb.service</command>. O arquivo aberto terá aparência similar à seguinte:
   </para>
<screen>
[Unit]
Description=MySQL server
Wants=basic.target
Conflicts=mariadb.target
After=basic.target network.target

[Install]
WantedBy=multi-user.target
Alias=mysql.service

[Service]
Restart=on-abort
Type=notify
ExecStartPre=/usr/lib/mysql/mysql-systemd-helper  install
ExecStartPre=/usr/lib/mysql/mysql-systemd-helper  upgrade
ExecStart=/usr/lib/mysql/mysql-systemd-helper     start

# Configures the time to wait for start-up/stop
TimeoutSec=300

# Prevent writes to /usr, /boot, and /etc
ProtectSystem=full

# Prevent accessing /home, /root and /run/user
ProtectHome=true

UMask=007</screen>
   <para>
    Ajuste o valor de <literal>TimeoutSec</literal> e grave as mudanças. Para habilitar as mudanças, execute <command>systemctl daemon-reload</command> como root.
   </para>
   <para>
    Para obter mais informações, consulte as páginas de manual que podem ser chamadas com o comando <command>man 1 systemctl</command>.
   </para>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-custom-drop-in">
   <title>Criando arquivos drop-in</title>
   <para>
    Para pequenas mudanças de um arquivo de configuração, use os chamados arquivos drop-in. Esses arquivos permitem estender a configuração dos arquivos de unidade sem ter que editá-los ou anulá-los realmente.
   </para>
   <para>
    Por exemplo, para mudar um valor único no serviço <replaceable>FOOBAR</replaceable> localizado em <filename>/usr/lib/systemd/system/<replaceable>FOOBAR.SERVICE</replaceable></filename>, faça o seguinte:
   </para>
   <procedure>
    <step>
     <para>
      Crie um diretório chamado <filename>/etc/systemd/system/<replaceable>FOOBAR</replaceable>.service.d/</filename>.
     </para>
     <para>
      Observe o sufixo <literal>.d</literal>. O diretório deve receber outro nome de acordo com o serviço que você deseja corrigir com o arquivo dropin.
     </para>
    </step>
    <step>
     <para>
      Nesse diretório, crie um arquivo <filename><replaceable>sua_modificação</replaceable>.conf</filename>.
     </para>
     <para>
      Verifique se ele contém somente a linha com o valor que deseja modificar.
     </para>
    </step>
    <step>
     <para>
      Grave as mudanças feitas no arquivo
     </para>
    </step>
   </procedure>
   
   <note>
    <title>Evitando conflitos de nome</title>
    <para>
    Para evitar conflitos de nome entre os arquivos drop-in e os arquivos fornecidos pelo SUSE, é recomendável prefixar todos os nomes de arquivos drop-in com um número de dois dígitos e um traço: por exemplo, <filename>80-override.conf</filename>.
    </para>
    <para>
     As seguintes faixas são reservadas:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <literal>0-19</literal> é reservada para upstream do <systemitem class="daemon">systemd</systemitem>
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>20-25</literal> é reservada para o <systemitem class="daemon">systemd</systemitem> fornecido pelo SUSE
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>26-29</literal> é reservada para pacotes do SUSE (diferentes do systemd)
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>50</literal> é reservada para arquivos drop-in criados com <command>systemctl set-property</command>.
      </para>
     </listitem>
    </itemizedlist>
    <para>
    Use um número de dois dígitos acima dessa faixa para garantir que nenhum dos arquivos drop-in fornecidos pelo SUSE anule os seus próprios arquivos drop-in.
    </para>
    <para>
    Você pode usar <command>systemctl cat $UNIT</command> para listar e verificar quais arquivos são levados em consideração na configuração dos units.
    </para>
   </note>
  </sect2>

  <sect2 xml:id="systemd-xinetd-conversion">
   <title>Convertendo serviços <systemitem>xinetd</systemitem> em <systemitem class="daemon">systemd</systemitem></title>
   <para>
    Desde o lançamento do <phrase role="productname"><phrase os="sled">SUSE Linux Enterprise Desktop</phrase></phrase> 15, a infraestrutura do <systemitem>xinetd</systemitem> foi removida. Esta seção descreve como converter arquivos existentes de serviço do <systemitem>xinetd</systemitem> em soquetes do <systemitem class="daemon">systemd</systemitem>.
   </para>
   <para>
    Para cada arquivo de serviço do <systemitem>xinetd</systemitem>, você precisa de pelo menos dois arquivos unit do <systemitem class="daemon">systemd</systemitem>: o arquivo de soquete (<filename>*.socket</filename>) e um arquivo de serviço associado (<filename>*.service</filename>). O arquivo de soquete informa ao <systemitem class="daemon">systemd</systemitem> qual soquete criar, e o arquivo de serviço informa ao <systemitem class="daemon">systemd</systemitem> qual executável iniciar.
   </para>
   <para>
    Considere o seguinte arquivo de serviço do <systemitem>xinetd</systemitem> de exemplo:
   </para>
<screen><prompt role="root"># </prompt>cat /etc/xinetd.d/example
service example
{
  socket_type = stream
  protocol = tcp
  port = 10085
  wait = no
  user = user
  group = users
  groups = yes
  server = /usr/libexec/example/exampled
  server_args = -auth=bsdtcp exampledump
  disable = no
}</screen>
   <para>
    Para convertê-lo em <systemitem class="daemon">systemd</systemitem>, você precisa dos dois arquivos correspondentes a seguir:
   </para>
<screen><prompt role="root"># </prompt>cat /usr/lib/systemd/system/example.socket
[Socket]
ListenStream=0.0.0.0:10085
Accept=false

[Install]
WantedBy=sockets.target</screen>
<screen><prompt role="root"># </prompt>cat /usr/lib/systemd/system/example.service
[Unit]
Description=example

[Service]
ExecStart=/usr/libexec/example/exampled -auth=bsdtcp exampledump
User=user
Group=users
StandardInput=socket
</screen>
   <para>
    Para obter uma lista completa das opções de arquivo de “soquete” e de “serviço” do <systemitem class="daemon">systemd</systemitem>, consulte as páginas de manual systemd.socket e systemd.service (<command>man 5 systemd.socket</command>, <command>man 5 systemd.service</command>).
   </para>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-custom-targets">
   <title>Criando destinos personalizados</title>
   <para>
    Nos sistemas init SUSE do System V, o nível de execução 4 não costuma ser usado para permitir que administradores criem sua própria configuração de nível de execução. O <systemitem class="daemon">systemd</systemitem> permite criar qualquer número de destinos personalizados. A sugestão é começar adaptando um destino existente, como <systemitem>graphical.target</systemitem>.
   </para>
   <procedure>
    <step>
     <para>
      Copie o arquivo de configuração <filename>/usr/lib/systemd/system/graphical.target</filename> para <filename>/etc/systemd/system/<replaceable>MEU_DESTINO</replaceable>.target</filename> e ajuste-o de acordo com as suas necessidades.
     </para>
    </step>
    <step>
     <para>
      O arquivo de configuração copiado na etapa anterior já inclui as dependências obrigatórias (<quote>hard</quote>) do destino. Para incluir também as dependências desejadas (<quote>soft</quote>), crie um diretório <filename>/etc/systemd/system/<replaceable>MEU_DESTINO</replaceable>.target.wants</filename>.
     </para>
    </step>
    <step>
     <para>
      Para cada serviço desejado, crie um link simbólico de <filename>/usr/lib/systemd/system</filename> para <filename>/etc/systemd/system/<replaceable>MEU_DESTINO</replaceable>.target.wants</filename>.
     </para>
    </step>
    <step>
     <para>
      Após concluir a configuração do destino, recarregue a configuração do <systemitem class="daemon">systemd</systemitem> para disponibilizar o novo destino:
     </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl daemon-reload</screen>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-boot-systemd-advanced">
  <title>Uso avançado</title>

  <para>
   As seções a seguir abordam tópicos avançados para administradores do sistema. Para conferir uma documentação ainda mais avançada do <systemitem class="daemon">systemd</systemitem>, consulte a série de Lennart Pöttering sobre o <systemitem class="daemon">systemd</systemitem> para administradores em <link xlink:href="http://0pointer.de/blog/projects"/>.
  </para>

  <sect2 xml:id="sec-boot-systemd-advanced-tmp">
   <title>Limpando diretórios temporários</title>
   <para>
    O <systemitem class="daemon">systemd</systemitem> suporta a limpeza de diretórios temporários regularmente. A configuração da versão do sistema anterior é automaticamente migrada e ativada. O <literal>tmpfiles.d</literal>, que é responsável por gerenciar arquivos temporários, lê sua configuração dos arquivos <filename>/etc/tmpfiles.d/*.conf</filename> , <filename>/run/tmpfiles.d/*.conf</filename> e <filename>/usr/lib/tmpfiles.d/*.conf. </filename> A configuração armazenada no <filename>/etc/tmpfiles.d/*.conf</filename> anula as configurações relacionadas dos outros dois diretórios (<filename>/usr/lib/tmpfiles.d/*.conf</filename> é o local onde os pacotes armazenam seus arquivos de configuração).
   </para>
   <para>
    O formato da configuração é de uma linha por caminho incluindo ação e caminho; e, opcionalmente, modo, propriedade e os campos de idade e argumento, dependendo da ação. O exemplo a seguir desvincula os arquivos de bloqueio do X11:
   </para>
<screen>Type Path               Mode UID  GID  Age Argument
r    /tmp/.X[0-9]*-lock</screen>
   <para>
    Para obter o status do temporizador tmpfile:
   </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl status systemd-tmpfiles-clean.timer
systemd-tmpfiles-clean.timer - Daily Cleanup of Temporary Directories
 Loaded: loaded (/usr/lib/systemd/system/systemd-tmpfiles-clean.timer; static)
 Active: active (waiting) since Tue 2018-04-09 15:30:36 CEST; 1 weeks 6 days ago
   Docs: man:tmpfiles.d(5)
         man:systemd-tmpfiles(8)

Apr 09 15:30:36 jupiter systemd[1]: Starting Daily Cleanup of Temporary Directories.
Apr 09 15:30:36 jupiter systemd[1]: Started Daily Cleanup of Temporary Directories.</screen>
   <para>
    Para obter mais informações sobre como lidar com os arquivos temporários, consulte <command>man 5 tmpfiles.d</command>.
   </para>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-advanced-logging">
   <title>Registro do sistema</title>
   <para>
    A <xref linkend="sec-boot-systemd-basics-services-debugging"/> explica como ver mensagens de registro de determinado serviço. No entanto, a exibição de mensagens de registro não se restringe a registros de serviços. É possível também acessar e consultar as mensagens de registro completas gravadas pelo <systemitem class="daemon">systemd</systemitem>, o chamado <quote>Diário</quote>. Use o comando <command>journalctl</command> para exibir as mensagens de registro completas começando pelas entradas mais antigas. Consulte <command>man 1 journalctl</command> para ver as opções. Por exemplo, aplicação de filtros ou mudança do formato de saída.
   </para>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-advanced-snapshots">
   <title>Instantâneos</title>
   <para>
    É possível gravar o estado atual do <systemitem class="daemon">systemd</systemitem> em um instantâneo nomeado e mais tarde revertê-lo com o subcomando <command>isolate</command>. Isso é útil para testar serviços ou destinos personalizados, pois permite retornar para um estado definido a qualquer momento. Um instantâneo só fica disponível na sessão atual e é apagado automaticamente na reinicialização. O nome do instantâneo deve terminar com <filename>.snapshot</filename>.
   </para>
   <variablelist>
    <varlistentry>
     <term>Criar um instantâneo</term>
     <listitem>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl snapshot <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Apagar um instantâneo</term>
     <listitem>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl delete <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Ver um instantâneo</term>
     <listitem>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl show <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Ativar um instantâneo</term>
     <listitem>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl isolate <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  

  

  <sect2 xml:id="sec-boot-systemd-advanced-kernel-modules">
   <title>Carregando módulos do kernel</title>
   <para>
    Com o <systemitem class="daemon">systemd</systemitem>, é possível carregar os módulos do kernel automaticamente no momento da inicialização, usando o arquivo de configuração em <filename>/etc/modules-load.d</filename>. O arquivo deve ser nomeado <replaceable>MÓDULO</replaceable>.conf e ter o seguinte conteúdo:
   </para>
<screen># load module <replaceable>MODULE</replaceable> at boot time
<replaceable>MODULE</replaceable></screen>
   <para>
    Se um pacote instalar um arquivo de configuração para carregar um módulo do kernel, o arquivo será instalado em <filename>/usr/lib/modules-load.d</filename>. Se houver dois arquivos de configuração com o mesmo nome, aquele em <filename>/etc/modules-load.d</filename> terá precedência.
   </para>
   <para>
    Para obter mais informações, consulte a página de manual de <systemitem>modules-load.d(5)</systemitem>.
   </para>
  </sect2>

  

  <sect2 xml:id="sec-boot-systemd-advanced-before-local">
   <title>Executando ações antes de carregar um serviço</title>
   <para>
    Com o System V, as ações init que precisam ser executadas antes de carregar um serviço tinham que ser especificadas em <filename>/etc/init.d/before.local</filename>. Esse procedimento não é mais suportado com o <systemitem class="daemon">systemd</systemitem>. Se você precisa executar ações antes de iniciar serviços, faça o seguinte:
   </para>
   <variablelist>
    <varlistentry>
     <term>Carregando módulos do kernel</term>
     <listitem>
      <para>
       Crie um arquivo drop-in no diretório <filename>/etc/modules-load.d</filename> (consulte <command>man modules-load.d</command> para ver a sintaxe)
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Criando arquivos ou diretórios, limpando diretórios, mudando a propriedade</term>
     <listitem>
      <para>
       Crie um arquivo drop-in em <filename>/etc/tmpfiles.d</filename> (consulte <command>man tmpfiles.d</command> para ver a sintaxe)
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Outras tarefas</term>
     <listitem>
      <para>
       Crie um arquivo de serviço de sistema, por exemplo <filename>/etc/systemd/system/before.service</filename>, com base no seguinte gabarito:
      </para>
<screen>[Unit]
Before=<replaceable>NAME OF THE SERVICE YOU WANT THIS SERVICE TO BE STARTED BEFORE</replaceable>
[Service]
Type=oneshot
RemainAfterExit=true
ExecStart=<replaceable>YOUR_COMMAND</replaceable>
# beware, executable is run directly, not through a shell, check the man pages
# systemd.service and systemd.unit for full syntax
[Install]
# target in which to start the service
WantedBy=multi-user.target
#WantedBy=graphical.target</screen>
      <para>
       Quando o arquivo de serviço é criado, você deve executar os seguintes comandos (como <systemitem class="username">root</systemitem>):
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl daemon-reload
<prompt>&gt; </prompt><command>sudo</command> systemctl enable before</screen>
      <para>
       Toda vez que você modifica o arquivo de serviço, deve executar:
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl daemon-reload</screen>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  

  <sect2 xml:id="sec-boot-systemd-advanced-cgroups">
   <title>Grupos de controle (cgroups) do kernel</title>
   <para>
    Em um sistema init tradicional do System V, nem sempre é possível atribuir claramente um processo ao serviço que o gerou. Alguns serviços, como o Apache, geram diversos processos de terceiros (por exemplo, processos CGI ou Java) que, por sua vez, geram mais processos. Isso dificulta ou até impossibilita uma atribuição clara. Além do mais, um serviço pode não terminar corretamente, deixando alguns filhos ativos.
   </para>
   <para>
    O <systemitem class="daemon">systemd</systemitem> resolve este problema colocando cada serviço em seu próprio grupo de controle (cgroup). Cgroups são recursos do kernel que possibilitam agregar processos e todos os seus filhos em grupos hierárquicos organizados. O <systemitem class="daemon">systemd</systemitem> nomeia cada cgroup de acordo com seu serviço. Como um processo não privilegiado não pode <quote>deixar</quote> seu cgroup, essa é uma forma eficiente de rotular todos os processos gerados por um serviço com o nome do serviço.
   </para>
   <para>
    Para listar todos os processos pertencentes a um serviço, use o comando <command>systemd-cgls</command>. O resultado será parecido com o seguinte exemplo (resumido):
   </para>
   <example>
    <title>Listar todos os processos pertencentes a um serviço</title>
<screen><prompt role="root"># </prompt>systemd-cgls --no-pager
├─1 /usr/lib/systemd/systemd --switched-root --system --deserialize 20
├─user.slice
│ └─user-1000.slice
│   ├─session-102.scope
│   │ ├─12426 gdm-session-worker [pam/gdm-password]
│   │ ├─15831 gdm-session-worker [pam/gdm-password]
│   │ ├─15839 gdm-session-worker [pam/gdm-password]
│   │ ├─15858 /usr/lib/gnome-terminal-server

[...]

└─system.slice
  ├─systemd-hostnamed.service
  │ └─17616 /usr/lib/systemd/systemd-hostnamed
  ├─cron.service
  │ └─1689 /usr/sbin/cron -n
  ├─postfix.service
  │ ├─ 1676 /usr/lib/postfix/master -w
  │ ├─ 1679 qmgr -l -t fifo -u
  │ └─15590 pickup -l -t fifo -u
  ├─sshd.service
  │ └─1436 /usr/sbin/sshd -D

[...]</screen>
   </example>
   <para>
    Consulte o <xref linkend="cha-tuning-cgroups"/> para obter mais informações sobre os cgroups.
   </para>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-advanced-kill">
   <title>Terminando os serviços (enviando sinais)</title>
   <para>
    Conforme explicado na <xref linkend="sec-boot-systemd-advanced-cgroups"/>, nem sempre é possível atribuir um processo a seu processo de serviço pai em um sistema init do System V. Isso dificulta terminar um serviço e todos os seus filhos. Os processos filhos que não forem terminados permanecerão como processos zumbis.
   </para>
   <para>
    O conceito do <systemitem class="daemon">systemd</systemitem> de confinar cada serviço em um cgroup possibilita identificar claramente todos os processos filho de um serviço e, portanto, permite enviar um sinal a cada um desses processos. Use <command>systemctl kill</command> para enviar sinais aos serviços. Para ver uma lista dos sinais disponíveis, consulte <command>man 7 signals</command>.
   </para>
   <variablelist>
    <varlistentry>
     <term>Enviando <systemitem>SIGTERM</systemitem> para um serviço</term>
     <listitem>
      <para>
       <systemitem>SIGTERM</systemitem> é o sinal padrão que é enviado.
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl kill <replaceable>MY_SERVICE</replaceable></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Enviando <replaceable>SIGNAL</replaceable> para um serviço</term>
     <listitem>
      <para>
       Use a opção <option>-s</option> para especificar o sinal que deve ser enviado.
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl kill -s <replaceable>SIGNAL</replaceable> <replaceable>MY_SERVICE</replaceable></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Selecionando processos</term>
     <listitem>
      <para>
       Por padrão, o comando <command>kill</command> envia o sinal para <option>todos</option> os processos do cgroup especificado. É possível restringi-lo ao processo <option>control</option> ou <option>main</option>. Este último, por exemplo, é útil para forçar um serviço a recarregar sua configuração enviando <systemitem>SIGHUP</systemitem>:
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl kill -s SIGHUP --kill-who=main <replaceable>MY_SERVICE</replaceable></screen>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-dbus">
   <title>Notas importantes sobre o serviço D-Bus</title>
   <para>
    O serviço D-BUS é o barramento de mensagem para comunicação entre clientes <systemitem class="daemon">systemd</systemitem> e o gerenciador systemd que está sendo executado como pid 1. Embora o <systemitem class="daemon">dbus</systemitem> seja um daemon independente, ele é parte integrante da infraestrutura do init.
   </para>
   <para>
    Terminar ou reiniciar o <systemitem class="daemon">dbus</systemitem> no sistema em execução é semelhante a uma tentativa de terminar ou reiniciar o pid 1. Isso interromperá a comunicação entre cliente e servidor <systemitem class="daemon">systemd</systemitem> e inutilizará a maioria das funções do <systemitem class="daemon">systemd</systemitem>.
   </para>
   <para>
    Portanto, terminar ou reiniciar o <systemitem class="daemon">dbus</systemitem> não é recomendado nem suportado.
   </para>
   <para>
    A atualização do <systemitem>dbus</systemitem> ou dos pacotes relacionados ao <systemitem>dbus</systemitem> requer uma reinicialização. Quando estiver em dúvida se uma reinicialização é necessária, execute o comando <command>sudo zypper ps -s</command>. Se <literal>dbus</literal> aparecer entre os serviços listados, será necessário reinicializar o sistema.
   </para>
   <para>
    Saiba que o <systemitem>dbus</systemitem> é atualizado mesmo quando as atualizações automáticas estão configuradas para ignorar os pacotes que exigem reinicialização.
   </para>
  </sect2>

  

  <sect2 xml:id="sec-boot-systemd-basics-services-debugging">
   <title>Depurando serviços</title>
   <para>
    Por padrão, o <systemitem class="daemon">systemd</systemitem> não é muito verboso. Se um serviço for iniciado com êxito, nenhuma saída será gerada. Em caso de falha, uma breve mensagem de erro será exibida. Porém, o <command>systemctl status</command> oferece os meios de depurar a inicialização e operação de um serviço.
   </para>
   <para>
    O <systemitem class="daemon">systemd</systemitem> já vem com um mecanismo de registro (<quote>The Journal</quote> — O Diário) que registra as mensagens do sistema. Isso permite exibir as mensagens de serviço juntamente com as mensagens de status. O comando <command>status</command> funciona de forma parecida com o comando <command>tail</command> e também exibe as mensagens de registro em formatos diferentes, o que faz dele uma poderosa ferramenta de depuração.
   </para>
   <variablelist>
    <varlistentry>
     <term>Mostrar falha na inicialização de serviço</term>
     <listitem>
      <para>
       Sempre que houver falha ao iniciar um serviço, use <command>systemctl status <replaceable>MEU_SERVIÇO</replaceable></command> para obter a mensagem de erro detalhada:
      </para>
<screen><prompt role="root"># </prompt>systemctl start apache2
Job failed. See system journal and 'systemctl status' for details.
<prompt role="root"># </prompt>systemctl status apache2
   Loaded: loaded (/usr/lib/systemd/system/apache2.service; disabled)
   Active: failed (Result: exit-code) since Mon, 04 Apr 2018 16:52:26 +0200; 29s ago
   Process: 3088 ExecStart=/usr/sbin/start_apache2 -D SYSTEMD -k start (code=exited, status=1/FAILURE)
   CGroup: name=systemd:/system/apache2.service

Apr 04 16:52:26 g144 start_apache2[3088]: httpd2-prefork: Syntax error on line
205 of /etc/apache2/httpd.conf: Syntax error on li...alHost&gt;</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Mostrar as últimas <replaceable>n</replaceable> mensagens de serviço</term>
     <listitem>
      <para>
       O comportamento padrão do subcomando <command>status</command> é exibir as dez últimas mensagens emitidas por um serviço. Para mudar o número de mensagens exibidas, use o parâmetro <option>--lines=<replaceable>N</replaceable></option>:
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl status chronyd
<prompt>&gt; </prompt><command>sudo</command> systemctl --lines=20 status chronyd</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Mostrar as mensagens de serviço no modo de anexação</term>
     <listitem>
      <para>
       Para exibir um <quote>fluxo ao vivo</quote> das mensagens de serviço, use a opção <option>--follow</option>, que funciona como o <command>tail </command> <option>-f</option>:
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl --follow status chronyd</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Formato de saída das mensagens</term>
     <listitem>
      <para>
       O parâmetro <option>--output=<replaceable>MODO</replaceable></option> permite mudar o formato de saída das mensagens de serviço. Os modos mais importantes disponíveis são:
      </para>
      <variablelist>
       <varlistentry>
        <term><option>short</option></term>
        <listitem>
         <para>
          O formato padrão. Mostra as mensagens de registro com uma marcação de horário legível.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><option>verbose</option></term>
        <listitem>
         <para>
          Saída completa com todos os campos.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><option>cat</option></term>
        <listitem>
         <para>
          Saída resumida sem marcações de horário.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-boot-systemd-timer-units">
  <title>Unidades do temporizador do <systemitem class="daemon">systemd</systemitem></title>

  <para>
   Semelhante ao cron, as unidades do temporizador do <systemitem class="daemon">systemd</systemitem> oferecem um mecanismo para programar tarefas no Linux. Embora as unidades do temporizador do <systemitem class="daemon">systemd</systemitem> tenham a mesma finalidade que o cron, elas oferecem várias vantagens.
  </para>

  <itemizedlist>
   <listitem>
    <para>
     As tarefas programadas usando uma unidade do temporizador podem depender de outros serviços do <systemitem class="daemon">systemd</systemitem>.
    </para>
   </listitem>
   <listitem>
    <para>
     As unidades do temporizador são tratadas como serviços regulares do <systemitem class="daemon">systemd</systemitem>, portanto, podem ser gerenciadas com o <command>systemctl</command>.
    </para>
   </listitem>
   <listitem>
    <para>
     Os temporizadores podem ser em tempo real e monotônicos.
    </para>
   </listitem>
   <listitem>
    <para>
     As unidades de tempo são registradas no diário do <systemitem class="daemon">systemd</systemitem>, o que facilita o monitoramento e a solução de problemas.
    </para>
   </listitem>
  </itemizedlist>

  <para>
   As unidades do temporizador do <systemitem class="daemon">systemd</systemitem> são identificadas pela extensão de nome de arquivo <literal>.timer</literal>.
  </para>

  <sect2 xml:id="sec-boot-systemd-timer-types">
   <title>Tipos de temporizador do <systemitem class="daemon">systemd</systemitem></title>
   <para>
    As unidades do temporizador podem usar temporizadores monotônicos e em tempo real.
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Semelhante ao cron, os temporizadores em tempo real são acionados com base em eventos do calendário. Os temporizadores em tempo real são definidos usando a opção <option>OnCalendar</option>.
     </para>
    </listitem>
    <listitem>
     <para>
      Os temporizadores monotônicos são acionados em um tempo especificado decorrido a partir de um determinado ponto inicial. O último pode ser um evento de boot do sistema ou de ativação da unidade do sistema. Há várias opções para definir temporizadores monotônicos, incluindo <option>OnBootSec</option>, <option>OnUnitActiveSec</option> e <option>OnTypeSec</option>. Os temporizadores monotônicos não são persistentes e são redefinidos após cada reinicialização.
     </para>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-timer-service-units">
   <title>Temporizadores e unidades de serviço do <systemitem class="daemon">systemd</systemitem></title>
   <para>
    Cada unidade do temporizador deve ter um arquivo de unidade do <systemitem class="daemon">systemd</systemitem> correspondente que ela controla. Em outras palavras, o arquivo <filename>.timer</filename> ativa e gerencia o arquivo <filename>.service</filename> correspondente. Quando usado com um temporizador, o arquivo <filename>.service</filename> não requer uma seção <literal>[Install]</literal>, já que o serviço é gerenciado pelo temporizador.
   </para>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-timer-example">
   <title>Exemplo prático</title>
   <para>
    Para entender os conceitos básicos das unidades do temporizador do <systemitem class="daemon">systemd</systemitem>, configuramos um temporizador que aciona o script shell <filename>foo.sh</filename>.
   </para>
   <para>
    A primeira etapa é criar uma unidade de serviço do <systemitem class="daemon">systemd</systemitem> que controle o script shell. Para fazer isso, abra um novo arquivo de texto para edição e adicione a seguinte definição de unidade de serviço:
   </para>
<screen>[Unit]
Description="Foo shell script"

[Service]
ExecStart=/usr/local/bin/foo.sh</screen>
   <para>
    Grave o arquivo com o nome <filename>foo.service</filename> no diretório <filename>/etc/systemd/system/</filename>.
   </para>
   <para>
    Em seguida, abra um novo arquivo de texto para edição e adicione a seguinte definição do temporizador:
   </para>
<screen>[Unit]
Description="Run foo shell script"

[Timer]
OnBootSec=5min
OnUnitActiveSec=24h
Unit=foo.service

[Install]
WantedBy=multi-user.target</screen>
   <para>
    A seção <literal>[Timer]</literal> no exemplo acima especifica qual serviço acionar (<literal>foo.service</literal>) e quando acioná-lo. Nesse caso, a opção <option>OnBootSec</option> especifica um temporizador monotônico que aciona o serviço cinco minutos após o boot do sistema, enquanto a opção <option>OnUnitActiveSec</option> aciona o serviço 24 horas após a ativação do serviço (ou seja, o temporizador acionará o serviço uma vez por dia). Por fim, a opção <option>WantedBy</option> especifica que o temporizador deve ser iniciado quando o sistema atingir o destino de multiusuários.
   </para>
   <para>
    Em vez de um temporizador monotônico, você pode especificar um em tempo real usando a opção <option>OnCalendar</option>. A seguinte definição do temporizador em tempo real aciona a unidade de serviço relacionada uma vez por semana, começando na segunda-feira às 12:00.
   </para>
<screen>[Timer]
OnCalendar=weekly
Persistent=true</screen>
   <para>
    A opção <option>Persistent=true</option> indica que o serviço será acionado logo após a ativação do temporizador, se o temporizador tiver perdido o último horário de início (por exemplo, porque o sistema estava desligado).
   </para>
   <para>
    A opção <option>OnCalendar</option> também pode ser usada para definir horários e datas específicos para acionar um serviço usando o seguinte formato: <literal>DiadaSemana Ano-Mês-Dia Hora:Minuto:Segundo</literal>. O exemplo abaixo aciona um serviço às 5:00 todos os dias:
   </para>
<screen>OnCalendar=*-*-* 5:00:00</screen>
   <para>
    Você pode usar um asterisco para especificar qualquer valor e vírgulas para listar os valores possíveis. Use dois valores separados por .. para indicar uma faixa contígua. O exemplo a seguir aciona um serviço às 18:00 todas as sextas-feiras do mês:
   </para>
<screen>OnCalendar=Fri *-*-1..7 18:00:00</screen>
   <para>
    Para acionar um serviço em horários diferentes, você pode especificar várias entradas <option>OnCalendar</option>:
   </para>
<screen>OnCalendar=Mon..Fri 10:00
OnCalendar=Sat,Sun 22:00</screen>
   <para>
    No exemplo acima, um serviço é acionado às 10:00 nos dias da semana e às 22:00 nos fins de semana.
   </para>
   <para>
    Quando você terminar de editar o arquivo de unidade do temporizador, grave-o com o nome <filename>foo.timer</filename> no diretório <filename>/etc/systemd/system/</filename>. Para verificar se os arquivos de unidade criados estão corretos, execute o seguinte comando:
   </para>
<screen><prompt>&gt; </prompt><command>sudo</command>  systemd-analyze verify /etc/systemd/system/foo.*</screen>
   <para>
    Se o comando não retornar nenhuma saída, os arquivos foram aprovados na verificação.
   </para>
   <para>
    Para iniciar o temporizador, use o comando <command>sudo systemctl start foo.timer</command>. Para habilitar o temporizador na inicialização, execute o comando <command>sudo systemctl enable foo.timer</command>.
   </para>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-timer-manage">
   <title>Gerenciando temporizadores do <systemitem class="daemon">systemd</systemitem></title>
   <para>
    Como os temporizadores são tratados como unidades regulares do <systemitem class="daemon">systemd</systemitem>, você pode gerenciá-los usando o <command>systemctl</command>. Você pode iniciar um temporizador com <command>systemctl start</command>, habilitar um temporizador com <command>systemctl enable</command> e assim por diante. Além disso, você pode listar todos os temporizadores ativos usando o comando <command>systemctl list-timers</command>. Para listar todos os temporizadores, incluindo os inativos, execute o comando <command>systemctl list-timers --all</command>.
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-boot-systemd-info">
  <title>Mais informações</title>

  <para>
   Para obter mais informações sobre o <systemitem class="daemon">systemd</systemitem>, consulte os seguintes recursos online:
  </para>

  <variablelist>
   <varlistentry>
    <term>Home page</term>
    <listitem>
     <para>
      <link xlink:href="http://www.freedesktop.org/wiki/Software/systemd"/>
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><systemitem class="daemon">systemd</systemitem> para administradores</term>
    <listitem>
     <para>
      Lennart Pöttering, um dos criadores do <systemitem class="daemon">systemd</systemitem>, escreveu uma série de entradas de blog (13 até o fechamento deste capítulo). Encontre-os em <link xlink:href="http://0pointer.de/blog/projects"/>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
</chapter>
