<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="urn:x-suse:xslt:profiling:docbook50-profile.xsl"
                 type="text/xml"
                 title="Profiling step"?>
<!DOCTYPE article
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="article-podman-guide" xml:lang="en">
<title>Podman guide</title>
<subtitle>&productname; &productnumber;</subtitle>
<info>
  <productnumber>&productnumber;</productnumber><productname>&productname;</productname>
  <date><?dbtimestamp format="B d, Y"?></date>
  <abstract>
   <para>
    This guide describes Podman and containers. 
   </para>
  </abstract>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker></dm:bugtracker>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>
 
 <section xml:id="sec-introduction-podman">
 <title>Podman overview</title>
 <para>
 Podman is a short name for Pod Manager Tool. It is a daemonless container engine that enables you to run and deploy applications using containers and containers images. Podman provides a command line interface to manage containers.
 </para>
 <para>
  As Podman does not have a daemon, it provides integration with systemd. This makes it possible to control containers via systemd units. You can create these units for existing containers as well as generate units that can start containers if they do not exist in the system. Moreover, Podman can run systemd inside containers.
 </para>
 
 <para>
 Podman enables you to organize your containers into pods. Pods share the same network interface and resources. Typical use case for organizing a group of containers into a pod can be a container that runs a database and a container with a client that accesses the database. For details about pods, refer to <xref linkend="pod-architecture"/>.
 </para>
 
 <section xml:id="pod-architecture">
 <title>Pod architecture</title>
 <para>
 A pod is a group of containers that share the same namespace, ports and network connection. Usually containers within one pod can communicate directly with each other. Each pod contains an infrastructure container, which purpose is to hold the name space and it enables Podman to add other containers. Port bindings, cgroup-parent values, and kernel namespaces are all assigned to the infrastructure container. Thus later changes of these values are not possible. 
 </para>
 <para>
 Each container in a pod has its own instance of a monitoring program. The monitoring program watches the container's process and if the container dies, the monitoring program saves its exit code. The program also holds open the tty for the particular container. The monitoring program enables to run containers in the detached mode when Podman exits, but this program continues to run and enables to attach tty later.
 </para>
 </section>
 </section>
 
 <section xml:id="sec-podman-delivery">
 <title>Getting Podman</title>
 <para>
 In case of &slema;, Podman is delivered in all raw images or is by default installed if you installed your system manually. But to verify that Podman is installed in your system, run the following command:
 </para>
 <screen>
 zypper se -i podman
 </screen>
 </section>
 
 <section xml:id="sec-getting-images">
 <title>Getting container images</title>
 <para>
 To run a container, you need an image. An image includes all the dependencies needed to run the application. You can obtain images from image registry, available registries are defined in the <filename>/etc/containers/registries.conf</filename> configuration file.
 </para>
 <para>
 &slema; does not provide tools for building custom container images. Thus all images need to be pulled from an image registry.
 </para>
 </section>
 
 <section xml:id="sec-working-containers">
 <title>Working with containers</title>
 </section>
 
 <section xml:id="sec-working-pods">
 <title>Working with pods</title>
 </section>
 
 <section xml:id="sec-introduction-containers">
 <title>Introduction to containers</title>
 <para>
  Containers offer a lightweight virtualization method to run multiple
  virtual environments (containers) simultaneously on a single host. Unlike
  technologies like &xen; or &kvm;, where the processor simulates a complete
  hardware environment and a hypervisor controls virtual machines, containers
  provide virtualization at the operating system level, where the kernel
  controls the isolated containers.
 </para>
 <itemizedlist mark="bullet" spacing="normal">
  <title>Advantages of using containers</title>
  <listitem>
   <para>
    Containers make it possible to isolate applications in self-contained
    units.
   </para>
  </listitem>
  <listitem>
   <para>
    Containers provide near-native performance. Depending on the runtime, a
    container can use the host kernel directly, thus minimizing overhead.
   </para>
  </listitem>
  <listitem>
   <para>
    It is possible to control network interfaces and apply resources inside
    containers through kernel control groups.
   </para>
  </listitem>
 </itemizedlist>
 <itemizedlist mark="bullet" spacing="normal">
  <title>Limitations of containers</title>
  <listitem>
   <para>
    Containers run on the host system's kernel, so they cannot use different
    kernels or different kernel versions.
   </para>
  </listitem>  
  <listitem>
   <para>
    Containers are not secure, and the overall security depends on the host
    system. Containerized applications can be secured through &aa; or &selnx;
    profiles. Securing containers is harder than securing virtual machines, due
    to the larger attack surface.
   </para>
  </listitem>
 </itemizedlist>
 </section>
  </article>
