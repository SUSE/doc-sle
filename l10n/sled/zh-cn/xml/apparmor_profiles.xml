<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="apparmor_profiles.xml" version="5.0" xml:id="cha-apparmor-profiles">
 <title>配置文件组件和语法</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>
 <para>
  构建 <phrase>AppArmor</phrase> 配置文件来限制应用程序的操作非常简单且直观。<phrase>AppArmor 附带了多种工具来帮助创建配置文件。</phrase>您无需编程或处理脚本。管理员唯一需要执行的任务是为每个需要强化的应用程序确定最严格的访问和执行权限策略。
 </para>
 <para>
  只有在软件配置或所需的活动范围发生变化时才有必要更新或修改应用程序配置文件。<phrase>AppArmor</phrase> 提供了直观的工具来处理配置文件的更新和修改。
 </para>
 <para>
  选择要构建配置文件的程序后，您就作好了构建 <phrase>AppArmor</phrase> 配置文件的准备。要执行此操作，必须了解配置文件的组件和语法。<phrase>AppArmor</phrase> 配置文件包含多个可帮助您构建简单且可重用配置文件代码的构建基块：
 </para>
 <variablelist>
  <varlistentry>
   <term>Include 文件</term>
   <listitem>
    <para>
     Include 语句用于提取其他 <phrase>AppArmor</phrase> 配置文件的组成部分，可简化新配置文件的结构。
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>抽象</term>
   <listitem>
    <para>
     抽象是按常见应用程序任务分组的 include 语句。
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>程序块</term>
   <listitem>
    <para>
     程序块是包含专用于程序套件的配置文件块的 include 语句。
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>功能项</term>
   <listitem>
    <para>
     功能项是任何 POSIX.1e <link xlink:href="http://en.wikipedia.org/wiki/POSIX#POSIX.1"/> Linux 功能的配置文件项，可用于精细控制允许受限制进程通过需要特权的系统调用执行哪些操作。
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>网络访问控制项</term>
   <listitem>
    <para>
     网络访问控制项基于地址类型和地址族调解网络访问。
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>局部变量定义</term>
   <listitem>
    <para>
     局部变量定义路径的快捷方式。
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>文件访问控制项</term>
   <listitem>
    <para>
     文件访问控制项指定应用程序可访问的文件集。
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>rlimit 项</term>
   <listitem>
    <para>
     rlimit 项设置和控制应用程序的资源限制。
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
 <para>
  如需有关确定要构建配置文件的程序的帮助，请参见<xref xrefstyle="ChapTitleOnPage" linkend="sec-apparmor-concept-determine"/>。要开始使用 YaST 构建 <phrase>AppArmor</phrase> 配置文件，请转到<xref linkend="cha-apparmor-yast"/>。要使用 <phrase>AppArmor</phrase> 命令行界面构建配置文件，请转到<xref linkend="cha-apparmor-commandline"/>。
 </para>
 <para>
  有关创建 <phrase>AppArmor</phrase> 配置文件的更多细节，请参见 <command>man 5 apparmor</command>。
 </para>
 <sect1 xml:id="sec-apparmor-profiles-parts">
  <title>分解 <phrase>AppArmor</phrase> 配置文件</title>

  <para>
   要介绍配置文件的构成以及创建配置文件的过程，最简单的方法就是显示示例配置文件的细节，本例使用了名为 <command>/usr/bin/foo</command> 的虚构应用程序的配置文件：
  </para>

<screen>#include &lt;tunables/global&gt;<co xml:id="co-apparmor-profiles-vardef"/>

# a comment naming the application to confine
/usr/bin/foo<co xml:id="co-apparmor-profiles-path"/> {<co xml:id="co-apparmor-profiles-brack"/>
   #include &lt;abstractions/base&gt;<co xml:id="co-apparmor-profiles-incl"/>

   capability setgid<co xml:id="co-apparmor-profiles-capent"/>,
   network inet tcp<co xml:id="co-apparmor-profiles-netd"/>,

   link /etc/sysconfig/foo -&gt; /etc/foo.conf,<co xml:id="co-apparmor-profiles-lp"/>
   /bin/mount            ux,
   /dev/{,u}<co xml:id="co-apparmor-profiles-ext"/>random     r,
   /etc/ld.so.cache      r,
   /etc/foo/*            r,
   /lib/ld-*.so*         mr,
   /lib/lib*.so*         mr,
   /proc/[0-9]**         r,
   /usr/lib/**           mr,
   /tmp/                 r,<co xml:id="co-apparmor-profiles-pathent"/>
   /tmp/foo.pid          wr,
   /tmp/foo.*            lrw,
   /@{HOME}<co xml:id="co-apparmor-profiles-variable"/>/.foo_file   rw,
   /@{HOME}/.foo_lock    kw,
   owner<co xml:id="co-apparmor-profiles-owner"/> /shared/foo/** rw,
   /usr/bin/foobar       Cx,<co xml:id="co-apparmor-profiles-cx"/>
   /bin/**               Px -&gt; bin_generic,<co xml:id="co-apparmor-profiles-named"/>

   # a comment about foo's local (children) profile for /usr/bin/foobar.

   profile /usr/bin/foobar<co xml:id="co-apparmor-profiles-local"/> {
      /bin/bash          rmix,
      /bin/cat           rmix,
      /bin/more          rmix,
      /var/log/foobar*   rwl,
      /etc/foobar        r,
   }

  # foo's hat, bar.
   ^bar<co xml:id="co-apparmor-profiles-hat"/> {
    /lib/ld-*.so*         mr,
    /usr/bin/bar          px,
    /var/spool/*          rwl,
   }
}
</screen>

  <calloutlist>
   <callout arearefs="co-apparmor-profiles-vardef">
    <para>
     此语句装载包含变量定义的文件。
    </para>
   </callout>
   <callout arearefs="co-apparmor-profiles-path">
    <para>
     受限制程序的规范化路径。
    </para>
   </callout>
   <callout arearefs="co-apparmor-profiles-brack">
    <para>
     花括号 (<literal>{}</literal>) 充当 include 语句、子配置文件、路径项、功能项和网络项的容器。
    </para>
   </callout>
   <callout arearefs="co-apparmor-profiles-incl">
    <para>
     此指令提取 <phrase>AppArmor</phrase> 配置文件的组件以简化配置文件。
    </para>
   </callout>
   <callout arearefs="co-apparmor-profiles-capent">
    <para>
     功能项语句可启用每个 29 POSIX.1e 草案功能。
    </para>
   </callout>
   <callout arearefs="co-apparmor-profiles-netd">
    <para>
     确定允许应用程序进行哪种网络访问的指令。有关详细信息，请参考 <xref linkend="sec-apparmor-profiles-nac"/>。
    </para>
   </callout>
   <callout arearefs="co-apparmor-profiles-lp">
    <para>
     链接对规则，指定链接的源和目标。有关更多信息，请参见<xref linkend="sec-apparmor-profiles-perm-link-pair"/>。
    </para>
   </callout>
   <callout arearefs="co-apparmor-profiles-ext">
    <para>
     此处的花括号 (<literal>{}</literal>) 允许所列的每个可能的值，其中一个可能的值为空字符串。
    </para>
   </callout>
   <callout arearefs="co-apparmor-profiles-pathent">
    <para>
     路径项，指定程序可以访问文件系统的哪些区域。路径项的第一部分指定文件的绝对路径（包括正则表达式通配），第二部分指示允许的访问模式（例如 <literal>r</literal> 表示读，<literal>w</literal> 表示写，<literal>x</literal> 表示执行）。路径名的开头可以包含任何类型的空白字符（空格或制表符），但必须以空格分隔路径名和模式说明符。可以选择用空格分隔各访问模式并在末端包含尾随逗号。<xref linkend="sec-apparmor-profiles-perm"/>中提供了可用访问模式的综合概述。
    </para>
   </callout>
   <callout arearefs="co-apparmor-profiles-variable">
    <para>
     此变量将扩展为一个无需更改整个配置文件即可更改的值。
    </para>
   </callout>
   <callout arearefs="co-apparmor-profiles-owner">
    <para>
     拥有者条件规则，授予对用户所拥有文件的读写权限。有关更多信息，请参考<xref linkend="sec-apparmor-profiles-perm-owner"/>。
    </para>
   </callout>
   <callout arearefs="co-apparmor-profiles-cx">
    <para>
     此项定义转换到本地配置文件 <literal>/usr/bin/foobar</literal>。<xref linkend="sec-apparmor-profiles-exec"/>中提供了可用执行模式的综合概述。
    </para>
   </callout>
   <callout arearefs="co-apparmor-profiles-named">
    <para>
     目标为位于全局范围内的 bin_generic 配置文件的命名配置文件转换。有关详细信息，请参见<xref linkend="sec-apparmor-profiles-exec-named"/>。
    </para>
   </callout>
   <callout arearefs="co-apparmor-profiles-local">
    <para>
     本地配置文件 <literal>/usr/bin/foobar</literal> 在此部分中定义。
    </para>
   </callout>
   <callout arearefs="co-apparmor-profiles-hat">
    <para>
     此部分引用了应用程序的<quote>帽子</quote>子配置文件。有关 <phrase>AppArmor</phrase> ChangeHat 功能的更多细节，请参见<xref linkend="cha-apparmor-hat"/>。
    </para>
   </callout>
  </calloutlist>

  <para>
   为程序创建配置文件后，此程序只可访问配置文件中指定的文件、模式和 POSIX 功能。这些限制是对本机 Linux 访问控制的补充。
  </para>

  <formalpara>
   <title>示例：</title>
   <para>
    要获得 <systemitem>CAP_CHOWN</systemitem> 功能，程序必须能够在常规 Linux 访问控制下访问 <systemitem>CAP_CHOWN</systemitem>（通常为 <systemitem class="username">root</systemitem> 拥有的进程），并且其配置文件中必须设置 <systemitem>chown</systemitem> 功能。与此类似，要能够写入 <filename>/foo/bar</filename> 文件，程序的文件属性中必须设置正确的用户 ID 和模式位，并且其配置文件中必须设置 <literal>/foo/bar w</literal>。
   </para>
  </formalpara>

  <para>
   违反 <phrase>AppArmor</phrase> 规则的尝试将记录在 <filename>/var/log/audit/audit.log</filename>（如果已安装 <systemitem class="resource">audit</systemitem> 软件包）、<filename>/var/log/messages</filename> 中，或仅记录在 <systemitem>journalctl</systemitem> 中（如果未安装传统的 syslog）。<phrase>AppArmor</phrase> 规则通常可防止攻击发挥作用，因为必要的文件不可访问。在任何情况下，<phrase>AppArmor</phrase> 限制都可以禁止攻击者可能对 <phrase>AppArmor</phrase> 所允许的文件集进行的破坏。
  </para>
 </sect1>
 <sect1 xml:id="sec-apparmor-profiles-types">
  <title>配置文件类型</title>

  <para>
   <phrase>AppArmor</phrase> 可识别四种不同类型的配置文件：标准配置文件、未关联的配置文件、本地配置文件和帽子。标准配置文件和未关联的配置文件是独立的配置文件，各自储存在 <filename>/etc/apparmor.d/</filename> 下的某个文件中。本地配置文件和帽子是在父配置文件内部嵌入的子配置文件，用于针对应用程序的子任务提供更严格或备选的限制。
  </para>

  <sect2 xml:id="sec-apparmor-profiles-types-attached">
   <title>标准配置文件</title>
   <para>
    默认的 <phrase>AppArmor</phrase> 配置文件将按其名称关联到程序，因此，配置文件的名称必须与其要限制的应用程序的路径相匹配。
   </para>
<screen>/usr/bin/foo {
...
}
</screen>
   <para>
    每当未受限的进程执行 <filename>/usr/bin/foo</filename> 时，就会自动使用此配置文件。
   </para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-types-unattached">
   <title>未关联的配置文件</title>
   <para>
    未关联的配置文件不会驻留在文件系统名称空间中，因此不会自动关联到应用程序。未关联的配置文件的名称前面带有关键字 <literal>profile</literal>。您可以自由选择配置文件名称，但存在以下限制：名称不得以 <literal>:</literal> 或 <literal>&#x002E;</literal> 字符开头。如果名称包含空格，必须将它括在引号中。如果名称以 <literal>/</literal> 开头，则将该配置文件视为标准配置文件，因此以下两个配置文件是相同的：
   </para>
<screen>profile /usr/bin/foo {
...
}
/usr/bin/foo {
...
}</screen>
   <para>
    系统永远不会自动使用未关联的配置文件，也不能通过 <literal>Px</literal> 规则将其他配置文件转换为未关联的配置文件。需使用命名配置文件转换（请参见<xref linkend="sec-apparmor-profiles-exec-named"/>）或 <literal>change_profile</literal> 规则（请参见<xref linkend="sec-apparmor-profiles-types-change"/>）将其关联到程序。
   </para>
   <para>
    一般不应由系统范围的配置文件（例如 <literal>/bin/bash</literal>）限制的系统实用程序的专用配置文件适合采用未关联的配置文件。它们还可用于设置角色或限制用户。
   </para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-types-local">
   <title>本地配置文件</title>
   <para>
    本地配置文件可让您方便地针对受限制应用程序启动的实用程序提供专门的限制。其指定方式类似于标准配置文件，不过，它们嵌入于父配置文件中，并以 <literal>profile</literal> 关键字开头：
   </para>
<screen>/parent/profile {
   ...
   profile /local/profile {
      ...
   }
}</screen>
   <para>
    要转换为本地配置文件，请使用 <literal>cx</literal> 规则（请参见<xref linkend="sec-apparmor-profiles-exec-cx"/>）或命名配置文件转换（请参见<xref linkend="sec-apparmor-profiles-exec-named"/>）。
   </para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-types-hat">
   <title>帽子</title>
   <para>
    <phrase>AppArmor</phrase>“帽子”属于本地配置文件，它们存在一些额外的限制，以及允许使用 <literal>change_hat</literal> 转换到这些配置文件的隐式规则。有关详细说明，请参见<xref linkend="cha-apparmor-hat"/>。
   </para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-types-change">
   <title>更改规则</title>
   <para>
    <phrase>AppArmor</phrase> 提供了 <literal>change_hat</literal> 和 <literal>change_profile</literal> 规则，用于控制域转换。<literal>change_hat</literal> 通过在配置文件中定义帽子来指定，而 <literal>change_profile</literal> 规则会引用另一个配置文件，并以关键字 <literal>change_profile</literal> 开头：
   </para>
<screen>change_profile -&gt; /usr/bin/foobar,</screen>
   <para>
    <literal>change_hat</literal> 和 <literal>change_profile</literal> 都提供应用程序导向的配置文件转换，而无需启动单独的应用程序。<literal>change_profile</literal> 在装载的任何配置文件之间均提供通用的单向转换。<literal>change_hat</literal> 提供可回转的父子转换，其中，应用程序可从父配置文件切换到帽子配置文件，如果它提供正确的机密密钥，则稍后可恢复为父配置文件。
   </para>
   <para>
    <literal>change_profile</literal> 最适合用于应用程序需要经历可信设置阶段，随后可以降低其特权级别的情况。在启动阶段映射或打开的任何资源在配置文件发生更改后仍可访问，但新配置文件将限制新资源的打开，甚至会限制在转变之前打开的某些资源。具体而言，在可以限制功能和文件资源（前提是它们未经过内存映射）的情况下，内存资源仍然可用。
   </para>
   <para>
    <literal>change_hat</literal> 最适合用于应用程序需运行不提供应用程序资源（例如 Apache 的 <literal>mod_php</literal>）直接访问途径的虚拟机或解释器的情况。由于 <literal>change_hat</literal> 将返回机密密钥储存在应用程序的内存中，因此在特权降级阶段，不应具有直接访问内存的权限。正确分隔文件访问权限也很重要，因为帽子可以限制对文件句柄的访问，但不会关闭文件句柄。如果应用程序在进行缓冲并通过缓冲提供对所打开文件的访问，内核可能看不到对这些文件的访问，因此新配置文件不会限制此类访问。
   </para>
   <warning>
    <title>域转换的安全性</title>
    <para>
     <literal>change_hat</literal> 和 <literal>change_profile</literal> 域转换不如通过执行完成的域转换安全，因为它们不会影响进程的内存映射，也不会关闭已打开的资源。
    </para>
   </warning>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-apparmor-profiles-includes">
  <title>Include 语句</title>

  <para>
   Include 语句是可提取其他 <phrase>AppArmor</phrase> 配置文件的组件以简化配置文件的指令。Include 文件会检索程序的访问权限。通过使用 include，您可以向程序赋予访问其它程序也需要的目录路径和文件的权限。使用 include 可减小配置文件的大小。
  </para>

  <para>
   Include 语句通常以井号 (<literal>#</literal>) 开头。这会造成混淆，因为配置文件中的注释也使用井号。因此，仅当不存在前置 #（<literal>##include</literal> 是注释）并且 <literal>#</literal> 与 <literal>include</literal> 之间不存在空格（<literal># include</literal> 是注释）时，才将 <literal>#include</literal> 视为 include。
  </para>

  <para>
   您也可以使用不带前导 <literal>#</literal> 的 <literal>include</literal>。
  </para>

<screen>include "/etc/apparmor.d/abstractions/foo"</screen>

  <para>
   等同于使用
  </para>

<screen>#include "/etc/apparmor.d/abstractions/foo"</screen>

  <note>
   <title>无尾随“,”</title>
   <para>
    请注意，由于 include 遵循 C 预处理器语法，因此不含尾随的“,”，这与大多数 <phrase>AppArmor</phrase> 规则一样。
   </para>
  </note>

  <para>
   您可以通过在语法中进行细微的更改来修改 <literal>include</literal> 的行为。如果在包含路径两侧使用 <literal>&quot;&quot;</literal>，则会指示解析器执行绝对或相对路径查找。
  </para>

<screen>include "/etc/apparmor.d/abstractions/foo"   # absolute path
include "abstractions/foo"   # relative path to the directory of current file</screen>

  <para>
   请注意，在使用相对路径 include 时，如果包含了文件，则会将此文件视为其 include 的当前新文件。例如，假设您在 <filename>/etc/apparmor.d/bar</filename> 文件中操作，那么
  </para>

<screen>include "abstractions/foo"</screen>

  <para>
   会包含文件 <filename>/etc/apparmor.d/abstractions/foo</filename>。如果
  </para>

<screen>include "example"</screen>

  <para>
   存在于 <filename>/etc/apparmor.d/abstractions/foo</filename> 文件中，则其会包含 <filename>/etc/apparmor.d/abstractions/example</filename>。
  </para>

  <para>
   使用 <literal>&lt;&gt;</literal> 会指定按顺序尝试 include 路径（由 <option>-I</option> 指定，默认为 <filename>/etc/apparmor.d</filename> 目录）。假设 include 路径为
  </para>

<screen>-I /etc/apparmor.d/ -I /usr/share/apparmor/</screen>

  <para>
   则 include 语句
  </para>

<screen>include &lt;abstractions/foo&gt;</screen>

  <para>
   将尝试 <filename>/etc/apparmor.d/abstractions/foo</filename>，如果该文件不存在，则下一次会尝试 <filename>/usr/share/apparmor/abstractions/foo</filename>。
  </para>

  <tip>
   <para>
    可以手动覆盖默认的 include 路径，方法是将 <option>-I</option> 传递给 <command>apparmor_parser</command>，或者在 <filename>/etc/apparmor/parser.conf</filename> 中设置 include 路径：
   </para>
<screen>Include /usr/share/apparmor/
Include /etc/apparmor.d/</screen>
   <para>
    允许多个项，其提取顺序与在 <command>apparmor_parser</command> 命令行中使用 <option>-I</option> 或 <option>--Include</option> 时的顺序相同。
   </para>
  </tip>

  <para>
   如果 include 以“/”结尾，则会将它视为目录 include，并会包含该目录中的所有文件。
  </para>

  <para>
   为帮助您构建应用程序的配置文件，<phrase>AppArmor</phrase> 提供了三类 include：抽象、程序块和 tunable。
  </para>

  <sect2 xml:id="sec-apparmor-profiles-includes-abstractions">
   <title>抽象</title>
   <para>
    抽象是按常见应用程序任务分组的 include。这些任务包括访问身份验证机制、访问名称服务例程、一般的图形要求以及系统统计。这些抽象中列出的文件特定于命名任务。需要其中某个文件的程序通常也需要抽象文件中列出的其他文件（取决于程序的本地配置和具体要求）。<filename>/etc/apparmor.d/abstractions</filename> 中提供了抽象。
   </para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-includes-chunks">
   <title>程序块</title>
   <para>
    program-chunks 目录 (<filename>/etc/apparmor.d/program-chunks</filename>) 中包含一些专用于程序套件的配置文件块，这些块在套件外部一般没有作用，因此，配置文件向导（<command>aa-logprof</command> 和 <command>aa-genprof</command>）从不建议在配置文件中使用这些配置文件块。目前，程序块仅适用于 postfix 程序套件。
   </para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-includes-tunables">
   <title>Tunables</title>
   <para>
    tunables 目录 (<filename>/etc/apparmor.d/tunables</filename>) 包含全局变量定义。在配置文件中使用时，这些变量将扩展为一个无需更改整个配置文件即可更改的值。请将应该可供每个配置文件使用的所有 tunable 定义添加到 <filename>/etc/apparmor.d/tunables/global</filename>。
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-apparmor-profiles-capabilities">
  <title>功能项 (POSIX.1e)</title>

  <para>
   功能规则很简单，就是 <literal>capability</literal> 一词后接 POSIX.1e 功能名称（如 <systemitem>capabilities(7)</systemitem> 手册页中所定义）。您可以在单条规则中列出多个功能，或者仅使用关键字 <literal>capability</literal> 授予所有已实现的功能。
  </para>

<screen>
capability dac_override sys_admin,   # multiple capabilities
capability,                          # grant all capabilities
</screen>
 </sect1>
 <sect1 xml:id="sec-apparmor-profiles-nac">
  <title>网络访问控制</title>

  <para>
   <phrase>AppArmor</phrase> 允许基于地址类型和地址族调解网络访问。下面将说明网络访问规则语法：
  </para>

<screen>network [[&lt;domain&gt;<co xml:id="co-apparmor-profiles-nac-dom"/>][&lt;type<co xml:id="co-apparmor-profiles-nac-type"/>&gt;][&lt;protocol<co xml:id="co-apparmor-profiles-nac-proto"/>&gt;]]</screen>

  <calloutlist>
   <callout arearefs="co-apparmor-profiles-nac-dom">
    <para>
     支持的域：<literal>inet</literal>、<literal>ax25</literal>、<literal>ipx</literal>、<literal>appletalk</literal>、<literal>netrom</literal>、<literal>bridge</literal>、<literal>x25</literal>、<literal>inet6</literal>、<literal>rose</literal>、<literal>netbeui</literal>、<literal>security</literal>、<literal>key</literal>、<literal>packet</literal>、<literal>ash</literal>、<literal>econet</literal>、<literal>atmsvc</literal>、<literal>sna</literal>、<literal>pppox</literal>、<literal>wanpipe</literal>、<literal>bluetooth</literal>、<literal>unix</literal>、<literal>atmpvc</literal>,<literal>netlink</literal>、<literal>llc</literal>、<literal>can</literal>、<literal>tipc</literal>、<literal>iucv</literal>、<literal>rxrpc</literal>、<literal>isdn</literal>、<literal>phonet</literal>、<literal>ieee802154</literal>、<literal>caif</literal>、<literal>alg</literal>、<literal>nfc</literal>、<literal>vsock</literal>
    </para>
   </callout>
   <callout arearefs="co-apparmor-profiles-nac-type">
    <para>
     支持的类型：<literal>stream</literal>、<literal>dgram</literal>、<literal>seqpacket</literal>、<literal>rdm</literal>、<literal>raw</literal>、<literal>packet</literal>
    </para>
   </callout>
   <callout arearefs="co-apparmor-profiles-nac-proto">
    <para>
     支持的协议：<literal>tcp</literal>、<literal>udp</literal>、<literal>icmp</literal>
    </para>
   </callout>
  </calloutlist>

  <para>
   <phrase>AppArmor</phrase> 工具仅支持族和类型规范。<phrase>AppArmor</phrase> 模块在 <quote>ACCESS DENIED</quote> 消息中仅会发出 <literal>network <replaceable>DOMAIN</replaceable>
   <replaceable>TYPE</replaceable></literal>。配置文件生成工具（YaST 和命令行）仅输出这些内容。
  </para>

  <para>
   下面的示例说明可在 <phrase>AppArmor</phrase> 配置文件中使用的可能网络相关规则。请注意，<phrase>AppArmor</phrase> 工具目前不支持最后两条规则的语法。
  </para>

<screen>network<co xml:id="co-apparmor-profiles-nac-nw"/>,
network inet<co xml:id="co-apparmor-profiles-nac-inet"/>,
network inet6<co xml:id="co-apparmor-profiles-nac-inet6"/>,
network inet stream<co xml:id="co-apparmor-profiles-nac-istream"/>,
network inet tcp<co xml:id="co-apparmor-profiles-nac-itcp"/>,
network tcp<co xml:id="co-apparmor-profiles-nac-tcp"/>,
</screen>

  <calloutlist>
   <callout arearefs="co-apparmor-profiles-nac-nw">
    <para>
     允许所有网络。不应用与域、类型或协议相关的限制。
    </para>
   </callout>
   <callout arearefs="co-apparmor-profiles-nac-inet">
    <para>
     允许 IPv4 网络的一般用法。
    </para>
   </callout>
   <callout arearefs="co-apparmor-profiles-nac-inet6">
    <para>
     允许 IPv6 网络的一般用法。
    </para>
   </callout>
   <callout arearefs="co-apparmor-profiles-nac-istream">
    <para>
     允许使用 IPv4 TCP 网络。
    </para>
   </callout>
   <callout arearefs="co-apparmor-profiles-nac-itcp">
    <para>
     允许使用 IPv4 TCP 网络（上一条规则的释义）。
    </para>
   </callout>
   <callout arearefs="co-apparmor-profiles-nac-tcp">
    <para>
     允许使用 IPv4 和 IPv6 TCP 网络。
    </para>
   </callout>
  </calloutlist>
 </sect1>
 <sect1 role="General" xml:id="sec-apparmor-profiles-glob">
  <title>配置文件名称、标志、路径和通配</title>

  <para>
   通常，通过指定程序可执行文件的完整路径来将配置文件关联到相应程序。例如，对于标准配置文件（请参见<xref linkend="sec-apparmor-profiles-types-attached"/>），通过以下方式来定义配置文件
  </para>

<screen>/usr/bin/foo { ... }</screen>

  <para>
   下列各节介绍在命名配置文件、将某个配置文件放入其他现有配置文件的环境中，或者指定文件路径时可以运用的若干有用技巧。
  </para>

  <para>
   <phrase>AppArmor</phrase> 显式区分目录路径名和文件路径名。对需要显式区分的任何目录路径使用尾随 <literal>/</literal>：
  </para>

  <variablelist>
   <varlistentry>
    <term><filename>/some/random/example/* r</filename>
    </term>
    <listitem>
     <para>
      允许对 <filename>/some/random/example</filename> 目录中的文件进行读取访问。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><filename>/some/random/example/ r</filename>
    </term>
    <listitem>
     <para>
      仅允许对该目录进行读取访问。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><filename>/some/**/ r</filename>
    </term>
    <listitem>
     <para>
      授予对 <filename>/some</filename> 下的任何目录（但不包括 /some/ 本身）的读取访问权限。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><filename>/some/random/example/** r</filename>
    </term>
    <listitem>
     <para>
      授予对 <filename>/some/random/example</filename> 下的文件和目录（但不包括 /some/random/example/ 本身）的读取访问权限。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><filename>/some/random/example/**[^/] r</filename>
    </term>
    <listitem>
     <para>
      授予对 <filename>/some/random/example</filename> 下的文件的读取访问权限。显式排除目录 (<literal>[^/]</literal>)。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   通配（亦称为常规表达式匹配）是您在修改目录路径时使用通配符将一组文件或子目录包含在内的情况。使用通配语法可以指定文件资源，类似于常用的外壳（如 csh、bash 和 zsh）使用的通配语法。
  </para>

  <informaltable>
   <tgroup cols="2">
    <tbody>
     <row>
      <entry>
       <para>
        <literal>*</literal>
       </para>
      </entry>
      <entry>
       <para>
        代替任意数目的任何字符，<literal>/</literal> 除外。
       </para>
       <para>
        示例：任意数目的文件路径元素。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <literal>**</literal>
       </para>
      </entry>
      <entry>
       <para>
        代替任意数目的字符，包括 <literal>/</literal>。
       </para>
       <para>
        示例：任意数目的路径元素，包括整个目录。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <literal>?</literal>
       </para>
      </entry>
      <entry>
       <para>
        代替任意单独字符，<literal>/</literal> 除外。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <literal>[abc]</literal>
       </para>
      </entry>
      <entry>
       <para>
        代替一个字符 <literal>a</literal>、<literal>b</literal> 或 <literal>c</literal>。
       </para>
       <para>
        示例：匹配 <literal>/home[01]/*/.plan</literal> 的规则允许程序访问 <filename>/home0</filename> 和 <filename>/home1</filename> 中的用户的 <filename>.plan</filename> 文件。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <literal>[a-c]</literal>
       </para>
      </entry>
      <entry>
       <para>
        代替一个字符 <literal>a</literal>、<literal>b</literal> 或 <literal>c</literal>。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <literal>{ab,cd}</literal>
       </para>
      </entry>
      <entry>
       <para>
        扩展为一条匹配 <literal>ab</literal> 的规则，以及一条匹配 <literal>cd</literal> 的规则。
       </para>
       <para>
        示例：匹配 <literal>/{usr,www}/pages/**</literal> 的规则授予对 <filename>/usr/pages</filename> 和 <filename>/www/pages</filename> 中的网页的访问权限。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <literal>[^a]</literal>
       </para>
      </entry>
      <entry>
       <para>
        代替任何字符，<literal>a</literal> 除外。
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>

  <sect2 xml:id="sec-apparmor-profiles-flags">
   <title>配置文件标志</title>
   <para>
    配置文件标志控制相关配置文件的行为。您可以通过手动编辑配置文件定义来将配置文件标志添加到其中。请参见以下语法：
   </para>
<screen>/path/to/profiled/binary flags=(list_of_flags) {
  [...]
}</screen>
   <para>
    可以使用以逗号“,”或空格“ ”分隔的多个标志。配置文件标志有三种基本类型：模式、相对和附加标志。
   </para>
   <para>
    <emphasis>模式</emphasis>标志为 <literal>complain</literal>（允许并记录非法访问）。如果省略该标志，则配置文件处于<literal>强制</literal>模式（强制执行策略）。
   </para>
   <tip>
    <para>
     将整个配置文件设置为控诉模式的更灵活的方式是在 <filename>/etc/apparmor.d/force-complain/</filename> 目录中基于该配置文件创建一个符号链接。
    </para>
<screen>ln -s /etc/apparmor.d/bin.ping /etc/apparmor.d/force-complain/bin.ping</screen>
   </tip>
   <para>
    <emphasis>相对</emphasis>标志为 <literal>chroot_relative</literal>（指出配置文件相对于 chroot 而不是名称空间）或 <literal>namespace_relative</literal>（默认值，表示路径相对于 chroot 外部）。这两个标志是互斥的。
   </para>
   <para>
    <emphasis>附加</emphasis>标志由两对互斥的标志构成：<literal>attach_disconnected</literal> 或 <literal>no_attach_disconnected</literal>（确定解析为名称空间外部的路径名是否附加到根目录，即，它们的开头是否包含“/”字符），<literal>chroot_attach</literal> 或 <literal>chroot_no_attach</literal>（在 chroot 环境中访问位于 chroot 外部但在名称空间内部的文件时，控制路径名生成）。
   </para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-glob-variables">
   <title>在配置文件中使用变量</title>
   <para>
    <phrase>AppArmor</phrase> 允许在配置文件中使用变量来包含路径。使用全局变量可使配置文件具有可移植性，使用局部变量可以创建路径的快捷方式。
   </para>
   <para>
    举个典型的示例，在用户主目录挂载到不同位置的网络方案中，全局变量就很方便。您无需在所有受影响的配置文件中修改主目录的路径，而只需更改变量的值。全局变量在 <filename>/etc/apparmor.d/tunables</filename> 下定义，需要通过 include 语句来使用。<filename>/etc/apparmor.d/tunables/home</filename> 文件中提供了此用例的变量定义（<envar>@{HOME}</envar> 和 <envar>@{HOMEDIRS}</envar>）。
   </para>
   <para>
    局部变量在配置文件的头部定义。这样便于提供 chroot 路径的基础，例如：
   </para>
<screen>@{CHROOT_BASE}=/tmp/foo
/sbin/rsyslogd {
...
# chrooted applications
@{CHROOT_BASE}/var/lib/*/dev/log w,
@{CHROOT_BASE}/var/log/** w,
...
}</screen>
   <para>
    在下面的示例中，@{HOMEDIRS} 会列出所有用户主目录的储存位置，@{HOME} 是主目录的空格分隔列表。接下来，@{HOMEDIRS} 会按用于储存用户主目录的两个新特定位置进行扩展。
   </para>
<screen>@{HOMEDIRS}=/home/
@{HOME}=@{HOMEDIRS}/*/ /root/
[...]
@{HOMEDIRS}+=/srv/nfs/home/ /mnt/home/</screen>
   <note>
    <para>
     在当前的 <phrase>AppArmor</phrase> 工具中，只能在手动编辑和维护配置文件时使用变量。
    </para>
   </note>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-pattern-matching">
   <title>模式匹配</title>
   <para>
    配置文件名称可以包含通配表达式，这样配置文件便可匹配多个二进制文件。
   </para>
   <para>
    下面的示例适用于 <command>foo</command> 二进制文件驻留在 <filename>/usr/bin</filename> 或 <filename>/bin</filename> 中的系统。
   </para>
<screen>/{usr/,}bin/foo { ... }</screen>
   <para>
    在下面的示例中，对可执行文件 <filename>/bin/foo</filename> 进行匹配时，<literal>/bin/foo</literal> 配置文件是完全匹配项，因此已将其选中。对于可执行文件 <filename>/bin/fat</filename>，配置文件 <literal>/bin/foo</literal> 不匹配，并且由于 <literal>/bin/f*</literal> 配置文件比 <literal>/bin/**</literal> 更具体（较不宽泛），因此选择了 <literal>/bin/f*</literal> 配置文件。
   </para>
<screen>
/bin/foo { ... }

/bin/f*  { ... }

/bin/**  { ... }
</screen>
   <para>
    有关配置文件名称通配示例的详细信息，请参见 <phrase>AppArmor</phrase> 的手册页 <command>man 5 apparmor.d</command> 以及“<literal>通配</literal>”一节。
   </para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-namespaces">
   <title>名称空间</title>
   <para>
    名称空间用于提供不同的配置文件集。例如，一个配置文件集用于系统，另一个配置文件集用于 chroot 环境或容器。名称空间是分层的 — 名称空间可以看到其子项，但子项看不到其父项。名称空间的名称以冒号 <literal>:</literal> 开头，后接一个字母数字字符串、一个尾随冒号 <literal>:</literal> 和一个可选的双斜线 <literal>//</literal>，例如
   </para>
<screen>:childNameSpace://</screen>
   <para>
    装载到子名称空间的配置文件以其名称空间名称为前缀（从父项的角度看）：
   </para>
<screen>:childNameSpace://apache</screen>
   <para>
    可以通过 <literal>change_profile</literal> API 或命名配置文件转换进入名称空间：
   </para>
<screen>/path/to/executable px -&gt; :childNameSpace://apache</screen>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-naming-attachment">
   <title>配置文件命名和附件规范</title>
   <para>
    配置文件可以有一个名称和一个附件规范。这样，您便可为配置文件指定一个比包含模式匹配（请参见<xref linkend="sec-apparmor-profiles-pattern-matching"/>）的名称更有意义且符合逻辑的名称，便于用户/管理员识别。例如，默认配置文件
   </para>
<screen>/** { ... }</screen>
   <para>
    可命名为
   </para>
<screen>profile default /** { ... }</screen>
   <para>
    另外，可为包含模式匹配的配置文件命名。例如：
   </para>
<screen>/usr/lib64/firefox*/firefox-*bin { ... }</screen>
   <para>
    可命名为
   </para>
<screen>profile firefox /usr/lib64/firefox*/firefox-*bin { ... }</screen>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-glob-alias">
   <title>别名规则</title>
   <para>
    别名规则提供了另一种操作站点特定布局的配置文件路径映射的方式。它们是另一种修改路径的方式（一种方式是使用变量），在解析变量后执行。别名规则告知要将具有相同源前缀的规则看作是规则位于目标前缀处。
   </para>
<screen>alias /home/ -&gt; /usr/home/</screen>
   <para>
    前缀与 <filename>/home/</filename> 匹配的所有规则都将允许访问 <filename>/usr/home/</filename>。例如，
   </para>
<screen>/home/username/** r,</screen>
   <para>
    也允许访问
   </para>
<screen>/usr/home/username/** r,</screen>
   <para>
    利用别名，您无需重新编写规则即可快速重新映射它们。它们可确保源路径仍可供访问 — 在本示例中，别名规则确保 <filename>/home/</filename> 下的路径仍可供访问。
   </para>
   <para>
    使用<literal>别名</literal>规则可以同时指向多个目标。
   </para>
<screen>alias /home/ -&gt; /usr/home/
alias /home/ -&gt; /mnt/home/</screen>
   <note>
    <para>
     在当前的 <phrase>AppArmor</phrase> 工具中，只能在手动编辑和维护配置文件时使用别名规则。
    </para>
   </note>
   <tip>
    <para>
     请在文件 <filename>/etc/apparmor.d/tunables/alias</filename> 中插入全局别名定义。
    </para>
   </tip>
  </sect2>
 </sect1>
 <sect1 role="General" xml:id="sec-apparmor-profiles-perm">
  <title>文件权限访问模式</title>

  <para>
   文件权限访问模式包括以下模式的组合：
  </para>

  <informaltable>
   <tgroup cols="2">
    <tbody>
     <row>
      <entry>
       <para>
        <literal>r</literal>
       </para>
      </entry>
      <entry>
       <para>
        读取模式
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <literal>w</literal>
       </para>
      </entry>
      <entry>
       <para>
        写入模式（与 <literal>a</literal> 互斥）
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <literal>a</literal>
       </para>
      </entry>
      <entry>
       <para>
        追加模式（与 <literal>w</literal> 互斥）
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <literal>k</literal>
       </para>
      </entry>
      <entry>
       <para>
        文件锁定模式
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <literal>l</literal>
       </para>
      </entry>
      <entry>
       <para>
        链接模式
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <literal>link <replaceable>FILE</replaceable> -&gt; <replaceable>TARGET</replaceable></literal>
       </para>
      </entry>
      <entry>
       <para>
        链接对规则（不能与其他访问模式结合使用）
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>

  <sect2 xml:id="sec-apparmor-profiles-perm-r">
   <title>读取模式 (r)</title>
   <para>
    允许程序拥有读取资源的权限。必需对外壳脚本和其他解释内容授予读取访问权限，该权限确定正在执行的进程是否可以进行核心转储。
   </para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-perm-w">
   <title>写入模式 (w)</title>
   <para>
    允许程序拥有写入资源的权限。将被取消链接（删除）的文件必须拥有此权限。
   </para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-perm-a">
   <title>追加模式 (a)</title>
   <para>
    允许程序写入到文件的末尾。与 <literal>w</literal> 模式相反，追加模式不包含重写数据、重命名或去除文件的功能。追加权限通常用于需要能够写入日志文件，但不应该能够操作日志文件中任何现有数据的应用程序。由于追加权限是与写入模式关联的权限的子集，<literal>w</literal> 和 <literal>a</literal> 权限标志不能结合使用，它们是互斥的。
   </para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-perm-k">
   <title>文件锁定模式 (k)</title>
   <para>
    应用程序可以采用文件锁。在以前的 <phrase>AppArmor</phrase> 版本中，如果应用程序有权访问文件，AppArmor 便允许锁定文件。通过使用独立的文件锁定模式，<phrase>AppArmor</phrase> 可确保仅对需要锁定的文件进行锁定，如此可增强安全性，因为在多种拒绝-服务攻击场景中都可以使用锁定。
   </para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-perm-link">
   <title>链接模式 (l)</title>
   <para>
    链接模式调解对硬链接的访问。创建链接后，目标文件的访问权限必须与所创建的链接相同（但目标不需要链接访问权限）。
   </para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-perm-link-pair">
   <title>链接对</title>
   <para>
    链接模式授予链接到任意文件的权限，前提是该链接具有目标所授予的权限的子集（子集权限测试）。
   </para>
<screen>/srv/www/htdocs/index.html rl,</screen>
   <para>
    通过指定源和目标，链接对规则可让您更好地控制创建硬链接的方式。默认情况下，链接对规则不会强制执行链接子集权限测试，而标准规则链接权限则需要进行此测试。
   </para>
<screen>link /srv/www/htdocs/index.html -&gt; /var/www/index.html</screen>
   <para>
    要强制让规则要求进行该测试，可使用 <literal>subset</literal> 关键字。以下规则是等效的：
   </para>
<screen>/var/www/index.html l,
link subset /var/www/index.html -&gt; /**,</screen>
   <note>
    <para>
     YaST 和命令行工具目前不支持链接对规则。要使用这些规则，请手动编辑配置文件。使用工具更新此类配置文件是安全的操作，因为这种方式不会改动链接对项。
    </para>
   </note>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-perm-file-allow">
   <title>可选的<literal>允许</literal>规则和<literal>文件</literal>规则</title>
   <para>
    <literal>allow</literal> 前缀是可选的，如果未指定并且不使用 <literal>deny</literal>（参见<xref linkend="sec-apparmor-profiles-perm-deny"/>）关键字，则按惯常隐式应用该前缀。
   </para>
<screen>
allow file /example r,
allow /example r,
allow network,
</screen>
   <para>
    您还可以使用可选的 <literal>file</literal> 关键字。如果您省略该关键字并且不存在其他以某个关键字（例如 <literal>network</literal> 或 <literal>mount</literal>）开头的规则类型，则自动隐式应用该前缀。
   </para>
<screen>file /example/rule r,</screen>
   <para>
    等效于
   </para>
<screen>/example/rule r,</screen>
   <para>
    下面的规则授予对所有文件的访问权限：
   </para>
<screen>file,</screen>
   <para>
    等效于
   </para>
<screen>/** rwmlk,</screen>
   <para>
    文件规则可以使用前导或尾随权限。不应将权限指定为尾随权限，而应在规则的开头使用。这一点非常重要，因为这样可使文件规则的行为类似于任何其他规则类型。
   </para>
<screen>
/path rw,            # old style
rw /path,            # leading permission
file rw /path,       # with explicit 'file' keyword
allow file rw /path, # optional 'allow' keyword added
</screen>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-perm-owner">
   <title>拥有者条件规则</title>
   <para>
    可以扩展文件规则，使其可以按条件应用于文件的拥有者用户（fsuid 需与文件的 uid 相匹配）。要实现此目的，需在规则的前面添加 <literal>owner</literal> 关键字。拥有者条件规则像普通的文件规则一样不断累积。
   </para>
<screen>owner /home/*/** rw</screen>
   <para>
    将文件所有权条件与链接规则结合使用时，将针对目标文件执行所有权测试，因此，用户必须拥有该文件才能链接到该文件。
   </para>
   <note>
    <title>普通文件规则的优先级</title>
    <para>
     拥有者条件规则被视为普通文件规则的子集。如果某个普通文件规则与某个拥有者条件文件规则重叠，这两条规则将会合并。参见以下示例。
    </para>
<screen>/foo r,
owner /foo rw,  # or w,</screen>
    <para>
     这些规则会合并 — 结果是每个人均具有 <literal>r</literal> 权限，只有拥有者具有 <literal>w</literal> 权限。
    </para>
   </note>
   <tip>
    <para>
     要指定<emphasis>除</emphasis>文件拥有者以外的每个人，请使用关键字 <literal>other</literal>。
    </para>
<screen>owner /foo rw,
other /foo r,</screen>
   </tip>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-perm-deny">
   <title>拒绝规则</title>
   <para>
    拒绝规则可用于批注已知拒绝或使其静止。配置文件生成工具不会询问有关拒绝规则所处理的已知拒绝的信息。发生拒绝后，此类拒绝也不会显示在审计日志中，以使日志文件保持精简。如果不需要此行为，请在拒绝项的前面添加关键字 <literal>audit</literal>。
   </para>
   <para>
    此外，还可以将拒绝规则与允许规则结合使用。这样，您便可以先指定一条宽泛的允许规则，然后再去掉几个不应允许的已知文件。拒绝规则还可与拥有者规则结合使用来拒绝用户拥有的文件。下面的示例允许对 users 目录中的任何内容进行读写访问，但不允许对 <filename>.ssh/</filename> 文件进行写入访问：
   </para>
<screen>deny /home/*/.ssh/** w,
owner /home/*/** rw,</screen>
   <para>
    一般不建议大量使用拒绝规则，因为这会大大增加理解配置文件的作用的难度。不过，审慎使用拒绝规则可以简化配置文件。因此，工具只会生成拒绝特定文件的配置文件，而不会在拒绝规则中使用通配。要添加使用通配的拒绝规则，请手动编辑配置文件。使用工具更新此类配置文件是安全的操作，因为这种方式不会改动拒绝项。
   </para>
  </sect2>
 </sect1>

 <sect1 xml:id="sec-apparmor-profiles-mount">
  <title>挂载规则</title>
  <para>
   <phrase>AppArmor</phrase> 可以限制挂载和卸载操作，包括文件系统类型和挂载标志。规则语法基于 <command>mount</command> 命令语法，以 <literal>mount</literal>、<literal>remount</literal> 或 <literal>umount</literal> 关键字开头。条件是可选项，如果不指定条件，则认为要匹配所有项。例如，不指定文件系统表示要匹配所有文件系统。
  </para>
  <para>
   可以使用 <literal>options=</literal> 或 <literal>options in</literal> 指定条件。
  </para>
  <para>
    <literal>options=</literal> 指定必须完全符合的条件。规则
  </para>
  <screen>mount options=ro /dev/foo -E /mnt/,</screen>
  <para>
    匹配
  </para>
  <screen><prompt role="root"># </prompt><command>mount -o ro /dev/foo /mnt</command></screen>
  <para>
    但不匹配
  </para>
<screen><prompt role="root"># </prompt><command>mount -o ro,atime /dev/foo /mnt</command>
<prompt role="root"># </prompt><command>mount -o rw /dev/foo /mnt</command></screen>
  <para>
   <literal>options in</literal> 要求至少使用一个所列的挂载选项。规则
  </para>
  <screen>mount options in (ro,atime) /dev/foo -&gt; /mnt/,</screen>
  <para>
   匹配
  </para>
  <screen><prompt role="root"># </prompt><command>mount -o ro /dev/foo /mnt</command>
<prompt role="root"># </prompt><command>mount -o ro,atime /dev/foo /mnt</command>
<prompt role="root"># </prompt><command>mount -o atime /dev/foo /mnt</command></screen>
  <para>
   但不匹配
  </para>
<screen><prompt role="root"># </prompt><command>mount -o ro,sync /dev/foo /mnt</command>
<prompt role="root"># </prompt><command>mount -o ro,atime,sync /dev/foo /mnt</command>
<prompt role="root"># </prompt><command>mount -o rw /dev/foo /mnt</command>
<prompt role="root"># </prompt><command>mount -o rw,noatime /dev/foo /mnt</command>
<prompt role="root"># </prompt><command>mount /dev/foo /mnt</command></screen>
  <para>
   如果使用多个条件，规则将为每组选项授予权限。规则
  </para>
  <screen>mount options=ro options=atime</screen>
  <para>
   匹配
  </para>
<screen><prompt role="root"># </prompt><command>mount -o ro /dev/foo /mnt</command>
<prompt role="root"># </prompt><command>mount -o atime /dev/foo /mnt</command></screen>
  <para>
   但不匹配
  </para>
  <screen><prompt role="root"># </prompt><command>mount -o ro,atime /dev/foo /mnt</command></screen>
  <para>
   单独的挂载规则是不同的，选项不会累积。规则
  </para>
<screen>mount options=ro,
mount options=atime,</screen>
  <para>
   与下列规则不等效
  </para>
<screen>mount options=(ro,atime),
mount options in (ro,atime),</screen>
  <para>
   下面的规则允许在 <filename>/mnt/</filename> 上挂载只读的 <filename>/dev/foo</filename> 并使用 inode 访问时间，或者允许使用“nodev”和“user”的某种组合在 <filename>/mnt/</filename> 上挂载 <filename>/dev/foo</filename>。
  </para>
  <screen>mount options=(ro, atime) options in (nodev, user) /dev/foo -&gt; /mnt/,</screen>
  <para>
   允许
  </para>
<screen><prompt role="root"># </prompt><command>mount -o ro,atime /dev/foo /mnt</command>
<prompt role="root"># </prompt><command>mount -o nodev /dev/foo /mnt</command>
<prompt role="root"># </prompt><command>mount -o user /dev/foo /mnt</command>
<prompt role="root"># </prompt><command>mount -o nodev,user /dev/foo /mnt</command></screen>
 </sect1>

 <sect1 xml:id="sec-apparmor-profiles-pivot-root">
  <title>Pivot Root 规则</title>
  <para>
   <phrase>AppArmor</phrase> 可以限制对根文件系统的更改。语法为
  </para>
  <screen>pivot_root [oldroot=<replaceable>OLD_ROOT</replaceable>] <replaceable>NEW_ROOT</replaceable></screen>
  <para>
   在“pivot_root”规则中指定的路径必须以“/”结尾，因为它们是目录。
  </para>
  <screen># Allow any pivot
pivot_root,

# Allow pivoting to any new root directory and putting the old root
# directory at /mnt/root/old/
pivot_root oldroot=/mnt/root/old/,

# Allow pivoting the root directory to /mnt/root/
pivot_root /mnt/root/,

# Allow pivoting to /mnt/root/ and putting the old root directory at
# /mnt/root/old/
pivot_root oldroot=/mnt/root/old/ /mnt/root/,

# Allow pivoting to /mnt/root/, putting the old root directory at
# /mnt/root/old/ and transition to the /mnt/root/sbin/init profile
pivot_root oldroot=/mnt/root/old/ /mnt/root/ -&gt; /mnt/root/sbin/init,</screen>
 </sect1>

 <sect1 xml:id="sec-apparmor-profiles-ptrace">
  <title>PTrace 规则</title>
  <para>
   <phrase>AppArmor</phrase> 支持限制 ptrace 系统调用。ptrace 规则将会累积，因此，授予的 ptrace 权限是全部所列 ptrace 规则权限的并集。如果某条规则未指定访问列表，则会隐式授予权限。
  </para>
  <para>
   <literal>trace</literal> 和 <literal>tracedby</literal> 权限控制 ptrace(2)；<literal>read</literal> 和 <literal>readby</literal> 控制 proc(5) 文件系统访问、kcmp(2)、futexes (get_robust_list(2)) 和 perf 跟踪事件。
  </para>
  <para>
   要允许 ptrace 操作，跟踪进程和被跟踪进程都需要有正确的权限。也就是说，跟踪进程需要有 <literal>trace</literal> 权限，被跟踪进程需要有 <literal>tracedby</literal> 权限。
  </para>
  <para>
   示例 AppArmor PTrace 规则：
  </para>
<screen># Allow all PTrace access
ptrace,

# Explicitly allow all PTrace access,
ptrace (read, readby, trace, tracedby),

# Explicitly deny use of ptrace(2)
deny ptrace (trace),

# Allow unconfined processes (eg, a debugger) to ptrace us
ptrace (readby, tracedby) peer=unconfined,

# Allow ptrace of a process running under the /usr/bin/foo profile
ptrace (trace) peer=/usr/bin/foo,</screen>
 </sect1>

 <sect1 xml:id="sec-apparmor-profiles-signal">
  <title>信号规则</title>
  <para>
   <phrase>AppArmor</phrase> 支持限制进程间的信号。AppArmor 信号规则会累积，因此，授予的信号权限是全部所列信号规则权限的并集。如果规则未显式指明访问列表，则隐式应用 <phrase>AppArmor</phrase> 信号权限。
  </para>
  <para>
   发送方进程和接收方进程都必须拥有正确的权限。
  </para>
  <para>
   示例信号规则：
  </para>
<screen># Allow all signal access
signal,

# Explicitly deny sending the HUP and INT signals
deny signal (send) set=(hup, int),

# Allow unconfined processes to send us signals
signal (receive) peer=unconfined,

# Allow sending of signals to a process running under the /usr/bin/foo
# profile
signal (send) peer=/usr/bin/foo,

# Allow checking for PID existence
signal (receive, send) set=("exists"),

# Allow us to signal ourselves using the built-in @{profile_name} variable
signal peer=@{profile_name},

# Allow two real-time signals
signal set=(rtmin+0 rtmin+32),</screen>
 </sect1>

 <sect1 xml:id="sec-apparmor-profiles-exec">
  <title>执行模式</title>

  <para>
   执行模式（也称为配置文件转换）包括以下模式：
  </para>

  <informaltable>
   <tgroup cols="2">
    <tbody>
     <row>
      <entry>
       <para>
        <literal>Px</literal>
       </para>
      </entry>
      <entry>
       <para>
        离散配置文件执行模式
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <literal>Cx</literal>
       </para>
      </entry>
      <entry>
       <para>
        离散本地配置文件执行模式
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <literal>Ux</literal>
       </para>
      </entry>
      <entry>
       <para>
        未受限执行模式
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <literal>ix</literal>
       </para>
      </entry>
      <entry>
       <para>
        继承执行模式
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <literal>m</literal>
       </para>
      </entry>
      <entry>
       <para>
        允许使用 <command>mmap(2)</command> 调用执行 <literal>PROT_EXEC</literal>
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>

  <sect2 xml:id="sec-apparmor-profiles-exec-px">
   <title>离散配置文件执行模式 (px)</title>
   <para>
    此模式要求为在 <phrase>AppArmor</phrase> 域转换时执行的资源定义一个离散安全配置文件。如果未定义配置文件，则会拒绝访问。
   </para>
   <para>
    与 <literal>Ux</literal>、<literal>ux</literal>、<literal>px</literal> 和 <literal>ix</literal> 不兼容。
   </para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-exec-cx">
   <title>离散本地配置文件执行模式 (cx)</title>
   <para>
    类似于 <literal>Px</literal>，但 <literal>Cx</literal> 不搜索全局配置文件集，而只搜索当前配置文件的本地配置文件。应用程序可以通过这种配置文件转换获得助手应用程序的备用配置文件。
   </para>
   <note>
    <title>离散本地配置文件执行模式 (cx) 的限制</title>
    <para>
     目前，Cx 转换仅对顶层配置文件适用，不能在帽子和子配置文件中使用。将来会去除这项限制。
    </para>
   </note>
   <para>
    与 <literal>Ux</literal>、<literal>ux</literal>、<literal>Px</literal>、<literal>px</literal>、<literal>cx</literal> 和 <literal>ix</literal> 不兼容。
   </para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-exec-ux">
   <title>未受限执行模式 (ux)</title>
   <para>
    允许程序执行资源，不对被执行的资源应用任何 <phrase>AppArmor</phrase> 配置文件。此模式可用于使被限制的程序能够执行需要特权的操作，如重新引导计算机等。通过在其他可执行文件中添加具有特权的部分并授予未受限的执行权限，您可以避开对全部受限制进程强制施加的限制。允许根进程不受限制意味着它可以更改 <phrase>AppArmor</phrase> 策略本身。有关限制内容的详细信息，请参见 <systemitem>apparmor(7)</systemitem> 手册页。
   </para>
   <para>
    此模式与 <literal>ux</literal>、<literal>px</literal>、<literal>Px</literal> 和 <literal>ix</literal> 不兼容。
   </para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-exec-clean">
   <title>不安全的执行模式</title>
   <para>
    仅在非常特殊的情况下才使用小写形式的执行模式 — <literal>px</literal>、<literal>cx</literal>、<literal>ux</literal>。这些模式不会整理 <envar>LD_PRELOAD</envar> 等变量的环境。因此，调用域可能会对被调用资源产生过度影响。仅当绝对<emphasis>必须</emphasis>以非受限方式运行子项并且必须使用 <envar>LD_PRELOAD</envar> 时，才使用这些模式。任何使用此类模式的配置文件几乎都不会提供任何安全性。使用这些模式需自负后果。
   </para>
   <remark>jsegitz 2014-07-15: if the child absolutely needs to use the environment of the calling process. (running unconfined isn't the important part here,
   you can you px and not run unconfined)</remark>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-exec-ix">
   <title>继承执行模式 (ix)</title>
   <para>
    当构建了配置文件的程序执行命名程序时，<literal>ix</literal> 会阻止 <command>execve(2)</command> 上的常规 <phrase>AppArmor</phrase> 域转换。相反，被执行的资源继承当前配置文件。
   </para>
   <para>
    当被限制的程序需要调用其它被限制的程序时此模式非常实用，无须获得目标程序配置文件的权限或失去当前配置文件的权限。没有任何版本会整理环境，因为 <literal>ix</literal> 执行不会更改特权。
   </para>
   <para>
    与 <literal>cx</literal>、<literal>ux</literal> 和 <literal>px</literal> 不兼容。隐式应用 <literal>m</literal>。
   </para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-exec-m">
   <title>允许可执行映射 (m)</title>
   <para>
    此模式允许使用 <command>mmap(2)</command> 的 <envar>PROT_EXEC</envar> 标志将文件映射到内存中。此标志将页面标示为可执行。某些体系结构使用此标志来提供不可执行的数据页面，这可以增加恶意利用的企图的困难度。<phrase>AppArmor</phrase> 使用此模式来限制可由行为正常的程序（或者强制实施不可执行内存访问控制的体系结构上的所有程序）用作库的文件，以及限制为 <command>ld(1)</command> 指定的无效 <option>-L</option> 标志以及为 <command>ld.so(8)</command> 指定的 <envar>LD_PRELOAD</envar> 和 <envar>LD_LIBRARY_PATH</envar> 所产生的影响。
   </para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-exec-named">
   <title>命名配置文件转换</title>
   <para>
    默认情况下，<literal>px</literal> 和 <literal>cx</literal>（也包括其清洁执行变体）将转换到名称与可执行文件名称匹配的配置文件。使用命名配置文件转换，您可以指定要转换到的配置文件。如果多个二进制文件需要共享单个配置文件，或者这些二进制文件需要使用的配置文件不同于其名称指定的配置文件，此方法将非常有用。可以将命名配置文件转换与 <literal>cx</literal>、<literal>Cx</literal>、<literal>px</literal> 和 <literal>Px</literal> 结合使用。目前，每个配置文件仅可具有 12 个命名配置文件转换。
   </para>
   <para>
    命名配置文件转换使用 <literal>-&gt;</literal> 来指示需要转换到的配置文件的名称：
   </para>
<screen>/usr/bin/foo
{
  /bin/** px -&gt; shared_profile,
  ...
  /usr/*bash cx -&gt; local_profile,
  ...
  profile local_profile
  {
    ...
  }
}
</screen>
   <note>
    <title>常规转换与命名转换之间的差别</title>
    <para>
     与通配结合使用时，常规转换提供<quote>一对多</quote>关系 — <literal>/bin/** px</literal> 将转换到 <filename>/bin/ping</filename>、<filename>/bin/cat</filename> 等，具体取决于所运行的程序。
    </para>
    <para>
     命名转换提供<quote>多对一</quote>关系 — 所有程序不管其名称是什么，只要与规则匹配，都将转换到指定的配置文件。
    </para>
    <para>
     命名配置文件转换具有模式 <literal>Nx</literal>，因此会显示在日志中。要转换到的配置文件的名称列于 <literal>name2</literal> 字段中。
    </para>
   </note>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-exec-fallback">
   <title>配置文件转换的回退模式</title>
   <para>
    <literal>px</literal> 和 <literal>cx</literal> 转换会指定硬依赖项 — 如果指定的配置文件不存在，则执行将会失败。使用继承回退时，执行将会成功，但会继承当前配置文件。要指定继承回退，请将 <literal>ix</literal> 与 <literal>cx</literal>、<literal>Cx</literal>、<literal>px</literal> 和 <literal>Px</literal> 结合使用，构成模式 <literal>cix</literal>、<literal>Cix</literal>、<literal>pix</literal> 和 <literal>Pix</literal>。
   </para>
<screen>/path Cix -&gt; profile_name,</screen>
   <para>
    或
   </para>
<screen>Cix /path -&gt; profile_name,</screen>
   <para>
    其中 <literal>-&gt; profile_name</literal> 是可选项。
   </para>
   <para>
    如果您添加未受限 <literal>ux</literal> 模式（这样最终模式为 <literal>cux</literal>、<literal>CUx</literal>、<literal>pux</literal> 和 <literal>PUx</literal>），上面所述同样适用。如果未找到指定的配置文件，这些模式允许回退到<quote>未受限</quote>。
   </para>
<screen>/path PUx -&gt; profile_name,</screen>
   <para>
    或
   </para>
<screen>PUx /path -&gt; profile_name,</screen>
   <para>
    其中 <literal>-&gt; profile_name</literal> 是可选项。
   </para>
   <para>
    您也可以对命名配置文件转换使用回退模式。
   </para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-exec-variables">
   <title>执行模式中的变量设置</title>
   <para>
    选择 Px、Cx 或 Ux 执行模式之一时，请注意在子进程继承这些模式之前，以下环境变量会从环境中去除。因此，如果向依赖于以下任何变量的应用程序或进程应用的配置文件带有 Px、Cx 或 Ux 标志，这些应用程序或进程将不再可正常运行：
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>
      <envar>GCONV_PATH</envar>
     </para>
    </listitem>
    <listitem>
     <para>
      <envar>GETCONF_DIR</envar>
     </para>
    </listitem>
    <listitem>
     <para>
      <envar>HOSTALIASES</envar>
     </para>
    </listitem>
    <listitem>
     <para>
      <envar>LD_AUDIT</envar>
     </para>
    </listitem>
    <listitem>
     <para>
      <envar>LD_DEBUG</envar>
     </para>
    </listitem>
    <listitem>
     <para>
      <envar>LD_DEBUG_OUTPUT</envar>
     </para>
    </listitem>
    <listitem>
     <para>
      <envar>LD_DYNAMIC_WEAK</envar>
     </para>
    </listitem>
    <listitem>
     <para>
      <envar>LD_LIBRARY_PATH</envar>
     </para>
    </listitem>
    <listitem>
     <para>
      <envar>LD_ORIGIN_PATH</envar>
     </para>
    </listitem>
    <listitem>
     <para>
      <envar>LD_PRELOAD</envar>
     </para>
    </listitem>
    <listitem>
     <para>
      <envar>LD_PROFILE</envar>
     </para>
    </listitem>
    <listitem>
     <para>
      <envar>LD_SHOW_AUXV</envar>
     </para>
    </listitem>
    <listitem>
     <para>
      <envar>LD_USE_LOAD_BIAS</envar>
     </para>
    </listitem>
    <listitem>
     <para>
      <envar>LOCALDOMAIN</envar>
     </para>
    </listitem>
    <listitem>
     <para>
      <envar>LOCPATH</envar>
     </para>
    </listitem>
    <listitem>
     <para>
      <envar>MALLOC_TRACE</envar>
     </para>
    </listitem>
    <listitem>
     <para>
      <envar>NLSPATH</envar>
     </para>
    </listitem>
    <listitem>
     <para>
      <envar>RESOLV_HOST_CONF</envar>
     </para>
    </listitem>
    <listitem>
     <para>
      <envar>RES_OPTIONS</envar>
     </para>
    </listitem>
    <listitem>
     <para>
      <envar>TMPDIR</envar>
     </para>
    </listitem>
    <listitem>
     <para>
      <envar>TZDIR</envar>
     </para>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-exec-clean-keywords">
   <title><literal>safe</literal> 和 <literal>unsafe</literal> 关键字</title>
   <para>
    您可以对规则使用 <literal>safe</literal> 和 <literal>unsafe</literal> 关键字来取代执行模式的大小写修饰符。例如，
   </para>
<screen>/example_rule Px,</screen>
   <para>
    等同于下列任何一项
   </para>
<screen>safe /example_rule px,
safe /example_rule Px,
safe px /example_rule,
safe Px /example_rule,</screen>
   <para>
    规则
   </para>
<screen>/example_rule px,</screen>
   <para>
    等同于下列任何一项
   </para>
<screen>unsafe /example_rule px,
unsafe /example_rule Px,
unsafe px /example_rule,
unsafe Px /example_rule,</screen>
   <para>
    <literal>safe</literal>/<literal>unsafe</literal> 关键字是互斥的，可在文件规则中的 <literal>owner</literal> 关键字后面使用，因此，规则关键字的顺序如下
   </para>
<screen>[audit] [deny] [owner] [safe|unsafe] file_rule</screen>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-apparmor-profiles-rlimit">
  <title>资源限制控制</title>

  <para>
   <phrase>AppArmor</phrase> 可以设置和控制应用程序的资源限制（rlimit，也称为 ulimit）。默认情况下，<phrase>AppArmor</phrase> 不会控制应用程序的 rlimit，而只控制限制配置文件中指定的这些限制。有关资源限制的详细信息，请参见 <systemitem>setrlimit(2)</systemitem>、<systemitem>ulimit(1)</systemitem> 或 <systemitem>ulimit(3)</systemitem> 手册页。
  </para>

  <para>
   <phrase>AppArmor</phrase> 会利用系统的 rlimit，因此不会另外提供审计（正常情况下会发生审计）。此外，它不能提高系统设置的 rlimit，<phrase>AppArmor</phrase> rlimit 只能降低应用程序的当前资源限制。
  </para>

  <para>
   进程的子项会继承这些值，即使转换到了新配置文件或者应用程序变得不受限制，这些值也会保留。因此，当应用程序转换到新配置文件时，该配置文件可以进一步降低应用程序的 rlimit。
  </para>

  <para>
   <phrase>AppArmor</phrase> 的 rlimit 规则还可以调解应用程序硬限制的设置（如果应用程序尝试提高这些限制）。应用程序不能将硬限制提高到超过配置文件中所指定的限制的水平。提高的硬限制不会像设置的值那样会被继承，因此，当应用程序转换到新配置文件时，它可以任意提高其限制（只要不超过配置文件中指定的值）。
  </para>

  <para>
   <phrase>AppArmor</phrase> 的 rlimit 控制除了会确保应用程序的软限制小于或等于应用程序的硬限制外，不会在其他方面影响软限制。
  </para>

  <para>
   <phrase>AppArmor</phrase> 硬限制规则一般采用如下格式：
  </para>

<screen>set rlimit <replaceable>RESOURCE</replaceable> &lt;= <replaceable>value</replaceable>,</screen>

  <para>
   其中 <replaceable>RESOURCE</replaceable> 和 <replaceable>VALUE</replaceable> 将替换为以下值：
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>cpu</literal>
    </term>
    <listitem>
     <para>
      CPU 时间限制，以秒为单位。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>fsize</literal>、<literal>data</literal>、<literal>stack</literal>、<literal>core</literal>、<literal>rss</literal>、<literal>as</literal>、<literal>memlock</literal>、<literal>msgqueue</literal>
    </term>
    <listitem>
     <para>
      以字节为单位的数字，或者带后缀的数字，例如，该后缀可以是 K/KB（千字节）、M/MB（兆字节）、G/GB（千兆字节）
     </para>
<screen>rlimit data &lt;= 100M,</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>fsize</literal>、<literal>nofile</literal>、<literal>locks</literal>、<literal>sigpending</literal>、<literal>nproc</literal><superscript>*</superscript>、<literal>rtprio</literal>
    </term>
    <listitem>
     <para>
      大于或等于 0 的数字
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>nice</literal>
    </term>
    <listitem>
     <para>
      -20 到 19 的值
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   <superscript>*</superscript>nproc rlimit 的处理方式不同于所有其他 rlimit。它不指示标准进程 rlimit，而是控制在任意时间可基于配置文件运行的最大进程数。如果超过限制，基于配置文件创建新进程将会失败，直到当前正在运行的进程数减少。
  </para>

  <note>
   <para>
    目前无法使用工具将 rlimit 规则添加到配置文件中。可将 rlimit 控制添加到配置文件的唯一方法是使用文本编辑器手动编辑配置文件。工具仍会处理包含 rlimit 规则的配置文件，并且不会去除这些规则，因此，使用工具更新包含这些规则的配置文件是安全的操作。
   </para>
  </note>
 </sect1>
 <sect1 xml:id="sec-apparmor-profiles-audit">
  <title>审计规则</title>

  <para>
   <phrase>AppArmor</phrase> 提供用于审计给定规则的功能，如此，当匹配这些规则时，审计日志中会显示审计消息。要对给定的规则启用审计消息，可在规则的前面添加 <literal>audit</literal> 关键字：
  </para>

<screen>audit /etc/foo/*        rw,</screen>

  <para>
   如果只希望审计给定的权限，可将该规则分割为两条规则。在下面的示例中，打开文件向其写入数据时会生成审计消息，但打开文件读取数据时，则不会生成消息：
  </para>

<screen>audit /etc/foo/*  w,
/etc/foo/*        r,</screen>

  <note>
   <para>
    并非每次对文件执行读取或写入操作时都会生成审计消息，只有在打开文件进行读取或写入操作时才生成消息。
   </para>
  </note>

  <para>
   可将审计控制与 <literal>owner</literal>/<literal>other</literal> 条件文件规则结合使用，以便在用户访问他们拥有/不拥有的文件时提供审计：
  </para>

<screen>audit owner /home/*/.ssh/**       rw,
audit other /home/*/.ssh/**       r,</screen>
 </sect1>
</chapter>
