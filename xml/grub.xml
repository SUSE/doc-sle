<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//Novell//DTD NovDoc XML V1.0//EN" "novdocx.dtd"
[
  <!ENTITY % NOVDOC.DEACTIVATE.IDREF "INCLUDE">
  <!ENTITY % entities SYSTEM "entity-decl.ent">
  %entities;
]>
<chapter id="cha.grub">
 <title>The Boot Loader &grub;</title><indexterm>
 <primary>booting</primary>
 <secondary>&grub;</secondary></indexterm><indexterm>
 <primary>&grub;</primary></indexterm>
 <abstract>
  <para>
   This chapter describes how to configure &grub; (Grand Unified
   Bootloader), the boot loader used in &productnamereg;. A special &yast;
   module is available for configuring all settings. If you are not familiar
   with the subject of booting in Linux, read the following sections to
   acquire some background information. This chapter also describes some of
   the problems frequently encountered when booting with &grub; and their
   solutions.
  </para>
 </abstract>
 <note os="sles;sled">
  <title>No &grub; on machines using UEFI</title>
  <para>
   &grub; will routinely be installed on machines equipped with a
   traditional BIOS and on UEFI (Unified Extensible Firmware Interface)
   machines using a Compatibility Support Module (CSM). On UEFI machines
   without enabled CSM, <systemitem>eLILO</systemitem> will automatically be
   installed (provided DVD1 booted successfully). Refer to the eLILO
   documentation at <filename>/usr/share/doc/packages/elilo/</filename> on
   your system for details.
  </para>
 </note>
 <para>
  This chapter focuses on boot management and the configuration of the boot
  loader &grub;. The boot procedure as a whole is outlined in
  <xref linkend="cha.boot"/>. A boot loader represents the interface between
  the machine (BIOS) and the operating system (&productname;). The
  configuration of the boot loader directly impacts the start of the
  operating system.
 </para>
 <para>
  The following terms appear frequently in this chapter and might need some
  explanation:
 </para>
 <variablelist>
  <varlistentry>
   <term>MBR (Master Boot Record)</term>
   <listitem><indexterm>
    <primary>booting</primary>
    <secondary>boot sectors</secondary></indexterm><indexterm>
    <primary>MBR</primary></indexterm><indexterm>
    <primary>Master Boot Record</primary>
    <see>MBR</see></indexterm><indexterm>
    <primary>partitions</primary>
    <secondary>partition table</secondary></indexterm><indexterm>
    <primary>&grub;</primary>
    <secondary>Master Boot Record (MBR)</secondary></indexterm>
    <remark>mdejmek: 081002:wondering what the plural form of BIOS is; found both BIOSs and BIOSes; due to consistency changed it to BIOSes but will keep 
     looking for reliable sources</remark>
    <para>
     The structure of the MBR is defined by an operating
     system&ndash;independent convention. The first 446&nbsp;bytes are
     reserved for the program code. They typically hold part of a boot
     loader program or an operating system selector. The next 64&nbsp;bytes
     provide space for a partition table of up to four entries. The
     partition table contains information about the partitioning of the hard
     disk and the file system types. The operating system needs this table
     for handling the hard disk. With conventional generic code in the MBR,
     exactly one partition must be marked <emphasis>active</emphasis>. The
     last two bytes of the MBR must contain a static <quote>magic
     number</quote> (<literal>AA55</literal>). An MBR containing a different
     value is regarded as invalid by some BIOSes, so is not considered for
     booting.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>Boot Sectors</term>
   <listitem><indexterm>
    <primary>booting</primary>
    <secondary>boot sectors</secondary></indexterm><indexterm>
    <primary>MBR</primary></indexterm><indexterm>
    <primary>&grub;</primary>
    <secondary>boot sectors</secondary></indexterm>
    <para>
     Boot sectors are the first sectors of hard disk partitions with the
     exception of the extended partition, which merely serves as a
     <quote>container</quote> for other partitions. These boot sectors have
     512&nbsp;bytes of space for code used to boot an operating system
     installed in the respective partition. This applies to boot sectors of
     formatted DOS, Windows, and OS/2 partitions, which also contain some
     basic important data of the file system. In contrast, the boot sectors
     of Linux partitions are initially empty after setting up a file system
     other than XFS. Therefore, a Linux partition is not bootable by itself,
     even if it contains a kernel and a valid root file system. A boot
     sector with valid code for booting the system has the same magic number
     as the MBR in its last two bytes (<literal>AA55</literal>).
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
 <sect1 id="sec.grub.basic">
  <title>Booting with &grub;</title><indexterm>

  <primary>&grub;</primary>

  <secondary>booting</secondary></indexterm><indexterm>

  <primary>installing</primary>

  <secondary>&grub;</secondary></indexterm><indexterm>

  <primary>booting</primary>

  <secondary>&grub;</secondary></indexterm><indexterm>

  <primary>configuring</primary>

  <secondary>&grub;</secondary></indexterm><indexterm>

  <primary>commands</primary>

  <secondary>grub</secondary></indexterm><indexterm>

  <primary>&grub;</primary>

  <secondary>commands</secondary></indexterm>

  <para>
   &grub; comprises two stages. Stage 1 consists of 512&nbsp;bytes and its
   only task is to load the second stage of the boot loader. Subsequently,
   stage 2 is loaded. This stage contains the main part of the boot loader.
  </para>

  <para>
   In some configurations, an intermediate stage 1.5 can be used, which
   locates and loads stage 2 from an appropriate file system. If possible,
   this method is chosen by default on installation or when initially
   setting up &grub; with &yast;.
  </para>

  <para>
   Stage 2 is able to access many file systems. Currently, ext2, ext3,
   ReiserFS, Minix, and the DOS FAT file system used by Windows are
   supported. To a certain extent, XFS, and UFS and FFS used by BSD systems
   are also supported. Since version 0.95 &grub; is also able to boot from a
   CD or DVD containing an ISO 9660 standard file system pursuant to the
   <quote>El Torito</quote> specification. Even before the system is booted,
   &grub; can access file systems of supported BIOS disk devices (floppy
   disks or hard disks, CD drives and DVD drives detected by the BIOS).
   Therefore, changes to the &grub; configuration file
   (<filename>menu.lst</filename>) do not require a new installation of the
   boot manager. When the system is booted, &grub; reloads the menu file
   with the valid paths and partition data of the kernel or the initial RAM
   disk (<literal>initrd</literal>) and locates these files.
  </para>

  <para>
   The actual configuration of &grub; is based on four files that are
   described below:
  </para>

  <variablelist>
   <varlistentry>
    <term><filename>/boot/grub/menu.lst</filename>
    </term>
    <listitem><indexterm>
     <primary>&grub;</primary>
     <secondary>menu.lst</secondary></indexterm>
     <para>
      This file contains all information about partitions or operating
      systems that can be booted with &grub;. Without this information, the
      &grub; command line prompts the user for how to proceed (see
      <xref linkend="sec.grub.menu.change"/> for details).
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><filename>/boot/grub/device.map</filename>
    </term>
    <listitem><indexterm>
     <primary>&grub;</primary>
     <secondary>device.map</secondary></indexterm>
     <para>
      This file translates device names from the &grub; and BIOS notation to
      Linux device names.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><filename>/etc/grub.conf</filename>
    </term>
    <listitem><indexterm>
     <primary>&grub;</primary>
     <secondary>grub.conf</secondary></indexterm>
     <para>
      This file contains the commands, parameters and options the &grub;
      shell needs for installing the boot loader correctly.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><filename>/etc/sysconfig/bootloader</filename>
    </term>
    <listitem><indexterm>
     <primary>&grub;</primary>
     <secondary>sysconfig/bootloader</secondary></indexterm>
     <para>
      This file is read by the perl-bootloader library which is used when
      configuring the bootloader with &yast; and every time a new kernel is
      installed. It contains configuration options (such as kernel
      parameters) that will be added by default to the bootloader
      configuration file.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   &grub; can be controlled in various ways. Boot entries from an existing
   configuration can be selected from the graphical menu (splash screen).
   The configuration is loaded from the file <filename>menu.lst</filename>.
  </para>

  <para>
   In &grub;, all boot parameters can be changed prior to booting. For
   example, errors made when editing the menu file can be corrected in this
   way. Boot commands can also be entered interactively at a kind of input
   prompt. For details, see <xref linkend="sec.grub.menu.change"/>. &grub;
   offers the possibility of determining the location of the kernel and the
   <filename>initrd</filename> prior to booting. In this way, you can even
   boot an installed operating system for which no entry exists in the boot
   loader configuration.
  </para>

  <para>
   &grub; actually exists in two versions: as a boot loader and as a normal
   Linux program in <filename>/usr/sbin/grub</filename>. The latter is
   referred to as the <emphasis>&grub; shell</emphasis>. It provides an
   emulation of &grub; in the installed system and can be used to install
   &grub; or test new settings before applying them. The functionality to
   install &grub; as the boot loader on a hard disk or floppy disk is
   integrated in &grub; in the form of the command <command>setup</command>.
   This is available in the &grub; shell when Linux is loaded.
  </para>

  <sect2 id="sec.grub.menu">
   <title>The File <filename>/boot/grub/menu.lst</filename></title><indexterm>
   <primary>configuration files</primary>
   <secondary>menu.lst</secondary></indexterm><indexterm>
   <primary>&grub;</primary>
   <secondary>boot menu</secondary></indexterm><indexterm>
   <primary>&grub;</primary>
   <secondary>menu.lst</secondary></indexterm>
   <para>
    The graphical splash screen with the boot menu is based on the &grub;
    configuration file <filename>/boot/grub/menu.lst</filename>, which
    contains all information about all partitions or operating systems that
    can be booted by the menu.
   </para>
   <para>
    Every time the system is booted, &grub; loads the menu file from the
    file system. For this reason, &grub; does not need to be reinstalled
    after every change to the file. Use the &yast; boot loader to modify the
    &grub; configuration as described in
    <xref linkend="sec.boot.yast2.config"/>.
   </para>
   <para>
    The menu file contains commands. The syntax is very simple. Every line
    contains a command followed by optional parameters separated by spaces
    like in the shell. For historical reasons, some commands permit an
    <literal>=</literal> in front of the first parameter. Comments are
    introduced by a hash (<literal>#</literal>).
   </para>
   <para>
    To identify the menu items in the menu overview, set a
    <literal>title</literal> for every entry. The text (including any
    spaces) following the keyword <literal>title</literal> is displayed as a
    selectable option in the menu. All commands up to the next
    <literal>title</literal> are executed when this menu item is selected.
   </para>
   <para>
    The simplest case is the redirection to boot loaders of other operating
    systems. The command is <literal>chainloader</literal> and the argument
    is usually the boot block of another partition, in &grub; block
    notation. For example:
   </para>
<screen>chainloader (hd0,3)+1</screen>
   <para>
    The device names in &grub; are explained in
    <xref linkend="sec.grub.devices"/>. This example specifies the first
    block of the fourth partition of the first hard disk.
   </para>
   <para>
    Use the command <literal>kernel</literal> to specify a kernel image. The
    first argument is the path to the kernel image in a partition. The other
    arguments are passed to the kernel on its command line.
   </para>
   <para>
    If the kernel does not have built-in drivers for access to the root
    partition or a recent Linux system with advanced hotplug features is
    used, <filename>initrd</filename> must be specified with a separate
    &grub; command whose only argument is the path to the
    <filename>initrd</filename> file. Because the loading address of the
    <filename>initrd</filename> is written into the loaded kernel image, the
    command <literal>initrd</literal> must follow after the
    <literal>kernel</literal> command.
   </para>
   <para>
    The command <literal>root</literal> simplifies the specification of
    kernel and initrd files. The only argument of <literal>root</literal> is
    a device or a partition. This device is used for all kernel,
    <filename>initrd</filename>, or other file paths for which no device is
    explicitly specified until the next <literal>root</literal> command.
   </para>
   <para>
    The <literal>boot</literal> command is implied at the end of every menu
    entry, so it does not need to be written into the menu file. However, if
    you use &grub; interactively for booting, you must enter the
    <literal>boot</literal> command at the end. The command itself has no
    arguments. It merely boots the loaded kernel image or the specified
    chain loader.
   </para>
   <para>
    After writing all menu entries, define one of them as the
    <literal>default</literal> entry. Otherwise, the first one (entry
    <literal>0</literal>) is used. You can also specify a time-out in
    seconds after which the default entry should boot.
    <literal>timeout</literal> and <literal>default</literal> usually
    precede the menu entries. An example file is described in
    <xref
     linkend="sec.grub.menu.example"/>.
   </para>
   <sect3 id="sec.grub.devices">
    <title>Naming Conventions for Hard Disks and Partitions</title><indexterm>
    <primary>&grub;</primary>
    <secondary>device names</secondary></indexterm><indexterm>
    <primary>&grub;</primary>
    <secondary>partition names</secondary></indexterm>
    <para>
     The naming convention &grub; uses for hard disks and partitions differ
     from that used for normal Linux devices. It more closely resembles the
     simple disk enumeration the BIOS does and the syntax is similar to that
     used in some BSD derivatives. In &grub;, the numbering of the
     partitions start with zero. This means that
     (<filename>hd0,0</filename>) is the first partition of the first hard
     disk. On a common desktop machine with a hard disk connected as primary
     master, the corresponding Linux device name is
     <filename>/dev/sda1</filename>.
    </para>
    <para>
     The four possible primary partitions are assigned the partition numbers
     <literal>0</literal> to <literal>3</literal>. The logical partitions
     are numbered from <literal>4</literal>:
    </para>
<screen>(hd0,0)   first primary partition of the first hard disk
(hd0,1)   second primary partition
(hd0,2)   third primary partition
(hd0,3)   fourth primary partition (usually an extended partition)
(hd0,4)   first logical partition
(hd0,5)   second logical partition</screen>
    <para>
     Being dependent on BIOS devices, &grub; does not distinguish between
     PATA (IDE), SATA, SCSI, and hardware RAID devices. All hard disks
     recognized by the BIOS or other controllers are numbered according to
     the boot sequence preset in the BIOS.
    </para>
    <para>
     Unfortunately, it is often not possible to map the Linux device names
     to BIOS device names exactly. It generates this mapping with the help
     of an algorithm and saves it to the file
     <filename>device.map</filename>, which can be edited if necessary.
     Information about the file <filename>device.map</filename> is available
     in <xref linkend="sec.grub.map"/>.
    </para>
    <para>
     A complete &grub; path consists of a device name written in parentheses
     and the path to the file in the file system in the specified partition.
     The path begins with a slash. For example, the bootable kernel could be
     specified as follows on a system with a single PATA (IDE) hard disk
     containing Linux in its first partition:
    </para>
<screen>(hd0,0)/boot/vmlinuz</screen>
   </sect3>
   <sect3 id="sec.grub.menu.example">
    <title>An Example Menu File</title>
    <para>
     The following example shows the structure of a &grub; menu file. The
     example installation has a Linux boot partition under
     <filename>/dev/sda5</filename>, a root partition under
     <filename>/dev/sda7</filename> and a Windows installation under
     <filename>/dev/sda1</filename>.
    </para>
    <remark>taroth 2010-07-09: looks like a good candidate for a callout list
     (referring to the respective entries would be much easier) - maybe change
     for next revision?</remark>
<screen>gfxmenu (hd0,4)/boot/message<co id="grub.menu.example.gfxmenu"/>
color white/blue black/light-gray<co id="grub.menu.example.color"/>
default 0<co id="grub.menu.example.default"/>
timeout 8<co id="grub.menu.example.timeout"/>

title linux<co id="grub.menu.example.linux"/>
   root (hd0,4)
   kernel /boot/vmlinuz root=/dev/sda7 vga=791 resume=/dev/sda9
   initrd /boot/initrd

title windows<co id="grub.menu.example.windows"/>
   rootnoverify (hd0,0)
   chainloader +1

title floppy<co id="grub.menu.example.floppy"/>
   rootnoverify (hd0,0)
   chainloader (fd0)+1

title failsafe<co id="grub.menu.example.failsafe"/>
   root (hd0,4)
   kernel /boot/vmlinuz.shipped root=/dev/sda7 ide=nodma \
   apm=off acpi=off vga=normal nosmp maxcpus=0 3 noresume
   initrd /boot/initrd.shipped</screen>
    <para>
     The first block defines the configuration of the splash screen:
    </para>
    <calloutlist>
     <callout arearefs="grub.menu.example.gfxmenu">
      <para>
       The background image <literal>message</literal> is located in the
       <filename>/boot</filename> directory of the
       <filename>/dev/sda5</filename> partition.
      </para>
     </callout>
     <callout arearefs="grub.menu.example.color">
      <para>
       Color scheme: white (foreground), blue (background), black
       (selection) and light gray (background of the selection). The color
       scheme has no effect on the splash screen, only on the customizable
       &grub; menu that you can access by exiting the splash screen with
       <keycap>Esc</keycap>.
      </para>
     </callout>
     <callout arearefs="grub.menu.example.default">
      <para>
       The first (<literal>0</literal>) menu entry <literal>title
       linux</literal> is booted by default.
      </para>
     </callout>
     <callout arearefs="grub.menu.example.timeout">
      <para>
       After eight seconds without any user input, &grub; automatically
       boots the default entry. To deactivate automatic boot, delete the
       <literal>timeout</literal> line. If you set <literal>timeout
       0</literal>, &grub; boots the default entry immediately.
      </para>
     </callout>
    </calloutlist>
    <para>
     The second and largest block lists the various bootable operating
     systems. The sections for the individual operating systems are
     introduced by <literal>title</literal>.
    </para>
    <calloutlist>
     <callout arearefs="grub.menu.example.linux">
      <para>
       The first entry (<literal>title linux</literal>) is responsible for
       booting &productname;. The kernel (<literal>vmlinuz</literal>) is
       located in the first logical partition (the boot partition) of the
       first hard disk. Kernel parameters, such as the root partition and
       VGA mode, are appended here. The root partition is specified
       according to the Linux naming convention
       (<filename>/dev/sda7/</filename>) because this information is read by
       the kernel and has nothing to do with &grub;. The
       <literal>initrd</literal> is also located in the first logical
       partition of the first hard disk.
      </para>
     </callout>
     <callout arearefs="grub.menu.example.windows">
      <para>
       The second entry is responsible for loading Windows. Windows is
       booted from the first partition of the first hard disk
       (<filename>hd0,0</filename>). The command <literal>chainloader
       +1</literal> causes &grub; to read and execute the first sector of
       the specified partition.
      </para>
     </callout>
     <callout arearefs="grub.menu.example.floppy">
      <para>
       The next entry enables booting from floppy disk without modifying the
       BIOS settings.
      </para>
     </callout>
     <callout arearefs="grub.menu.example.failsafe">
      <para>
       The boot option <literal>failsafe</literal> starts Linux with a
       selection of kernel parameters that enables Linux to boot even on
       problematic systems.
      </para>
     </callout>
    </calloutlist>
    <para>
     The menu file can be changed whenever necessary. &grub; then uses the
     modified settings during the next boot. Edit the file permanently using
     &yast; or an editor of your choice. Alternatively, make temporary
     changes interactively using the edit function of &grub;. See
     <xref linkend="sec.grub.menu.change"/>.
    </para>
   </sect3>
   <sect3 id="sec.grub.menu.change">
    <title>Editing Menu Entries during the Boot Procedure</title><indexterm>
    <primary>&grub;</primary>
    <secondary>menu editor</secondary></indexterm>
    <para>
     In the graphical boot menu, select the operating system to boot with
     the arrow keys. If you select a Linux system, you can enter additional
     boot parameters at the boot prompt. To edit individual menu entries
     directly, press <keycap>Esc</keycap> to exit the splash screen and get
     to the &grub; text-based menu then press <keycap>E</keycap>. Changes
     made in this way only apply to the current boot and are not adopted
     permanently.
    </para>
    <important>
     <title>Keyboard Layout during the Boot Procedure</title>
     <para>
      The US keyboard layout is the only one available when booting. See
      <xref linkend="fig.trouble.install.keyboard_us"/>.
     </para>
    </important>
    <para>
     Editing menu entries facilitates the repair of a defective system that
     can no longer be booted, because the faulty configuration file of the
     boot loader can be circumvented by manually entering parameters.
     Manually entering parameters during the boot procedure is also useful
     for testing new settings without impairing the native system.
    </para>
    <para>
     After activating the editing mode, use the arrow keys to select the
     menu entry of the configuration to edit. To make the configuration
     editable, press <keycap>E</keycap> again. In this way, edit incorrect
     partitions or path specifications before they have a negative effect on
     the boot process. Press <keycap>Enter</keycap> to exit the editing mode
     and return to the menu. Then press <keycap>B</keycap> to boot this
     entry. Further possible actions are displayed in the help text at the
     bottom.
    </para>
    <para>
     To enter changed boot options permanently and pass them to the kernel,
     open the file <filename>menu.lst</filename> as the user
     <systemitem
      class="username">root</systemitem> and append the
     respective kernel parameters to the existing line, separated by spaces:
    </para>
<screen>title linux
   root(hd0,0)
     kernel /vmlinuz root=/dev/sda3 <replaceable>additional parameter</replaceable>
   initrd /initrd</screen>
    <para>
     &grub; automatically adopts the new parameters the next time the system
     is booted. Alternatively, this change can also be made with the &yast;
     boot loader module. Append the new parameters to the existing line,
     separated by spaces.
    </para>
   </sect3>
  </sect2>

  <sect2 id="sec.grub.map">
   <title>The File device.map</title><indexterm>
   <primary>&grub;</primary>
   <secondary>device.map</secondary></indexterm>
   <para>
    The file <filename>device.map</filename> maps &grub; and BIOS device
    names to Linux device names. In a mixed system containing PATA (IDE) and
    SCSI hard disks, &grub; must try to determine the boot sequence by a
    special procedure, because &grub; may not have access to the BIOS
    information on the boot sequence. &grub; saves the result of this
    analysis in the file <filename>/boot/grub/device.map</filename>. Example
    <filename>device.map</filename> files for a system on which the boot
    sequence in the BIOS is set to PATA before SCSI could look as follows:
   </para>
<screen>(fd0)  /dev/fd0
(hd0)  /dev/sda
(hd1)  /dev/sdb</screen>
   <para>
    or
   </para>
<screen>(fd0)  /dev/fd0
(hd0)  /dev/disk-by-id/<replaceable>DISK1 ID</replaceable>
(hd1)  /dev/disk-by-id/<replaceable>DISK2 ID</replaceable></screen>
   <para>
    Because the order of PATA (IDE), SCSI and other hard disks depends on
    various factors and Linux is not able to identify the mapping, the
    sequence in the file <filename>device.map</filename> can be set
    manually. If you encounter problems when booting, check if the sequence
    in this file corresponds to the sequence in the BIOS and use the &grub;
    prompt to modify it temporarily, if necessary. After the Linux system
    has booted, the file <filename>device.map</filename> can be edited
    permanently with the &yast; boot loader module or an editor of your
    choice.
   </para>
   <note os="sles">
    <title>Maximum Number of Hard Disks</title>
    <para>
     To address a hard disk, &grub; uses BIOS services. This is done via the
     software interrupt Int13h. Since Int13h is limited to handling a
     maximum number of eight disks, &grub; can only boot from the disks
     handled by Int13h, even if there are more disks present (which is often
     the case on multipath systems). The <filename>device.map</filename>
     file created during the installation will therefore only contain a
     maximum number of the eight disks handled by Int13h.
    </para>
   </note>
   <para>
    After manually changing <filename>device.map</filename>, execute the
    following command to reinstall &grub;. This command causes the file
    <filename>device.map</filename> to be reloaded and the commands listed
    in <filename>grub.conf</filename> to be executed:
   </para>
<screen>grub --batch &lt; /etc/grub.conf</screen>
  </sect2>

  <sect2 id="sec.grub.conf">
   <title>The File /etc/grub.conf</title><indexterm>
   <primary>configuration files</primary>
   <secondary>grub.conf</secondary></indexterm><indexterm>
   <primary>&grub;</primary>
   <secondary>grub.conf</secondary></indexterm><indexterm>
   <primary>configuring</primary>
   <secondary>&grub;</secondary></indexterm>
   <para>
    The third important &grub; configuration file after
    <filename>menu.lst</filename> and <filename>device.map</filename> is
    <filename>/etc/grub.conf</filename>. This file contains the commands,
    parameters and options the &grub; shell needs for installing the boot
    loader correctly:
   </para>
<screen>setup --stage2=/boot/grub/stage2 --force-lba (hd0,1) (hd0,1)
   quit</screen>
   <para>
    This command tells &grub; to automatically install the boot loader to
    the second partition on the first hard disk (hd0,1) using the boot
    images located on the same partition. The
    <option>--stage2=/boot/grub/stage2</option> parameter is needed to
    install the <filename>stage2</filename> image from a mounted file
    system. Some BIOSes have a faulty LBA support implementation,
    <option>--force-lba</option> provides a solution to ignore them.
   </para>
  </sect2>

  <sect2 id="sec.grub.sysconfig">
   <title>The File <filename>/etc/sysconfig/bootloader</filename></title><indexterm>
   <primary>&grub;</primary>
   <secondary>sysconfig/bootloader</secondary></indexterm>
   <para>
    This configuration file is only used when configuring the bootloader
    with &yast; and every time a new kernel is installed. It is evaluated by
    the perl-bootloader library which modifies the bootloader configuration
    file (for example <filename>/boot/grub/menu.lst</filename> for &grub;)
    accordingly. <filename>/etc/sysconfig/bootloader</filename> is not a
    &grub; specific configuration file - the values are applied to any
    bootloader installed on &productname;.
   </para>
   <note>
    <title>Bootloader Configuration after a Kernel Update</title>
    <para>
     Every time a new kernel is installed, the perl-bootloader writes a new
     bootloader configuration file (for example
     <filename>/boot/grub/menu.lst</filename> for &grub;) using the defaults
     specified in <filename>/etc/sysconfig/bootloader</filename>. If you are
     using a customized set of kernel parameters, make sure to adjust the
     relevant defaults in <filename>/etc/sysconfig/bootloader</filename>
     according to your needs.
    </para>
   </note>
   <variablelist>
    <varlistentry>
     <term><literal>LOADER_TYPE</literal>
     </term>
     <listitem>
      <para>
       Specifies the bootloader installed on the system (e.g. &grub; or
       LILO). Do not modify&mdash;use &yast; to change the bootloader as
       described in <xref
        linkend="pro.boot.yast2.config.loader"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>DEFAULT_VGA / FAILSAFE_VGA / XEN_VGA</literal>
     </term>
     <listitem>
      <para>
       Screen resolution and color depth of the framebuffer used during
       booting are configured with the kernel parameter
       <literal>vga</literal>. These values define which resolution and
       color depth to use for the default boot entry, the failsafe and the
       XEN entry. The following values are valid:
      </para>
      <table>
       <title>Screen Resolution and Color Depth Reference</title>
       <tgroup cols="6">
        <thead>
         <row>
          <entry>
           <para/>
          </entry>
          <entry>
           <para>
            640x480
           </para>
          </entry>
          <entry>
           <para>
            800x600
           </para>
          </entry>
          <entry>
           <para>
            1024x768
           </para>
          </entry>
          <entry>
           <para>
            1280x1024
           </para>
          </entry>
          <entry>
           <para>
            1600x1200
           </para>
          </entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry>
           <para>
            8bit
           </para>
          </entry>
          <entry>
           <para>
            0x301
           </para>
          </entry>
          <entry>
           <para>
            0x303
           </para>
          </entry>
          <entry>
           <para>
            0x305
           </para>
          </entry>
          <entry>
           <para>
            0x307
           </para>
          </entry>
          <entry>
           <para>
            0x31C
           </para>
          </entry>
         </row>
         <row>
          <entry>
           <para>
            15bit
           </para>
          </entry>
          <entry>
           <para>
            0x310
           </para>
          </entry>
          <entry>
           <para>
            0x313
           </para>
          </entry>
          <entry>
           <para>
            0x316
           </para>
          </entry>
          <entry>
           <para>
            0x319
           </para>
          </entry>
          <entry>
           <para>
            0x31D
           </para>
          </entry>
         </row>
         <row>
          <entry>
           <para>
            16bit
           </para>
          </entry>
          <entry>
           <para>
            0x311
           </para>
          </entry>
          <entry>
           <para>
            0x314
           </para>
          </entry>
          <entry>
           <para>
            0x317
           </para>
          </entry>
          <entry>
           <para>
            0x31A
           </para>
          </entry>
          <entry>
           <para>
            0x31E
           </para>
          </entry>
         </row>
         <row>
          <entry>
           <para>
            24bit
           </para>
          </entry>
          <entry>
           <para>
            0x312
           </para>
          </entry>
          <entry>
           <para>
            0x315
           </para>
          </entry>
          <entry>
           <para>
            0x318
           </para>
          </entry>
          <entry>
           <para>
            0x31B
           </para>
          </entry>
          <entry>
           <para>
            0x31F
           </para>
          </entry>
         </row>
        </tbody>
       </tgroup>
      </table>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>DEFAULT_APPEND / FAILSAFE_APPEND / XEN_KERNEL_APPEND</literal>
     </term>
     <listitem>
      <para>
       Kernel parameters (other than <literal>vga</literal>) that are
       automatically appended to the default, failsafe and XEN boot entries
       in the bootloader configuration file.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>CYCLE_DETECTION / CYCLE_NEXT_ENTRY</literal>
     </term>
     <listitem>
      <para>
       Configure whether to use boot cycle detection and if so, which
       alternative entry from <filename>/boot/grub/menu.lst</filename> to
       boot in case of a reboot cycle (e.g.
       <systemitem>Failsafe</systemitem>). See
       <filename>/usr/share/doc/packages/bootcycle/README</filename> for
       detailed information.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="sec.grub.password">
   <title>Setting a Boot Password</title><indexterm>
   <primary>&grub;</primary>
   <secondary>boot password</secondary></indexterm>
   <para>
    Even before the operating system is booted, &grub; enables access to
    file systems. Users without root permissions can access files in your
    Linux system to which they have no access once the system is booted. To
    block this kind of access or to prevent users from booting certain
    operating systems, set a boot password.
   </para>
   <important>
    <title>Boot Password and Splash Screen</title>
    <para>
     If you use a boot password for &grub;, the usual splash screen is not
     displayed.
    </para>
   </important>
   <para>
    As the user <literal>root</literal>, proceed as follows to set a boot
    password:
   </para>
   <procedure>
    <step>
     <para>
      At the root prompt, encrypt the password using grub-md5-crypt:
     </para>
<screen># grub-md5-crypt
Password: ****
Retype password: ****
Encrypted: $1$lS2dv/$JOYcdxIn7CJk9xShzzJVw/</screen>
    </step>
    <step>
     <para>
      Paste the encrypted string into the global section of the file
      <filename>menu.lst</filename>:
     </para>
<screen>gfxmenu (hd0,4)/message
color white/blue black/light-gray
default 0
timeout 8
password --md5 $1$lS2dv/$JOYcdxIn7CJk9xShzzJVw/</screen>
     <para>
      Now &grub; commands can only be executed at the boot prompt after
      pressing <keycap>P</keycap> and entering the password. However, users
      can still boot all operating systems from the boot menu.
     </para>
    </step>
    <step>
     <para>
      To prevent one or several operating systems from being booted from the
      boot menu, add the entry <literal>lock</literal> to every section in
      <filename>menu.lst</filename> that should not be bootable without
      entering a password. For example:
     </para>
<screen>title linux
   kernel (hd0,4)/vmlinuz root=/dev/sda7 vga=791
   initrd (hd0,4)/initrd
   lock</screen>
     <para>
      After rebooting the system and selecting the Linux entry from the boot
      menu, the following error message is displayed:
     </para>
<screen>Error 32: Must be authenticated</screen>
     <para>
      Press <keycap>Enter</keycap> to enter the menu. Then press
      <keycap>P</keycap> to get a password prompt. After entering the
      password and pressing <keycap>Enter</keycap>, the selected operating
      system (Linux in this case) should boot.
     </para>
    </step>
   </procedure>
  </sect2>
 </sect1>
<!-- taken from former lilo.xml -->
 <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="grub_yast_i.xml"/>
 <sect1
  id="sec.grub.entfernen">
  <title>Uninstalling the Linux Boot Loader</title><indexterm>

  <primary>uninstalling</primary>

  <secondary>&grub;</secondary></indexterm><indexterm>

  <primary>uninstalling</primary>

  <secondary>Linux</secondary></indexterm><indexterm>

  <primary>&grub;</primary>

  <secondary>uninstalling</secondary></indexterm><indexterm>

  <primary>Linux</primary>

  <secondary>uninstalling</secondary></indexterm>

  <para>
   &yast; can be used to uninstall the Linux boot loader and restore the MBR
   to the state it had prior to the installation of Linux. During the
   installation, &yast; automatically creates a backup copy of the original
   MBR and restores it upon request.
  </para>

  <para>
   To uninstall &grub;, start &yast; and click <menuchoice>
   <guimenu>System</guimenu> <guimenu>Boot Loader</guimenu> </menuchoice> to
   start the boot loader module. Select <menuchoice>
   <guimenu>Other</guimenu> <guimenu>Restore MBR of Hard Disk</guimenu>
   </menuchoice> and confirm with <guimenu>Yes, Rewrite</guimenu>.
  </para>
 </sect1>
 <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="grub_bootcd_i.xml"/>
 <sect1 id="sec.boot.screen">
  <title>The Graphical &suse; Screen</title><indexterm>

  <primary>booting</primary>

  <secondary>graphic</secondary></indexterm><indexterm>

  <primary>consoles</primary>

  <secondary>graphical</secondary></indexterm>

  <para>
   The graphical &suse; screen is displayed on the first console if the
   option <option>vga=<replaceable>value</replaceable></option> is used as a
   kernel parameter. If you install using &yast;, this option is
   automatically activated in accordance with the selected resolution and
   the graphics card. There are three ways to disable the &suse; screen, if
   desired:
  </para>

  <variablelist>
   <varlistentry>
    <term>Disabling the &suse; Screen When Necessary</term>
    <listitem>
     <para>
      Enter the command <command>echo 0 &gt;/proc/splash</command> on the
      command line to disable the graphical screen. To activate it again,
      enter <command>echo 1 &gt;/proc/splash</command>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Disabling the &suse; screen by default.</term>
    <listitem>
     <para>
      Add the kernel parameter <option>splash=0</option> to your boot loader
      configuration. <xref linkend="cha.grub"/> provides more information
      about this. However, if you prefer the text mode (the default in
      earlier versions) set <option>vga=normal</option>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Completely Disabling the &suse; Screen</term>
    <listitem>
     <para>
      Compile a new kernel and disable the option <guimenu>Use splash screen
      instead of boot logo</guimenu> in <guimenu>framebuffer
      support</guimenu>. Disabling framebuffer support in the kernel
      automatically disables the splash screen, as well.
     </para>
     <warning>
      <title>No Support</title>
      <para>
       &suse; cannot provide any support for your system if you run it with
       a custom kernel.
      </para>
     </warning>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 id="sec.grub.probs">
  <title>Troubleshooting</title><indexterm>

  <primary>&grub;</primary>

  <secondary>troubleshooting</secondary></indexterm>

  <para>
   This section lists some of the problems frequently encountered when
   booting with &grub; and a short description of possible solutions. Some
   of the problems are covered in articles in the
   <phrase os="sled;sles">Knowledge base at
   <ulink url="http://www.suse.com/support"
    /></phrase><phrase os="osuse">Support
   Database at
   <ulink url="http://en.opensuse.org/Portal:Support_database"
    /></phrase>.
   Use the search dialog to search for keywords like
   <emphasis>&grub;</emphasis>, <emphasis>boot</emphasis> and <emphasis>boot
   loader</emphasis>.
  </para>

  <variablelist>
   <varlistentry>
    <term>&grub; and XFS</term>
    <listitem>
     <para>
      XFS leaves no room for <filename>stage1</filename> in the partition
      boot block. Therefore, do not specify an XFS partition as the location
      of the boot loader. This problem can be solved by creating a separate
      boot partition that is not formatted with XFS.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>&grub; Reports GRUB Geom Error</term>
    <listitem><indexterm>
     <primary>&grub;</primary>
     <secondary>GRUB Geom Error</secondary></indexterm>
     <para>
      &grub; checks the geometry of connected hard disks when the system is
      booted. Sometimes, the BIOS returns inconsistent information and
      &grub; reports a GRUB Geom Error. In this case, update the BIOS.
     </para>
     <para>
      &grub; also returns this error message if Linux was installed on an
      additional hard disk that is not registered in the BIOS.
      <emphasis>stage1</emphasis> of the boot loader is found and loaded
      correctly, but <emphasis>stage2</emphasis> is not found. This problem
      can be remedied by registering the new hard disk in the BIOS.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>System Containing Several Hard Disks Does Not Boot</term>
    <listitem>
     <para>
      During the installation, &yast; may have incorrectly determined the
      boot sequence of the hard disks. For example, &grub; may regard the
      PATA (IDE) disk as <filename>hd0</filename> and the SCSI disk as
      <filename>hd1</filename>, although the boot sequence in the BIOS is
      reversed (SCSI <emphasis>before</emphasis> PATA).
     </para>
     <para>
      In this case, correct the hard disks during the boot process with the
      help of the &grub; command line. After the system has booted, edit
      <filename>device.map</filename> to apply the new mapping permanently.
      Then check the &grub; device names in the files
      <filename>/boot/grub/menu.lst</filename> and
      <filename>/boot/grub/device.map</filename> and reinstall the boot
      loader with the following command:
     </para>
<screen>grub --batch &lt; /etc/grub.conf</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Booting Windows from the Second Hard Disk</term>
    <listitem>
     <para>
      Some operating systems, such as Windows, can only boot from the first
      hard disk. If such an operating system is installed on a hard disk
      other than the first hard disk, you can effect a logical change for
      the respective menu entry.
     </para>
<screen>...
title windows
   map (hd0) (hd1)
   map (hd1) (hd0)
   chainloader(hd1,0)+1
...</screen>
     <para>
      In this example, Windows is started from the second hard disk. For
      this purpose, the logical order of the hard disks is changed with
      <literal>map</literal>. This change does not affect the logic within
      the &grub; menu file. Therefore, the second hard disk must be
      specified for <literal>chainloader</literal>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 id="sec.grub.info">
  <title>For More Information</title>

  <para>
   Extensive information about &grub; is available at
   <ulink
    url="http://www.gnu.org/software/grub/"/>. Also refer to the
   <command>grub</command> info page. <phrase os="osuse">You can also search
   for the keyword <quote>&grub;</quote> in the Support Database at
   <ulink url="http://en.opensuse.org/Portal:Support_database"/> to get
   information about special issues.</phrase><phrase os="sles;sled">You can
   also search for the keyword <quote>&grub;</quote> in the Technical
   Information Search at <ulink url="http://www.novell.com/support"/> to get
   information about special issues.</phrase>
  </para>
 </sect1>
</chapter>
