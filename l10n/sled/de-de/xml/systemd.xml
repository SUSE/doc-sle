<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="systemd.xml" version="5.0" xml:id="cha-systemd">
  <title>Der Daemon <systemitem class="daemon">systemd</systemitem></title>
  <info>
    <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
      <dm:bugtracker/>
      <dm:translation>yes</dm:translation>
    </dm:docmanager>
  </info>
  <para>
    <systemitem class="daemon">systemd</systemitem> initialisiert das System. Er hat die Prozess-ID 1. <systemitem class="daemon">systemd</systemitem> wird direkt vom Kernel gestartet und widersteht dem Signal 9, das in der Regel Prozesse beendet. Alle anderen Programme werden direkt von <systemitem class="daemon">systemd</systemitem> oder von einem seiner untergeordneten Prozesse gestartet. <systemitem class="daemon">systemd</systemitem> ist ein Ersatz für den Daemon „System V-init“ und vollständig mit System V-init kompatibel (durch Unterstützung von init-Skripten).
  </para>
  <para>
    Der wichtigste Vorteil von <systemitem class="daemon">systemd</systemitem> ist der erheblich schnellere Systemstart durch die Parallelisierung der Dienststarts. Darüber hinaus startet <systemitem class="daemon">systemd</systemitem> einen Dienst nur dann, wenn er tatsächlich benötigt wird. Deamons werden nicht in jedem Fall beim Booten gestartet, sondern erst dann, wenn sie erstmalig benötigt werden. <systemitem class="daemon">systemd</systemitem> unterstützt auch Kernel-Steuergruppen (cgroups), das Erstellen von Snapshots und das Wiederherstellen des Systemstatus. Weitere Einzelheiten finden Sie unter <link xlink:href="https://www.freedesktop.org/wiki/Software/systemd/"/>.
  </para>
  <tip>
    <title><systemitem class="daemon">systemd</systemitem> innerhalb des WSL</title>
    <para>
      Das Windows-Subsystem für Linux (WSL) ermöglicht die Ausführung von Linux-Anwendungen und -Distributionen unter dem Betriebssystem Microsoft Windows. WSL verwendet seinen init-Prozess anstelle von <systemitem class="daemon">systemd</systemitem>. Um <systemitem class="daemon">systemd</systemitem> in <phrase role="productname"><phrase os="sled">SLED</phrase></phrase> zu aktivieren, das unter WSL ausgeführt wird, installieren Sie das <literal>wsl_systemd</literal>-Schema, das den Prozess automatisiert:
    </para>
<screen><prompt>&gt; </prompt><command>sudo</command> zypper in -t pattern wsl_systemd</screen>
    <para>
      Alternativ können Sie <filename>/etc/wsl.conf</filename> bearbeiten und die folgenden Zeilen manuell hinzufügen:
    </para>
<screen>[boot]
systemd=true</screen>
    <para>
      Beachten Sie, dass die Unterstützung für <systemitem class="daemon">systemd</systemitem> unter WSL teilweise ist – <systemitem class="daemon">systemd</systemitem>-Unit-Dateien müssen ein angemessenes Prozessverwaltungsverhalten aufweisen.
    </para>
  </tip>
  <sect1 xml:id="sec-boot-systemd-concept">
    <title>Das Konzept von <systemitem class="daemon">systemd</systemitem></title>

    <para>
      Im folgenden Abschnitt wird das Konzept hinter <systemitem class="daemon">systemd</systemitem> erläutert.
    </para>

    <para>
      <systemitem class="daemon">systemd</systemitem> ist ein System- und Sitzungsmanager für Linux und mit System V- und LSB-init-Skripts kompatibel. Die wichtigsten Funktionen von <systemitem class="daemon">systemd</systemitem>:
    </para>

    <itemizedlist mark="bullet" spacing="normal">
      <listitem>
        <para>
          Parallelisierungsfunktionen
        </para>
      </listitem>
      <listitem>
        <para>
          Starten von Diensten per Socket- und D-Bus-Aktivierung
        </para>
      </listitem>
      <listitem>
        <para>
          Starten der Daemons bei Bedarf
        </para>
      </listitem>
      <listitem>
        <para>
          Verfolgen von Prozessen mithilfe von Linux-cgroups
        </para>
      </listitem>
      <listitem>
        <para>
          Erstellen von Snapshots und Wiederherstellen des Systemstatus
        </para>
      </listitem>
      <listitem>
        <para>
          Einhängepunkte und Automount-Punkte
        </para>
      </listitem>
      <listitem>
        <para>
          Ausgereifte Dienststeuerlogik auf der Basis der Transaktionsabhängigkeiten
        </para>
      </listitem>
    </itemizedlist>

    <sect2 xml:id="sec-boot-systemd-unitfile">
      <title>Unit-Datei</title>
      <para>
        Eine Unit-Konfigurationsdatei enthält Informationen zu einem Dienst, Socket, Gerät, Einhängepunkt, Automount-Punkt, einer Auslagerungsdatei oder Partition, einem Startziel, einem überwachten Dateisystempfad, einem von <systemitem class="daemon">systemd</systemitem> gesteuerten und überwachten Zeitgeber, einem Snapshot eines temporären Systemstatus, einem Ressourcenverwaltungs-Slice oder einer Gruppe extern erstellter Prozesse.
      </para>
      <para>
        <quote>Unit-Datei</quote><systemitem class="daemon">systemd</systemitem> ist in ein generischer Term für Folgendes:
      </para>
      <itemizedlist mark="bullet" spacing="normal">
        <listitem>
          <formalpara>
            <title>Service</title>
            <para>
              Informationen zu einem Prozess (z. B. Ausführung eines Daemon); Datei endet auf .service
            </para>
          </formalpara>
        </listitem>
        <listitem>
          <formalpara>
            <title>Zielgruppen</title>
            <para>
              Fassen Units zu Gruppen zusammen bzw. fungieren als Synchronisierungspunkte beim Starten; Datei endet auf .target
            </para>
          </formalpara>
        </listitem>
        <listitem>
          <formalpara>
            <title>Sockets</title>
            <para>
              Informationen zu einem IPC- oder Netzwerk-Socket oder einem Dateisystem-FIFO, für die socketbasierte Aktivierung (wie <systemitem class="daemon">inetd</systemitem>); Datei endet auf .socket
            </para>
          </formalpara>
        </listitem>
        <listitem>
          <formalpara>
            <title>Path</title>
            <para>
              Dient als Auslöser von anderen Units (z. B. Ausführen eines Diensts, wenn Dateien geändert werden); Datei endet auf .path
            </para>
          </formalpara>
        </listitem>
        <listitem>
          <formalpara>
            <title>Zeitgeber</title>
            <para>
              Informationen zu einem gesteuerten Zeitgeber für die zeitgeberbasierte Aktivierung; Datei endet auf .timer
            </para>
          </formalpara>
        </listitem>
        <listitem>
          <formalpara>
            <title>Einhängepunkt</title>
            <para>
              In der Regel automatisch durch den fstab-Generator erzeugt; Datei endet auf .mount
            </para>
          </formalpara>
        </listitem>
        <listitem>
          <formalpara>
            <title>Automount-Punkt</title>
            <para>
              Informationen zu einem Dateisystem-Automount-Punkt; Datei endet auf .automount
            </para>
          </formalpara>
        </listitem>
        <listitem>
          <formalpara>
            <title>Swap</title>
            <para>
              Informationen zu einem Auslagerungsgerät oder einer Auslagerungsdatei für das Arbeitsspeicher-Paging; Datei endet auf .swap
            </para>
          </formalpara>
        </listitem>
        <listitem>
          <formalpara>
            <title>Gerät</title>
            <para>
              Informationen zu einer Geräte-Unit in der Geräte-Baumstruktur sysfs/udev(7); Datei endet auf .device
            </para>
          </formalpara>
        </listitem>
        <listitem>
          <formalpara>
            <title>Bereich/Slice</title>
            <para>
              Konzept für die hierarchische Verwaltung von Ressourcen einer Prozessgruppe; Datei endet auf .scope/.slice
            </para>
          </formalpara>
        </listitem>
      </itemizedlist>
      <para>
        Weitere Informationen zu <systemitem class="daemon">systemd</systemitem>-Unit-Dateien finden Sie in <link xlink:href="https://www.freedesktop.org/software/systemd/man/latest/systemd.unit.html"/>
      </para>
    </sect2>
  </sect1>
  <sect1 xml:id="sec-boot-systemd-basics">
    <title>Grundlegende Verwendung</title>

    <para>
      Im System V-init-System werden Dienste mit mehreren Befehlen verarbeitet – mit init-Skripten, <command>insserv</command>, <command>telinit</command> und anderen. <systemitem class="daemon">systemd</systemitem> Vereinfacht die Verwaltung von Diensten, da es nur einen Befehl gibt, um die meisten dienstbezogenen Aufgaben zu erledigen: <command>systemctl</command> Hierbei gilt die Syntax <quote>Befehl plus Unterbefehl</quote> wie bei <command>git</command> oder <command>zypper</command>:
    </para>

<screen>systemctl <replaceable>GENERAL OPTIONS</replaceable> <replaceable>SUBCOMMAND</replaceable> <replaceable>SUBCOMMAND OPTIONS</replaceable></screen>

    <para>
      Vollständige Anweisungen finden Sie in <command>man 1 systemctl</command>.
    </para>

    <tip>
      <title>Terminalausgabe und Bash-Vervollständigung</title>
      <para>
        Wenn die Ausgabe an ein Terminal geht (und nicht an eine Pipe oder Datei usw.), senden die <systemitem class="daemon">systemd</systemitem>-Befehle standardmäßig eine ausführliche Ausgabe an einen Pager. Mit der Option <option>--no-pager</option> deaktivieren Sie den Paging-Modus.
      </para>
      <para>
        <systemitem class="daemon">systemd</systemitem> unterstützt außerdem die Bash-Vervollständigung. Hierbei geben Sie die ersten Buchstaben eines Unterbefehls ein und drücken dann <keycap function="tab"/>. Diese Funktion ist nur in der <systemitem>bash</systemitem>-Shell verfügbar und das Paket <systemitem class="resource">bash-completion</systemitem> muss installiert sein.
      </para>
    </tip>

    <sect2 xml:id="sec-boot-systemd-basics-services">
      <title>Verwalten von Diensten auf einem laufenden System</title>
      <para>
        Die Unterbefehle zum Verwalten der Dienste sind mit den entsprechenden Befehlen in System V-init identisch (<command>start</command>, <command>stop</command> usw.). Die allgemeine Syntax für Dienstverwaltungsbefehle lautet wie folgt:
      </para>
      <variablelist>
        <varlistentry>
          <term><systemitem class="daemon">systemd</systemitem></term>
          <listitem>
<screen>systemctl reload|restart|start|status|stop|<replaceable>...</replaceable> <replaceable>MY_SERVICE(S)</replaceable></screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>System V-init</term>
          <listitem>
<screen>rc<replaceable>MY_SERVICE(S)</replaceable> reload|restart|start|status|stop|<replaceable>...</replaceable></screen>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
        Mit <systemitem class="daemon">systemd</systemitem> können Sie mehrere Dienste gleichzeitig verwalten. Im Gegensatz zu System V-init, bei dem die init-Skripts einzeln nacheinander ausgeführt werden, führen Sie einen einzigen Befehl aus, beispielsweise:
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl start <replaceable>MY_1ST_SERVICE</replaceable> <replaceable>MY_2ND_SERVICE</replaceable></screen>
      <para>
        So rufen Sie eine Liste aller auf dem System verfügbaren Dienste ab:
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl list-unit-files --type=service</screen>
      <para>
        Die folgende Tabelle zeigt die wichtigsten Dienstverwaltungsbefehle für <systemitem class="daemon">systemd</systemitem> und System V-init:
      </para>
      <table rowsep="1">
        <title>Befehle zur Dienstverwaltung</title>
        <tgroup cols="3">
          <colspec colnum="1" colname="1" colwidth="50*"/>
          <colspec colnum="2" colname="2" colwidth="30*"/>
          <colspec colnum="3" colname="3" colwidth="20*"/>
          <thead>
            <row>
              <entry colname="1">
                <para>
                  Aufgabe
                </para>
              </entry>
              <entry colname="2">
                <para>
                  <systemitem class="daemon">systemd</systemitem>-Befehl
                </para>
              </entry>
              <entry colname="3">
                <para>
                  System V-init-Befehl
                </para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry colname="1">
                <formalpara>
                  <title>Starten</title>
                  <para/>
                </formalpara>
              </entry>
              <entry colname="2">
<screen>start</screen>
              </entry>
              <entry colname="3">
<screen>start</screen>
              </entry>
            </row>
            <row>
              <entry colname="1">
                <formalpara>
                  <title>Stoppen</title>
                  <para/>
                </formalpara>
              </entry>
              <entry colname="2">
<screen>stop</screen>
              </entry>
              <entry colname="3">
<screen>stop</screen>
              </entry>
            </row>
            <row>
              <entry colname="1">
                <formalpara>
                  <title>Neu starten</title>
                  <para>
                    Fährt Dienste herunter und startet sie dann neu. Wenn ein Dienst noch nicht ausgeführt wird, wird er gestartet.
                  </para>
                </formalpara>
              </entry>
              <entry colname="2">
<screen>restart</screen>
              </entry>
              <entry colname="3">
<screen>restart</screen>
              </entry>
            </row>
            <row>
              <entry colname="1">
                <formalpara>
                  <title>Bedingt neu starten</title>
                  <para>
                    Startet Dienste neu, wenn sie derzeit ausgeführt werden. Keine Auswirkung bei Diensten, die nicht ausgeführt werden.
                  </para>
                </formalpara>
              </entry>
              <entry colname="2">
<screen>try-restart</screen>
              </entry>
              <entry colname="3">
<screen>try-restart</screen>
              </entry>
            </row>
            <row>
              <entry colname="1">
                <formalpara>
                  <title>Neu laden</title>
                  <para>
                    Weist die Dienste an, die Konfigurationsdateien neu zu laden ohne die laufenden Vorgänge zu unterbrechen. Anwendungsbeispiel: Weisen Sie Apache an, eine bearbeitete <filename>httpd.conf</filename>-Konfigurationsdatei neu zu laden. Nicht alle Dienste unterstützen das Neuladen.
                  </para>
                </formalpara>
              </entry>
              <entry colname="2">
<screen>reload</screen>
              </entry>
              <entry colname="3">
<screen>reload</screen>
              </entry>
            </row>
            <row>
              <entry colname="1">
                <formalpara>
                  <title>Neu laden oder neu starten</title>
                  <para>
                    Lädt Dienste neu, wenn das Neuladen unterstützt wird; ansonsten werden die Dienste neu gestartet. Wenn ein Dienst noch nicht ausgeführt wird, wird er gestartet.
                  </para>
                </formalpara>
              </entry>
              <entry colname="2">
<screen>reload-or-restart</screen>
              </entry>
              <entry colname="3">
<screen>n/a</screen>
              </entry>
            </row>
            <row>
              <entry colname="1">
                <formalpara>
                  <title>Bedingt neu laden oder neu starten</title>
                  <para>
                    Lädt Dienste neu, wenn das Neuladen unterstützt wird; ansonsten werden die Dienste neu gestartet, wenn sie derzeit ausgeführt werden. Keine Auswirkung bei Diensten, die nicht ausgeführt werden.
                  </para>
                </formalpara>
              </entry>
              <entry colname="2">
<screen>reload-or-try-restart</screen>
              </entry>
              <entry colname="3">
<screen>n/a</screen>
              </entry>
            </row>
            <row>
              <entry colname="1">
                <formalpara>
                  <title>Ausführliche Statusinformationen abrufen</title>
                  <para>
                    Zeigt Informationen zum Dienststatus. Der Befehl <systemitem class="daemon">systemd</systemitem> zeigt Details wie Beschreibung, ausführbare Datei, Status, cgroup und zuletzt durch den Dienst ausgegebene Meldungen (siehe <xref linkend="sec-boot-systemd-basics-services-debugging"/>). Die Detailtiefe bei System V-init ist von Dienst zu Dienst unterschiedlich.
                  </para>
                </formalpara>
              </entry>
              <entry colname="2">
<screen>status</screen>
              </entry>
              <entry colname="3">
<screen>status</screen>
              </entry>
            </row>
            <row>
              <entry colname="1">
                <formalpara>
                  <title>Kurze Statusinformationen abrufen</title>
                  <para>
                    Gibt an, ob Dienste aktiv sind oder nicht.
                  </para>
                </formalpara>
              </entry>
              <entry colname="2">
<screen>is-active</screen>
              </entry>
              <entry colname="3">
<screen>status</screen>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-basics-services-enabling">
      <title>Dienste dauerhaft aktivieren/deaktivieren</title>
      <para>
        Mit den Dienstverwaltungsbefehlen im vorangegangenen Abschnitt können Sie die Dienste für die aktuelle Sitzung bearbeiten. Mit <systemitem class="daemon">systemd</systemitem> können Sie Dienste außerdem dauerhaft aktivieren oder deaktivieren, sodass sie entweder automatisch bei Bedarf gestartet werden oder gar nicht verfügbar sind. Sie können dies mithilfe von YaST oder über die Befehlszeile tun.
      </para>
      <sect3 xml:id="sec-boot-systemd-basics-services-enabling-cmd">
        <title>Aktivieren/Deaktivieren von Diensten über die Befehlszeile</title>
        <para>
          Die folgende Tabelle zeigt die wichtigsten Aktivierungs- und Deaktivierungsbefehle für <systemitem class="daemon">systemd</systemitem> und System V-init:
        </para>
        <important>
          <title>Dienststart</title>
          <para>
            Wenn ein Dienst über die Befehlszeile aktiviert wird, wird er nicht automatisch gestartet. Der Dienst wird beim nächsten Systemstart oder bei der nächsten Änderung des Runlevels/Ziels gestartet. Um einen Dienst sofort zu starten, nachdem Sie ihn aktiviert haben, führen Sie <command>systemctl start
            <replaceable>MY_SERVICE</replaceable></command> oder <command>rc
            <replaceable>MY_SERVICE</replaceable> start</command> explizit aus.
          </para>
        </important>
        <table rowsep="1">
          <title>Befehle zum Aktivieren und Deaktivieren von Diensten</title>
          <tgroup cols="3">
            <colspec colnum="1" colname="1" colwidth="32*"/>
            <colspec colnum="2" colname="2" colwidth="40*"/>
            <colspec colnum="3" colname="3" colwidth="28*"/>
            <thead>
              <row>
                <entry colname="1">
                  <para>
                    Aufgabe
                  </para>
                </entry>
                <entry colname="2">
                  <para>
                    <systemitem class="daemon">systemd</systemitem>-Befehl
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    System V-init-Befehl
                  </para>
                </entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry colname="1">
                  <formalpara>
                    <title>Aktivieren von</title>
                    <para/>
                  </formalpara>
                </entry>
                <entry colname="2">
                  <para>
                    <command>systemctl enable
                    <replaceable>MY_SERVICE(S)</replaceable></command>
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    <command>insserv
                    <replaceable>MY_SERVICE(S)</replaceable></command>, <command>chkconfig -a
                    <replaceable>MY_SERVICE(S)</replaceable></command>
                  </para>
                </entry>
              </row>
              <row>
                <entry colname="1">
                  <formalpara>
                    <title>Deaktivieren</title>
                    <para/>
                  </formalpara>
                </entry>
                <entry colname="2">
                  <para>
                    <command>systemctl disable
                    <replaceable>MY_SERVICE(S)</replaceable>.service</command>
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    <command>insserv -r
                    <replaceable>MY_SERVICE(S)</replaceable></command>, <command>chkconfig -d
                    <replaceable>MY_SERVICE(S)</replaceable></command>
                  </para>
                </entry>
              </row>
              <row>
                <entry colname="1">
                  <formalpara>
                    <title>Überprüfen</title>
                    <para>
                      Zeigt an, ob ein Dienst aktiviert ist oder nicht.
                    </para>
                  </formalpara>
                </entry>
                <entry colname="2">
                  <para>
                    <command>systemctl is-enabled
                    <replaceable>MY_SERVICE</replaceable></command>
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    <command>chkconfig
                    <replaceable>MY_SERVICE</replaceable></command>
                  </para>
                </entry>
              </row>
              <row>
                <entry colname="1">
                  <formalpara>
                    <title>Erneut aktivieren</title>
                    <para>
                      Ähnlich wie beim Neustarten eines Diensts, deaktiviert dieser Befehl einen Dienst und aktiviert ihn dann wieder. Nützlich, wenn ein Dienst mit den Standardeinstellungen erneut aktiviert werden soll.
                    </para>
                  </formalpara>
                </entry>
                <entry colname="2">
                  <para>
                    <command>systemctl reenable
                    <replaceable>MY_SERVICE</replaceable></command>
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    n/v
                  </para>
                </entry>
              </row>
              <row>
                <entry colname="1">
                  <formalpara>
                    <title>Maskierung</title>
                    <para>
                      Nach dem <quote>Deaktivieren</quote> eines Dienstes kann er weiterhin manuell aktiviert werden. Soll ein Dienst deaktiviert werden, maskieren Sie ihn. Mit Vorsicht verwenden.
                    </para>
                  </formalpara>
                </entry>
                <entry colname="2">
                  <para>
                    <command>systemctl mask
                    <replaceable>MY_SERVICE</replaceable></command>
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    n/v
                  </para>
                </entry>
              </row>
              <row>
                <entry colname="1">
                  <formalpara>
                    <title>Demaskieren</title>
                    <para>
                      Ein maskierter Dienst kann erst dann wieder genutzt werden, wenn er demaskiert wurde.
                    </para>
                  </formalpara>
                </entry>
                <entry colname="2">
                  <para>
                    <command>systemctl unmask
                    <replaceable>MY_SERVICE</replaceable></command>
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    n/v
                  </para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </sect3>
    </sect2>
  </sect1>
  <sect1 xml:id="sec-boot-systemd-boot">
    <title>Systemstart und Zielverwaltung</title>

    <para>
      Der gesamte Vorgang des Startens und Herunterfahrens des Systems wird von <systemitem class="daemon">systemd</systemitem> verwaltet. Von diesem Gesichtspunkt aus kann der Kernel als Hintergrundprozess betrachtet werden, der alle anderen Prozesse verwaltet und die CPU-Zeit sowie den Hardwarezugriff entsprechend den Anforderungen anderer Programme anpasst.
    </para>

    <sect2 xml:id="sec-boot-systemd-targets">
      <title>Ziele im Vergleich zu Runlevels</title>
      <para>
        Bei System V-init wurde das System in ein sogenanntes <quote>Runlevel</quote> gebootet. Ein Runlevel definiert, wie das System gestartet wird und welche Dienste im laufenden System verfügbar sind. Die Runlevels sind nummeriert. Die bekanntesten Runlevels sind <literal>0</literal> (System herunterfahren), <literal>3</literal> (Mehrbenutzermodus mit Netzwerk) und <literal>5</literal> (Mehrbenutzermodus mit Netzwerk und Anzeigemanager).
      </para>
      <para>
        <systemitem class="daemon">systemd</systemitem> führt mit den sogenannten <quote>Ziel-Units ein neues Konzept ein</quote>. Dennoch bleibt die Kompatibilität mit dem Runlevel-Konzept uneingeschränkt erhalten. Die Ziel-Units tragen Namen statt Zahlen und erfüllen bestimmte Zwecke. Mit den Zielen <systemitem>local-fs.target</systemitem> und <systemitem>swap.target</systemitem> werden beispielsweise lokale Dateisysteme und Auslagerungsbereiche eingehängt.
      </para>
      <para>
        Das Ziel <systemitem>graphical.target</systemitem> stellt ein Mehrbenutzersystem mit Netzwerk sowie Anzeigemanager-Funktionen bereit und entspricht Runlevel 5. Komplexe Ziele wie <systemitem>graphical.target</systemitem> fungieren als <quote>Metaziele</quote>, in denen eine Teilmenge anderer Ziele vereint ist. Mit <systemitem class="daemon">systemd</systemitem> können Sie problemlos vorhandene Ziele kombinieren und so benutzerdefinierte Ziele bilden. Damit bietet dieser Befehl eine hohe Flexibilität.
      </para>
      <para>
        Die nachfolgende Liste zeigt die wichtigsten <systemitem class="daemon">systemd</systemitem>-Ziel-Units. Eine vollständige Liste finden Sie in <command>man 7 systemd.special</command>.
      </para>
      <variablelist>
        <title>Ausgewählte <systemitem class="daemon">systemd</systemitem>-Ziel-Units</title>
        <varlistentry>
          <term><systemitem>default.target</systemitem></term>
          <listitem>
            <para>
              Das Ziel, das standardmäßig gebootet wird. Kein <quote>reales</quote> Ziel, sondern ein symbolischer Link zu einem anderen Ziel wie <systemitem>graphic.target</systemitem>. Kann über YaST dauerhaft geändert werden (siehe <xref linkend="sec-boot-runlevel-edit"/>). Soll das Ziel für eine einzige Sitzung geändert werden, geben Sie den Kernel-Parameter <literal>systemd.unit=<replaceable>MY_TARGET.target</replaceable></literal> am Bootprompt ein.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><systemitem>emergency.target</systemitem></term>
          <listitem>
            <para>
              Startet eine minimale <systemitem class="username">root</systemitem>-Notfall-Shell an der Konsole. Dieser Befehl darf nur an der Boot-Eingabeaufforderung im Format <literal>systemd.unit=emergency.target</literal> verwendet werden.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><systemitem>graphical.target</systemitem></term>
          <listitem>
            <para>
              Startet ein System mit Netzwerk, Mehrbenutzerunterstützung und Anzeigemanager.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><systemitem>halt.target</systemitem></term>
          <listitem>
            <para>
              Fährt das System herunter.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><systemitem>mail-transfer-agent.target</systemitem></term>
          <listitem>
            <para>
              Startet alle Dienste, die zum Senden und Empfangen von Mails erforderlich sind.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><systemitem>multi-user.target</systemitem></term>
          <listitem>
            <para>
              Startet ein Mehrbenutzersystem mit Netzwerk.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><systemitem>reboot.target</systemitem></term>
          <listitem>
            <para>
              Bootet das System neu.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><systemitem>rescue.target</systemitem></term>
          <listitem>
            <para>
              Startet ein <systemitem class="username">root</systemitem>-Einzelbenutzersystem ohne Netzwerk. Es stehen grundlegende Werkzeuge für die Systemadministration zur Verfügung. Das <literal>rescue</literal>-Ziel eignet sich zum Lösen mehrerer Systemprobleme, z. B. zum Beheben fehlerhafter Anmeldungen oder zum Beheben von Problemen mit einem Anzeigetreiber.
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
        Damit die Kompatibilität mit dem Runlevel-System von System V-init gewährleistet bleibt, bietet <systemitem class="daemon">systemd</systemitem> besondere Ziele mit der Bezeichnung <literal>runlevel<replaceable>X</replaceable>.target</literal>, denen die entsprechenden, mit <replaceable>X</replaceable> nummerierten Runlevels zugeordnet sind.
      </para>
      <para>
        Verwenden Sie zum Prüfen des aktuellen Ziels den folgenden Befehl: <command>systemctl
        get-default</command>
      </para>
      <table rowsep="1">
        <title>System V-Runlevels und <systemitem class="daemon">systemd</systemitem>-Ziel-Units</title>
        <tgroup cols="3">
          <colspec colnum="1" colname="1" colwidth="20*"/>
          <colspec colnum="2" colname="2" colwidth="40*"/>
          <colspec colnum="3" colname="3" colwidth="40*"/>
          <thead>
            <row>
              <entry>
                <para>
                  System V-Runlevel
                </para>
              </entry>
              <entry>
                <para>
                  <systemitem class="daemon">systemd</systemitem> Ziel
                </para>
              </entry>
              <entry>
                <para>
                  Beschreibung
                </para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>
                  0
                </para>
              </entry>
              <entry>
                <para>
                  <systemitem>runlevel0.target</systemitem>, <systemitem>halt.target</systemitem>, <systemitem>poweroff.target</systemitem>
                </para>
              </entry>
              <entry>
                <para>
                  System herunterfahren
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  1, S
                </para>
              </entry>
              <entry>
                <para>
                  <systemitem>runlevel1.target</systemitem>, <systemitem>rescue.target</systemitem>,
                </para>
              </entry>
              <entry>
                <para>
                  Einzelbenutzermodus
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  2
                </para>
              </entry>
              <entry>
                <para>
                  <systemitem>runlevel2.target</systemitem>, <systemitem>multi-user.target</systemitem>,
                </para>
              </entry>
              <entry>
                <para>
                  Lokaler Mehrbenutzermodus ohne entferntes Netzwerk
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  3
                </para>
              </entry>
              <entry>
                <para>
                  <systemitem>runlevel3.target</systemitem>, <systemitem>multi-user.target</systemitem>,
                </para>
              </entry>
              <entry>
                <para>
                  Mehrbenutzer-Vollmodus mit Netzwerk
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  4
                </para>
              </entry>
              <entry>
                <para>
                  <systemitem>runlevel4.target</systemitem>
                </para>
              </entry>
              <entry>
                <para>
                  Nicht verwendet/benutzerdefiniert
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  5
                </para>
              </entry>
              <entry>
                <para>
                  <systemitem>runlevel5.target</systemitem>, <systemitem>graphical.target</systemitem>,
                </para>
              </entry>
              <entry>
                <para>
                  Mehrbenutzer-Vollmodus mit Netzwerk und Anzeige-Manager
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  6
                </para>
              </entry>
              <entry>
                <para>
                  <systemitem>runlevel6.target</systemitem>, <systemitem>reboot.target</systemitem>,
                </para>
              </entry>
              <entry>
                <para>
                  Systemneustart
                </para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <important>
        <title><systemitem class="daemon">systemd</systemitem> ignoriert <filename>/etc/inittab</filename></title>
        <para>
          Die Runlevels in einem System V-init-System werden in <filename>/etc/inittab</filename> konfiguriert. Bei <systemitem class="daemon">systemd</systemitem> wird diese Konfiguration <emphasis>nicht</emphasis> verwendet. Weitere Anweisungen zum Erstellen eines bootfähigen Ziels finden Sie unter <xref linkend="sec-boot-systemd-custom-targets"/>.
        </para>
      </important>
      <sect3 xml:id="sec-boot-systemd-targets-commands">
        <title>Befehle zum Ändern von Zielen</title>
        <para>
          Mit den folgenden Befehlen arbeiten Sie mit den Ziel-Units:
        </para>
        <informaltable rowsep="1">
          <tgroup cols="3">
            <colspec colnum="1" colname="1" colwidth="20*"/>
            <colspec colnum="2" colname="2" colwidth="50*"/>
            <colspec colnum="3" colname="3" colwidth="30*"/>
            <thead>
              <row>
                <entry colname="1">
                  <para>
                    Aufgabe
                  </para>
                </entry>
                <entry colname="2">
                  <para>
                    <systemitem class="daemon">systemd</systemitem>-Befehl
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    System V-init-Befehl
                  </para>
                </entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry colname="1">
                  <para>
                    Aktuelles Ziel/Runlevel ändern
                  </para>
                </entry>
                <entry colname="2">
                  <para>
                    <command>systemctl isolate</command>
                    <replaceable>MY_TARGET</replaceable>.Ziel
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    <command>telinit</command> <replaceable>X</replaceable>
                  </para>
                </entry>
              </row>
              <row>
                <entry colname="1">
                  <para>
                    Zum standardmäßigen Ziel/Runlevel wechseln
                  </para>
                </entry>
                <entry colname="2">
                  <para>
                    <command>systemctl default</command>
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    n/v
                  </para>
                </entry>
              </row>
              <row>
                <entry colname="1">
                  <para>
                    Aktuelles Ziel/Runlevel abrufen
                  </para>
                </entry>
                <entry colname="2">
                  <para>
                    <command>systemctl list-units --type=target</command>
                  </para>
                  <para>
                    Bei <systemitem class="daemon">systemd</systemitem> sind in der Regel mehrere Ziele aktiv. Mit diesem Befehl werden alle derzeit aktiven Ziele aufgelistet.
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    <command>who -r</command>
                  </para>
                  <para>
                    oder
                  </para>
                  <para>
                    <command>runlevel</command>
                  </para>
                </entry>
              </row>
              <row>
                <entry colname="1">
                  <para>
                    Standard-Runlevel dauerhaft ändern
                  </para>
                </entry>
                <entry colname="2">
                  <para>
                    Verwenden Sie die Dienste-Verwaltung, oder führen Sie den folgenden Befehl aus:
                  </para>
                  <para>
                    <command>ln -sf /usr/lib/systemd/system/</command>
                    <replaceable>MY_TARGET</replaceable>.target /etc/systemd/system/default.target
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    Verwenden Sie die Dienste-Verwaltung, oder ändern Sie die Zeile
                  </para>
                  <para>
                    <command>id:</command>
                    <replaceable>X</replaceable>:initdefault:
                  </para>
                  <para>
                    in <filename>/etc/inittab</filename>
                  </para>
                </entry>
              </row>
              <row>
                <entry colname="1">
                  <para>
                    Standard-Runlevel für den aktuellen Bootprozess ändern
                  </para>
                </entry>
                <entry colname="2">
                  <para>
                    Geben Sie an der Boot-Eingabeaufforderung die folgende Option ein:
                  </para>
                  <para>
                    <command>systemd.unit=</command>
                    <replaceable>MY_TARGET</replaceable>.Ziel
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    Geben Sie an der Boot-Eingabeaufforderung die gewünschte Runlevel-Nummer ein.
                  </para>
                </entry>
              </row>
              <row>
                <entry colname="1">
                  <para>
                    Abhängigkeiten für ein Ziel/Runlevel anzeigen
                  </para>
                </entry>
                <entry colname="2">
                  <para>
                    <command>systemctl show -p "Requires"</command>
                    <replaceable>MY_TARGET</replaceable>.Ziel
                  </para>
                  <para>
                    <command>systemctl show -p "Wants"</command>
                    <replaceable>MY_TARGET</replaceable>.Ziel
                  </para>
                  <para>
                    <quote>Requires</quote> (Benötigt) zeigt eine Liste der harten Abhängigkeiten (die in jedem Fall aufgelöst werden müssen), <quote>Wants</quote> (Erwünscht) dagegen eine Liste der weichen Abhängigkeiten (die nach Möglichkeit aufgelöst werden).
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    n/v
                  </para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </sect3>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-debug">
      <title>Fehlersuche beim Systemstart</title>
      <para>
        <systemitem class="daemon">systemd</systemitem> bietet eine Möglichkeit, den Systemstartvorgang zu analysieren. Sie können die Liste der Dienste mit dem jeweiligen Status prüfen (ohne durch <filename>/var/log/</filename> blättern zu müssen). Mit <systemitem class="daemon">systemd</systemitem> können Sie zudem den Startvorgang scannen und so ermitteln, wie lang das Starten der einzelnen Dienste dauert.
      </para>
      <sect3 xml:id="sec-boot-systemd-debug-review">
        <title>Prüfen des Startvorgangs der Dienste</title>
        <para>
          Mit dem Befehl <command>systemctl</command> erzeugen Sie eine Liste aller Dienste, die seit dem Booten des Systems gestartet wurden. Hier werden alle aktiven Dienste wie im nachstehenden (gekürzten) Beispiel aufgeführt. Mit <command>systemctl status
          <replaceable>MY_SERVICE</replaceable></command> erhalten Sie weitere Informationen zu einem bestimmten Dienst.
        </para>
        <example>
          <title>Liste der aktiven Dienste</title>
<screen><prompt role="root"># </prompt>systemctl
UNIT                        LOAD   ACTIVE SUB       JOB DESCRIPTION
[...]
iscsi.service               loaded active exited    Login and scanning of iSC+
kmod-static-nodes.service   loaded active exited    Create list of required s+
libvirtd.service            loaded active running   Virtualization daemon
nscd.service                loaded active running   Name Service Cache Daemon
chronyd.service             loaded active running   NTP Server Daemon
polkit.service              loaded active running   Authorization Manager
postfix.service             loaded active running   Postfix Mail Transport Ag+
rc-local.service            loaded active exited    /etc/init.d/boot.local Co+
rsyslog.service             loaded active running   System Logging Service
[...]
LOAD   = Reflects whether the unit definition was properly loaded.
ACTIVE = The high-level unit activation state, i.e. generalization of SUB.
SUB    = The low-level unit activation state, values depend on unit type.

161 loaded units listed. Pass --all to see loaded but inactive units, too.
To show all installed unit files use 'systemctl list-unit-files'.</screen>
        </example>
        <para>
          Soll die Ausgabe auf Dienste beschränkt werden, die nicht gestartet werden konnten, geben Sie die Option <option>--failed</option> an:
        </para>
        <example>
          <title>Liste der fehlerhaften Dienste</title>
<screen><prompt role="root"># </prompt>systemctl --failed
UNIT                   LOAD   ACTIVE SUB    JOB DESCRIPTION
apache2.service        loaded failed failed     apache
NetworkManager.service loaded failed failed     Network Manager
plymouth-start.service loaded failed failed     Show Plymouth Boot Screen

[...]</screen>
        </example>
      </sect3>
      <sect3 xml:id="sec-boot-systemd-debug-time">
        <title>Fehlersuche für die Startzeit</title>
        <para>
          Mit dem Befehl <command>systemd-analyze</command> in <systemitem class="daemon">systemd</systemitem> führen Sie die Fehlersuche für die Startzeit durch. Hiermit werden der Gesamtzeitaufwand für den Startvorgang sowie eine Liste der beim Starten angeforderten Dienste angezeigt. Auf Wunsch kann auch eine SVG-Grafik erstellt werden, aus der hervorgeht, wie lange der Start der Dienste im Vergleich zu den anderen Diensten dauerte.
        </para>
        <variablelist>
          <varlistentry>
            <term>Auflisten der Startzeit des Systems</term>
            <listitem>
<screen><prompt role="root"># </prompt>systemd-analyze
Startup finished in 2666ms (kernel) + 21961ms (userspace) = 24628ms</screen>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Auflisten der Startzeit der Dienste</term>
            <listitem>
<screen><prompt role="root"># </prompt>systemd-analyze blame
    15.000s backup-rpmdb.service
    14.879s mandb.service
     7.646s backup-sysconfig.service
     4.940s postfix.service
     4.921s logrotate.service
     4.640s libvirtd.service
     4.519s display-manager.service
     3.921s btrfsmaintenance-refresh.service
     3.466s lvm2-monitor.service
     2.774s plymouth-quit-wait.service
     2.591s firewalld.service
     2.137s initrd-switch-root.service
     1.954s ModemManager.service
     1.528s rsyslog.service
     1.378s apparmor.service
    [...]
</screen>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Grafische Darstellung der Startzeit der Dienste</term>
            <listitem>
<screen><prompt role="root"># </prompt>systemd-analyze plot &gt; jupiter.example.com-startup.svg</screen>
              <informalfigure>
                <mediaobject>
                  <imageobject role="fo">
                    <imagedata fileref="systemd_startup.svg" width="75%"/>
                  </imageobject>
                  <imageobject role="html">
                    <imagedata fileref="systemd_startup.png" width="75%"/>
                  </imageobject>
                </mediaobject>
              </informalfigure>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect3>
      <sect3 xml:id="sec-boot-systemd-debug-complete">
        <title>Prüfen des gesamten Startvorgangs</title>
        <para>
          Die Befehle oben listen die gestarteten Dienste und ihre Startzeiten auf. Eine detailliertere Übersicht erhalten Sie, wenn Sie folgende Parameter an der Boot-Eingabeaufforderung angeben, damit <systemitem class="daemon">systemd</systemitem> ein ausführliches Protokoll des gesamten Startvorgangs erstellt.
        </para>
<screen>systemd.log_level=debug systemd.log_target=kmsg</screen>
        <para>
          <systemitem class="daemon">systemd</systemitem> schreibt die Protokollmeldungen nunmehr in den Kernel-Ringpuffer. Diesen Puffer zeigen Sie mit <command>dmesg</command> an:
        </para>
<screen><prompt>&gt; </prompt>dmesg -T | less</screen>
      </sect3>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-sysv-compatibility">
      <title>System V-Kompatibilität</title>
      <para>
        <systemitem class="daemon">systemd</systemitem> ist mit System V kompatibel, sodass Sie vorhandene System V-init-Skripte weiterhin nutzen können. Es gibt allerdings mindestens ein bekanntes Problem, bei dem ein System V-init-Skript nicht ohne Weiteres mit <systemitem class="daemon">systemd</systemitem> zusammenarbeitet: Wenn Sie einen Dienst als ein anderer Benutzer über <command>su</command> oder <command>sudo</command> in init-Skripten starten, tritt der Fehler <quote>Access denied</quote> (Zugriff verweigert) auf.
      </para>
      <para>
        Wenn Sie den Benutzer mit <command>su</command> oder <command>sudo</command> ändern, wird eine PAM-Sitzung gestartet. Diese Sitzung wird beendet, sobald das init-Skript abgeschlossen ist. Als Folge wird auch der Dienst, der durch das init-Skript gestartet wurde, beendet. Als Workaround für diesen Fehler gehen Sie wie folgt vor:
      </para>
      <procedure>
        <step>
          <para>
            Erstellen Sie einen Service-Datei-Wrapper mit demselben Namen wie das init-Skript und der Dateinamenerweiterung <filename>.service</filename>:
          </para>
<screen>[Unit]
Description=<replaceable>DESCRIPTION</replaceable>
After=network.target

[Service]
User=<replaceable>USER</replaceable>
Type=forking<co xml:id="co-service-wrapper-type"/>
PIDFile=<replaceable>PATH TO PID FILE</replaceable><xref linkend="co-service-wrapper-type" xrefstyle="select:label nopage"/>
ExecStart=<replaceable>PATH TO INIT SCRIPT</replaceable> start
ExecStop=<replaceable>PATH TO INIT SCRIPT</replaceable> stop
ExecStopPost=/usr/bin/rm -f <replaceable>PATH TO PID FILE</replaceable><xref linkend="co-service-wrapper-type" xrefstyle="select:label nopage"/>

[Install]
WantedBy=multi-user.target<co xml:id="co-service-wrapper-target"/></screen>
          <para>
            Ersetzen Sie alle Werte in <replaceable>UPPERCASE
            LETTERS</replaceable> durch die entsprechenden Werte.
          </para>
          <calloutlist>
            <callout arearefs="co-service-wrapper-type">
              <para>
                Optional; nur zu verwenden, wenn mit dem init-Skript ein Daemon gestartet wird.
              </para>
            </callout>
            <callout arearefs="co-service-wrapper-target">
              <para>
                <literal>multi-user.target</literal> startet ebenfalls das init-Skript, wenn Sie in <literal>graphical.target</literal> booten. Falls der Start nur beim Booten in den Display-Manager erfolgen soll, verwenden Sie <literal>graphical.target</literal>.
              </para>
            </callout>
          </calloutlist>
        </step>
        <step>
          <para>
            Starten Sie den Daemon mit <command>systemctl start
            <replaceable>APPLICATION</replaceable></command>.
          </para>
        </step>
      </procedure>
    </sect2>
  </sect1>
  <sect1 xml:id="sec-boot-runlevel-edit">
    <title>Verwalten von Diensten mit YaST</title>

    <para>
      Grundlegende Aufgaben können auch mit dem YaST-Modul Dienste-Verwaltung ausgeführt werden. Hiermit werden das Starten, Stoppen, Aktivieren und Deaktivieren von Diensten unterstützt. Darüber hinaus können Sie den Status eines Dienstes abrufen und das Standardziel ändern. Starten Sie das YaST-Modul mit <menuchoice> <guimenu>YaST</guimenu>
      <guimenu>System</guimenu> <guimenu>Dienste-Verwaltung</guimenu>
      </menuchoice>.
    </para>

    <figure xml:id="fig-yast2-runlevel">
      <title>Services Manager</title>
      <mediaobject>
        <imageobject role="fo">
          <imagedata fileref="yast2_runlevel.png" width="75%"/>
        </imageobject>
        <imageobject role="html">
          <imagedata fileref="yast2_runlevel.png" width="75%"/>
        </imageobject>
      </mediaobject>
    </figure>

    <variablelist>
      <varlistentry>
        <term>Ändern des <guimenu>Standard-Systemziels</guimenu></term>
        <listitem>
          <para>
            Zum Ändern des Ziels, in das das System gebootet wird, wählen Sie ein Ziel in der Dropdown-Liste <guimenu>Default System Target</guimenu> aus. Die häufigsten Ziele sind <guimenu>Graphical Interface</guimenu> (Grafische Oberfläche; öffnet einen grafischen Anmeldebildschirm) und <guimenu>Multi-User</guimenu> (Mehrbenutzer; startet das System im Befehlszeilenmodus).
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Starten oder Stoppen eines Dienstes</term>
        <listitem>
          <para>
            Wählen Sie einen Dienst in der Tabelle aus. Die Spalte <guimenu>Aktiv</guimenu> zeigt, ob er derzeit ausgeführt wird (<guimenu>Aktiv</guimenu>) oder nicht (<guimenu>Inaktiv</guimenu>). Mit <guimenu>Starten</guimenu> bzw. <guimenu>Stoppen</guimenu> schalten Sie den Status um.
          </para>
          <para>
            Durch das Starten und Stoppen eines Dienstes wird sein Status für die aktuelle Sitzung geändert. Soll der Status beim Neubooten geändert werden, müssen Sie den Dienst aktivieren oder deaktivieren.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Definieren des Verhaltens beim Starten von Diensten</term>
        <listitem>
          <para>
            Dienste können entweder automatisch bei Booten oder manuell gestartet werden. Wählen Sie einen Dienst in der Tabelle aus. Die Spalte <guimenu>Start</guimenu> zeigt, ob er derzeit gestartet ist <guimenu>Manuell</guimenu> oder <guimenu>Beim Booten</guimenu>. Mit <guimenu>Startmodus</guimenu> schalten Sie den Status um.
          </para>
          <para>
            Um den Status eines Dienstes in der aktuellen Sitzung zu ändern, müssen Sie ihn wie oben beschrieben starten oder stoppen.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Anzeigen von Statusmeldungen</term>
        <listitem>
          <para>
            Zum Anzeigen der Statusmeldungen für einen Dienst wählen Sie den gewünschten Dienst in der Liste aus und wählen Sie <guimenu>Details anzeigen</guimenu>. Die Ausgabe ist mit der Ausgabe des Befehls <command>systemctl</command>
            <option>-l</option> und dem Status <replaceable>MY_SERVICE</replaceable> identisch.
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
  </sect1>
  <sect1 xml:id="sec-boot-systemd-custom">
    <title>Anpassen <systemitem>systemd</systemitem></title>

    <para>
      In den folgenden Abschnitten wird beschrieben, wie <systemitem class="daemon">systemd</systemitem>-Unit-Dateien angepasst werden.
    </para>
    <sect2 xml:id="systemd-unit-file-placement">
      <title>Wo werden Unit-Dateien gespeichert?</title>
      <para>
        Von SUSE bereitgestellte <systemitem class="daemon">systemd</systemitem>-Unit-Dateien werden in <filename>/usr/lib/systemd/</filename> gespeichert. Benutzerdefinierte Unit-Dateien und <emphasis>Drop-Ins</emphasis> von Unit-Dateien werden in <filename>/etc/systemd/</filename> gespeichert.
      </para>
      <warning>
        <title>Verhindern des Überschreibens Ihrer Anpassung</title>
        <para>
          Verwenden Sie beim Anpassen von <systemitem class="daemon">systemd</systemitem> immer das Verzeichnis <filename>/etc/systemd/</filename> anstelle von <filename>/usr/lib/systemd/</filename>. Ansonsten werden Ihre Änderungen bei der nächsten Aktualisierung von <systemitem class="daemon">systemd</systemitem> überschrieben.
        </para>
      </warning>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-custom-service">
      <title>Überschreiben mit Drop-In-Dateien</title>
      <para>
        Drop-In-Dateien (oder <emphasis>Drop-Ins</emphasis>) sind teilweise Unit-Dateien, die nur bestimmte Einstellungen der Unit-Datei überschreiben. Drop-Ins haben Vorrang vor Hauptkonfigurationsdateien. Der Befehl <command>systemctl edit <replaceable>SERVICE</replaceable></command> startet den Standardtexteditor und erstellt ein Verzeichnis mit einer leeren <filename>override.conf</filename>-Datei in <filename>/etc/systemd/system/<replaceable>NAME</replaceable>.service.d/</filename>. Der Befehl benachrichtigt außerdem den laufenden <systemitem class="daemon">systemd</systemitem>-Vorgang über die Änderungen.
      </para>
      <para>
        Um beispielsweise die Zeit zu ändern, die das System auf den Start von MariaDB wartet, führen Sie <command>sudo systemctl edit mariadb.service</command> aus und bearbeiten die geöffnete Datei so, dass nur die geänderten Zeilen eingefügt werden:
      </para>
<screen>
# Configures the time to wait for start-up/stop
TimeoutSec=300
</screen>
      <para>
        Passen Sie den Wert <literal>TimeoutSec</literal> an und speichern Sie die Änderungen. Führen Sie zum Aktivieren der Änderungen <command>sudo systemctl daemon-reload</command> auf.
      </para>
      <para>
        Weitere Informationen finden Sie auf den man-Seiten, die Sie mit dem Befehl <command>man 1 systemctl</command> aufrufen können.
      </para>
      <warning>
        <title>Erstellen einer Kopie einer vollständigen Unit-Datei</title>
        <para>
          Wenn Sie die Option <option>--full</option> im Befehl <command>systemctl edit --full
          <replaceable>SERVICE</replaceable></command> verwenden, wird eine Kopie der ursprünglichen Unit-Datei erstellt, in der Sie bestimmte Optionen ändern können. Eine solche Anpassung wird nicht empfohlen, da bei der Aktualisierung der Unit-Datei durch SUSE ihre Änderungen durch die angepasste Kopie im Verzeichnis <filename>/etc/systemd/system/</filename> überschrieben werden. Wenn SUSE Aktualisierungen für Distributions-Drop-Ins bereitstellt, überschreiben sie außerdem die Kopie der Unit-Datei, die mit <option>--full</option> wurde. Um diese Verwirrung zu vermeiden und damit Ihre Anpassung immer gültig bleibt, verwenden Sie Drop-Ins.
        </para>
      </warning>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-custom-drop-in">
      <title>Manuelles Erstellen von Drop-in-Dateien</title>
      <para>
        Neben der Verwendung des Befehls <command>systemctl edit</command> können Sie Drop-Ins manuell erstellen, um mehr Kontrolle über ihre Priorität zu haben. Mit solchen Drop-Ins können Sie sowohl Unit- als auch Daemon-Konfigurationsdateien erweitern, ohne die Dateien selbst bearbeiten oder überschreiben zu müssen. Sie werden in den folgenden Verzeichnissen gespeichert:
      </para>
      <variablelist>
        <varlistentry>
          <term><filename>/etc/systemd/*.conf.d/</filename>, <filename>/etc/systemd/system/*.service.d/</filename></term>
          <listitem>
            <para>
              Drop-Ins, die von Systemadministratoren hinzugefügt und angepasst werden.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><filename>/usr/lib/systemd/*.conf.d/</filename>, <filename>/usr/lib/systemd/system/*.service.d/</filename></term>
          <listitem>
            <para>
              Drop-Ins, die von Anpassungspaketen installiert werden, um Upstream-Einstellungen zu überschreiben. SUSE stellt beispielsweise <package>systemd-default-settings</package> bereit.
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
      <tip>
        <para>
          Auf der Manpage für <command>man 5 systemd.unit</command> finden Sie die vollständige Liste der Unit-Suchpfade.
        </para>
      </tip>
      <para>
        Gehen Sie beispielsweise folgendermaßen vor, um die Ratenbegrenzung zu deaktivieren, die durch die Standardeinstellung von <systemitem class="daemon">systemd-journald</systemitem> erzwungen wird:
      </para>
      <procedure>
        <step>
          <para>
            Erstellen Sie ein Verzeichnis mit dem Namen <filename>/etc/systemd/journald.conf.d</filename>.
          </para>
<screen><prompt>&gt; </prompt><command>sudo</command> mkdir /etc/systemd/journald.conf.d</screen>
          <note>
            <para>
              Der Verzeichnisname muss dem Dienstnamen folgen, den Sie mit der Drop-In-Datei patchen möchten.
            </para>
          </note>
        </step>
        <step>
          <para>
            Erstellen Sie in diesem Verzeichnis eine Datei mit der Option <filename>/etc/systemd/journald.conf.d/60-rate-limit.conf</filename>, die Sie überschreiben möchten, z. B.:
          </para>
<screen><prompt>&gt; </prompt><command>cat /etc/systemd/journald.conf.d/60-rate-limit.conf</command>
# Disable rate limiting
RateLimitIntervalSec=0</screen>
        </step>
        <step>
          <para>
            Speichern Sie Ihre Änderungen und starten Sie den Dienst des entsprechenden Daemons <systemitem class="daemon">systemd</systemitem> neu.
          </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl restart systemd-journald</screen>
        </step>
      </procedure>
      
      <note>
        <title>Vermeiden von Namenskonflikten</title>
        <para>
          Damit Namenskonflikte zwischen Ihren Drop-Ins und von SUSE bereitgestellten Dateien vermieden werden, empfiehlt es sich, allen Drop-Ins eine zweistellige Nummer und einen Bindestrich voranzustellen, z. B. <filename>80-override.conf</filename>.
        </para>
        <para>
          Die folgenden Bereiche sind reserviert:
        </para>
        <itemizedlist>
          <listitem>
            <para>
              <literal>0-19</literal> ist für <systemitem class="daemon">systemd</systemitem>-Upstream reserviert.
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>20-29</literal> ist für <systemitem class="daemon">systemd</systemitem> reserviert (von SUSE bereitgestellt).
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>30-39</literal> ist für SUSE-Pakete reserviert (außer <systemitem class="daemon">systemd</systemitem>).
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>40-49</literal> ist für Pakete von Drittanbietern reserviert.
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>50</literal> ist für Unit-Drop-In-Dateien reserviert, die mit <command>systemctl set-property</command> erstellt werden.
            </para>
          </listitem>
        </itemizedlist>
        <para>
          Geben Sie eine zweistellige Zahl oberhalb dieses Bereichs an, damit die von SUSE bereitgestellten Drop-Ins Ihre eigenen Drop-Ins nicht überschreiben können.
        </para>
      </note>
      <tip>
        <para>
          Sie können mit <command>systemctl cat $UNIT</command> auflisten und überprüfen, welche Dateien in der Units-Konfiguration berücksichtigt werden.
        </para>
      </tip>
      <tip>
        <para>
          Da die Konfiguration von <systemitem class="daemon">systemd</systemitem>-Komponenten auf verschiedene Stellen im Dateisystem verstreut sein kann, ist es möglicherweise schwierig, einen Gesamtüberblick zu erhalten. Verwenden Sie die folgenden Befehle, um die Konfiguration einer <systemitem class="daemon">systemd</systemitem>-Komponente zu prüfen:
        </para>
        <itemizedlist>
          <listitem>
            <para>
              <command>systemctl cat
              <replaceable>UNIT_PATTERN</replaceable></command> druckt Konfigurationsdateien, die sich auf eine oder mehrere <systemitem class="daemon">systemd</systemitem>-Units beziehen, z. B.:
            </para>
<screen><prompt>&gt; </prompt>systemctl cat atd.service</screen>
          </listitem>
          <listitem>
            <para>
              <command>systemd-analyze cat-config
              <replaceable>DAEMON_NAME_OR_PATH</replaceable></command> kopiert den Inhalt einer Konfigurationsdatei und Drop-Ins für einen <systemitem class="daemon">systemd</systemitem>-Daemon, z. B.:
            </para>
<screen><prompt>&gt; </prompt>systemd-analyze cat-config systemd/journald.conf</screen>
          </listitem>
        </itemizedlist>
      </tip>
    </sect2>

    <sect2 xml:id="systemd-xinetd-conversion">
      <title>Konvertieren von <systemitem>xinetd</systemitem>-Diensten in <systemitem class="daemon">systemd</systemitem></title>
      <para>
        Seit der Version <phrase role="productname"><phrase os="sled">SUSE Linux Enterprise Desktop</phrase></phrase> 15 wurde die <systemitem>xinetd</systemitem>-Infrastruktur entfernt. In diesem Abschnitt wird beschrieben, wie Sie vorhandene benutzerdefinierte <systemitem>xinetd</systemitem>-Dienstdateien in <systemitem class="daemon">systemd</systemitem>-Sockets konvertieren.
      </para>
      <para>
        Für jede <systemitem>xinetd</systemitem>-Dienstdatei benötigen Sie mindestens zwei <systemitem class="daemon">systemd</systemitem>-Unit-Dateien: die Socket-Datei (<filename>*.socket</filename>) und eine zugehörige Dienstdatei (<filename>*.service</filename>). Die Socket-Datei weist <systemitem class="daemon">systemd</systemitem> an, welcher Socket erstellt werden soll, und die Dienstdatei weist <systemitem class="daemon">systemd</systemitem> an, welche ausführbare Datei gestartet werden soll.
      </para>
      <para>
        Betrachten Sie das folgende Beispiel für eine <systemitem>xinetd</systemitem>-Dienstdatei:
      </para>
<screen><prompt role="root"># </prompt>cat /etc/xinetd.d/example
service example
{
  socket_type = stream
  protocol = tcp
  port = 10085
  wait = no
  user = user
  group = users
  groups = yes
  server = /usr/libexec/example/exampled
  server_args = -auth=bsdtcp exampledump
  disable = no
}</screen>
      <para>
        Zum Konvertieren in <systemitem class="daemon">systemd</systemitem> benötigen Sie die folgenden beiden Dateien:
      </para>
<screen><prompt role="root"># </prompt>cat /usr/lib/systemd/system/example.socket
[Socket]
ListenStream=0.0.0.0:10085
Accept=false

[Install]
WantedBy=sockets.target</screen>
<screen><prompt role="root"># </prompt>cat /usr/lib/systemd/system/example.service
[Unit]
Description=example

[Service]
ExecStart=/usr/libexec/example/exampled -auth=bsdtcp exampledump
User=user
Group=users
StandardInput=socket
</screen>
      <para>
        Eine vollständige Liste der <systemitem class="daemon">systemd</systemitem> <quote>Socket</quote>- und <quote>Dienst</quote>-Dateioptionen finden Sie auf den Handbuchseiten für „systemd.socket“ und „systemd.service“ (<command>man 5 systemd.socket</command>, <command>man 5 systemd.service</command>).
      </para>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-custom-targets">
      <title>Erstellen von benutzerdefinierten Zielen</title>
      <para>
        Auf SUSE-Systemen mit System V-init wird Runlevel 4 nicht genutzt, sodass die Administratoren eine eigene Runlevel-Konfiguration erstellen können. Mit <systemitem class="daemon">systemd</systemitem> können Sie beliebig viele benutzerdefinierte Ziele erstellen. Zum Einstieg sollten Sie ein vorhandenes Ziel anpassen, beispielsweise <systemitem>graphical.target</systemitem>.
      </para>
      <procedure>
        <step>
          <para>
            Kopieren Sie die Konfigurationsdatei <filename>/usr/lib/systemd/system/graphical.target</filename> in <filename>/etc/systemd/system/<replaceable>MY_TARGET</replaceable>.target</filename> und passen Sie sie entsprechend Ihrer Anforderungen an.
          </para>
        </step>
        <step>
          <para>
            Die im vorangegangenen Schritt kopierte Konfigurationsdatei enthält bereits die erforderlichen (<quote>harten</quote>) Abhängigkeiten für das Ziel. Um auch die gewünschten (<quote>weichen</quote>) Abhängigkeiten abzudecken, erstellen Sie das Verzeichnis <filename>/etc/systemd/system/<replaceable>MY_TARGET</replaceable>.target.wants</filename>.
          </para>
        </step>
        <step>
          <para>
            Erstellen Sie für jeden gewünschten Dienst einen symbolischen Link von <filename>/usr/lib/systemd/system</filename> nach <filename>/etc/systemd/system/<replaceable>MY_TARGET</replaceable>.target.wants</filename>.
          </para>
        </step>
        <step>
          <para>
            Sobald Sie alle Einstellungen für das Ziel festgelegt haben, laden Sie die <systemitem class="daemon">systemd</systemitem>-Konfiguration neu. Damit wird das neue Ziel verfügbar:
          </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl daemon-reload</screen>
        </step>
      </procedure>
    </sect2>
  </sect1>
  <sect1 xml:id="sec-boot-systemd-advanced">
    <title>Erweiterte Nutzung</title>

    <para>
      In den nachfolgenden Abschnitten finden Sie weiterführende Themen für Systemadministratoren. Eine noch eingehendere Dokumentation zu <systemitem class="daemon">systemd</systemitem> finden Sie in der Serie von Lennart Pöttering zu <systemitem class="daemon">systemd</systemitem> für Administratoren unter <link xlink:href="https://0pointer.de/blog/projects/"/>.
    </para>

    <sect2 xml:id="sec-boot-systemd-advanced-tmp">
      <title>Bereinigen von temporären Verzeichnissen</title>
      <para>
        <systemitem class="daemon">systemd</systemitem> unterstützt das regelmäßige Bereinigen der temporären Verzeichnisse. Die Konfiguration aus der bisherigen Systemversion wird automatisch migriert und ist aktiv. <literal>tmpfiles.d</literal> – für die Verwaltung temporärer Dateien verantwortlich – liest ihre Konfiguration aus den Dateien <filename>/etc/tmpfiles.d/*.conf</filename>, <filename>/run/tmpfiles.d/*.conf</filename> und <filename>/usr/lib/tmpfiles.d/*.conf</filename>. Die Konfiguration in <filename>/etc/tmpfiles.d/*.conf</filename> hat Vorrang vor ähnlichen Konfigurationen in den anderen beiden Verzeichnissen. (In <filename>/usr/lib/tmpfiles.d/*.conf</filename> werden die Konfigurationsdateien der Pakete gespeichert.)
      </para>
      <para>
        Im Konfigurationsformat ist eine Zeile pro Pfad vorgeschrieben, wobei diese Zeile die Aktion und den Pfad enthalten muss und optional Felder für Modus, Eigentümer, Alter und Argument (je nach Aktion) enthalten kann. Im folgenden Beispiel wird die Verknüpfung der X11-Sperrdateien aufgehoben:
      </para>
<screen>Type Path               Mode UID  GID  Age Argument
r    /tmp/.X[0-9]*-lock</screen>
      <para>
        So rufen Sie den Status aus dem tmpfile-Zeitgeber ab:
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl status systemd-tmpfiles-clean.timer
systemd-tmpfiles-clean.timer - Daily Cleanup of Temporary Directories
 Loaded: loaded (/usr/lib/systemd/system/systemd-tmpfiles-clean.timer; static)
 Active: active (waiting) since Tue 2018-04-09 15:30:36 CEST; 1 weeks 6 days ago
   Docs: man:tmpfiles.d(5)
         man:systemd-tmpfiles(8)

Apr 09 15:30:36 jupiter systemd[1]: Starting Daily Cleanup of Temporary Directories.
Apr 09 15:30:36 jupiter systemd[1]: Started Daily Cleanup of Temporary Directories.</screen>
      <para>
        Weitere Informationen zum Arbeiten mit temporären Dateien finden Sie unter <command>man 5
        tmpfiles.d</command>.
      </para>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-advanced-logging">
      <title>Systemprotokoll</title>
      <para>
        In <xref linkend="sec-boot-systemd-basics-services-debugging"/> wird erläutert, wie Sie Protokollmeldungen für einen bestimmten Dienst anzeigen. Die Anzeige von Protokollmeldungen ist allerdings nicht auf Dienstprotokolle beschränkt. Sie können auch auf das gesamte von <systemitem class="daemon">systemd</systemitem> geschriebene Protokoll (das sogenannte <quote>Journal</quote>) zugreifen und Abfragen darauf ausführen. Mit dem Befehl <command>journalctl</command> zeigen Sie das gesamte Protokoll an, beginnend mit den ältesten Einträgen. Informationen zu weiteren Optionen, beispielsweise zum Anwenden von Filtern oder zum Ändern des Ausgabeformats, finden Sie unter <command>man 1
        journalctl</command>.
      </para>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-advanced-snapshots">
      <title>Aufnahmen</title>
      <para>
        Mit dem Unterbefehl <command>isolate</command> können Sie den aktuellen Status von <systemitem class="daemon">systemd</systemitem> als benannten Snapshot speichern und später wiederherstellen. Dies ist beim Testen von Diensten oder benutzerdefinierten Zielen hilfreich, weil Sie jederzeit zu einem definierten Status zurückkehren können. Ein Snapshot ist nur in der aktuellen Sitzung verfügbar; beim Neubooten wird er automatisch gelöscht. Der Snapshot-Name muss auf <filename>.snapshot</filename> enden.
      </para>
      <variablelist>
        <varlistentry>
          <term>Erstellen eines Snapshots</term>
          <listitem>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl snapshot <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Löschen eines Snapshots</term>
          <listitem>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl delete <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Anzeigen eines Snapshots</term>
          <listitem>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl show <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Aktivieren eines Snapshots</term>
          <listitem>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl isolate <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>

    

    

    <sect2 xml:id="sec-boot-systemd-advanced-kernel-modules">
      <title>Laden der Kernelmodule</title>
      <para>
        Mit <systemitem class="daemon">systemd</systemitem> können Kernel-Module automatisch zum Bootzeitpunkt geladen werden, und zwar über die Konfigurationsdatei in <filename>/etc/modules-load.d</filename>. Die Datei sollte den Namen <replaceable>MODULE</replaceable>.conf haben und den folgenden Inhalt aufweisen:
      </para>
<screen># load module <replaceable>MODULE</replaceable> at boot time
<replaceable>MODULE</replaceable></screen>
      <para>
        Falls ein Paket eine Konfigurationsdatei zum Laden eines Kernel-Moduls installiert, wird diese Datei unter <filename>/usr/lib/modules-load.d</filename> installiert. Wenn zwei Konfigurationsdateien mit demselben Namen vorhanden sind, hat die Datei unter <filename>/etc/modules-load.d</filename> Vorrang.
      </para>
      <para>
        Weitere Informationen finden Sie auf der man-Seite zu <systemitem>modules-load.d(5)</systemitem>.
      </para>
    </sect2>

    

    <sect2 xml:id="sec-boot-systemd-advanced-before-local">
      <title>Ausführen von Aktionen vor dem Laden eines Dienstes</title>
      <para>
        Bei System V mussten init-Aktionen, die vor dem Laden eines Dienstes ausgeführt werden müssen, in <filename>/etc/init.d/before.local
        </filename> festgelegt werden. Dieses Verfahren wird in <systemitem class="daemon">systemd</systemitem> nicht mehr unterstützt. Wenn Aktionen vor dem Starten von Diensten ausgeführt werden müssen, gehen Sie wie folgt vor:
      </para>
      <variablelist>
        <varlistentry>
          <term>Laden der Kernelmodule</term>
          <listitem>
            <para>
              Erstellen Sie eine Drop-in-Datei im Verzeichnis <filename>/etc/modules-load.d</filename> (Syntax siehe <command>man modules-load.d</command>).
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Erstellen von Dateien oder Verzeichnissen, Bereinigen von Verzeichnissen, Ändern des Eigentümers</term>
          <listitem>
            <para>
              Erstellen Sie eine Drop-in-Datei in <filename>/etc/tmpfiles.d</filename> (Syntax siehe <command>man tmpfiles.d</command>).
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Weitere Aufgaben</term>
          <listitem>
            <para>
              Erstellen Sie eine Systemdienstdatei (beispielsweise <filename>/etc/systemd/system/before.service</filename>) anhand der folgenden Vorlage:
            </para>
<screen>[Unit]
Before=<replaceable>NAME OF THE SERVICE YOU WANT THIS SERVICE TO BE STARTED BEFORE</replaceable>
[Service]
Type=oneshot
RemainAfterExit=true
ExecStart=<replaceable>YOUR_COMMAND</replaceable>
# beware, executable is run directly, not through a shell, check the man pages
# systemd.service and systemd.unit for full syntax
[Install]
# target in which to start the service
WantedBy=multi-user.target
#WantedBy=graphical.target</screen>
            <para>
              Sobald die Dienstdatei erstellt ist, führen Sie die folgenden Befehle aus (als <systemitem class="username">root</systemitem>):
            </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl daemon-reload
<prompt>&gt; </prompt><command>sudo</command> systemctl enable before</screen>
            <para>
              Bei jedem Bearbeiten der Dienstdatei müssen Sie Folgendes ausführen:
            </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl daemon-reload</screen>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>

    

    <sect2 xml:id="sec-boot-systemd-advanced-cgroups">
      <title>Kernel-Steuergruppen (cgroups)</title>
      <para>
        Auf einem traditionellen System-V-init-System kann ein Prozess nicht immer eindeutig dem Dienst zugeordnet werden, durch den er erzeugt wurde. Bestimmt Dienste (z. B. Apache) erzeugen zahlreiche externe Prozesse (z. B. CGI- oder Java-Prozesse), die wiederum weitere Prozesse erzeugen. Eindeutige Zuweisungen sind damit schwierig oder völlig unmöglich. Wenn ein Dienst nicht ordnungsgemäß beendet wird, bleiben zudem ggf. bestimmte untergeordnete Dienste weiterhin aktiv.
      </para>
      <para>
        Bei <systemitem class="daemon">systemd</systemitem> wird jeder Dienst in eine eigene cgroup aufgenommen, womit dieses Problem gelöst ist. cgroups sind eine Kernel-Funktion, mit der die Prozesse mit allen ihren untergeordneten Prozessen in hierarchisch strukturierten Gruppen zusammengefasst werden. <systemitem class="daemon">systemd</systemitem> benennt die cgroups dabei nach dem jeweiligen Dienst. Da ein nicht privilegierter Dienst seine cgroup nicht <quote>verlassen</quote> darf, ist es damit möglich, alle von einem Dienst erzeugten Prozesse mit dem Namen dieses Dienstes zu versehen.
      </para>
      <para>
        Mit dem Befehl <command>systemd-cgls</command> erhalten Sie eine Liste aller Prozesse, die zu einem Dienst gehören, z. B.:
      </para>
      <example>
        <title>Auflisten aller Prozesse, die zu einem Dienst gehören</title>
<screen><prompt role="root"># </prompt>systemd-cgls --no-pager
├─1 /usr/lib/systemd/systemd --switched-root --system --deserialize 20
├─user.slice
│ └─user-1000.slice
│   ├─session-102.scope
│   │ ├─12426 gdm-session-worker [pam/gdm-password]
│   │ ├─15831 gdm-session-worker [pam/gdm-password]
│   │ ├─15839 gdm-session-worker [pam/gdm-password]
│   │ ├─15858 /usr/lib/gnome-terminal-server

[...]

└─system.slice
  ├─systemd-hostnamed.service
  │ └─17616 /usr/lib/systemd/systemd-hostnamed
  ├─cron.service
  │ └─1689 /usr/sbin/cron -n
  ├─postfix.service
  │ ├─ 1676 /usr/lib/postfix/master -w
  │ ├─ 1679 qmgr -l -t fifo -u
  │ └─15590 pickup -l -t fifo -u
  ├─sshd.service
  │ └─1436 /usr/sbin/sshd -D

[...]</screen>
      </example>
      <para>
        Weitere Informationen zu cpgroups finden Sie im <xref linkend="cha-tuning-cgroups"/>.
      </para>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-advanced-kill">
      <title>Beenden von Diensten (Senden von Signalen)</title>
      <para>
        Wie in <xref linkend="sec-boot-systemd-advanced-cgroups"/> erläutert, kann ein Prozess in einem System-V-init-System nicht immer eindeutig seinem übergeordneten Dienstprozess zugeordnet werden. Das erschwert das Anhalten eines Diensts und seiner untergeordneten Dienste. Untergeordnete Prozesse, die nicht ordnungsgemäß beendet wurden, bleiben als „Zombie-Prozesse“ zurück.
      </para>
      <para>
        Durch das Konzept von <systemitem class="daemon">systemd</systemitem>, mit dem jeder Dienst in einer eigenen cgroup abgegrenzt wird, können alle untergeordneten Prozesse eines Diensts erkannt werden, so dass Sie ein Signal zu diesen Prozessen senden können. Mit Use <command>systemctl kill</command> senden Sie die Signale an die Dienste. Eine Liste der verfügbaren Signale finden Sie in <command>man 7 signals</command>.
      </para>
      <variablelist>
        <varlistentry>
          <term>Senden von <systemitem>SIGTERM</systemitem> an einen Dienst</term>
          <listitem>
            <para>
              <systemitem>SIGTERM</systemitem> ist das standardmäßig gesendete Signal.
            </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl kill <replaceable>MY_SERVICE</replaceable></screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Senden von <replaceable>SIGNAL</replaceable> an einen Dienst</term>
          <listitem>
            <para>
              Mit der Option <option>-s</option> legen Sie das zu sendende Signal fest.
            </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl kill -s <replaceable>SIGNAL</replaceable> <replaceable>MY_SERVICE</replaceable></screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Auswählen von Prozessen</term>
          <listitem>
            <para>
              Standardmäßig sendet der Befehl <command>kill</command> das Signal an alle (<option>all</option>) Prozesse der angegebenen cgroup. Sie können dies jedoch auf den Prozess <option>control</option> oder <option>main</option> beschränken. Damit können Sie beispielsweise das Neuladen der Konfiguration eines Diensts mit dem Signal <systemitem>SIGHUP</systemitem> erzwingen:
            </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl kill -s SIGHUP --kill-who=main <replaceable>MY_SERVICE</replaceable></screen>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-dbus">
      <title>Wichtige Hinweise zum D-Bus-Dienst</title>
      <para>
        Der D-Bus-Dienst fungiert als Meldungsbus für die Kommunikation zwischen den <systemitem class="daemon">systemd</systemitem>-Clients und dem systemd-Manager, der als PID 1 ausgeführt wird. <systemitem class="daemon">dbus</systemitem> ist zwar ein eigenständiger Dämon, bildet jedoch auch einen wesentlichen Bestandteil der init-Infrastruktur.
      </para>
      <para>
        Das Anhalten von <systemitem class="daemon">dbus</systemitem> oder das Neustarten im laufenden System entspricht dem Versuch, PID 1 zu anzuhalten oder neu zu starten. Dadurch wird die Client/Server-Kommunikation von <systemitem class="daemon">systemd</systemitem> unterbrochen und die meisten <systemitem class="daemon">systemd</systemitem>-Funktionen werden unbrauchbar.
      </para>
      <para>
        Das Beenden oder Neustarten von <systemitem class="daemon">dbus</systemitem> wird daher weder empfohlen noch unterstützt.
      </para>
      <para>
        Nach einer Aktualisierung von <systemitem>dbus</systemitem> oder <systemitem>dbus</systemitem>-Paketen fällt ein Neustart an. Wenn Sie sich nicht sicher sind, ob ein Neustart erforderlich ist, führen Sie den Befehl <command>sudo zypper ps
        -s</command> aus. Ist <literal>dbus</literal> unter den aufgelisteten Diensten zu finden, müssen Sie das System neu starten.
      </para>
      <para>
        Beachten Sie, dass <systemitem>dbus</systemitem> selbst dann aktualisiert wird, wenn in der Konfiguration der automatischen Aktualisierungen festgelegt ist, dass die Pakete, die einen Neustart erfordern, übersprungen werden sollen.
      </para>
    </sect2>

    

    <sect2 xml:id="sec-boot-systemd-basics-services-debugging">
      <title>Fehlersuche für Dienste</title>
      <para>
        Standardmäßig ist die Ausgabe von <systemitem class="daemon">systemd</systemitem> auf ein Minimum beschränkt. Wenn ein Dienst ordnungsgemäß gestartet wurde, erfolgt keine Ausgabe. Bei einem Fehler wird eine kurze Fehlermeldung angezeigt. <command>systemctl
        status</command> bietet jedoch eine Möglichkeit, den Start und Betrieb eines Diensts zu debuggen.
      </para>
      <para>
        <systemitem class="daemon">systemd</systemitem> umfasst einen Protokollierungsmechanismus (<quote>Journal</quote>), mit dem die Systemmeldungen protokolliert werden. Auf diese Weise können Sie die Dienstmeldungen zusammen mit den Statusmeldungen abrufen. Der Befehl <command>status</command> hat eine ähnliche Funktion wie <command>tail</command> und kann zudem die Protokollmeldungen in verschiedenen Formaten anzeigen, ist also ein wirksames Hilfsmittel für die Fehlersuche.
      </para>
      <variablelist>
        <varlistentry>
          <term>Anzeigen von Fehlern beim Starten von Diensten</term>
          <listitem>
            <para>
              Wenn ein Dienst nicht gestartet wird, erhalten Sie mit <command>systemctl status
              <replaceable>MY_SERVICE</replaceable></command> eine ausführliche Fehlermeldung:
            </para>
<screen><prompt role="root"># </prompt>systemctl start apache2
Job failed. See system journal and 'systemctl status' for details.
<prompt role="root"># </prompt>systemctl status apache2
   Loaded: loaded (/usr/lib/systemd/system/apache2.service; disabled)
   Active: failed (Result: exit-code) since Mon, 04 Apr 2018 16:52:26 +0200; 29s ago
   Process: 3088 ExecStart=/usr/sbin/start_apache2 -D SYSTEMD -k start (code=exited, status=1/FAILURE)
   CGroup: name=systemd:/system/apache2.service

Apr 04 16:52:26 g144 start_apache2[3088]: httpd2-prefork: Syntax error on line
205 of /etc/apache2/httpd.conf: Syntax error on li...alHost&gt;</screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Anzeigen der letzten <replaceable>N</replaceable> Dienstmeldungen</term>
          <listitem>
            <para>
              Standardmäßig zeigt der Unterbefehl <command>status</command> die letzten zehn Meldungen an, die ein Dienst ausgegeben hat. Mit dem Parameter <option>--lines=<replaceable>N</replaceable></option> legen Sie eine andere Anzahl von Nachrichten fest:
            </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl status chronyd
<prompt>&gt; </prompt><command>sudo</command> systemctl --lines=20 status chronyd</screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Anzeigen von Dienstmeldungen im Anhängemodus</term>
          <listitem>
            <para>
              Mit der Option <option>--follow</option> erhalten Sie einen <quote>Live-Stream</quote> mit Dienstmeldungen; diese Option entspricht <command>tail</command> <option>-f</option>:
            </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl --follow status chronyd</screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Ausgabeformat der Meldungen</term>
          <listitem>
            <para>
              Mit dem Parameter <option>--output=<replaceable>MODE</replaceable></option> legen Sie das Ausgabeformat für die Dienstmeldungen fest. Die wichtigsten Modi sind:
            </para>
            <variablelist>
              <varlistentry>
                <term><option>short</option></term>
                <listitem>
                  <para>
                    Das Standardformat. Zeigt die Protokollmeldungen mit einem Zeitstempel in Klartext an.
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><option>verbose</option></term>
                <listitem>
                  <para>
                    Vollständige Ausgabe mit sämtlichen Feldern.
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><option>cat</option></term>
                <listitem>
                  <para>
                    Kurze Ausgabe ohne Zeitstempel.
                  </para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>
  </sect1>
  <sect1 xml:id="sec-boot-systemd-timer-units">
    <title><systemitem class="daemon">systemd</systemitem>-Zeitgeber-Units</title>

    <para>
      Ähnlich wie Cron bieten <systemitem class="daemon">systemd</systemitem>-Zeitgeber-Units einen Mechanismus für die Planung von Aufträgen unter Linux. Die <systemitem class="daemon">systemd</systemitem>-Zeitgeber-Units dienen zwar demselben Zweck wie Cron, eröffnen allerdings mehrere Vorteile.
    </para>

    <itemizedlist>
      <listitem>
        <para>
          Aufträge, die mit einer Zeitgeber-Unit geplant werden, können von anderen <systemitem class="daemon">systemd</systemitem>-Diensten abhängig sein.
        </para>
      </listitem>
      <listitem>
        <para>
          Zeitgeber-Units werden wie normale <systemitem class="daemon">systemd</systemitem>-Dienste behandelt und können daher mit <command>systemctl</command> verwaltet werden.
        </para>
      </listitem>
      <listitem>
        <para>
          Timer können in Echtzeit und monoton vorliegen.
        </para>
      </listitem>
      <listitem>
        <para>
          Zeiteinheiten werden im <systemitem class="daemon">systemd</systemitem>-Journal protokolliert, was die Überwachung und Fehlerbehebung vereinfacht.
        </para>
      </listitem>
    </itemizedlist>

    <para>
      <systemitem class="daemon">systemd</systemitem>-Zeitgeber-Units sind mit der Dateinamenerweiterung <literal>.timer</literal> gekennzeichnet.
    </para>

    <sect2 xml:id="sec-boot-systemd-timer-types">
      <title><systemitem class="daemon">systemd</systemitem>-Zeitgebertypen</title>
      <para>
        Timer-Einheiten können monotone und Echtzeit-Timer verwenden.
      </para>
      <itemizedlist>
        <listitem>
          <para>
            Ähnlich wie Cronjobs werden Echtzeit-Zeitgeber durch Kalenderereignisse ausgelöst. Echtzeit-Zeitgeber werden mit der Option <option>OnCalendar</option> definiert.
          </para>
        </listitem>
        <listitem>
          <para>
            Monotone Zeitgeber werden ausgelöst, sobald ein angegebener Zeitraum nach einem bestimmten Startpunkt vergangen ist. Dies ist beispielsweise ein Systemstart-Ereignis oder ein System-Unit-Aktivierungsereignis. Für die Definition von monotonen Zeitgebern stehen mehrere Optionen zur Auswahl, einschließlich <option>OnBootSec</option>, <option>OnUnitActiveSec</option> und <option>OnTypeSec</option>. Monotone Timer sind nicht permanent und werden nach jedem Neustart zurückgesetzt.
          </para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-timer-service-units">
      <title><systemitem class="daemon">systemd</systemitem>-Timer und Dienst-Units</title>
      <para>
        Für jede Zeitgeber-Unit muss eine entsprechende <systemitem class="daemon">systemd</systemitem>-Unit-Datei vorliegen, die durch die Zeitgeber-Unit gesteuert wird. Anders ausgedruckt aktiviert und verwaltet eine <filename>.timer</filename>-Datei die entsprechende <filename>.service</filename>-Datei. Wird eine <filename>.service</filename>-Datei mit einem Zeitgeber verwendet, muss die Datei keinen Abschnitt <literal>[Install]</literal> enthalten, da der Dienst durch den Zeitgeber verwaltet wird.
      </para>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-timer-example">
      <title>Beispiel aus der Praxis</title>
      <para>
        Zur Veranschaulichung der Grundlagen von <systemitem class="daemon">systemd</systemitem>-Zeitgeber-Units soll ein Zeitgeber eingerichtet werden, der das Shell-Skript <filename>foo.sh</filename> auslöst.
      </para>
      <para>
        Im ersten Schritt erstellen Sie eine <systemitem class="daemon">systemd</systemitem>-Dienst-Unit, die das Shell-Skript steuert. Öffnen Sie dazu eine neue Textdatei zur Bearbeitung und fügen Sie die folgende Dienst-Unit-Definition hinzu:
      </para>
<screen>[Unit]
Description="Foo shell script"

[Service]
ExecStart=/usr/local/bin/foo.sh</screen>
      <para>
        Speichern Sie die Datei unter dem Namen <filename>foo.service</filename> im Verzeichnis <filename>/etc/systemd/system/</filename>.
      </para>
      <para>
        Öffnen Sie als Nächstes eine neue Textdatei zur Bearbeitung und fügen Sie die folgende Timer-Definition hinzu:
      </para>
<screen>[Unit]
Description="Run foo shell script"

[Timer]
OnBootSec=5min
OnUnitActiveSec=24h
Unit=foo.service

[Install]
WantedBy=multi-user.target</screen>
      <para>
        Der Abschnitt <literal>[Timer]</literal> im Beispiel oben gibt an, welcher Dienst (<literal>foo.service</literal>) ausgelöst werden soll und wann er ausgelöst werden soll. In diesem Fall gibt die Option <option>OnBootSec</option> einen monotonen Zeitgeber an, der den Dienst fünf Minuten nach Systemstart auslöst, während die Option <option>OnUnitActiveSec</option> den Dienst 24 Stunden nach Aktivierung des Diensts auslöst (der Zeitgeber löst den Dienst also einmal täglich aus). Die Option <option>WantedBy</option> gibt schließlich an, dass der Zeitgeber gestartet werden soll, sobald das System das Mehrbenutzerziel erreicht hat.
      </para>
      <para>
        Anstelle eines monotonen Zeitgebers können Sie mit der Option <option>OnCalendar</option> einen Echtzeit-Zeitgeber angeben. Die folgende Echtzeit-Zeitgeberdefinition löst die zugehörige Dienst-Unit einmal wöchentlich aus, beginnend am Montag um 12:00 Uhr.
      </para>
<screen>[Timer]
OnCalendar=weekly
Persistent=true</screen>
      <para>
        Die Option <option>Persistent=true</option> gibt an, dass der Dienst sofort nach Aktivierung des Zeitgebers ausgelöst wird, falls der Zeitgeber die letzte Startzeit versäumt hat (z. B. weil das System ausgeschaltet war).
      </para>
      <para>
        Mit der Option <option>OnCalendar</option> können außerdem bestimmte Zeitpunkte (Datum und Uhrzeit) für die Auslösung eines Dienstes im folgenden Format definiert werden: <literal>DayOfWeek Year-Month-Day Hour:Minute:Second</literal> Im folgenden Beispiel wird ein Dienst täglich um 5:00 Uhr gestartet:
      </para>
<screen>OnCalendar=*-*-* 5:00:00</screen>
      <para>
        Sie können ein Sternchen verwenden, um einen beliebigen Wert anzugeben, und Kommas, um mögliche Werte aufzulisten. Verwenden Sie zwei durch .. getrennte Werte, um einen zusammenhängenden Bereich anzugeben. Im folgenden Beispiel wird ein Dienst an jedem Freitag
im Monat um 18:00 Uhr gestartet:
      </para>
<screen>OnCalendar=Fri *-*-1..7 18:00:00</screen>
      <para>
        Soll ein Dienst zu verschiedenen Zeiten ausgelöst werden, können Sie mehrere <option>OnCalendar</option>-Einträge angeben:
      </para>
<screen>OnCalendar=Mon..Fri 10:00
OnCalendar=Sat,Sun 22:00</screen>
      <para>
        Im Beispiel oben wird ein Dienst an Wochentagen um 10 Uhr und am Wochenende um 22 Uhr ausgelöst.
      </para>
      <para>
        Wenn Sie die Zeitgeber-Unit-Datei bearbeitet haben, speichern Sie sie unter dem Namen <filename>foo.timer</filename> im Verzeichnis <filename>/etc/systemd/system/</filename>. Prüfen Sie die erstellten Unit-Dateien mit folgendem Befehl:
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command>  systemd-analyze verify /etc/systemd/system/foo.*</screen>
      <para>
        Wenn der Befehl keine Ausgabe zurückgibt, haben die Dateien die Überprüfung erfolgreich bestanden.
      </para>
      <para>
        Starten Sie den Zeitgeber mit dem Befehl <command>sudo systemctl start
        foo.timer</command>. Soll der Zeitgeber beim Starten aktiviert werden, führen Sie den Befehl <command>sudo systemctl enable foo.timer</command> aus.
      </para>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-timer-manage">
      <title>Verwalten von <systemitem class="daemon">systemd</systemitem>-Zeitgebern</title>
      <para>
        Da Zeitgeber wie normale <systemitem class="daemon">systemd</systemitem>-Units behandelt werden, können Sie sie mit <command>systemctl</command> verwalten. Sie können einen Timer mit <command>systemctl start</command> starten, einen Timer mit <command>systemctl enable</command> aktivieren usw. Außerdem können Sie mit dem Befehl <command>systemctl
        list-timers</command> alle aktiven Zeitgeber auflisten. Mit dem Befehl <command>systemctl list-timers --all</command> werden alle Zeitgeber aufgelistet, auch wenn sie inaktiv sind.
      </para>
    </sect2>
  </sect1>
  <sect1 xml:id="sec-boot-systemd-info">
    <title>Weitere Informationen</title>

    <para>
      Weitere Informationen zu <systemitem class="daemon">systemd</systemitem> finden Sie in folgenden Online-Quellen:
    </para>

    <variablelist>
      <varlistentry>
        <term>Startseite</term>
        <listitem>
          <para>
            <link xlink:href="https://systemd.io/"/>
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><systemitem class="daemon">systemd</systemitem> für Administratoren</term>
        <listitem>
          <para>
            Lennart Pöttering, einer der <systemitem class="daemon">systemd</systemitem>-Autoren, hat eine Serie von Blogeinträgen verfasst. (Zum Zeitpunkt, als dieses Kapitel verfasst wurde, standen bereits 13 Einträge zur Verfügung.) Diese sind unter <link xlink:href="https://0pointer.de/blog/projects/"/> zu finden.
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
  </sect1>
</chapter>
