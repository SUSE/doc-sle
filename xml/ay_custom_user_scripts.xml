<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>

<sect1 version="5.0" xml:id="createprofile-scripts"
  xmlns="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2001/XInclude"
  xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Custom user scripts</title>

 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker></dm:bugtracker>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>

   <para>
    By adding scripts to the auto-installation process you can customize the
    installation according to your needs and take control in different
    stages of the installation.
   </para>

   <para>
    In the auto-installation process, five types of scripts can be executed
    at different points in time during the installation:
   </para>

   <para>
    All scripts need to be in the &lt;scripts&gt; section.
   </para>

   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>
      <literal>pre-scripts</literal> (very early, before anything else
      really happens)
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>postpartitioning-scripts</literal> (after partitioning and
      mounting to <filename>/mnt</filename> but before RPM installation)
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>chroot-scripts</literal> (after the package installation,
      before the first boot)
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>post-scripts</literal> (during the first boot of the
      installed system, no services running)
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>init-scripts</literal> (during the first boot of the
      installed system, all services up and running)
     </para>
    </listitem>
   </itemizedlist>

   <sect2 xml:id="pre-install-scripts">
    <title>Pre-install scripts</title>
    <para>
     Executed before &yast; does any real change to the system (before
     partitioning and package installation but after the hardware
     detection).
    </para>
    <para>
     You can use a pre-script to modify your control file and let &ay;
     reread it. Find your control file in
     <filename>/tmp/profile/autoinst.xml</filename>. Adjust the file and
     store the modified version in
     <filename>/tmp/profile/modified.xml</filename>. &ay; will read the
     modified file after the pre-script finishes.
    </para>
    <para>
     It is also possible to modify the storage devices in your pre-scripts. For example,
     you can create new partitions or change the configuration of certain technologies
     like multipath. &ay; always inspects the storage devices again after executing all the
     pre-install scripts.
    </para>
    <note>
     <title>Pre-install scripts with confirmation</title>
     <para>
      Pre-scripts are executed at an early stage of the installation. This
      means if you have requested to confirm the installation, the
      pre-scripts will be executed before the confirmation screen shows up
      (<literal>profile/install/general/mode/confirm</literal>).
     </para>
    </note>
    <note>
     <title>Pre-install and Zypper</title>
     <para>
      To call <emphasis>zypper</emphasis> in the pre-install
      script you will need to set the environment variable <emphasis>ZYPP_LOCKFILE_ROOT="/var/run/autoyast"</emphasis>
      to prevent conflicts with the running &yast; process.
     </para>
    </note>
    <para>
     Pre-Install Script elements must be placed as follows:
    </para>
<screen>&lt;scripts&gt;
  &lt;pre-scripts config:type="list"&gt;
    &lt;script&gt;
      ...
    &lt;/script&gt;
  &lt;/pre-scripts&gt;
&lt;/scripts&gt;</screen>
   </sect2>

   <sect2 xml:id="postpartitioning-install-scripts">
    <title>Post-partitioning scripts</title>
    <para>
     Executed after &yast; has done the partitioning and written
     <filename>/etc/fstab</filename>. The empty system is already mounted to
     <filename>/mnt</filename>.
    </para>
    <para>
     Post-partitioning script elements must be placed as follows:
    </para>
<screen>&lt;scripts&gt;
  &lt;postpartitioning-scripts config:type="list"&gt;
    &lt;script&gt;
      ...
    &lt;/script&gt;
  &lt;/postpartitioning-scripts&gt;
&lt;/scripts&gt;</screen>
   </sect2>

   <sect2 xml:id="chroot-scripts">
    <title>Chroot environment scripts</title>
    <para>
     Chroot scripts are executed before the machine reboots for the first
     time. You can execute chroot scripts before the installation chroots
     into the installed system and configures the boot loader or you can
     execute a script after the chroot into the installed system has
     happened (look at the <literal>chrooted</literal> parameter for that).
    </para>
    <para>
     Chroot Environment script elements must be placed as follows:
    </para>
<screen>&lt;scripts&gt;
  &lt;chroot-scripts config:type="list"&gt;
    &lt;script&gt;
      ...
    &lt;/script&gt;
  &lt;/chroot-scripts&gt;
&lt;/scripts&gt;</screen>
   </sect2>

   <sect2 xml:id="post-install-scripts">
    <title>Post-install scripts</title>
    <para>
     These scripts are executed after &ay; has completed the system
     configuration and after it has booted the system for the first time.
    </para>
    <para>
     Post-install script elements must be placed as follows:
    </para>
<screen>&lt;scripts&gt;
    &lt;post-scripts config:type="list"&gt;
      &lt;script&gt;
        ...
      &lt;/script&gt;
    &lt;/post-scripts&gt;
  &lt;/scripts&gt;</screen>
   </sect2>

   <sect2 xml:id="init-scripts">
    <title>Init scripts</title>
    <para>
     These scripts are executed when &yast; has finished, during the
     initial boot process after the network has been initialized. These
     final scripts are executed using
     <filename>/usr/lib/YaST2/bin/autoyast-initscripts.sh</filename> and are
     executed only once. Init scripts are configured using the tag
     <emphasis>init-scripts</emphasis>.
    </para>
    <para>
     Init scripts elements must be placed as follows:
    </para>
<screen>&lt;scripts&gt;
    &lt;init-scripts config:type="list"&gt;
      &lt;script&gt;
        ...
      &lt;/script&gt;
    &lt;/init-scripts&gt;
&lt;/scripts&gt;</screen>

    <para>
     Init scripts are different from the rest of script types because they are
     not executed by &yast;, but after &yast; has finished. For this reason,
     their XML representation is different from other script types.
    </para>
    <table>
     <title>Init script XML representation</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>
         <para>
          Element
         </para>
        </entry>
        <entry>
         <para>
          Description
         </para>
        </entry>
        <entry>
         <para>
          Comment
         </para>
        </entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <para>
          <literal>location</literal>
         </para>
        </entry>
        <entry>
         <para>
          Define a location from where the script gets fetched. Locations
          can be the same as for the profile (HTTP, FTP, NFS, etc.).
         </para>
<screen>&lt;location
&gt;http://10.10.0.1/myInitScript.sh&lt;/location&gt;</screen>
        </entry>
        <entry>
         <para>
          Either &lt;location&gt; or &lt;source&gt; must be
          defined.
         </para>
        </entry>
       </row>
       <row>
        <entry>
         <para>
          <literal>source</literal>
         </para>
        </entry>
        <entry>
         <para>
          The script itself (source code), encapsulated in a CDATA tag. If
          you do not want to put the whole shell script into the XML
          profile, use the location parameter.
         </para>
<screen>&lt;source&gt;
&lt;![CDATA[
echo "Testing the init script" &gt;
/tmp/init_out.txt
]]&gt;
&lt;/source&gt;</screen>
        </entry>
        <entry>
         <para>
          Either &lt;location&gt; or &lt;source&gt; must be
          defined.
         </para>
        </entry>
       </row>
       <row>
        <entry>
         <para>
          <literal>filename</literal>
         </para>
        </entry>
        <entry>
         <para>
          The file name of the script. It will be stored in a temporary
          directory under <filename>/tmp</filename>
         </para>
<screen>&lt;filename&gt;mynitScript5.sh&lt;/filename&gt;</screen>
        </entry>
        <entry>
         <para>
          Optional in case you only have a single init script. The default
          name (<filename>init-scripts</filename>) is used in this case. If
          having specified more than one init script, you must set a unique
          name for each script.
         </para>
        </entry>
       </row>
       <row>
        <entry>
         <para>
          <literal>rerun</literal>
         </para>
        </entry>
        <entry>
         <para>
          Normally, a script is only run once, even if you use <literal>ayast_setup</literal>
          to run an XML file multiple times. Change this default behavior by
          setting this boolean to <literal>true</literal>.
         </para>
<screen>&lt;rerun config:type="boolean"&gt;true&lt;/rerun&gt;</screen>
        </entry>
        <entry>
         <para>
          Optional. Default is <literal>false</literal> (scripts only run
          once).
         </para>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
    <para>
     When added to the control file manually, scripts need to be included in
     a <emphasis>CDATA</emphasis> element to avoid confusion with the file
     syntax and other tags defined in the control file.
    </para>
   </sect2>

   <sect2 xml:id="scripts-syntax">
    <title>Script XML representation</title>
    <para>
     Most of the XML elements described below can be used for all the script
     types described above, except for <emphasis>init scripts</emphasis>, whose
     definitions can contain only a subset of these elements. See <xref
     linkend="init-scripts" /> for further information about them.
    </para>
    <important>
      <title>Deprecated elements</title>
      <para>
       <literal>debug</literal> is a deprecated element and can be removed in future
       releases. To adapt, use an interpreter-specific debugging parameter in <literal>interpreter</literal>.
       E.g. instead of "&lt;interpreter&gt;shell&lt;/interpreter&gt; use
       &lt;interpreter&gt;/bin/sh -x&lt;/interpreter&gt; for the same result
       as having enabled the <literal>debug</literal> flag.
      </para>
    </important>
    <table>
     <title>Script XML representation</title>
     <tgroup cols="3">
      <colspec colwidth="1*"/>
      <colspec colwidth="3*"/>
      <colspec colwidth="2*"/>
      <thead>
       <row>
        <entry>
         <para>
          Element
         </para>
        </entry>
        <entry>
         <para>
          Description
         </para>
        </entry>
        <entry>
         <para>
          Comment
         </para>
        </entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <para>
          <literal>location</literal>
         </para>
        </entry>
        <entry>
         <para>
          Define a location from where the script gets fetched. Locations
          can be the same as for the control file (HTTP, FTP, NFS, etc.).
          Additionally a relative URL can be used that defines a path relative to
          the directory with the control file, using the
          syntax <literal>relurl://script.sh</literal>.
         </para>
<screen>&lt;location
&gt;http://10.10.0.1/myPreScript.sh&lt;/location&gt;</screen>
        </entry>
        <entry>
         <para>
          Either <literal>location</literal> or <literal>source</literal>
          must be defined.
         </para>
        </entry>
       </row>
       <row>
        <entry>
         <para>
          <literal>source</literal>
         </para>
        </entry>
        <entry>
         <para>
          The script itself (source code), encapsulated in a CDATA tag. If
          you do not want to put the whole shell script into the XML control
          file, refer to the location parameter.
         </para>
<screen>&lt;source&gt;
&lt;![CDATA[
echo "Testing the pre script" &gt; /tmp/pre-script_out.txt
]]&gt;
&lt;/source&gt;</screen>
        </entry>
        <entry>
         <para>
          Either <literal>location</literal> or <literal>source</literal>
          must be defined.
         </para>
        </entry>
       </row>
       <row>
        <entry>
         <para>
          <literal>interpreter</literal>
         </para>
        </entry>
        <entry>
         <para>
          Specify the interpreter that must be used for the script.
          Any interpreter available in the given environment can be specified.
          It is possible to provide a full path to the interpreter, including parameters.
          There are also deprecated keywords interpreter "shell", "perl" and "python" that are
          supported by <literal>debug</literal> flag.
         </para>
<screen>&lt;interpreter&gt;/bin/bash -x&lt;/interpreter&gt;</screen>
        </entry>
        <entry>
         <para>
          Optional; default is <literal>shell</literal>.
         </para>
        </entry>
       </row>
       <row>
        <entry>
         <para>
          <literal>file name</literal>
         </para>
        </entry>
        <entry>
         <para>
          The file name of the script. It will be stored in a temporary
          directory under <filename>/tmp</filename>.
         </para>
<screen>&lt;filename&gt;myPreScript5.sh&lt;/filename&gt;</screen>
        </entry>
        <entry>
         <para>
          Optional; default is the type of the script (pre-scripts in this
          case). If you have more than one script, you should define
          different names for each script. If <literal>filename</literal>
          is not defined and <literal>location</literal> is defined,
          the filename from the location path will be used.
         </para>
        </entry>
       </row>
       <row>
        <entry>
         <para>
          <literal>feedback</literal>
         </para>
        </entry>
        <entry>
         <para>
          If this boolean is <literal>true</literal>, output and error
          messages of the script (STDOUT and STDERR) will be shown in a
          pop-up. The user needs to confirm them via the OK button.
         </para>
<screen>&lt;feedback config:type="boolean"&gt;true&lt;/feedback&gt;</screen>
        </entry>
        <entry>
         <para>
          Optional; default is <literal>false</literal>.
         </para>
        </entry>
       </row>
       <row>
        <entry>
         <para>
          <literal>feedback_type</literal>
         </para>
        </entry>
        <entry>
         <para>
          This can be <literal>message</literal>, <literal>warning</literal>
          or <literal>error</literal>. Set the timeout for these pop-ups in
          the &lt;report&gt; section.
         </para>
<screen>&lt;feedback_type&gt;warning&lt;/feedback_type&gt;</screen>
        </entry>
        <entry>
         <para>
          Optional; if missing, an always-blocking pop-up is used.
         </para>
        </entry>
       </row>
       <row>
        <entry>
         <para>
          <literal>debug</literal>
         </para>
        </entry>
        <entry>
         <para>
          If this is <literal>true</literal>, every single line of a shell
          script is logged. Perl scripts are run with warnings turned on.
          This only works for the deprecated keyword <literal>interpreter</literal>.
          For other languages, give the path to the interpreter as a parameter in the 
          <literal>interpreter</literal> value, for example "&lt;interpreter&gt;ruby -w&lt;/interpreter&gt;".
         </para>
<screen>&lt;debug config:type="boolean"&gt;true&lt;/debug&gt;</screen>
        </entry>
        <entry>
         <para>
          Optional; default is <literal>true</literal>.
         </para>
        </entry>
       </row>
       <row>
        <entry>
         <para>
          <literal>notification</literal>
         </para>
        </entry>
        <entry>
         <para>
          This text will be shown in a pop-up for the time the script is
          running in the background.
         </para>
<screen>&lt;notification&gt;Please wait while script is running...&lt;/notification&gt;</screen>
        </entry>
        <entry>
         <para>
          Optional; if not configured, no notification pop-up will be shown.
         </para>
        </entry>
       </row>
       <row>
        <entry>
         <para>
          <literal>param-list</literal>
         </para>
        </entry>
        <entry>
         <para>
          It is possible to specify parameters given to the script being
          called. You may have more than one <literal>param</literal> entry.
          They are concatenated by a single space character on the script
          command line. If any shell quoting should be necessary (for
          example to protect embedded spaces) you need to include this.
         </para>
<screen>&lt;param-list config:type="list"&gt;
  &lt;param&gt;par1&lt;/param&gt;
  &lt;param&gt;par2 par3&lt;/param&gt;
  &lt;param&gt;"par4.1 par4.2"&lt;/param&gt;
&lt;/param-list&gt;</screen>
        </entry>
        <entry>
         <para>
          Optional; if not configured, no parameters get passed to script.
         </para>
        </entry>
       </row>
       <row>
        <entry>
         <para>
          <literal>rerun</literal>
         </para>
        </entry>
        <entry>
         <para>
          A script is only run once. Even if you use
          <literal>ayast</literal>_setup to run an XML file multiple times,
          the script is only run once. Change this default behavior by
          setting this boolean to <literal>true</literal>.
         </para>
<screen>&lt;rerun config:type="boolean"&gt;true&lt;/rerun&gt;</screen>
        </entry>
        <entry>
         <para>
          Optional; default is <literal>false</literal>, meaning that scripts
          only run once.
         </para>
        </entry>
       </row>
       <row>
        <entry>
         <para>
          <literal>chrooted</literal>
         </para>
        </entry>
        <entry>
         <para>
          During installation, the new system is mounted at <filename>/mnt</filename>.
          If this parameter is set to <literal>false</literal>, &ay; does not
          run <command>chroot</command> and does not install the boot loader
          at this stage. If the parameter is set to <literal>true</literal>, &ay;
          performs a <command>chroot</command> into <filename>/mnt</filename> and
          installs the boot loader. The result is that to change
          anything in the newly-installed system, you no longer need to use the
          <filename>/mnt</filename> prefix.
         </para>
<screen>&lt;chrooted config:type="boolean"
&gt;true&lt;/chrooted&gt;</screen>
        </entry>
        <entry>
         <para>
          Optional; default is <literal>false</literal>. This option is only
          available for chroot environment scripts.
         </para>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect2>

   <sect2 xml:id="script-examples">
    <title>Script example</title>
    <example>
     <title>Script configuration</title>
<screen>&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE profile&gt;
&lt;profile xmlns="http://www.suse.com/1.0/yast2ns" xmlns:config="http://www.suse.com/1.0/configns"&gt;
&lt;scripts&gt;
  &lt;chroot-scripts config:type="list"&gt;
    &lt;script&gt;
      &lt;chrooted config:type="boolean"&gt;true&lt;/chrooted&gt;
      &lt;filename&gt;chroot-post.sh&lt;/filename&gt;
      &lt;interpreter&gt;shell&lt;/interpreter&gt;
      &lt;source&gt;&lt;![CDATA[
echo "Testing chroot (chrooted) scripts"
ls
]]&gt;
      &lt;/source&gt;
    &lt;/script&gt;
    &lt;script&gt;
      &lt;filename&gt;chroot-pre.sh&lt;/filename&gt;
        &lt;interpreter&gt;/bin/bash -x&lt;/interpreter&gt;
        &lt;source&gt;&lt;![CDATA[
echo "Testing chroot scripts"
df
cd /mnt
ls
]]&gt;
        &lt;/source&gt;
      &lt;/script&gt;
    &lt;/chroot-scripts&gt;
    &lt;post-scripts config:type="list"&gt;
      &lt;script&gt;
        &lt;filename&gt;post.sh&lt;/filename&gt;
        &lt;interpreter&gt;shell&lt;/interpreter&gt;
        &lt;source&gt;&lt;![CDATA[
echo "Running Post-install script"
systemctl start portmap
mount -a 192.168.1.1:/local /mnt
cp /mnt/test.sh /tmp
umount /mnt
]]&gt;
        &lt;/source&gt;
      &lt;/script&gt;
      &lt;script&gt;
        &lt;filename&gt;post.pl&lt;/filename&gt;
        &lt;interpreter&gt;perl&lt;/interpreter&gt;
        &lt;source&gt;&lt;![CDATA[
print "Running Post-install script";
]]&gt;
        &lt;/source&gt;
      &lt;/script&gt;
    &lt;/post-scripts&gt;
    &lt;pre-scripts config:type="list"&gt;
      &lt;script&gt;
        &lt;interpreter&gt;shell&lt;/interpreter&gt;
        &lt;location&gt;http://192.168.1.1/profiles/scripts/prescripts.sh&lt;/location&gt;
      &lt;/script&gt;
      &lt;script&gt;
        &lt;filename&gt;pre.sh&lt;/filename&gt;
        &lt;interpreter&gt;shell&lt;/interpreter&gt;
        &lt;source&gt;&lt;![CDATA[
echo "Running pre-install script"
]]&gt;
        &lt;/source&gt;
      &lt;/script&gt;
    &lt;/pre-scripts&gt;
    &lt;postpartitioning-scripts config:type="list"&gt;
      &lt;script&gt;
        &lt;filename&gt;postpart.sh&lt;/filename&gt;
        &lt;interpreter&gt;shell&lt;/interpreter&gt;
        &lt;debug config:type="boolean"&gt;false&lt;/debug&gt;
        &lt;feedback config:type="boolean"&gt;true&lt;/feedback&gt;
        &lt;source&gt;&lt;![CDATA[
touch /mnt/testfile
echo Hi
]]&gt;
        &lt;/source&gt;
      &lt;/script&gt;
    &lt;/postpartitioning-scripts&gt;
  &lt;/scripts&gt;
&lt;/profile&gt;</screen>
    </example>
    <para>
     After installation is finished, the scripts and the output logs can be
     found in the directory <filename>/var/adm/autoinstall</filename>. The
     scripts are located in the subdirectory <filename>scripts</filename>
     and the output logs in the <filename>log</filename> directory.
    </para>
    <para>
     The log consists of the output produced when executing the
     scripts, containing a combination of both the standard output
     and the standard error output.
    </para>
    <para>
     If the script ends with a non-zero exit code, then a warning will
     be shown with the content of the logs, unless the <literal>feedback</literal>
     option was provided.
    </para>
   </sect2>
  </sect1>
