<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="deployment_pxe.xml" version="5.0" role="General" xml:id="cha-deployment-prep-pxe">
 <title>Preparazione dell&apos;ambiente di avvio della rete</title>
 <info>
  <abstract>
   <para>
    In questo capitolo è descritto come configurare i server DHCP e TFTP che forniscono l&apos;infrastruttura necessaria per eseguire l&apos;avvio da PXE.
   </para>
  </abstract>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>

 <para>
  È possibile installare <phrase role="productname"><phrase os="sles">SUSE® Linux Enterprise Server</phrase></phrase> tramite un ambiente PXE (Preboot Execution Environment). L&apos;avvio tramite PXE deve essere supportato dall&apos;hardware client. In rete devono essere disponibili un server DHCP e un server TFTP che forniscano ai client i dati richiesti. In questo capitolo è indicata la procedura per configurare i server necessari.
 </para>
 <para>
  Con PXE vengono avviati solo un kernel e il file initrd. È possibile utilizzarlo per eseguire l&apos;avvio in un ambiente di installazione o in sistemi live. Per configurare le origini di installazione, vedere <xref linkend="cha-deployment-instserver"/>.
 </para>
 <para>
  In questa sezione vengono illustrate le attività di configurazione necessarie per scenari di avvio complessi. Vengono presentati esempi di configurazione pronti all&apos;uso per DHCP, avvio PXE, TFTP e Wake on LAN.
 </para>
 <para>
  Gli esempi presuppongono che i server DHCP, TFTP e NFS si trovino sullo stesso computer con indirizzo IP <literal>192.168.1.1</literal>. Tutti i servizi possono trovarsi su computer diversi senza alcun problema. Assicurarsi di modificare gli indirizzi IP secondo necessità.
 </para>

 <sect1 xml:id="sec-deployment-dhcp-server">
  <title>Configurazione di un server DHCP</title>
  <para>
   Un server DHCP fornisce l&apos;assegnazione di indirizzi IP dinamici (<xref linkend="sec-deployment-dhcp-dynamic"/>) e statici (<xref linkend="sec-deployment-dhcp-static"/>) ai client di rete. Pubblicizza server, instradamenti e domini. Per i server TFTP, DHCP fornisce inoltre il kernel e i file initrd. I file da caricare dipendono dall&apos;architettura del computer di destinazione e dall&apos;uso dell&apos;avvio BIOS o UEFI esistente. I client trasmettono il rispettivo tipo di architettura nelle richieste DHCP. In base a tali informazioni, il server DHCP decide i file che il client deve scaricare per l&apos;avvio.
  </para>
  <warning>
   <title>errori di avvio PXE e installazione AutoYaST</title>
   <para>
    A partire da SUSE Linux Enterprise 15.0 esistono condizioni speciali che determinano errori di avvio PXE e installazione AutoYaST. Per ulteriori informazioni e per la relativa soluzione, consultare la <xref linkend="sec-deployment-dhcp-rfc4361"/>.
   </para>
  </warning>

  <sect2 xml:id="sec-deployment-dhcp-dynamic">
   <title>Assegnazione dinamica degli indirizzi</title>
   <para>
    Il seguente esempio illustra come configurare un server DHCP che assegna in modo dinamico gli indirizzi IP ai client e pubblicizza server, instradamenti, domini e file di avvio.
   </para>
   <procedure xml:id="pro-deployment-dhcp-server">
    <step>
     <para>
      Eseguire il login come <systemitem class="username">root</systemitem> nel computer che ospita il server DHCP.
     </para>
    </step>
    <step>
     <para>
      Abilitare il server DHCP eseguendo il comando <command>systemctl enable dhcpd</command>.
     </para>
    </step>
    <step>
     <para>
      Aggiungere le righe seguenti ad una configurazione di sottorete del file di configurazione del server DHCP ubicato in <filename>/etc/dhcpd.conf</filename>:
     </para>
<screen># The following lines are optional
option domain-name "my.lab";
option domain-name-servers 192.168.1.1;
option routers 192.168.1.1;
option ntp-servers 192.168.1.1;
ddns-update-style none;
default-lease-time 3600;

# The following lines are required
option arch code 93 = unsigned integer 16; # RFC4578
subnet 192.168.1.0 netmask 255.255.255.0 {
 next-server 192.168.1.1;
 range 192.168.1.100 192.168.1.199;
 default-lease-time 3600;
 max-lease-time 3600;
 if option arch = 00:07 or option arch = 00:09 {
   filename "/EFI/x86/grub.efi";
 }
 else if option arch = 00:0b {
   filename "/EFI/aarch64/bootaa64.efi";
 }
 else  {
   filename "/BIOS/x86/pxelinux.0";
 }
}</screen>
     <para>
      Questo esempio di configurazione utilizza la sottorete <literal>192.168.1.0/24</literal> con DHCP, DNS e gateway sul server con indirizzo IP <literal>192.168.1.1</literal>. Verificare che tutti gli indirizzi IP vengano modificati in base al layout di rete. Per ulteriori informazioni sulle opzioni disponibili in <filename></filename>, vedere la documentazione relativa a <systemitem>dhcpd.conf</systemitem>dhcpd.conf.
     </para>
    </step>
    <step>
     <para>
      Riavviare il server DHCP eseguendo il comando <command>systemctl restart dhcpd</command>.
     </para>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="sec-deployment-dhcp-static">
   <title>Assegnazione di indirizzi IP statici</title>
   <para>
    Un server DHCP può anche assegnare indirizzi IP statici e nomi host ai client di rete. Un caso d&apos;uso consiste nell&apos;assegnare indirizzi statici ai server. Un altro caso è quello che limita la possibilità di entrare a far parte della rete ai soli client con indirizzi IP statici assegnati e che non fornisce pool di indirizzi dinamici.
  </para>
  <para>
    Modificare la configurazione DHCP di cui sopra in base al seguente esempio:
   </para>
<screen>group {
 host test {
   hardware ethernet <replaceable>MAC_ADDRESS</replaceable>;
   fixed-address <replaceable>IP_ADDRESS</replaceable>;
   }
}
</screen>
   <para>
    La dichiarazione host assegna un nome host alla destinazione di installazione. Per associare il nome host e l&apos;indirizzo IP a un host specifico, è necessario specificare l&apos;indirizzo hardware (MAC) del client. Sostituire tutte le variabili utilizzare nell&apos;esempio con i valori effettivi corrispondenti all&apos;ambiente, quindi salvare le modifiche e riavviare il server DHCP.
   </para>
  </sect2>

  <sect2 xml:id="sec-deployment-dhcp-rfc4361">
   <title>Errori di avvio PXE e installazione AutoYaST</title>
   <para>
    A partire da SUSE Linux Enterprise 15.0 e ISC DHCP 4.3.x esistono circostanze specifiche che determinano errori di avvio PXE e installazione AutoYaST. Se un server DHCP non dispone di un pool di indirizzi IP dinamici, ma consente solo indirizzi statici predefiniti per client, e i client inviano identificatori RFC 4361, si verificano errori di avvio PXE e installazione AutoYaST. Per evitare che computer casuali entrino a far parte della rete, consentire solo indirizzi assegnati a specifici client di rete e non fornire pool di indirizzi dinamici.
   </para>
   <para>
    Se un nuovo sistema viene avviato in PXE, invia una richiesta al server DHCP e si autoidentifica mediante un identificatore client creato in base al tipo di hardware e all&apos;indirizzo MAC dell&apos;interfaccia di rete. Si tratta di un <literal>ID client</literal> RFC 2132. Il server DHCP fornisce quindi l&apos;indirizzo IP assegnato. Viene quindi caricato il kernel di installazione, che invia un&apos;altra richiesta DHCP, ma l&apos;<literal>ID client</literal> è diverso e viene inviato in formato RFC 4361. Il server DHCP non lo riconosce come lo stesso client e cercherà un indirizzo IP dinamico libero, che non è disponibile. L&apos;installazione si arresta.
   </para>
   <para>
    La soluzione consiste nel configurare l&apos;invio di ID client RFC 2132. Per inviare un <literal>ID client</literal> RFC 2132 durante l&apos;installazione, utilizzare <literal>linuxrc</literal> per passare il seguente comando <literal>ifcfg</literal>:
   </para>
<screen>ifcfg=eth0=dhcp,DHCLIENT_CLIENT_ID=<replaceable>01:03:52:54:00:02:c2:67</replaceable>,
DHCLIENT6_CLIENT_ID=<replaceable>00:03:52:54:00:02:c2:67</replaceable></screen>
   <para>
    L&apos;<literal>ID client</literal> DHCPv4 RFC 2132 in genere utilizzato nella rete Ethernet viene creato in base al tipo di hardware (<literal>01</literal> per Ethernet), seguito dall&apos;indirizzo hardware (MAC), ad esempio:
   </para>
<screen>01:52:54:00:02:c2:67</screen>
   <para>
    L&apos;<literal>ID client</literal> DHCPv4 RFC 4361 tenta di correggere il problema di identificazione di un computer con più di un&apos;interfaccia di rete. Il nuovo <literal>ID client</literal> DHCPv4 presenta lo stesso formato dell&apos;<literal>ID client</literal> DHCPv6. Inizia con il prefisso <literal>0xff</literal>, anziché con il tipo di hardware, seguito dall&apos;IAID DHCPv6, ovvero l&apos;ID di associazione dell&apos;indirizzo di interfaccia che descrive l&apos;interfaccia sul computer, seguito dal DUID, l&apos;identificatore univoco DHCPv6 del computer.
   </para>
   <para>
    Utilizzando il DUID basato sul tipo e sull&apos;indirizzo hardware di cui sopra, il nuovo <literal>ID client</literal> DHCPv4 RFC 4361 sarà:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Utilizzando gli ultimi byte dell&apos;indirizzo MAC come IAID: <literal>ff:00:02:c2:67:00:01:xx:xx:xx:xx:52:54:00:02:c2:67</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      Se l&apos;IAID è un numero semplice incrementato: <literal>ff:00:00:00:01:00:01:xx:xx:xx:xx:52:54:00:02:c2:67</literal>
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Il campo <replaceable>xx:xx:xx:xx</replaceable> nel DUID-LLT, ovvero la registrazione data e ora del livello di collegamento DUID, indica la data e ora di creazione. Un DUID-LL (<literal>00:03:00:01:$MAC</literal>) non dispone della registrazione data e ora.
   </para>
   <para>
    Per ulteriori informazioni sull&apos;utilizzo di <literal>linuxrc</literal>, consultare la <citetitle>Guida di AutoYaST</citetitle>. Fare inoltre riferimento a <literal>man 4 initrd</literal> e alla documentazione per le opzioni <literal>dhcp4 &quot;create-cid&quot;</literal> e <literal>dhcp6 &quot;default-duid&quot;</literal> in <literal>man 5 wicked-config</literal>, <literal>wicked duid --help</literal> e <literal>wicked iaid --help</literal>.
   </para>
  </sect2>
 </sect1>

 <sect1 xml:id="sec-deployment-tftp-server">
  <title>Configurazione di un server TFTP</title>
  <para>
   La seguente procedura illustra come preparare il server in modo da consentire l&apos;avvio in remoto dei computer client con UEFI e BIOS mediante i file esportati da TFTP.
  </para>
  <sect2 xml:id="sec-deployment-tftp-server-install">
   <title>Installazione di un server TFTP</title>
   <para>
    Per installare un server TFTP, attenersi alla procedura seguente:
   </para>

   <procedure>
    <step>
     <para>
      Installare il pacchetto <systemitem>tftp</systemitem>.
     </para>
     <screen><prompt>&gt; </prompt><command>sudo</command> <command>zypper in tftp</command></screen>
    </step>
    <step>
     <para>
      Rivedere la configurazione <systemitem class="daemon">tftpd</systemitem> in <filename>/etc/sysconfig/tftp</filename> e aggiungere o modificare le opzioni secondo necessità. Per ulteriori dettagli, fare riferimento a <command>man 8 tftpd</command>. Il daemon TFTP funziona senza dover modificare la configurazione. La directory radice di default per i file è <filename>/srv/tftpboot</filename>.
     </para>
    </step>
    <step>
     <para>
      Assicurarsi che <systemitem class="daemon">tftpd</systemitem> sia stato eseguito all&apos;avvio e riavviarlo per visualizzare la nuova configurazione.
     </para>
     <screen><prompt>&gt; </prompt><command>sudo</command> <command>systemctl enable tftp.socket</command>
<prompt>&gt; </prompt><command>sudo</command> <command>systemctl restart tftp.socket</command></screen>
    </step>
   </procedure>
  </sect2>
  <sect2 xml:id="sec-deployment-tftp-server-grub-package">
   <title>Installazione dei file per l&apos;avvio</title>
   <para>
    In <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> vengono forniti i file necessari per eseguire l&apos;avvio da PXE in computer BIOS o UEFI. Sono supportate le seguenti architetture hardware:
   </para>

   <itemizedlist>
    <listitem>
     <para>
      AMD64/Intel 64
     </para>
    </listitem>
    <listitem>
     <para>
      AArch64
     </para>
    </listitem>
    <listitem>
     <para>
      POWER
     </para>
    </listitem>
    <listitem>
     <para>
      IBM Z
     </para>
    </listitem>
   </itemizedlist>

   <para>
    I file richiesti per l&apos;avvio da una specifica architettura hardware sono inclusi in un pacchetto RPM. Installarli nel computer sul quale viene eseguito il server TFTP:
   </para>
   <screen><prompt>&gt; </prompt><command>sudo</command> <command>zypper in tftpboot-installation-SLE-<replaceable>OS_VERSION</replaceable>-<replaceable>ARCHITECTURE</replaceable></command></screen>
   <para>
    Sostituire <replaceable>OS_VERSION</replaceable> con il numero di versione dell&apos;installazione di <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> in uso, ad esempio <replaceable>SLE-15-SP3-x86_64</replaceable>, e <replaceable>ARCHITECTURE</replaceable> con l&apos;architettura del sistema, ad esempio <literal>x86_64</literal>. Il testo risultante sarà: <package>tftpboot-installation-SLE-15-SP3-x86_64</package>. Eseguire <command>zypper se tftpboot</command> per cercare tutte le versioni e le architetture disponibili.
   </para>
   <para>
    I file vengono installati in <filename>/srv/tftpboot/SLE-<replaceable>OS_VERSION</replaceable>-<replaceable>ARCHITECTURE</replaceable></filename>. È inoltre possibile copiare altre versioni e architetture di <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> nella directory<filename>/srv/tftpboot</filename>.
   </para>
   <tip>
    <title>gestione di architetture diverse</title>
    <para>
     L&apos;architettura hardware di un client e un server può variare. Ad esempio, è possibile eseguire un server TFTP AMD64/Intel 64 e fornire un ambiente di avvio per computer client AArch64 installando il pacchetto <package>tftpboot-installation-SLE-15-SP3-aarch64</package>.
    </para>
   </tip>
   <note>
    <title>directory <filename>/srv/tftpboot/</filename> esistente</title>
    <para>
     Se sul computer esiste già la directory <filename>/srv/tftpboot/</filename>, tutti i file verranno installati in <filename>/usr/share/tftpboot-installation/</filename>, come nel caso in cui si effettua l&apos;upgrade del server PXE da una release precedente di SLES.
    </para>
    <para>
     Per correggere il problema, copiare i file manualmente da <filename>/usr/share/tftpboot-installation/</filename> in <filename>/srv/tftpboot/</filename>. In alternativa, rimuovere <filename>/srv/tftpboot/</filename> e installare di nuovo il pacchetto <package>tftpboot-installation-SLE-<replaceable>OS_VERSION</replaceable>-<replaceable>ARCHITECTURE</replaceable></package>.
    </para>
   </note>
  </sect2>
  <sect2 xml:id="sec-deployment-tftp-server-pxelinux">
   <title>Configurazione di PXELINUX</title>
   <para>
    Aprire il file <filename>/srv/tftpboot/SLE-<replaceable>OS_VERSION</replaceable>-<replaceable>ARCHITECTURE</replaceable>/net/pxelinux.cfg/default</filename> in un editor. Sostituire il percorso del parametro <literal>install</literal> in base alla configurazione descritta nel <xref linkend="cha-deployment-instserver"/>. Sostituire anche <replaceable>TFTP_SERVER</replaceable> con l&apos;indirizzo IP del server TFTP. Per una panoramica delle opzioni di configurazione di PXELINUX, vedere <xref linkend="sec-deployment-prep-boot-pxeopts"/>.
   </para>
<screen>default linux

# install
label linux
  ipappend 2
  kernel boot/<replaceable>ARCHITECTURE</replaceable>/loader/linux
  append initrd=boot/<replaceable>ARCHITECTURE</replaceable>/loader/initrd instsys=tftp://<replaceable>TFTP_SERVER</replaceable>/SLE-<replaceable>OS_VERSION</replaceable>-<replaceable>ARCHITECTURE</replaceable>/boot/<replaceable>ARCHITECTURE</replaceable>/root install=<replaceable>PROTOCOL</replaceable>://<replaceable>SERVER_IP</replaceable>:/<replaceable>PATH</replaceable>

display  message
implicit 1
prompt  1
timeout  50</screen>
   <para>
    Per i dettagli sui parametri di avvio utilizzati nella riga <literal>append</literal>, vedere <xref linkend="sec-boot-parameters-list"/>.
   </para>
   <para>
    Se necessario, modificare <filename>/srv/tftpboot/SLE-<replaceable>OS_VERSION</replaceable>-<replaceable>ARCHITECTURE</replaceable>/net/pxelinux.cfg/message</filename> per visualizzare un messaggio nel menu di avvio.
   </para>
  </sect2>
  <sect2 xml:id="sec-deployment-tftp-server-efilinux-x86">
   <title>Preparazione dell&apos;avvio da PXE per EFI con GRUB2</title>
   <para>
     In genere i file di configurazione GRUB2 non richiedono modifiche. Tuttavia, le impostazioni predefinite non includono una risorsa di rete per l&apos;installazione del sistema. Per eseguire un&apos;installazione completa di <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> tramite la rete, è necessario specificare il parametro <option>install</option> nell&apos;istruzione <option>linuxefi</option> del file <filename>/srv/tftpboot/SLE-<replaceable>VERSIONE_SISTEMA_OPERATIVO</replaceable>-<replaceable>ARCHITETTURA</replaceable>/EFI/BOOT/grub.cfg</filename>. Fare riferimento alla <xref linkend="sec-boot-parameters-list-install-source"/> per ulteriori informazioni sul parametro <option>install</option>.
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-deployment-prep-boot-pxeopts">
  <title>Opzioni di configurazione di PXELINUX</title>

  <para>
   Le opzioni elencate di seguito sono solo una parte di tutte le opzioni disponibili per il file di configurazione di PXELINUX.
  </para>

  <variablelist>
   <varlistentry>
    <term><option>APPEND <replaceable>OPTIONS</replaceable></option>
    </term>
    <listitem>
     <para>
      Consente di aggiungere una o più opzioni alla riga di comando del kernel. Queste vengono aggiunte sia per l&apos;avvio automatico, sia per quello manuale. Le opzioni vengono aggiunte all&apos;inizio della riga di comando del kernel e solitamente possono essere ignorate dalle opzioni del kernel immesse esplicitamente.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><option>APPEND -</option>
    </term>
    <listitem>
     <para>
      Non aggiunge alcun elemento. <option>APPEND</option>, seguito da un singolo trattino come argomento in una sezione <option>LABEL</option>, può essere utilizzato per ignorare l&apos;opzione <option>APPEND</option> generale.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><option>DEFAULT <replaceable>KERNEL_OPTIONS</replaceable>...</option>
    </term>
    <listitem>
     <para>
      Consente di impostare la riga di comando del kernel di default. Se PXELINUX viene avviato automaticamente, agisce come se le voci che seguono DEFAULT fossero state digitate al prompt di avvio, ad eccezione dell&apos;opzione auto che viene aggiunta automaticamente, indicando un avvio automatico.
     </para>
     <para>
      Se non sono disponibili file di configurazione o nel file di configurazione non è definita alcuna voce DEFAULT, per default il nome del kernel è <quote>linux</quote>, senza opzioni.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>

    <term><option>IFAPPEND <replaceable>FLAG</replaceable></option>
    </term>
    <listitem>
     <para>
      Aggiunge un&apos;opzione specifica alla riga di comando del kernel a seconda del valore di <replaceable>FLAG</replaceable>. L&apos;opzione <option>IFAPPEND</option> è disponibile solo su PXELINUX. Per <replaceable>FLAG</replaceable> è previsto un valore descritto nella <xref linkend="tab-deployment-boot-pxeopts-ifappend"/>:
     </para>
     <table xml:id="tab-deployment-boot-pxeopts-ifappend">
      <title>Opzioni della riga di comando del kernel generate e aggiunte da <option>IFAPPEND</option></title>
      <tgroup cols="2">
       <colspec colwidth="1*"/>
       <colspec colwidth="4*"/>
       <thead>
        <row>
         <entry valign="middle">
          <para>
           Argomento
          </para>
         </entry>
         <entry>
          <para>
           Riga di comando del kernel generata/Descrizione
          </para>
         </entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>
          <para>
           <option>1</option>
          </para>
         </entry>
         <entry>
<screen>ip=<replaceable>CLIENT_IP</replaceable>:<replaceable>BOOT_SERVER_IP</replaceable>:<replaceable>GW_IP</replaceable>:<replaceable>NETMASK</replaceable></screen>
          <para>
           I segnaposto vengono sostituiti in base all&apos;input ricevuto dal server di avvio DHCP/BOOTP o PXE.
          </para>
          <para>
           Questa opzione non sostituisce l&apos;esecuzione di un client DHCP nel sistema avviato. Senza rinnovi regolari, il lease acquisito dal BIOS PXE scadrà e l&apos;indirizzo IP potrà essere riutilizzato dal server DHCP.
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
           <option>2</option>
          </para>
         </entry>
         <entry>
<screen>BOOTIF=<replaceable>MAC_ADDRESS_OF_BOOT_INTERFACE</replaceable></screen>
          <para>
           Questa opzione è utile se si desidera evitare timeout quando il server di installazione esamina un&apos;interfaccia LAN dopo l&apos;altra fino a quando non ottiene una risposta da un server DHCP. Questa funzione consente a un programma initrd di determinare l&apos;interfaccia di avvio del sistema. linuxrc legge l&apos;opzione e utilizza l&apos;interfaccia di rete specificate.
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
           <option>4</option>
          </para>
         </entry>
         <entry>
<screen>SYSUUID=<replaceable>SYSTEM_UUID</replaceable></screen>
          <para>
           Aggiunge UUID sotto forma di esadecimali in minuscolo. Vedere <filename>/usr/share/doc/packages/syslinux/pxelinux.txt</filename>
          </para>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><option>LABEL <replaceable>LABEL</replaceable> KERNEL <replaceable>IMAGE</replaceable> APPEND <replaceable>OPTIONS</replaceable>...</option>
    </term>
    <listitem>
     <para>
      Indica che se si immette <replaceable>LABEL</replaceable> come kernel per l&apos;avvio, PXELINUX deve avviare invece <replaceable>IMAGE</replaceable> ed è necessario utilizzare le opzioni <option>APPEND</option> specificate. Tali opzioni sostituiscono quelle specificate nella sezione globale del file, prima del primo comando <option>LABEL</option>. L&apos;impostazione di default di <replaceable>IMAGE</replaceable> è la stessa di <replaceable>LABEL</replaceable> e, se non viene fornita alcuna opzione <option>APPEND</option>, per default viene utilizzata la voce generale, se presente. Sono ammesse fino a 128 voci <option>LABEL</option>.
     </para>

     <para>
      PXELINUX utilizza la sintassi seguente:
     </para>
<screen>label <replaceable>MYLABEL</replaceable>
  kernel <replaceable>MYKERNEL</replaceable>
  append <replaceable>MYOPTIONS</replaceable></screen>
     <para>
      Le etichette vengono modificate come se fossero nomi di file e devono essere univoche dopo essere state modificate. Le due etichette <quote>v2.6.30</quote> e <quote>v2.6.31</quote>, ad esempio, non sarebbero distinguibili in PXELINUX poiché entrambe vengono modificate e risultano nello stesso nome file DOS.
     </para>
     <para>
      Il kernel non deve essere necessariamente un kernel di Linux. Può essere anche un settore di avvio o un file COMBOOT.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><option>LOCALBOOT <replaceable>TYPE</replaceable></option>
    </term>
    <listitem>
     <para>
      In PXELINUX, se si specifica <option>LOCALBOOT 0</option> invece dell&apos;opzione <option>KERNEL</option>, viene chiamata questa etichetta e viene avviato il disco locale invece del kernel.
     </para>
     <informaltable frame="topbot" rowsep="0">
      <tgroup cols="2">

       <thead>
        <row>
         <entry>
          <para>
           Argomento
          </para>
         </entry>
         <entry>
          <para>
           Descrizione
          </para>
         </entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>
          <para>
           <literal>0</literal>
          </para>
         </entry>
         <entry>
          <para>
           Consente di eseguire un avvio normale.
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
           <literal>4</literal>
          </para>
         </entry>
         <entry>
          <para>
           Consente di eseguire un avvio locale mediante Universal Network Driver Interface (UNDI) ancora residente in memoria.
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
           <literal>5</literal>
          </para>
         </entry>
         <entry>
          <para>
           Consente di eseguire l&apos;avvio locale mediante lo stack PXE completo, incluso il driver UNDI, ancora residente in memoria.
          </para>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
     <para>
      Tutti gli altri valori non sono definiti. Se non si conoscono gli stack UNDI o PXE, specificare <literal>0</literal>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><option>TIMEOUT <replaceable>TIME-OUT</replaceable></option>
    </term>
    <listitem>
     <para>
      Indica il tempo di attesa al prompt di avvio prima dell&apos;avvio automatico, espresso in unità di 1/10 di secondo. Il timeout viene annullato quando l&apos;utente digita un testo qualsiasi con la tastiera, presupponendo che l&apos;utente completerà il comando iniziato. Un valore di timeout pari a zero disabilita completamente il timeout. Questa è anche l&apos;impostazione di default. Il valore massimo di timeout possibile è 35996 (poco meno di un&apos;ora).
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><option>PROMPT<replaceable> flag_val</replaceable></option>
    </term>
    <listitem>
     <para>
      Se <option>flag_val</option> è 0, il prompt di avvio viene visualizzato solo se viene premuto <keycap function="shift"/> o <keycap function="alt"/> oppure <keycap>se è selezionato il blocco delle maiuscole</keycap> o <keycap>il blocco dello scorrimento</keycap>. Questa è l&apos;impostazione di default. Se <option>flag_val</option> è 1, il prompt di avvio viene sempre visualizzato.
     </para>
<screen>F2  <replaceable>FILENAME</replaceable>
F1  <replaceable>FILENAME</replaceable>
..etc..
F9  <replaceable>FILENAME</replaceable>
F10 <replaceable>FILENAME</replaceable></screen>
     <para>
      Consente di visualizzare il file indicato sullo schermo quando viene premuto un tasto funzione al prompt di avvio. Può essere utilizzato per implementare la Guida online relativa al preavvio, presumibilmente per le opzioni della riga di comando del kernel. Per la compatibilità con versioni precedenti, è possibile inoltre immettere <keycap>F10</keycap> come <literal>F0</literal>. Si noti che non esiste attualmente alcun modo per associare i nomi file a <keycap>F11</keycap> e <keycap>F12</keycap>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 xml:id="sec-deployment-prep-boot-pxeprep">
  <title>Preparazione del sistema di destinazione per l&apos;avvio PXE</title>

  <para>
   Preparare il BIOS del sistema per l&apos;avvio PXE includendo l&apos;opzione PXE nell&apos;ordine di avvio del BIOS.
  </para>

  <warning>
   <title>ordine di avvio nel BIOS</title>
   <para>
    Non posizionare l&apos;opzione PXE davanti al parametro di avvio del disco rigido nel BIOS, altrimenti il sistema cercherà di reinstallarsi a ogni avvio.
   </para>
  </warning>
 </sect1>

 <sect1 xml:id="sec-deployment-prep-boot-wol">
  <title>Utilizzo di Wake-On-LAN per riattivazioni remote</title>
   <para>
       Wake-On-LAN (WOL) è uno standard Ethernet per la riattivazione remota di un computer attraverso l&apos;invio di un segnale di riattivazione sulla rete. Questo segnale è denominato <quote>pacchetto magico</quote>. Installare WOL sui computer client per abilitare le riattivazioni remote e su ogni computer che si intende utilizzare per l&apos;invio del segnale di riattivazione. Il pacchetto magico viene sottoposto a broadcast mediante la porta UDP 9 all&apos;indirizzo MAC dell&apos;interfaccia di rete sul computer client.
   </para>
   <para>
       Un computer arrestato non viene in genere spento completamente, ma passa a una modalità di risparmio energetico. Se l&apos;interfaccia di rete supporta WOL, ascolta il segnale di riattivazione del pacchetto magico quando il computer viene spento. È possibile inviare manualmente il pacchetto magico oppure pianificare riattivazioni in un processo cron sul computer di invio.
   </para>

  <sect2 xml:id="sec-deployment-prep-boot-wol-prereqs">
       <title>Prerequisiti</title>
   <para>
       WOL è compatibile con le schede Ethernet cablate e wireless che supportano lo standard.
   </para>
   <para>
       Potrebbe essere necessario abilitare WOL nel BIOS/UEFI del sistema.
   </para>
   <para>
       Verificare le impostazioni del BIOS/UEFI relative all&apos;avvio PXE e accertarsi che sia disabilitato per evitare reinstallazioni accidentali.
   </para>
   <para>
       Regolare il firewall per consentire il traffico sulla porta UDP 9.
   </para>
  </sect2>

  <sect2 xml:id="sec-deployment-prep-boot-wiredethernet">
       <title>Verifica del supporto per l&apos;interfaccia Ethernet cablata</title>
   <para>
       Eseguire il seguente comando per capire se un&apos;interfaccia Ethernet cablata supporta WOL:
   </para>
   <screen><prompt>&gt; </prompt><command>sudo</command> ethtool <replaceable>eth0</replaceable> | grep -i wake-on
Supports Wake-on: pumbg
Wake-on: g</screen>
   <para>
       L&apos;esempio mostra che eth0 supporta WOL, indicato dal flag <literal>g</literal> nella riga <literal>Supports Wake-on</literal>. <literal>Wake-on: g</literal> indica che WOL è già abilitato, quindi l&apos;interfaccia è pronta per ricevere segnali di riattivazione. Se WOL non è abilitato, abilitarlo con questo comando:
   </para>
   <screen><prompt>&gt; </prompt><command>sudo</command> ethtool -s <replaceable>eth0</replaceable> wol g</screen>
  </sect2>

   <sect2 xml:id="sec-deployment-prep-boot-wirelessethernet">
       <title>Verifica del supporto per l&apos;interfaccia wireless</title> 
   <para>
       Wakeup-Over-Wifi, o WoWLAN, richiede un&apos;interfaccia di rete wireless che supporti WoWLAN. Testarlo con il comando <command>iw</command>, fornito dal pacchetto <package>iw</package>:
   </para>
   <screen><prompt>&gt; </prompt><command>sudo</command> zypper in iw</screen>
   <para>
       Individuare il nome del dispositivo:
   </para>
   <screen><prompt>&gt; </prompt><command>sudo</command> iw dev
phy#0
        Interface wlan2
                ifindex 3
                wdev 0x1
                addr 9c:ef:d5:fe:01:7c
                ssid accesspoint
                type managed
                channel 11 (2462 MHz), width: 20 MHz, center1: 2462 MHz
                txpower 20.00 dBm</screen>
   <para>
       In questo esempio, il nome del dispositivo da utilizzare per eseguire query sul supporto WoWLAN è <literal>phy#0</literal>. Questo esempio mostra che non è supportato:
   </para>
       <screen><prompt>&gt; </prompt><command>sudo</command> iw phy#0 wowlan show
command failed: Operation not supported (-95)</screen>
   <para>
       Questo esempio mostra un&apos;interfaccia che supporta WoWLAN, ma lo standard non è abilitato:
   </para>
   <screen><prompt>&gt; </prompt><command>sudo</command> iw phy#0 wowlan show
WoWLAN is disabled</screen>
   <para>
       Abilitarlo:
   </para>
   <screen><prompt>&gt; </prompt><command>sudo</command> iw phy#0 wowlan enable magic-packet
WoWLAN is enabled:
* wake up on magic packet</screen>
</sect2>

<sect2 xml:id="sec-deployment-prep-boot-wol-install">
    <title>Installazione e test di WOL</title>
    <para>
        Per utilizzare WOL, installare il pacchetto <package>wol</package> sui computer client e di invio:
    </para>
<screen><prompt>&gt; </prompt><command>sudo</command> zypper in wol</screen>
    <para>          
        Installare <package>wol-udev-rules</package> sui computer client. Il pacchetto installa una regola udev che abilita WOL automaticamente all&apos;avvio.
   </para>
   <para>
       Ottenere l&apos;indirizzo MAC dell&apos;interfaccia di rete sul computer client:
   </para>
   <screen><prompt>&gt; </prompt><command>sudo</command> ip addr show eth0|grep ether
link/ether 7c:ef:a5:fe:06:7c brd ff:ff:ff:ff:ff:ff</screen>
   <para>
       Nell&apos;esempio, <literal>7c:ef:a5:fe:06:7c</literal> è l&apos;indirizzo MAC.
   </para>
   <para>
       Arrestare il computer client e inviare un segnale di riattivazione da un altro computer sulla stessa sottorete:
   </para>
   <screen><prompt>&gt; </prompt>wol <replaceable>7c:ef:a5:fe:06:7c</replaceable></screen>
   <para>
       Se il computer di destinazione e il secondo dispositivo sono sulla stessa rete, ma in sottoreti diverse, specificare l&apos;indirizzo broadcast per il computer di destinazione:
   </para>
   <screen><prompt>&gt; </prompt>wol -i <replaceable>192.168.0.63 7c:ef:a5:fe:06:7c</replaceable></screen>
   <para>
       Poiché WOL si basa su domini broadcast, il computer di invio deve trovarsi sulla stessa rete, anche se in un segmento di rete diverso.
   </para>
   <para>
       È possibile inviare il pacchetto magico da una rete diversa. Un metodo è costituito dal port forwarding, se è supportato dal router a un indirizzo broadcast. Un metodo più sicuro consiste nel connettersi a un host all&apos;interno della rete tramite SSH e inviare il pacchetto da qui.
   </para>
  </sect2>
 </sect1>
</chapter>
