<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="net_basic.xml" version="5.0" xml:id="cha-network">
 <title>Rede básica</title>
 <info>
  <abstract>
   <para>
    O Linux oferece os recursos e as ferramentas de rede necessários para a integração em todos os tipos de estruturas de rede. É possível configurar o acesso a rede usando uma placa de rede com o YaST. A configuração também pode ser feita manualmente. Neste capítulo são abordados apenas os mecanismos fundamentais e os arquivos de configuração de rede relevantes.
   </para>
  </abstract>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>
 <para>
  Linux e outros sistemas operacionais Unix usam o protocolo TCP/IP. Não é um protocolo de rede único, mas uma família de protocolos de rede que oferece vários serviços. Os protocolos listados na <xref linkend="tab-net-basic-tcpproto"/> são oferecidos para trocar dados entre duas máquinas por meio do TCP/IP. As redes combinadas por TCP/IP compõem uma rede mundial também chamada de <quote>Internet</quote>.
 </para>
 <para>
  RFC significa <emphasis>Request for Comments</emphasis>. Os RFCs são documentos que descrevem vários procedimentos de implementação e protocolos da Internet para o sistema operacional e seus aplicativos. Os documentos RFC descrevem a configuração dos protocolos da Internet. Para obter mais informações sobre RFCs, visite <link xlink:href="https://datatracker.ietf.org/"/>.
 </para>
 <variablelist xml:id="tab-net-basic-tcpproto">
  <title>Vários protocolos na família de protocolos TCP/IP</title>
  <varlistentry>
   <term>TCP</term>
   <listitem>
    <para>
     Transmission Control Protocol: um protocolo seguro orientado por conexão. Os dados a serem transmitidos são enviados primeiramente pelo aplicativo como fluxo de dados e convertidos no formato adequado ao sistema operacional. Os dados chegam ao respectivo aplicativo no host de destino com o formato original de fluxo de dados no qual foram inicialmente enviados. O TCP determina se algum dado foi perdido ou embaralhado durante a transmissão. O TCP é implementado onde a sequência de dados for necessária.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>UDP</term>
   <listitem>
    <para>
     User Datagram Protocol: um protocolo inseguro, não baseado em conexão. Os dados a serem transmitidos são enviados na forma de pacotes gerados pelo aplicativo. A ordem em que os dados chegam ao destinatário não é garantida, havendo possibilidade de perda dos dados. O UDP é adequado para aplicativos orientados por registro. Ele possui um período de latência menor que o TCP.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>ICMP</term>
   <listitem>
    <para>
     Internet Control Message Protocol: Não se trata de um protocolo para o usuário final, mas de um protocolo de controle especial que emite relatórios de erros e pode controlar o comportamento de máquinas que participam da transferência de dados TCP/IP. Além disso, ele fornece um modo de eco especial, que pode ser visualizado usando o programa ping.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>IGMP</term>
   <listitem>
    <para>
     Internet Group Management Protocol: esse protocolo controla o comportamento da máquina na implementação de multicast IP.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
 <para>
  Conforme mostrado na <xref linkend="fig-net-basic-OSI"/>, a troca de dados ocorre em camadas diferentes. A camada de rede real é a transferência de dados insegura por IP (Internet protocol). Acima do IP, o TCP garante, até certo ponto, a segurança na transferência de dados. A camada IP é suportada pelo protocolo base dependente do hardware, como a Ethernet.
 </para>
 <figure xml:id="fig-net-basic-OSI">
  <title>Modelo simplificado de camadas para TCP/IP</title>
  <mediaobject>
   <imageobject role="fo">
    <imagedata width="100%" fileref="net_basic_osi.svg"/>
   </imageobject>
   <imageobject role="html">
    <imagedata width="75%" fileref="net_basic_osi.png"/>
   </imageobject>
  </mediaobject>
 </figure>
 <para>
  O diagrama fornece um ou dois exemplos para cada camada. As camadas são organizadas de acordo com os <emphasis>níveis de abstração</emphasis>. A camada mais baixa fica muito próxima do hardware. A camada mais alta é quase completamente abstraída do hardware. Todas as camadas possuem suas funções especiais próprias. As funções especiais de cada camada, na maioria das vezes, estão implícitas em suas descrições. A vinculação de dados e as camadas físicas representam a rede física usada, como a Ethernet.
 </para>
 <para>
  Quase todos os protocolos de hardware funcionam em uma base orientada por pacotes. Os dados a serem transmitidos são reunidos em <emphasis>pacotes</emphasis> (não podem ser enviados todos de uma vez). O tamanho máximo de um pacote TCP/IP é de aproximadamente 64 KB. Os pacotes são normalmente bem menores, já que o hardware da rede pode ser um fator de limitação. O tamanho máximo de um pacote de dados na Ethernet é de cerca de 1.500 bytes. O tamanho do pacote TCP/IP limita-se a esse valor quando os dados são enviados por Ethernet. Se mais dados forem transferidos, mais pacotes de dados precisarão ser enviados pelo sistema operacional.
 </para>
 <para>
  Para que as camadas executem suas respectivas funções, informações adicionais referentes a cada uma delas devem ser gravadas no pacote de dados. Isso ocorre no <emphasis>cabeçalho</emphasis> do pacote. Todas as camadas anexam um pequeno bloco de dados, chamado cabeçalho do protocolo, à frente de cada pacote emergente. Veja uma demonstração de pacote de dados TCP/IP passando por um cabo Ethernet na <xref linkend="fig-net-basic-TCPPaket"/>. A soma de teste está localizada no final do pacote e não no início. Isso torna as coisas mais simples para o hardware de rede.
 </para>
 <figure xml:id="fig-net-basic-TCPPaket">
  <title>Pacote Ethernet TCP/IP</title>
  <mediaobject>
   <imageobject role="fo">
    <imagedata width="80%" fileref="net_basic_tcppacket.svg"/>
   </imageobject>
   <imageobject role="html">
    <imagedata width="75%" fileref="net_basic_tcppacket.png"/>
   </imageobject>
  </mediaobject>
 </figure>
 <para>
  Quando um aplicativo envia dados por uma rede, eles passam por cada camada, todas implementadas no kernel do Linux, exceto a camada física. Cada camada é responsável pela preparação dos dados, para que eles possam passar para a camada seguinte. A camada mais baixa é a responsável pelo envio de dados. Todo o processo é invertido quando os dados são recebidos. Como camadas de uma cebola, em cada uma os cabeçalhos de protocolo são removidos dos dados transportados. Por fim, a camada de transporte é responsável por disponibilizar os dados para uso pelos aplicativos de destino. Dessa forma, cada camada se comunica somente com a camada diretamente acima ou abaixo dela. Para os aplicativos, é irrelevante se os dados são transmitidos por uma conexão com ou sem fio. Da mesma forma, é irrelevante para a linha de dados os tipos de dados transmitidos, contanto que os pacotes estejam no formato correto.
 </para>
 <sect1 xml:id="sec-network-addresses">
  <title>Endereços IP e roteamento</title>

  <para>
   Esta seção limita-se à abordagem de redes IPv4. Para obter informações sobre o protocolo IPv6, sucessor do IPv4, consulte a <xref linkend="sec-network-ipv6"/>.
  </para>

  <sect2 xml:id="sec-network-addresses-ip">
   <title>Endereços IP</title>
   <para>
    Todo computador na Internet possui um endereço de 32 bits exclusivo. Os 32 bits (ou 4 bytes) normalmente são gravados conforme ilustrado na segunda linha em <xref linkend="aus-net-basic-ipaddress"/>.
   </para>
   <example xml:id="aus-net-basic-ipaddress">
    <title>Gravando endereços IP</title>
<screen>IP Address (binary):  11000000 10101000 00000000 00010100
IP Address (decimal):      192.     168.       0.      20</screen>
   </example>
   <para>
    Na forma decimal, os quatro bytes são gravados no sistema de números decimais, separados por pontos. O endereço IP é designado a um host ou a uma interface de rede. Ele pode ser usado apenas uma vez em todo o mundo. Há exceções a essa regra, mas não são relevantes para as passagens a seguir.
   </para>
   <para>
    Os pontos nos endereços IP indicam o sistema hierárquico. Até os anos 90, os endereços IP eram estritamente categorizados em classes. Entretanto, esse sistema demonstrou ser excessivamente inflexível e foi desativado. Agora, o <emphasis>CIDR</emphasis> (Classless Interdomain Routing — Roteamento Interdomínio sem Classes) é usado.
   </para>
  </sect2>

  <sect2 xml:id="sec-network-addresses-route">
   <title>Máscaras de rede e roteamento</title>
   <para>
    As máscaras de rede são usadas para definir a faixa de endereços de uma sub-rede. Se dois hosts estiverem na mesma sub-rede, eles poderão acessar um ao outro diretamente. Se não estiverem na mesma sub-rede, eles precisarão do endereço de um gateway que manipule todo o tráfego da sub-rede. Para verificar se dois endereços IP estão em uma mesma sub-rede, basta <quote>E</quote> os dois endereços com a máscara de rede. Se o resultado for idêntico, os dois endereços IP estarão na mesma rede local. Se houver diferenças, o endereço IP remoto e, portanto, a interface remota, só poderão ser localizados através de um gateway.
   </para>
   <para>
    Para compreender como as máscaras de rede funcionam, consulte o <xref linkend="tab-net-basic-netmask"/>. A máscara de rede consiste em 32 bits que identificam o quanto um endereço IP pertence à rede. Todos os bits <literal>1</literal> marcam o bit correspondente no endereço IP como pertencente à rede. Todos os bits <literal>0</literal> marcam os bits dentro da sub-rede. Isso significa que quanto maior a quantidade de bits <literal>1</literal>, menor será o tamanho da sub-rede. Como a máscara de rede sempre consiste em vários bits <literal>1</literal> sucessivos, também é possível contar o número de bits da máscara de rede. Na <xref linkend="tab-net-basic-netmask"/>, a primeira rede com 24 bits também pode ser gravada como <literal>192.168.0.0/24</literal>.
   </para>
   <example xml:id="tab-net-basic-netmask">
    <title>Vinculando endereços IP à máscara de rede</title>
<screen>IP address (192.168.0.20):  11000000 10101000 00000000 00010100
Netmask   (255.255.255.0):  11111111 11111111 11111111 00000000
---------------------------------------------------------------
Result of the link:         11000000 10101000 00000000 00000000
In the decimal system:           192.     168.       0.       0

IP address (213.95.15.200): 11010101 10111111 00001111 11001000
Netmask    (255.255.255.0): 11111111 11111111 11111111 00000000
---------------------------------------------------------------
Result of the link:         11010101 10111111 00001111 00000000
In the decimal system:           213.      95.      15.       0</screen>
   </example>
   <para>
    Para dar outro exemplo: todas as máquinas conectadas ao mesmo cabo Ethernet, normalmente, estão localizadas na mesma sub-rede e são diretamente acessíveis. Mesmo quando a sub-rede é dividida fisicamente por switches ou pontes, esses hosts ainda assim podem ser diretamente localizados.
   </para>
   <para>
    Endereços IP fora da sub-rede local só poderão ser localizados se um gateway for configurado para a rede de destino. Nos casos mais comuns, há somente um gateway que controla todo o tráfego externo. Entretanto, também é possível configurar vários gateways para sub-redes diferentes.
   </para>
   <para>
    Se um gateway tiver sido configurado, todos os pacotes IP externos serão enviados para o gateway apropriado. Esse gateway tentará então encaminhar os pacotes da mesma forma (de host para host) até acessar o host de destino ou até o TTL (time to live) do pacote expirar.
   </para>
   <variablelist xml:id="net-basic-spezial-net">
    <title>Endereços específicos</title>
    <varlistentry>
     <term>
      Endereço de Rede Base
     </term>
     <listitem>
      <para>
       Essa é a máscara de rede E qualquer endereço na rede, conforme mostrado no <xref linkend="tab-net-basic-netmask"/> em <literal>Resultado</literal>. Esse endereço não pode ser designado a nenhum host.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      Endereço de broadcast
     </term>
     <listitem>
      <para>
       Isso pode ser parafraseado como: <quote>Acessar todos os hosts nesta sub-rede.</quote> Para gerar isso, a máscara de rede é invertida no formato binário e vinculada ao endereço de rede base com um OU lógico. Portanto, o exemplo acima resulta em 192.168.0.255. Esse endereço não pode ser atribuído a nenhum host.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      Host Local
     </term>
     <listitem>
      <para>
       O endereço <systemitem class="ipaddress">127.0.0.1</systemitem> é designado ao <quote>dispositivo loopback</quote> em cada host. Pode-se configurar uma conexão para a sua própria máquina com este endereço e com todos os endereços da rede de loopback completa <systemitem class="ipaddress">127.0.0.0/8</systemitem>, conforme definidos com o IPv4. Com o IPv6, existe apenas um endereço de loopback (<systemitem class="ipaddress">::1</systemitem>).
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Como os endereços IP precisam ser exclusivos em qualquer parte do mundo, não é possível selecionar endereços aleatoriamente. Há três domínios de endereços a serem usados para configurar uma rede baseada em IP privado. Eles não conseguem se conectar ao restante da Internet, pois não podem ser transmitidos através dela. Esses domínios de endereço são especificados no RFC 1597 e listados na <xref linkend="tab-net-basic-privat-net"/>.
   </para>
   <table xml:id="tab-net-basic-privat-net">
    <title>Domínios de endereços IP privados</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>
        <para>
         Rede/máscara de rede
        </para>
       </entry>
       <entry>
        <para>
         Domínio
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         <systemitem class="ipaddress">10.0.0.0</systemitem>/<systemitem class="netmask">255.0.0.0</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         <systemitem class="ipaddress">10.x.x.x</systemitem>
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <systemitem class="ipaddress">172.16.0.0</systemitem>/<systemitem class="netmask">255.240.0.0</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         <systemitem class="ipaddress">172.16.x.x</systemitem> – <systemitem class="ipaddress">172.31.x.x</systemitem>
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <systemitem class="ipaddress">192.168.0.0</systemitem>/<systemitem class="netmask">255.255.0.0</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         <systemitem class="ipaddress">192.168.x.x</systemitem>
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-network-ipv6">
  <title>IPv6: a Internet de última geração</title>

  

  <para>
   Devido ao surgimento da World Wide Web (WWW), a Internet teve um crescimento massivo com um número cada vez maior de computadores se comunicando por TCP/IP nos últimos 15 anos. Desde que Tim Berners-Lee da CERN (<link xlink:href="http://public.web.cern.ch"/>) inventou a WWW em 1990, o número de hosts da Internet cresceu de poucos milhares para centenas de milhões deles.
  </para>

  <para>
   Conforme mencionado, um endereço IPv4 consiste em apenas 32 bits. Além disso, muitos endereços IP são perdidos, eles não podem ser usados devido à forma como as redes são organizadas. O número de endereços disponíveis na sua sub-rede é dois elevado à potência do número de bits, menos dois. Uma sub-rede tem, por exemplo, 2, 6 ou 14 endereços disponíveis. Para conectar 128 hosts à Internet, por exemplo, você precisa de uma sub-rede com 256 endereços IP, dos quais apenas 254 são utilizáveis, visto que são necessários dois endereços IP para a estrutura da própria sub-rede: o endereço de broadcast e o endereço de rede base.
  </para>

  <para>
   No protocolo IPv4 atual, DHCP ou NAT (Network Address Translation — Conversão de Endereços de Rede) são os mecanismos comuns usados para contornar a grande falta de endereços. Combinado à convenção de manter endereços públicos e privados separados por espaços, esses métodos podem certamente reduzir a falta de endereços. O problema deles está em suas configurações, trabalhosas para configurar e difíceis de manter. Para configurar um host em uma rede IPv4, você precisa de vários itens de endereço, como o próprio endereço IP do host, a máscara de sub-rede, o endereço de gateway e talvez um endereço de servidor de nomes. Todos esses itens precisam ser conhecidos e não podem ser derivados de outro lugar.
  </para>

  <para>
   Com o IPv6, tanto a falta de endereços quanto as configurações complicadas passariam a ser problemas do passado. As seções a seguir oferecem mais informações sobre os aprimoramentos e benefícios trazidos pelo IPv6 e sobre a transição do protocolo antigo para o novo.
  </para>

  <sect2 xml:id="sec-network-ipv6-adv">
   <title>Vantagens</title>
   <para>
    A melhoria mais importante e visível oferecida pelo protocolo mais recente é a expansão enorme do espaço de endereço disponível. Um endereço IPv6 é composto por valores de 128 bits, em vez dos 32 bits tradicionais. Ele é capaz de fornecer &apos;quatrilhões&apos; de endereços IP.
   </para>
   <para>
    Entretanto, os endereços IPv6 não diferem de seus antecessores apenas em relação ao comprimento. Também possuem uma estrutura interna diferente, que pode conter mais informações específicas sobre os sistemas e as redes a que pertencem. Leia mais detalhes sobre eles na <xref linkend="sec-network-ipv6-address"/>.
   </para>
   <para>
    Veja a seguir uma lista de outras vantagens do protocolo mais recente:
   </para>
   <variablelist>
    <varlistentry>
     <term>Configuração automática</term>
     <listitem>
      <para>
       O IPv6 torna apto o <quote>plug and play</quote> da rede, o que significa que um sistema recém-configurado é integrado à rede (local) sem qualquer configuração manual. O novo host usa seu mecanismo de configuração automática para derivar seu próprio endereço a partir das informações disponibilizadas pelos roteadores vizinhos, com base em um protocolo chamado <emphasis>ND</emphasis> (Neighbor Discovery — descoberta de vizinho). Esse método não exige nenhuma intervenção por parte do administrador e não há necessidade de manter um servidor central para alocação de endereços; uma vantagem adicional em relação ao IPv4, cuja alocação automática de endereços exige um servidor DHCP.
      </para>
      <para>
       No entanto, se houver um roteador conectado a um switch, ele deverá enviar anúncios periódicos com flags avisando os hosts de uma rede como eles devem interagir entre si. Para obter mais informações, consulte o RFC 2462, a página de manual do <systemitem>radvd.conf(5)</systemitem> e o RFC 3315.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Mobilidade</term>
     <listitem>
      <para>
       O IPv6 torna possível a atribuição de vários endereços a uma interface de rede ao mesmo tempo. Isso permite que usuários acessem várias redes facilmente, o que é comparado aos serviços de roaming internacionais oferecidos pelas empresas de celulares. Quando você viaja com seu celular, ele automaticamente se conecta a um serviço interurbano, ao entrar na área correspondente. Dessa forma, você pode ser localizado no mesmo número de celular em qualquer lugar e pode fazer ligações como se estivesse em sua cidade.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Comunicação segura</term>
     <listitem>
      <para>
       Com o IPv4, a segurança da rede é uma função adicional. O IPv6 inclui IPsec como um de seus recursos principais, permitindo que sistemas se comuniquem por um túnel seguro, para evitar a intromissão de estranhos na Internet.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Compatibilidade Retroativa</term>
     <listitem>
      <para>
       De forma realista, seria impossível mudar toda a Internet de IPv4 para IPv6 de uma só vez. Portanto, é essencial que ambos os protocolos possam coexistir na Internet, mas também em um sistema. Isso é garantido ao usar endereços compatíveis (endereços IPv4 podem facilmente ser convertidos em endereços IPv6) e vários túneis. Consulte a <xref linkend="sec-network-ipv6-coexist"/>. Da mesma forma, os sistemas podem se basear em uma técnica <emphasis>IP de pilha dupla</emphasis> para suportar os dois protocolos ao mesmo tempo, significando que possuem duas pilhas de rede completamente separadas, de tal forma que não há interferência entre as duas versões de protocolos.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Serviços adaptados e personalizados através de multicasting</term>
     <listitem>
      <para>
       Com o IPv4, alguns serviços, como SMB, precisam transmitir seus pacotes para todos os host na rede local. O IPv6 oferece uma abordagem muito mais refinada, permitindo que os servidores direcionem hosts por <emphasis>multicasting</emphasis>, ou seja, direcionando vários hosts como partes de um grupo. Esse procedimento é diferente de direcionar todos os hosts por meio de <emphasis>broadcasting</emphasis> ou cada host individualmente por <emphasis>unicasting</emphasis>. Os hosts enviados como grupos talvez dependam do aplicativo concreto. É possível enviar todos os servidores de nomes para alguns grupos predefinidos (o <emphasis>grupo multicast de servidores de nomes</emphasis>), por exemplo ou todos os roteadores (o <emphasis>grupo multicast de todos os roteadores</emphasis>).
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="sec-network-ipv6-address">
   <title>Estrutura e tipos de endereços</title>
   <para>
    Conforme mencionado, o protocolo IP atual tem duas limitações importantes: os endereços IP estão cada vez mais escassos, e a configuração de rede com manutenção de tabelas de rotina vem se tornando uma tarefa cada vez mais complexa e onerosa. O IPv6 soluciona o primeiro problema expandindo o espaço dos endereços para 128 bits. O segundo problema é amenizado com a introdução de uma estrutura hierárquica de endereços, combinada com técnicas sofisticadas para alocar endereços de rede e com <emphasis>multihoming</emphasis> (a capacidade de atribuir vários endereços a um dispositivo, concedendo acesso a diversas redes).
   </para>
   <para>
    Ao utilizar o IPv6, é útil saber que há três tipos diferentes de endereços:
   </para>
   <variablelist>
    <varlistentry>
     <term>Unicast</term>
     <listitem>
      <para>
       Endereços desse tipo são associados com exatamente uma interface de rede. Pacotes com esse tipo de endereço são entregues em apenas um destino. Da mesma forma, os endereços unicast são usados para transferir pacotes para hosts individuais na rede local ou na Internet.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Multicast</term>
     <listitem>
      <para>
       Endereços desse tipo estão relacionados a um grupo de interfaces de rede. Pacotes com esse tipo de endereço são entregues a todos os destinos pertencentes ao grupo. Endereços multicast são usados, principalmente, por certos tipos de serviços de rede para se comunicarem com determinados grupos de host de forma bem direcionada.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Anycast</term>
     <listitem>
      <para>
       Endereços desse tipo estão relacionados a um grupo de interfaces. Pacotes com esse tipo de endereço são entregues ao membro do grupo mais próximo do remetente, de acordo com os princípios do protocolo de roteamento subjacente. Endereços anycast são usados para que hosts possam descobrir mais facilmente servidores que oferecem certos serviços na área da rede determinada. Todos os servidores do mesmo tipo possuem o mesmo endereço anycast. Sempre que um host solicita um serviço, ele recebe uma resposta do servidor com o local mais próximo, conforme determinado pelo protocolo de roteamento. Caso ocorra alguma falha com esse servidor, o protocolo selecionará automaticamente o segundo servidor mais próximo ou então o terceiro e assim por diante.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Um endereço IPv6 é constituído de oito campos de quatro dígitos, cada um representando 16 bits, gravados em notação hexadecimal. Eles são separados por dois-pontos (<literal>:</literal>). Quaisquer zero bytes iniciais em um determinado campo podem ser descartados, mas zeros dentro ou no final do campo não podem ser descartados. Outra convenção é a de que mais de quatro zero bytes consecutivos podem retornar como dois-pontos duplos. Entretanto, apenas um separador do tipo <literal>::</literal> é permitido por endereço. Esse tipo de notação reduzida é mostrado no <xref linkend="aus-net-ipv6-add"/>, em que todas as três linhas representam o mesmo endereço.
   </para>
   <example xml:id="aus-net-ipv6-add">
    <title>Amostra de endereço IPv6</title>
<screen>fe80 : 0000 : 0000 : 0000 : 0000 : 10 : 1000 : 1a4
fe80 :    0 :    0 :    0 :    0 : 10 : 1000 : 1a4
fe80 :                           : 10 : 1000 : 1a4</screen>
   </example>
   <para>
    Cada parte de um endereço IPv6 possui uma função definida. Os primeiros bytes formam o prefixo e especificam o tipo de endereço. A parte central é a porção do endereço na rede, mas pode não ser utilizada. O final do endereço forma a parte do host. Com o IPv6, a máscara de rede é definida indicando o comprimento do prefixo depois de uma barra no final do endereço. Um endereço, como mostrado no <xref linkend="aus-net-ipv6-addpre"/>, contém as informações de que os primeiros 64 bits formam a parte da rede do endereço e que os últimos 64 formam a parte do host. Em outras palavras, <literal>64</literal> significa que a máscara de rede está preenchida com 64 valores de 1 bit a partir da esquerda. Como no IPv4, o endereço IP é combinado com E, com os valores da máscara de rede, para determinar se o host está localizado na mesma sub-rede ou em outra.
   </para>
   <example xml:id="aus-net-ipv6-addpre">
    <title>Endereço IPv6 que especifica o comprimento do prefixo</title>
<screen>fe80::10:1000:1a4/64</screen>
   </example>
   <para>
    O IPv6 conhece vários tipos de prefixos predefinidos. Alguns deles são mostrados na <xref linkend="list-net-basic-ipv6-prefix"/>.
   </para>
   <variablelist xml:id="list-net-basic-ipv6-prefix">
    <title>Vários prefixos IPv6</title>
    <varlistentry>
     <term><systemitem class="ipaddress">00</systemitem>
     </term>
     <listitem>
      <para>
       Endereços IPv4 e endereços de compatibilidade de IPv4 sobre IPv6. Esses são usados para manter a compatibilidade com IPv4. O seu uso ainda exige um roteador capaz de converter pacotes IPv6 em pacotes IPv4. Vários endereços especiais, como o do dispositivo loopback, também possuem esse prefixo.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem class="ipaddress">2</systemitem> ou <systemitem class="ipaddress">3</systemitem> como o primeiro dígito
     </term>
     <listitem>
      <para>
       Endereços unicast globais agregativos. Como no caso do IPv4, uma interface pode ser atribuída para fazer parte de determinada sub-rede. Atualmente, existem os seguintes espaços de endereço: <systemitem class="ipaddress">2001::/16</systemitem> (espaço de endereço de qualidade de produção) e <systemitem class="ipaddress">2002::/16</systemitem> (espaço de endereço 6to4).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem class="ipaddress">fe80::/10</systemitem>
     </term>
     <listitem>
      <para>
       Endereços locais de links. Endereços com este prefixo não devem ser roteados e, portanto, só devem ser encontrados na mesma sub-rede.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem class="ipaddress">fec0::/10</systemitem>
     </term>
     <listitem>
      <para>
       Endereços locais de sites. Esses podem ser roteados, mas somente na rede da organização a que pertencem. Na verdade, eles são o equivalente IPv6 do espaço de endereço de rede privada atual, como <systemitem class="ipaddress">10.x.x.x</systemitem>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem class="ipaddress">ff</systemitem>
     </term>
     <listitem>
      <para>
       Esses são endereços multicast.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Um endereço unicast consiste em três componentes básicos:
   </para>
   <variablelist>
    <varlistentry>
     <term>Topologia pública</term>
     <listitem>
      <para>
       A primeira parte (que também contém um dos prefixos mencionados acima) é usada para rotear pacotes através da Internet pública. Ela inclui informações sobre a empresa ou instituição que fornece o acesso à Internet.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Topologia do site</term>
     <listitem>
      <para>
       A segunda parte contém informações de roteamento sobre a sub-rede à qual o pacote deve ser entregue.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>ID de interface</term>
     <listitem>
      <para>
       A terceira parte identifica a interface à qual o pacote deve ser entregue. Isso também permite que o MAC faça parte do endereço. Como MAC é um identificador fixo globalmente exclusivo codificado no dispositivo pelo fabricante do hardware, o procedimento de configuração é bastante simplificado. Na verdade, os primeiros 64 bits de endereço são consolidados para formar o token <literal>EUI-64</literal>, com os últimos 48 bits obtidos no MAC e os 24 bits restantes contendo informações especiais sobre o tipo de token. Isso também permite atribuir um token <literal>EUI-64</literal> a interfaces que não tenham MAC, como aquelas baseadas em PPP.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    No topo dessa estrutura básica, o IPv6 faz distinção entre cinco tipos de endereços unicast:
   </para>
   <variablelist>
    <varlistentry>
     <term><systemitem class="ipaddress">::</systemitem> (não especificado) </term>
     <listitem>
      <para>
       Esse endereço é usado pelo host como seu endereço de origem durante a primeira inicialização da interface (momento em que o endereço ainda não pode ser determinado por outros meios).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem class="ipaddress">::1</systemitem> (loopback) </term>
     <listitem>
      <para>
       O endereço do dispositivo loopback.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Endereços compatíveis com IPv4</term>
     <listitem>
      <para>
       O endereço IPv6 é formado pelo endereço IPv4 e um prefixo consistindo em 96 zero bits. Esse tipo de endereço de compatibilidade é usado para um túnel (consulte a <xref linkend="sec-network-ipv6-coexist"/>) para permitir que os hosts IPv4 e IPv6 se comuniquem com outros que estejam operando em um ambiente IPv4 puro.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Endereços IPv4 mapeados para IPv6</term>
     <listitem>
      <para>
       Esse tipo de endereço especifica um endereço IPv4 puro em uma notação IPv6.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Endereços locais</term>
     <listitem>
      <para>
       Há dois tipos de endereços para uso local:
      </para>
      <variablelist>
       <varlistentry>
        <term>link-local</term>
        <listitem>
         <para>
          Este tipo de endereço só pode ser usado na sub-rede local. Pacotes com endereço de origem ou de destino desse tipo não devem ser roteados para a Internet nem para outras sub-redes. Esses endereços contêm um prefixo especial (<systemitem class="ipaddress">fe80::/10</systemitem>) e o ID da interface da placa de rede, com a parte do meio consistindo em zero bytes. Endereços desse tipo são usados durante a configuração automática para se comunicarem com outros hosts pertencentes à mesma sub-rede.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>site-local</term>
        <listitem>
         <para>
          Pacotes com este tipo de endereço podem ser roteados para outras sub-redes, mas não para a Internet mais ampla. Eles devem permanecer dentro da própria rede da organização. Tais endereços são usados para intranets e equivalem ao espaço de endereço privado definido pelo IPv4. Eles contêm um prefixo especial (<systemitem class="ipaddress">fec0::/10</systemitem>), o ID da interface e um campo de 16 bits que especifica o ID da sub-rede. Novamente, o restante é preenchido com bytes zero.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Como um recurso completamente novo, introduzido com o IPv6, cada interface de rede normalmente obtém vários endereços IP, com a vantagem de que várias redes podem ser acessadas através da mesma interface. Uma dessas redes pode ser totalmente configurada de forma automática usando o MAC e um prefixo conhecido, resultando na possibilidade de todos os hosts na rede local serem encontrados quando o IPv6 é habilitado (usando o endereço link-local). Com o MAC fazendo parte disso, qualquer endereço IP usado no mundo será exclusivo. As únicas partes variáveis do endereço são aquelas que indicam a <emphasis>topologia do site</emphasis> e a <emphasis>topologia pública</emphasis>, dependendo da rede real na qual o host estiver operando no momento.
   </para>
   <para>
    Para que um host avance e retroceda entre duas redes diferentes ele precisa de, pelo menos, dois endereços. Um deles, o <emphasis>endereço pessoal</emphasis>, contém não só o ID de interface, como também um identificador da rede doméstica a que ele normalmente pertence (e o prefixo correspondente). O endereço pessoal é um endereço estático e, portanto, normalmente não se modifica. Mesmo assim, todos os pacotes destinados ao host móvel podem ser entregues a ele, independentemente de ele operar na rede doméstica ou em outro local externo. Isso é possível devido aos recursos totalmente novos introduzidos com o IPv6, como <emphasis>configuração automática sem estado</emphasis> e <emphasis>descoberta de vizinho</emphasis>. Além do endereço residencial, um host móvel obtém um ou mais endereços adicionais pertencentes às redes interurbanas com roaming. Eles são chamados endereços <emphasis>care-of. </emphasis> A rede doméstica tem um recurso que encaminha qualquer pacote destinado ao host quando ele está em roaming. Em um ambiente IPv6, essa tarefa é executada pelo <emphasis>agente local</emphasis>, que retransmite todos os pacotes destinados ao endereço residencial através de um túnel. Por outro lado, esses pacotes destinados ao endereço care-of são diretamente transferidos para o host móvel sem qualquer desvio especial.
   </para>
  </sect2>

  <sect2 xml:id="sec-network-ipv6-coexist">
   <title>Coexistência de IPv4 e IPv6</title>
   <para>
    A migração de todos os hosts conectados à Internet do IPv4 para o IPv6 é um processo gradual. Os dois protocolos coexistirão durante algum tempo. A coexistência deles em um sistema é garantida onde houver uma implementação de <emphasis>pilha dupla</emphasis> de ambos os protocolos. Ainda resta a dúvida de como um host habilitado para IPv6 deve se comunicar com um host IPv4 e como os pacotes do IPv6 devem ser transportados pelas redes atuais, que são predominantemente baseadas no IPv4. As melhores soluções oferecem endereços de compatibilidade e túnel (consulte a <xref linkend="sec-network-ipv6-address"/>).
   </para>
   <para>
    Os hosts IPv6 que estiverem mais ou menos isolados na rede IPv4 (mundial) podem se comunicar por túneis: os pacotes IPv6 são encapsulados como pacotes IPv4 para que sejam transmitidos por uma rede IPv4. Tal conexão entre dois hosts IPv4 é chamada de <emphasis>túnel</emphasis>. Para que isso ocorra, os pacotes devem incluir o endereço IPv6 de destino (ou o prefixo correspondente) e o endereço IPv4 do host remoto na extremidade de recepção do túnel. Um túnel básico pode ser configurado manualmente, de acordo com um contrato entre os administradores dos hosts. Também é chamado de <emphasis>túnel estático</emphasis>.
   </para>
   <para>
    Entretanto, a configuração e manutenção de túneis estáticos é normalmente muito trabalhosa para ser usada diariamente em comunicações. Portanto, o IPv6 fornece três métodos de <emphasis>túneis dinâmicos</emphasis>:
   </para>
   <variablelist>
    <varlistentry>
     <term>6over4</term>
     <listitem>
      <para>
       Os pacotes IPv6 são automaticamente encapsulados como pacotes IPv4 e enviados por uma rede IPv4 com capacidade multicast. O IPv6 é induzido a considerar a rede inteira (Internet) como uma gigantesca rede local. Com isso, é possível determinar automaticamente o destino final do túnel IPv4. Entretanto, esse método não faz um dimensionamento muito bom e também é dificultado porque o multicasting IP não é tão difundido na Internet. Portanto, ele apenas fornece uma solução para redes corporativas ou institucionais menores, em que o multicast pode ser habilitado. As especificações para esse método estão descritas no RFC 2529.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>6to4</term>
     <listitem>
      <para>
       Com esse método, os endereços IPv4 são automaticamente gerados a partir de endereços IPv6, habilitando a comunicação de hosts IPv6 isolados através de uma rede IPv4. Entretanto, vários problemas foram relatados em relação à comunicação entre esses hosts IPv6 isolados e a Internet. O método está descrito no RFC 3056.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Controlador do túnel IPv6</term>
     <listitem>
      <para>
       Esse método se baseia em servidores especiais que fornecem túneis dedicados para hosts IPv6. É descrito no RFC 3053.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="sec-network-ipv6-config">
   <title>Configurando o IPv6</title>

   <para>
    Para configurar o IPv6, normalmente não é necessário fazer mudanças nas estações de trabalho individuais. O IPv6 é habilitado por padrão. Para desabilitar ou habilitar o IPv6 em um sistema instalado, use o módulo <guimenu>Configurações de Rede</guimenu> do YaST. Na guia <guimenu>Opções Globais</guimenu>, marque ou desmarque a opção <guimenu>Habilitar IPv6</guimenu> conforme necessário. Para habilitá-lo temporariamente até a próxima reinicialização, digite <command>modprobe</command> <option>-i ipv6</option> como <systemitem class="username">root</systemitem>. É impossível descarregar o módulo IPv6 depois de carregado.
   </para>
   <para>
    Devido ao conceito de configuração automática do IPv6, um endereço é designado à placa de rede na rede <emphasis>link-local. </emphasis> Normalmente, nenhum gerenciamento de tabela de roteamento é feito em uma estação de trabalho. Os roteadores de rede podem ser consultados pela estação de trabalho, usando o <emphasis>protocolo de anúncios do roteador</emphasis>, para o qual devem ser implementados um prefixo e gateways. O programa radvd pode ser usado para configurar um roteador IPv6. Esse programa informa às estações de trabalho o prefixo que deve ser usado para os endereços IPv6 e os roteadores. Outra opção é usar zebra/quagga para a configuração automática dos dois endereços e para roteamento.
   </para>

   <para>
    Para obter informações sobre como configurar vários tipos de túneis usando os arquivos <filename>/etc/sysconfig/network</filename>, consulte a página de manual de <literal>ifcfg-tunnel</literal> (<command>man ifcfg-tunnel</command>).
   </para>
  </sect2>

  <sect2 xml:id="sec-network-ipv6-moreinfo">
   <title>Mais informações</title>
   <para>
    A visão geral acima não abrange totalmente o tópico do IPv6. Para obter informações mais detalhadas sobre o protocolo mais recente, consulte os livros e a documentação online a seguir:
   </para>
   <variablelist>
    <varlistentry>
     <term><link xlink:href="http://www.ipv6.org/"/>
     </term>
     <listitem>
      <para>
       O ponto de partida para tudo relativo ao IPv6.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link xlink:href="http://www.ipv6day.org"/>
     </term>
     <listitem>
      <para>
       Todas as informações necessárias para iniciar sua própria rede IPv6.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link xlink:href="http://www.ipv6-to-standard.org/"/>
     </term>
     <listitem>
      <para>
       A lista de produtos habilitados para IPv6.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link xlink:href="http://www.bieringer.de/linux/IPv6/"/>
     </term>
     <listitem>
      <para>
       Aqui, encontre o Linux IPv6-HOWTO e muitos links relacionados ao tópico.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>RFC2460</term>
     <listitem>
      <para>
       Informações fundamentais do RFC sobre o IPv6.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>IPv6 Essentials</term>
     <listitem>
      <para>
       Um livro que descreve todos os aspectos importantes do tópico é o <emphasis>IPv6 Essentials</emphasis> de Silvia Hagen (ISBN 0-596-00125-8).
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-network-nameres">
  <title>Resolução de nome</title>

  <para>
   O DNS ajuda na designação de um endereço IP a um ou mais nomes e na designação de um nome a um endereço IP. No Linux, essa conversão normalmente é executada por um tipo especial de software chamado bind. A máquina responsável por essa conversão é chamada de <emphasis>servidor de nomes</emphasis>. Os nomes criam um sistema hierárquico, no qual cada componente do nome é separado um ponto. A hierarquia de nomes é, entretanto, independente da hierarquia de endereços IP descrita acima.
  </para>

  <para>
   Considere um nome completo, como <systemitem class="fqdomainname">jupiter.example.com</systemitem>, gravado no formato <systemitem class="fqdomainname">hostname.domain</systemitem>. Um nome completo, denominado <emphasis>FQDN</emphasis> (Fully Qualified Domain Name – Nome de Domínio Completo e Qualificado), consiste em um nome de host e um nome de domínio (<systemitem class="domainname">example.com</systemitem>). O último também inclui o <emphasis>TLD</emphasis> (Top Level Domain — Domínio de Nível Superior) (<systemitem class="domainname">com</systemitem>).
  </para>

  <para>
   A designação TLD tornou-se bastante confusa por razões históricas. Tradicionalmente, nomes de domínio com três letras são usados nos EUA. No resto do mundo, os códigos nacionais ISO de duas letras são o padrão. Além disso, TLDs mais longos foram introduzidos em 2000, representando certas esferas de atividades (por exemplo, <systemitem class="domainname">.info</systemitem>, <systemitem class="domainname">.name</systemitem>, <systemitem class="domainname">.museum</systemitem>).
  </para>

  <para>
   No início da Internet (antes de 1990), o arquivo <filename>/etc/hosts</filename> era usado para armazenar os nomes de todas as máquinas representadas na Internet. Isso rapidamente se tornou impraticável, devido ao crescente número de computadores conectados à Internet. Por essa razão, um banco de dados descentralizado foi desenvolvido para armazenar nomes de host de uma forma amplamente distribuída. Esse banco de dados, semelhante ao servidor de nomes, não possui os dados pertencentes a todos os hosts na Internet já disponíveis, mas pode encaminhar solicitações a outros servidores de nomes.
  </para>

  <para>
   A parte superior da hierarquia é ocupada pelos <emphasis>servidores de nomes raiz</emphasis>. Esses servidores de nomes raiz gerenciam os domínios de nível superior e são executados pelo NIC (Network Information Center). Cada servidor de nomes raiz conhece os servidores de nomes responsáveis por um determinado domínio de nível superior. Para obter informações sobre NICs de domínio superior, vá para <link xlink:href="http://www.internic.net"/>.
  </para>

  <para>
   O DNS pode fazer mais do que resolver nomes de host. O servidor de nomes também distingue qual host recebe e-mails para um domínio inteiro: o <emphasis>MX (servidor de correio)</emphasis>.
  </para>

  <para>
   Para sua máquina resolver um endereço IP, ela precisa pelo menos conhecer um servidor de nomes e seu respectivo endereço IP. Especifique facilmente esse tipo de servidor de nomes usando o YaST. 
  </para>

  <para>
   O protocolo <literal>whois</literal> está intimamente relacionado ao DNS. Com esse programa, é possível descobrir rapidamente o responsável por um domínio especificado.
  </para>



  <note>
   <title>MDNS e nomes de domínio .local</title>
   <para>
    O domínio de nível superior <literal>.local</literal> é tratado como domínio link-local pelo resolver. As solicitações de DNS são enviadas como solicitações de DNS multicast, em vez de solicitações de DNS normal. Se você já usa o domínio <literal>.local</literal> em sua configuração de servidor de nomes, deverá desativar essa opção em <filename>/etc/host.conf</filename>. Para obter mais informações, consulte a página de manual <filename>host.conf</filename>.
   </para>
   <para>
    Para desativar o MDNS durante a instalação, use <literal>nomdns=1</literal> como parâmetro de boot.
   </para>
   <para>
    Para obter mais informações sobre DNS de multicast, consulte <link xlink:href="http://www.multicastdns.org"/>.
   </para>
  </note>
 </sect1>
 <xi:include href="net_yast.xml"/>
 <xi:include href="networkmanager.xml"/>
 <xi:include href="net_wicked.xml"/>
 
 <xi:include href="net_bonding.xml"/>
 <xi:include href="net_teaming.xml"/>
 
</chapter>
