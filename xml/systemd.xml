<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<!-- Converted by suse-upgrade version 1.1 -->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="cha.systemd">

 <title>The &systemd; Daemon</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker></dm:bugtracker>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>
 <para>
  The program &systemd; is the process with process ID 1. It is responsible for
  initializing the system in the required way. &systemd; is started directly by
  the Kernel and resists signal&nbsp;9, which normally terminates processes.
  All other programs are either started directly by systemd or by one of its
  child processes.
 </para>
 <para>
  Starting with &productname; 12 systemd is a replacement for the popular
  System V init daemon. &systemd; is fully compatible with System V init (by
  supporting init scripts). One of the main advantages of systemd is that it
  considerably speeds up boot time by aggressively paralleling service starts.
  Furthermore, systemd only starts a service when it is really needed. Daemons
  are not started unconditionally at boot time, but rather when being required
  for the first time. systemd also supports Kernel Control Groups (cgroups),
  snapshotting and restoring the system state and more. See
  <link xlink:href="http://www.freedesktop.org/wiki/Software/systemd/"/> for
  details.
 </para>
<!-- fs 2012-06-20:
       according to fcrozat:
        * too complex
        * it is up to packagers to enable such behaviour (socket activation on
          demand) and we don't have a lot of packages doing so atm

  <para>
   Services depend on each other. For example the <systemitem
   class="daemon">sshd</systemitem> daemon requires the network to be set up
   before it can be started. Each service provides a socket accepting
   connections or a mount point in the file system. Starting <systemitem
   class="daemon">sshd</systemitem> is only successful if all sockets it
   connects to, are available. Using System V results in serializing the
   services start-up&mdash;a service is not started until all other services it
   depends on, have been successfully started.
  </para>
  <para>
   &systemd; has a different approach. It provides provide sockets and mount
   points for all services. Afterward all services are started at once and
   get <quote>their</quote> socket passed on execution.  This allows to
   considerably speed up the boot process by starting all services in
   parallel.
  </para>

  -->
 <sect1 xml:id="sec.boot.systemd.concept">
  <title>The systemd Concept</title>

  <para>
   This section will go into detail about the concept behind systemd.
  </para>

  <sect2 xml:id="sec.boot.systemd.whatissystemd">
   <title>What Is systemd</title>
   <para>
    systemd is a system and session manager for Linux, compatible with System V
    and LSB init scripts. The main features are:
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>
      provides aggressive parallelization capabilities
     </para>
    </listitem>
    <listitem>
     <para>
      uses socket and D-Bus activation for starting services
     </para>
    </listitem>
    <listitem>
     <para>
      offers on-demand starting of daemons
     </para>
    </listitem>
    <listitem>
     <para>
      keeps track of processes using Linux cgroups
     </para>
    </listitem>
    <listitem>
     <para>
      supports snapshotting and restoring of the system state
     </para>
    </listitem>
    <listitem>
     <para>
      maintains mount and automount points
     </para>
    </listitem>
    <listitem>
     <para>
      implements an elaborate transactional dependency-based service control
      logic
     </para>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 xml:id="sec.boot.systemd.unitfile">
   <title>Unit File</title>
   <para>
    A unit configuration file encodes information about a service, a socket, a
    device, a mount point, an automount point, a swap file or partition, a
    start-up target, a watched file system path, a timer controlled and
    supervised by systemd, a temporary system state snapshot, a resource
    management slice or a group of externally created processes. <quote>Unit
    file</quote> is a generic term used by systemd for the following:
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <formalpara>
      <title>Service</title>
      <para>
       Information about a process (for example running a daemon); file ends
       with .service
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Targets</title>
      <para>
       Used for grouping units and as synchronization points during start-up;
       file ends with .target
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Sockets</title>
      <para>
       Information about an IPC or network socket or a file system FIFO, for
       socket-based activation (like
       <systemitem class="daemon">inetd</systemitem>); file ends with .socket
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Path</title>
      <para>
       Used to trigger other units (for example running a service when files
       change); file ends with .path
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Timer</title>
      <para>
       Information about a timer controlled, for timer-based activation; file
       ends with .timer
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Mount point</title>
      <para>
       Usually auto-generated by the fstab generator; file ends with .mount
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Automount point</title>
      <para>
       Information about a file system automount point; file ends with
       .automount
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Swap</title>
      <para>
       Information about a swap device or file for memory paging; file ends
       with .swap
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Device</title>
      <para>
       Information about a device unit as exposed in the sysfs/udev(7) device
       tree; file ends with .device
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Scope / Slice</title>
      <para>
       A concept for hierarchically managing resources of a group of processes;
       file ends with .scope/.slice
      </para>
     </formalpara>
    </listitem>
   </itemizedlist>
   <para>
    For more information about systemd.unit see
    <link xlink:href="http://www.freedesktop.org/software/systemd/man/systemd.unit.html"/>
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.boot.systemd.basics">
  <title>Basic Usage</title>

  <para>
   The System V init system uses several commands to handle services&mdash;the
   init scripts, <command>insserv</command>, <command>telinit</command> and
   others. systemd makes it easier to manage services, since there is only one
   command to memorize for the majority of service-handling tasks:
   <command>systemctl</command>. It uses the <quote>command plus
   subcommand</quote> notation like <command>git</command> or
   <command>zypper</command>:
  </para>

<screen>systemctl <replaceable>[general OPTIONS]</replaceable> <replaceable>subcommand</replaceable> <replaceable>[subcommand OPTIONS]</replaceable></screen>

  <para>
   See <command>man 1 systemctl</command> for a complete manual.
  </para>

  <tip>
   <title>Terminal Output and Bash Completion</title>
   <para>
    If the output goes to a terminal (and not to a pipe or a file, for example)
    systemd commands send long output to a pager by default. Use the
    <option>--no-pager</option> option to turn off paging mode.
   </para>
   <para>
    systemd also supports bash-completion, allowing you to enter the first
    letters of a subcommand and then press <keycap function="tab"/> to
    automatically complete it. This feature is only available in the
    <systemitem>bash</systemitem> shell and requires the installation of the
    package <systemitem class="resource">bash-completion</systemitem>.
   </para>
  </tip>

  <sect2 xml:id="sec.boot.systemd.basics.services">
   <title>Managing Services in a Running System</title>
   <para>
    Subcommands for managing services are the same as for managing a service
    with System V init (<command>start</command>, <command>stop</command>,
    ...). The general syntax for service management commands is as follows:
   </para>
   <variablelist>
    <varlistentry>
     <term>systemd</term>
     <listitem>
<screen>systemctl reload|restart|start|status|stop|<replaceable>...</replaceable> <replaceable>&lt;my_service(s)&gt;</replaceable></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>System V init</term>
     <listitem>
<screen>rc<replaceable>&lt;my_service(s)&gt;</replaceable> reload|restart|start|status|stop|<replaceable>...</replaceable></screen>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    systemd allows you to manage several services in one go. Instead of
    executing init scripts one after the other as with System V init, execute a
    command like the following:
   </para>
<screen>systemctl start <replaceable>&lt;my_1st_service&gt;</replaceable> <replaceable>&lt;my_2nd_service&gt;</replaceable></screen>
   <para>
    If you want to list all services available on the system:
   </para>
<screen>systemctl list-unit-files --type=service</screen>
   <para>
    The following table lists the most important service management commands
    for systemd and System V init:
   </para>
   <table rowsep="1">
    <title>Service Management Commands</title>
    <tgroup cols="3">
     <colspec colnum="1" colname="1" colwidth="50*"/>
     <colspec colnum="2" colname="2" colwidth="30*"/>
     <colspec colnum="3" colname="3" colwidth="20*"/>
     <thead>
      <row>
       <entry colname="1">
        <para>
         Task
        </para>
       </entry>
       <entry colname="2">
        <para>
         systemd Command
        </para>
       </entry>
       <entry colname="3">
        <para>
         System V init Command
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Starting</title>
         <para/>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>start</screen>
       </entry>
       <entry colname="3">
<screen>start</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Stopping</title>
         <para/>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>stop</screen>
       </entry>
       <entry colname="3">
<screen>stop</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Restarting</title>
         <para>
          Shuts down services and starts them afterward. If a service is not
          yet running it will be started.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>restart</screen>
       </entry>
       <entry colname="3">
<screen>restart</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Restarting conditionally</title>
         <para>
          Restarts services if they are currently running. Does nothing for
          services that are not running.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>try-restart</screen>
       </entry>
       <entry colname="3">
<screen>try-restart</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Reloading</title>
         <para>
          Tells services to reload their configuration files without
          interrupting operation. Use case: Tell Apache to reload a modified
          <filename>httpd.conf</filename> configuration file. Note that not all
          services support reloading.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>reload</screen>
       </entry>
       <entry colname="3">
<screen>reload</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Reloading or restarting</title>
         <para>
          Reloads services if reloading is supported, otherwise restarts them.
          If a service is not yet running it will be started.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>reload-or-restart</screen>
       </entry>
       <entry colname="3">
<screen>n/a</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Reloading or restarting conditionally</title>
         <para>
          Reloads services if reloading is supported, otherwise restarts them
          if currently running. Does nothing for services that are not running.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>reload-or-try-restart</screen>
       </entry>
       <entry colname="3">
<screen>n/a</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Getting detailed status information</title>
         <para>
          Lists information about the status of services. The &systemd; command
          shows details such as description, executable, status, cgroup, and
          messages last issued by a service (see
          <xref linkend="sec.boot.systemd.basics.services_debugging"/>). The
          level of details displayed with the System V init differs from
          service to service.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>status</screen>
       </entry>
       <entry colname="3">
<screen>status</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Getting short status information</title>
         <para>
          Shows whether services are active or not.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>is-active</screen>
       </entry>
       <entry colname="3">
<screen>status</screen>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>

  <sect2 xml:id="sec.boot.systemd.basics.services_enabling">
   <title>Permanently Enabling/Disabling Services</title>
   <para>
    The service management commands mentioned in the previous section let you
    manipulate services for the current session. systemd also lets you
    permanently enable or disable services, so they are automatically started
    when requested or are always unavailable. You can either do this by using
    &yast;, or on the command line.
   </para>
   <sect3 xml:id="sec.boot.systemd.basics.services_enabling.cmd">
    <title>Enabling/Disabling Services on the Command Line</title>
    <para>
     The following table lists enabling and disabling commands for systemd and
     System V init:
    </para>
    <important>
     <title>Service Start</title>
     <para>
      When enabling a service on the command line, it is not started
      automatically. It is scheduled to be started with the next system
      start-up or runlevel/target change. To immediately start a service after
      having enabled it, explicitly run <command>systemctl start
      <replaceable>&lt;my_service&gt;</replaceable></command> or <command>rc
      <replaceable>&lt;my_service&gt;</replaceable> start</command>.
     </para>
    </important>
    <table rowsep="1">
     <title>Commands for Enabling and Disabling Services</title>
     <tgroup cols="3">
      <colspec colnum="1" colname="1" colwidth="32*"/>
      <colspec colnum="2" colname="2" colwidth="40*"/>
      <colspec colnum="3" colname="3" colwidth="28*"/>
      <thead>
       <row>
        <entry colname="1">
         <para>
          Task
         </para>
        </entry>
        <entry colname="2">
         <para>
          &systemd; Command
         </para>
        </entry>
        <entry colname="3">
         <para>
          System V init Command
         </para>
        </entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Enabling</title>
          <para/>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl enable
          <replaceable>&lt;my_service(s)&gt;</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>insserv
          <replaceable>&lt;my_service(s)&gt;</replaceable></command>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Disabling</title>
          <para/>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl disable
          <replaceable>&lt;my_service(s)&gt;</replaceable>.service</command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>insserv -r
          <replaceable>&lt;my_service(s)&gt;</replaceable></command>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Checking</title>
          <para>
           Shows whether a service is enabled or not.
          </para>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl is-enabled
          <replaceable>&lt;my_service&gt;</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/a
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Re-enabling</title>
          <para>
           Similar to restarting a service, this command first disables and
           then enables a service. Useful to re-enable a service with its
           defaults.
          </para>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl reenable
          <replaceable>&lt;my_service&gt;</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/a
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Masking</title>
          <para>
           After <quote>disabling</quote> a service, it can still be started
           manually. To completely disable a service, you need to mask it. Use
           with care.
          </para>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl mask
          <replaceable>&lt;my_service&gt;</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/a
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Unmasking</title>
          <para>
           A service that has been masked can only be used again after it has
           been unmasked.
          </para>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl unmask
          <replaceable>&lt;my_service&gt;</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/a
         </para>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.boot.systemd.boot">
  <title>System Start and Target Management</title>

  <para>
   The entire process of starting the system and shutting it down is maintained
   by systemd. From this point of view, the Kernel can be considered a
   background process to maintain all other processes and adjust CPU time and
   hardware access according to requests from other programs.
  </para>

  <sect2 xml:id="sec.boot.systemd.targets">
   <title>Targets Compared to Runlevels</title>
   <para>
    With System V init the system was booted into a so-called
    <quote>Runlevel</quote>. A runlevel defines how the system is started and
    what services are available in the running system. Runlevels are numbered;
    the most commonly known ones are <literal>0</literal> (shutting down the
    system), <literal>3</literal> (multiuser with network) and
    <literal>5</literal> (multiuser with network and display manager).
   </para>
   <para>
    systemd introduces a new concept by using so-called <quote>target
    units</quote>. However, it remains fully compatible with the runlevel
    concept. Target units are named rather than numbered and serve specific
    purposes. For example, the targets <systemitem>local-fs.target</systemitem>
    and <systemitem>swap.target</systemitem> mount local file systems and swap
    spaces.
   </para>
   <para>
    The target <systemitem>graphical.target</systemitem> provides a multiuser
    system with network and display manager capabilities and is equivalent to
    runlevel 5. Complex targets, such as
    <systemitem>graphical.target</systemitem> act as <quote>meta</quote>
    targets by combining a subset of other targets. Since systemd makes it easy
    to create custom targets by combining existing targets, it offers great
    flexibility.
   </para>
   <para>
    The following list shows the most important systemd target units. For a
    full list refer to <command>man 7 systemd.special</command>.
   </para>
   <variablelist>
    <title>Selected systemd Target Units</title>
    <varlistentry>
     <term><systemitem>default.target</systemitem>
     </term>
     <listitem>
      <para>
       The target that is booted by default. Not a <quote>real</quote> target,
       but rather a symbolic link to another target like
       <systemitem>graphic.target</systemitem>. Can be permanently changed via
       &yast; (see <xref linkend="sec.boot.runlevel.edit"/>). To change it for
       a session, use the Kernel command line option
       <literal>systemd.unit=<replaceable>&lt;my_target&gt;.target</replaceable></literal>
       at the boot prompt.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>emergency.target</systemitem>
     </term>
     <listitem>
      <para>
       Starts an emergency shell on the console. Only use it at the boot prompt
       as <literal>systemd.unit=emergency.target</literal>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>graphical.target</systemitem>
     </term>
     <listitem>
      <para>
       Starts a system with network, multiuser support and a display manager.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>halt.target</systemitem>
     </term>
     <listitem>
      <para>
       Shuts down the system.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mail-transfer-agent.target</systemitem>
     </term>
     <listitem>
      <para>
       Starts all services necessary for sending and receiving mails.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>multi-user.target</systemitem>
     </term>
     <listitem>
      <para>
       Starts a multiuser system with network.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>reboot.target</systemitem>
     </term>
     <listitem>
      <para>
       Reboots the system.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>rescue.target</systemitem>
     </term>
     <listitem>
      <para>
       Starts a single-user system without network.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    To remain compatible with the System V init runlevel system, systemd
    provides special targets named
    <literal>runlevel<replaceable>X</replaceable>.target</literal> mapping the
    corresponding runlevels numbered <replaceable>X</replaceable>.
   </para>
   <para>
    If you want to know the current target, use the command: <command>systemctl
    get-default</command>
   </para>
   <table rowsep="1">
    <title>System V Runlevels and &systemd; Target Units</title>
    <tgroup cols="3">
     <colspec colnum="1" colname="1" colwidth="20*"/>
     <colspec colnum="2" colname="2" colwidth="40*"/>
     <colspec colnum="3" colname="3" colwidth="40*"/>
     <thead>
      <row>
       <entry>
        <para>
         System V runlevel
        </para>
       </entry>
       <entry>
        <para>
         &systemd; target
        </para>
       </entry>
       <entry>
        <para>
         Purpose
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         0
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel0.target</systemitem>,
         <systemitem>halt.target</systemitem>,
         <systemitem>poweroff.target</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         System shutdown
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         1, S
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel1.target</systemitem>,
         <systemitem>rescue.target</systemitem>,
        </para>
       </entry>
       <entry>
        <para>
         Single-user mode
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         2
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel2.target</systemitem>,
         <systemitem>multi-user.target</systemitem>,
        </para>
       </entry>
       <entry>
        <para>
         Local multiuser without remote network
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         3
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel3.target</systemitem>,
         <systemitem>multi-user.target</systemitem>,
        </para>
       </entry>
       <entry>
        <para>
         Full multiuser with network
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         4
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel4.target</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         Unused/User-defined
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         5
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel5.target</systemitem>,
         <systemitem>graphical.target</systemitem>,
        </para>
       </entry>
       <entry>
        <para>
         Full multiuser with network and display manager
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         6
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel6.target</systemitem>,
         <systemitem>reboot.target</systemitem>,
        </para>
       </entry>
       <entry>
        <para>
         System reboot
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <important>
    <title>systemd Ignores <filename>/etc/inittab</filename></title>
    <para>
     The runlevels in a System V init system are configured in
     <filename>/etc/inittab</filename>. systemd does <emphasis>not</emphasis>
     use this configuration. Refer to
     <xref linkend="sec.boot.systemd.custom.targets"/> for instructions on how
     to create your own bootable target.
    </para>
   </important>
   <sect3 xml:id="sec.boot.systemd.targets.commands">
    <title>Commands to Change Targets</title>
    <para>
     Use the following commands to operate with target units:
    </para>
    <informaltable rowsep="1">
     <tgroup cols="3">
      <colspec colnum="1" colname="1" colwidth="20*"/>
      <colspec colnum="2" colname="2" colwidth="50*"/>
      <colspec colnum="3" colname="3" colwidth="30*"/>
      <thead>
       <row>
        <entry colname="1">
         <para>
          Task
         </para>
        </entry>
        <entry colname="2">
         <para>
          systemd Command
         </para>
        </entry>
        <entry colname="3">
         <para>
          System V init Command
         </para>
        </entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry colname="1">
         <para>
          Change the current target/runlevel
         </para>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl isolate</command>
          <replaceable>&lt;my_target&gt;</replaceable>.target
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>telinit</command> <replaceable>X</replaceable>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          Change to the default target/runlevel
         </para>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl default</command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/a
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          Get the current target/runlevel
         </para>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl list-units --type=target</command>
         </para>
         <para>
          With systemd there is usually more than one active target. The
          command lists all currently active targets.
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>who -r</command>
         </para>
         <para>
          or
         </para>
         <para>
          <command>runlevel</command>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          persistently change the default runlevel
         </para>
        </entry>
        <entry colname="2">
         <para>
          Use the &ycc_runlevel; or run the following command:
         </para>
         <para>
          <command>ln -sf /usr/lib/systemd/system/</command>
          <replaceable>&lt;my_target&gt;</replaceable>.target
          /etc/systemd/system/default.target
         </para>
        </entry>
        <entry colname="3">
         <para>
          Use the &ycc_runlevel; or change the line
         </para>
         <para>
          <command>id:</command> <replaceable>X</replaceable>:initdefault:
         </para>
         <para>
          in <filename>/etc/inittab</filename>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          Change the default runlevel for the current boot process
         </para>
        </entry>
        <entry colname="2">
         <para>
          Enter the following option at the boot prompt
         </para>
         <para>
          <command>systemd.unit=</command>
          <replaceable>&lt;my_target&gt;</replaceable>.target
         </para>
        </entry>
        <entry colname="3">
         <para>
          Enter the desired runlevel number at the boot prompt.
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          Show a target's/runlevel's dependencies
         </para>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl show -p "Requires"</command>
          <replaceable>&lt;my_target&gt;</replaceable>.target
         </para>
         <para>
          <command>systemctl show -p "Wants"</command>
          <replaceable>&lt;my_target&gt;</replaceable>.target
         </para>
         <para>
          <quote>Requires</quote> lists the hard dependencies (the ones that
          must be resolved), whereas <quote>Wants</quote> lists the soft
          dependencies (the ones that get resolved if possible).
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/a
         </para>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </sect3>
  </sect2>

  <sect2 xml:id="sec.boot.systemd.debug">
   <title>Debugging System Start-Up</title>
   <para>
    systemd offers the means to analyze the system start-up process. You can
    conveniently review the list of all services and their status (rather than
    having to parse <filename>/varlog/</filename>). systemd also allows you to
    scan the start-up procedure to find out how much time each service start-up
    consumes.
   </para>
   <sect3 xml:id="sec.boot.systemd.debug.review">
    <title>Review Start-Up of Services</title>
    <para>
     To review the complete list of services that have been started since
     booting the system, enter the command <command>systemctl</command>. It
     lists all active services like shown below (shortened). To get more
     information on a specific service, use <command>systemctl status
     <replaceable>&lt;my_service&gt;</replaceable></command>.
    </para>
    <example>
     <title>List Active Services</title>
<screen>&prompt.root;systemctl
UNIT                        LOAD   ACTIVE SUB       JOB DESCRIPTION
[...]
iscsi.service               loaded active exited    Login and scanning of iSC+
kmod-static-nodes.service   loaded active exited    Create list of required s+
libvirtd.service            loaded active running   Virtualization daemon
nscd.service                loaded active running   Name Service Cache Daemon
ntpd.service                loaded active running   NTP Server Daemon
polkit.service              loaded active running   Authorization Manager
postfix.service             loaded active running   Postfix Mail Transport Ag+
rc-local.service            loaded active exited    /etc/init.d/boot.local Co+
rsyslog.service             loaded active running   System Logging Service
[...]
LOAD   = Reflects whether the unit definition was properly loaded.
ACTIVE = The high-level unit activation state, i.e. generalization of SUB.
SUB    = The low-level unit activation state, values depend on unit type.

161 loaded units listed. Pass --all to see loaded but inactive units, too.
To show all installed unit files use 'systemctl list-unit-files'.</screen>
    </example>
    <para>
     To restrict the output to services that failed to start, use the
     <option>--failed</option> option:
    </para>
    <example>
     <title>List Failed Services</title>
<screen>&prompt.root;systemctl --failed
UNIT                   LOAD   ACTIVE SUB    JOB DESCRIPTION
apache2.service        loaded failed failed     apache
NetworkManager.service loaded failed failed     Network Manager
plymouth-start.service loaded failed failed     Show Plymouth Boot Screen

[...]</screen>
    </example>
   </sect3>
   <sect3 xml:id="sec.boot.systemd.debug.time">
    <title>Debug Start-Up Time</title>
    <para>
     To debug system start-up time, systemd offers the
     <command>systemd-analyze</command> command. It shows the total start-up
     time, a list of services ordered by start-up time and can also generate an
     SVG graphic showing the time services took to start in relation to the
     other services.
    </para>
    <variablelist>
     <varlistentry>
      <term>Listing the System Start-Up Time</term>
      <listitem>
<screen>&prompt.root;systemd-analyze
Startup finished in 2666ms (kernel) + 21961ms (userspace) = 24628ms</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Listing the Services Start-Up Time</term>
      <listitem>
<screen>&prompt.root;systemd-analyze blame
  6472ms systemd-modules-load.service
  5833ms remount-rootfs.service
  4597ms network.service
  4254ms systemd-vconsole-setup.service
  4096ms postfix.service
  2998ms xdm.service
  2483ms localnet.service
  2470ms &susefirewallfiles;_init.service
  2189ms avahi-daemon.service
  2120ms systemd-logind.service
  1210ms xinetd.service
  1080ms ntp.service
[...]
    75ms fbset.service
    72ms purge-kernels.service
    47ms dev-vda1.swap
    38ms bluez-coldplug.service
    35ms splash_early.service</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Services Start-Up Time Graphics</term>
      <listitem>
<screen>&prompt.root;systemd-analyze plot &gt; &wsIname;-startup.svg</screen>
       <informalfigure>
        <mediaobject>
         <imageobject role="fo">
          <imagedata fileref="systemd_startup.svg" width="75%" format="SVG"/>
         </imageobject>
         <imageobject role="html">
          <imagedata fileref="systemd_startup.png" width="75%" format="PNG"/>
         </imageobject>
        </mediaobject>
       </informalfigure>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3 xml:id="sec.boot.systemd.debug.complete">
    <title>Review the Complete Start-Up Process</title>
    <para>
     The above-mentioned commands let you review the services that started and
     the time it took to start them. If you need to know more details, you can
     tell &systemd; to verbosely log the complete start-up procedure by
     entering the following parameters at the boot prompt:
    </para>
<screen>systemd.log_level=debug systemd.log_target=kmsg</screen>
    <para>
     Now &systemd; writes its log messages into the kernel ring buffer. View
     that buffer with <command>dmesg</command>:
    </para>
<screen>dmesg -T | less</screen>
   </sect3>
  </sect2>

  <sect2 xml:id="sec.boot.systemd.sysv_compatibility">
   <title>System V Compatibility</title>
   <para>
    systemd is compatible with System V, allowing you to still use existing
    System V init scripts. However, there is at least one known issue where a
    System V init script does not work with systemd out of the box: starting a
    service as a different user via <command>su</command> or
    <command>sudo</command> in init scripts will result in a failure of the
    script, producing an <quote>Access denied</quote> error.
   </para>
   <para>
    When changing the user with <command>su</command> or
    <command>sudo</command>, a PAM session is started. This session will be
    terminated after the init script is finished. As a consequence, the service
    that has been started by the init script will also be terminated. To work
    around this error, proceed as follows:
   </para>
   <procedure>
    <step>
     <para>
      Create a service file wrapper with the same name as the init script plus
      the file name extension <filename>.service</filename>:
     </para>
<screen>[Unit]
Description=<replaceable>DESCRIPTION</replaceable>
After=network.target

[Service]
User=<replaceable>USER</replaceable>
Type=forking<co xml:id="co.service_wrapper.type"/>
PIDFile=<replaceable>PATH TO PID FILE</replaceable><xref linkend="co.service_wrapper.type" xrefstyle="select:label nopage"/>
ExecStart=<replaceable>PATH TO INIT SCRIPT</replaceable> start
ExecStop=<replaceable>PATH TO INIT SCRIPT</replaceable> stop
ExecStopPost=/usr/bin/rm -f <replaceable>PATH TO PID FILE</replaceable><xref linkend="co.service_wrapper.type" xrefstyle="select:label nopage"/>

[Install]
WantedBy=multi-user.target<co xml:id="co.service_wrapper.target"/></screen>
     <para>
      Replace all values written in <replaceable>UPPERCASE
      LETTERS</replaceable> with appropriate values.
     </para>
     <calloutlist>
      <callout arearefs="co.service_wrapper.type">
       <para>
        Optional&mdash;only use if the init script starts a daemon.
       </para>
      </callout>
      <callout arearefs="co.service_wrapper.target">
       <para>
        <literal>multi-user.target</literal> also starts the init script when
        booting into <literal>graphical.target</literal>. If it should only be
        started when booting into the display manager, user
        <literal>graphical.target</literal> here.
       </para>
      </callout>
     </calloutlist>
    </step>
    <step>
     <para>
      Start the daemon with <command>systemctl start
      <replaceable>APPLICATION</replaceable></command>.
     </para>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.boot.runlevel.edit">
  <title>Managing Services with &yast;</title>

  <para>
   Basic service management can also be done with the &yast; &ycc_runlevel;
   module. It supports starting, stopping, enabling and disabling services. It
   also lets you show a service's status and change the default target. Start
   the &yast; module with <menuchoice> <guimenu>&yast;</guimenu>
   <guimenu>System</guimenu> <guimenu>&ycc_runlevel;</guimenu> </menuchoice>.
  </para>

  <figure xml:id="fig.yast2.runlevel">
   <title>&ycc_runlevel;</title>
   <mediaobject>
    <imageobject role="fo">
     <imagedata fileref="yast2_runlevel.png" width="75%" format="PNG"/>
    </imageobject>
    <imageobject role="html">
     <imagedata fileref="yast2_runlevel.png" width="75%" format="PNG"/>
    </imageobject>
   </mediaobject>
  </figure>

  <variablelist>
   <varlistentry>
    <term>Changing the <guimenu>Default System Target</guimenu>
    </term>
    <listitem>
     <para>
      To change the target the system boots into, choose a target from the
      <guimenu>Default System Target</guimenu> drop-down box. The most often
      used targets are <guimenu>Graphical Interface</guimenu> (starting a
      graphical login screen) and <guimenu>Multi-User</guimenu> (starting the
      system in command line mode).
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Starting or Stopping a Service</term>
    <listitem>
     <para>
      Select a service from the table. The <guimenu>Active</guimenu> column
      shows whether it is currently running (<guimenu>Active</guimenu>) or not
      (<guimenu>Inactive</guimenu>). Toggle its status by choosing
      <guimenu>Start/Stop</guimenu>.
     </para>
     <para>
      Starting or stopping a service changes its status for the currently
      running session. To change its status throughout a reboot, you need to
      enable or disable it.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Enabling or Disabling a Service</term>
    <listitem>
     <para>
      Select a service from the table. The <guimenu>Enabled</guimenu> column
      shows whether it is currently <guimenu>Enabled</guimenu> or
      <guimenu>Disabled</guimenu>. Toggle its status by choosing
      <guimenu>Enable/Disable</guimenu>.
     </para>
     <para>
      By enabling or disabling a service you configure whether it is started
      during booting (<guimenu>Enabled</guimenu>) or not
      (<guimenu>Disabled</guimenu>). This setting will not affect the current
      session. To change its status in the current session, you need to start
      or stop it.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>View a Status Messages</term>
    <listitem>
     <para>
      To view the status message of a service, select it from the list and
      choose <guimenu>Show Details</guimenu>. The output you will see is
      identical to the one generated by the command
      <command>systemctl</command> <option>-l</option> status
      <replaceable>&lt;my_service&gt;</replaceable>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <warning>
   <title>Faulty Runlevel Settings May Damage Your System</title>
   <para>
    Faulty runlevel settings may make your system unusable. Before applying
    your changes, make absolutely sure that you know their consequences.
   </para>
  </warning>
 </sect1>
 <sect1 xml:id="sec.boot.systemd.custom">
  <title>Customization of <systemitem>systemd</systemitem></title>

  <para>
   The following sections contain some examples for
   <systemitem>systemd</systemitem> customization.
  </para>

  <warning>
   <title>Avoiding Overwritten Customization</title>
   <para>
    Always do systemd customization in <filename>/etc/systemd/</filename>,
    <emphasis>never</emphasis> in <filename>/usr/lib/systemd/</filename>.
    Otherwise your changes will be overwritten by the next update of systemd.
   </para>
  </warning>

  <sect2 xml:id="sec.boot.systemd.custom.service">
   <title>Customizing Service Files</title>
   <para>
    The systemd service files are located in
    <filename>/usr/lib/systemd/system</filename>. If you want to customize
    them, proceed as follows:
   </para>
   <procedure>
    <step>
     <para>
      Copy the files you want to modify from
      <filename>/usr/lib/systemd/system</filename> to
      <filename>/etc/systemd/system</filename>. Keep the file names identical
      to the original ones.
     </para>
    </step>
    <step>
     <para>
      Modify the copies in <filename>/etc/systemd/system</filename> according
      to your needs.
     </para>
    </step>
    <step>
     <para>
      For an overview of your configuration changes, use the
      <command>systemd-delta</command> command. It can compare and identify
      configuration files that override other configuration files. For details,
      refer to the <command>systemd-delta</command> man page.
     </para>
    </step>
   </procedure>
   <para>
    The modified files in <filename>/etc/systemd</filename> will take
    precedence over the original files in
    <filename>/usr/lib/systemd/system</filename>, provided that their file name
    is the same.
   </para>
  </sect2>

  <sect2 xml:id="sec.boot.systemd.custom.drop-in">
   <title>Creating <quote>Drop-in</quote> Files</title>
   <para>
    If you only want to add a few lines to a configuration file or modify a
    small part of it, you can use so-called <quote>drop-in</quote> files.
    Drop-in files let you extend the configuration of unit files without having
    to edit or override the unit files themselves.
   </para>
   <para>
    For example, to change one value for the <replaceable>foobar</replaceable>
    service located in
    <filename>/usr/lib/systemd/system/<replaceable>foobar.service</replaceable></filename>,
    proceed as follows:
   </para>
   <procedure>
    <step>
     <para>
      Create a directory called
      <filename>/etc/systemd/system/<replaceable>&lt;my_service&gt;</replaceable>.service.d/</filename>.
     </para>
     <para>
      Note the <literal>.d</literal> suffix. The directory must otherwise be
      named like the service that you want to patch with the drop-in file.
     </para>
    </step>
    <step>
     <para>
      In that directory, create a file
      <filename><replaceable>whatevermodification</replaceable>.conf</filename>.
     </para>
     <para>
      Make sure it only contains the line with the value that you want to
      modify.
     </para>
    </step>
    <step>
     <para>
      Save your changes to the file. It will be used as an extension of the
      original file.
     </para>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="sec.boot.systemd.custom.targets">
   <title>Creating Custom Targets</title>
   <para>
    On System V init &suse; systems, runlevel 4 is unused to allow
    administrators to create their own runlevel configuration. systemd allows
    you to create any number of custom targets. It is suggested to start by
    adapting an existing target such as
    <systemitem>graphical.target</systemitem>.
   </para>
   <procedure>
    <step>
     <para>
      Copy the configuration file
      <filename>/usr/lib/systemd/system/graphical.target</filename> to
      <filename>/etc/systemd/system/<replaceable>&lt;my_target&gt;</replaceable>.target</filename>
      and adjust it according to your needs.
     </para>
    </step>
    <step>
     <para>
      The configuration file copied in the previous step already covers the
      required (<quote>hard</quote>) dependencies for the target. To also cover
      the wanted (<quote>soft</quote>) dependencies, create a directory
      <filename>/etc/systemd/system/<replaceable>&lt;my_target&gt;</replaceable>.target.wants</filename>.
     </para>
    </step>
    <step>
     <para>
      For each wanted service, create a symbolic link from
      <filename>/usr/lib/systemd/system</filename> into
      <filename>/etc/systemd/system/<replaceable>&lt;my_target&gt;</replaceable>.target.wants</filename>.
     </para>
    </step>
    <step>
     <para>
      Once you have finished setting up the target, reload the systemd
      configuration to make the new target available:
     </para>
<screen>systemctl daemon-reload</screen>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.boot.systemd.advanced">
  <title>Advanced Usage</title>

  <para>
   The following sections cover advanced topics for system administrators. For
   even more advanced systemd documentation, refer to Lennart PÃ¶ttering's
   series about systemd for administrators at
   <link xlink:href="http://0pointer.de/blog/projects"/>.
  </para>

  <sect2 xml:id="sec.boot.systemd.advanced.tmp">
   <title>Cleaning Temporary Directories</title>
   <para>
    &systemd; supports cleaning temporary directories regularly. The
    configuration from the previous system version is automatically migrated
    and active. <literal>tmpfiles.d</literal>&mdash;which is responsible for
    managing temporary files&mdash;reads its configuration from
    <filename>/etc/tmpfiles.d/*.conf</filename> ,
    <filename>/run/tmpfiles.d/*.conf</filename>, and
    <filename>/usr/lib/tmpfiles.d/*.conf</filename> files. Configuration placed
    in <filename>/etc/tmpfiles.d/*.conf</filename> overrides related
    configurations from the other two directories
    (<filename>/usr/lib/tmpfiles.d/*.conf</filename> is where packages store
    their configuration files).
   </para>
   <para>
    The configuration format is one line per path containing action and path,
    and optionally mode, ownership, age and argument fields, depending on the
    action. The following example unlinks the X11 lock files:
   </para>
<screen>Type Path               Mode UID  GID  Age Argument
r    /tmp/.X[0-9]*-lock</screen>
   <para>
    To get the status the tmpfile timer:
   </para>
<screen>systemctl status systemd-tmpfiles-clean.timer
systemd-tmpfiles-clean.timer - Daily Cleanup of Temporary Directories
 Loaded: loaded (/usr/lib/systemd/system/systemd-tmpfiles-clean.timer; static)
 Active: active (waiting) since Tue 2014-09-09 15:30:36 CEST; 1 weeks 6 days ago
   Docs: man:tmpfiles.d(5)
         man:systemd-tmpfiles(8)

Sep 09 15:30:36 &wsI; systemd[1]: Starting Daily Cleanup of Temporary Directories.
Sep 09 15:30:36 &wsI; systemd[1]: Started Daily Cleanup of Temporary Directories.</screen>
   <para>
    For more information on temporary files handling, see <command>man 5
    tmpfiles.d</command>.
   </para>
  </sect2>

  <sect2 xml:id="sec.boot.systemd.advanced.logging">
   <title>System Log</title>
   <para>
    <xref linkend="sec.boot.systemd.basics.services_debugging"/> explains how
    to view log messages for a given service. However, displaying log messages
    is not restricted to service logs. You can also access and query the
    complete log messages written by &systemd;&mdash;the so-called
    <quote>Journal</quote>. Use the command
    <command>systemd-journalctl</command> to display the complete log messages
    starting with the oldest entries. Refer to <command>man 1
    systemd-journalctl</command> for options such as applying filters or
    changing the output format.
   </para>
  </sect2>

  <sect2 xml:id="sec.boot.systemd.advanced.snapshots">
   <title>Snapshots</title>
   <para>
    You can save the current state of &systemd; to a named snapshot and later
    revert to it with the <command>isolate</command> subcommand. This is useful
    when testing services or custom targets, because it allows you to return to
    a defined state at any time. A snapshot is only available in the current
    session and will automatically be deleted on reboot. A snapshot name must
    end in <filename>.snapshot</filename>.
   </para>
   <variablelist>
    <varlistentry>
     <term>Create a Snapshot</term>
     <listitem>
<screen>systemctl snapshot <replaceable>&lt;my_snapshot&gt;</replaceable>.snapshot</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Delete a Snapshot</term>
     <listitem>
<screen>systemctl delete <replaceable>&lt;my_snapshot&gt;</replaceable>.snapshot</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>View a Snapshot</term>
     <listitem>
<screen>systemctl show <replaceable>&lt;my_snapshot&gt;</replaceable>.snapshot</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Activate a Snapshot</term>
     <listitem>
<screen>systemctl isolate <replaceable>&lt;my_snapshot&gt;</replaceable>.snapshot</screen>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

<!-- ================================================================== -->

<!-- bnc#892349 -->

  <sect2 xml:id="sec.boot.systemd.advanced.kernel_modules">
   <title>Loading Kernel Modules</title>
   <para>
    With &systemd;, kernel modules can automatically be loaded at boot time via
    a configuration file in <filename>/etc/modules-load.d</filename>. The file
    should be named <replaceable>module</replaceable>.conf and have the
    following content:
   </para>
<screen># load module <replaceable>module</replaceable> at boot time
<replaceable>module</replaceable></screen>
   <para>
    In case a package installs a configuration file for loading a Kernel
    module, the file gets installed to
    <filename>/usr/lib/modules-load.d</filename>. If two configuration files
    with the same name exist, the one in
    <filename>/etc/modules-load.d</filename> tales precedence.
   </para>
   <para>
    For more information, see the <systemitem>modules-load.d(5)</systemitem>
    man page.
   </para>
  </sect2>

<!-- fate #316631 -->

  <sect2 xml:id="sec.boot.systemd.advanced.before.local">
   <title>Performing Actions Before Loading a Service</title>
   <para>
    With System V init actions that need to be performed before loading a
    service, needed to be specified in <filename>/etc/init.d/before.local
    </filename>. This procedure is no longer supported with systemd. If you
    need to do actions before starting services, do the following:
   </para>
   <variablelist>
    <varlistentry>
     <term>Loading Kernel Modules</term>
     <listitem>
      <para>
       Create a drop-in file in <filename>/etc/modules-load.d</filename>
       directory (see <command>man modules-load.d</command> for the syntax)
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
     Creating Files or Directories, Cleaning-up Directories, Changing
     Ownership
     </term>
     <listitem>
      <para>
       Create a drop-in file in <filename>/etc/tmpfiles.d</filename> (see
       <command>man tmpfiles.d</command> for the syntax)
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Other Tasks</term>
     <listitem>
      <para>
       Create a system service file, for example
       <filename>/etc/systemd/system/before.service</filename>, from the
       following template:
      </para>
<screen>[Unit]
Before=<replaceable>NAME OF THE SERVICE YOU WANT THIS SERVICE TO BE STARTED BEFORE</replaceable>
[Service]
Type=oneshot
RemainAfterExit=true
ExecStart=<replaceable>YOUR_COMMAND</replaceable>
# beware, executable is run directly, not through a shell, check the man pages
# systemd.service and systemd.unit for full syntax
[Install]
# target in which to start the service
WantedBy=multi-user.target
#WantedBy=graphical.target</screen>
      <para>
       When the service file is created, you should run the following commands
       (as &rootuser;):
      </para>
<screen>systemctl daemon-reload
systemctl enable before</screen>
      <para>
       Every time you modify the service file, you need to run:
      </para>
<screen>systemctl daemon-reload</screen>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

<!-- ================================================================== -->

  <sect2 xml:id="sec.boot.systemd.advanced.cgroups">
   <title>Kernel Control Groups (cgroups)</title>
   <para>
    On a traditional System V init system it is not always possible to clearly
    assign a process to the service that spawned it. Some services, such as
    Apache, spawn a lot of third-party processes (for example CGI or Java
    processes), which themselves spawn more processes. This makes a clear
    assignment difficult or even impossible. Additionally, a service may not
    terminate correctly, leaving some children alive.
   </para>
   <para>
    systemd solves this problem by placing each service into its own cgroup.
    cgroups are a Kernel feature that allows aggregating processes and all
    their children into hierarchical organized groups. systemd names each
    cgroup after its service. Since a non-privileged process is not allowed to
    <quote>leave</quote> its cgroup, this provides an effective way to label
    all processes spawned by a service with the name of the service.
   </para>
   <para>
    To list all processes belonging to a service, use the command
    <command>systemd-cgls</command>. The result will look like the following
    (shortened) example:
   </para>
   <example>
    <title>List all Processes Belonging to a Service</title>
<screen>&prompt.root;systemd-cgls --no-pager
ââ1 /usr/lib/systemd/systemd --switched-root --system --deserialize 20
ââuser.slice
â ââuser-1000.slice
â   ââsession-102.scope
â   â ââ12426 gdm-session-worker [pam/gdm-password]
â   â ââ15831 gdm-session-worker [pam/gdm-password]
â   â ââ15839 gdm-session-worker [pam/gdm-password]
â   â ââ15858 /usr/lib/gnome-terminal-server

[...]

ââsystem.slice
  ââsystemd-hostnamed.service
  â ââ17616 /usr/lib/systemd/systemd-hostnamed
  ââcron.service
  â ââ1689 /usr/sbin/cron -n
  âântpd.service
  â ââ1328 /usr/sbin/ntpd -p /var/run/ntp/ntpd.pid -g -u ntp:ntp -c /etc/ntp.conf
  ââpostfix.service
  â ââ 1676 /usr/lib/postfix/master -w
  â ââ 1679 qmgr -l -t fifo -u
  â ââ15590 pickup -l -t fifo -u
  ââsshd.service
  â ââ1436 /usr/sbin/sshd -D

[...]</screen>
   </example>
   <para>
    See <xref linkend="cha.tuning.cgroups"/> for more information about
    cgroups.
   </para>
  </sect2>

  <sect2 xml:id="sec.boot.systemd.advanced.kill">
   <title>Terminating Services (Sending Signals)</title>
   <para>
    As explained in <xref linkend="sec.boot.systemd.advanced.cgroups"/>, it is
    not always possible to assign a process to its parent service process in a
    System V init system. This makes it difficult to terminate a service and
    all of its children. Child processes that have not been terminated will
    remain as zombie processes.
   </para>
   <para>
    systemd's concept of confining each service into a cgroup makes it possible
    to clearly identify all child processes of a service and therefore allows
    you to send a signal to each of these processes. Use <command>systemctl
    kill</command> to send signals to services. For a list of available signals
    refer to <command>man 7 signals</command>.
   </para>
   <variablelist>
    <varlistentry>
     <term>Sending <systemitem>SIGTERM</systemitem> to a Service</term>
     <listitem>
      <para>
       <systemitem>SIGTERM</systemitem> is the default signal that is sent.
      </para>
<screen>systemctl kill <replaceable>&lt;my_service&gt;</replaceable></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Sending <replaceable>SIGNAL</replaceable> to a Service</term>
     <listitem>
      <para>
       Use the <option>-s</option> option to specify the signal that should be
       sent.
      </para>
<screen>systemctl kill -s <replaceable>SIGNAL</replaceable> <replaceable>&lt;my_service&gt;</replaceable></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Selecting Processes</term>
     <listitem>
      <para>
       By default the <command>kill</command> command sends the signal to
       <option>all</option> processes of the specified cgroup. You can restrict
       it to the <option>control</option> or the <option>main</option> process.
       The latter is for example useful to force a service to reload its
       configuration by sending <systemitem>SIGHUP</systemitem>:
      </para>
<screen>systemctl kill -s SIGHUP --kill-who=main <replaceable>&lt;my_service&gt;</replaceable></screen>
     </listitem>
    </varlistentry>
   </variablelist>

   <warning>
    <title>Terminating or Restarting the D-BUS Service is not Supported</title>
    <para>
     The D-Bus service is the message bus for communication between systemd
     clients and the systemd manager that is running as pid 1. Even though
     <systemitem class="daemon">dbus</systemitem> is a standalone daemon, it is
     an integral part of the init infrastructure.
    </para>
    <para>
     Terminating <systemitem
     class="daemon">dbus</systemitem> or restarting it in the running system is
     similar to an attempt of terminating or restarting pid 1. It will break
     systemd client-server communication and make most systemd functions
     unusable.
    </para>
    <para>
     Therefore, terminating or restarting <systemitem
     class="daemon">dbus</systemitem> is neither recommended nor supported.
    </para>
   </warning>

  </sect2>

<!-- debug section should be at the end to be more positive -->

  <sect2 xml:id="sec.boot.systemd.basics.services_debugging">
   <title>Debugging Services</title>
   <para>
    By default, systemd is not overly verbose. If a service was started
    successfully, no output will be produced. In case of a failure, a short
    error message will be displayed. However, <command>systemctl
    status</command> provides means to debug start-up and operation of a
    service.
   </para>
   <para>
    systemd comes with its own logging mechanism (<quote>The Journal</quote>)
    that logs system messages. This allows you to display the service messages
    together with status messages. The <command>status</command> command works
    similar to <command>tail</command> and can also display the log messages in
    different formats, making it a powerful debugging tool.
   </para>
   <variablelist>
    <varlistentry>
     <term>Show Service Start-Up Failure</term>
     <listitem>
      <para>
       Whenever a service fails to start, use <command>systemctl status
       <replaceable>&lt;my_service&gt;</replaceable></command> to get a
       detailed error message:
      </para>
<screen>&prompt.root;systemctl start apache2
Job failed. See system journal and 'systemctl status' for details.
&prompt.root;systemctl status apache2
   Loaded: loaded (/usr/lib/systemd/system/apache2.service; disabled)
   Active: failed (Result: exit-code) since Mon, 04 Jun 2012 16:52:26 +0200; 29s ago
   Process: 3088 ExecStart=/usr/sbin/start_apache2 -D SYSTEMD -k start (code=exited, status=1/FAILURE)
   CGroup: name=systemd:/system/apache2.service

Jun 04 16:52:26 g144 start_apache2[3088]: httpd2-prefork: Syntax error on line
205 of /etc/apache2/httpd.conf: Syntax error on li...alHost&gt;</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Show Last <replaceable>n</replaceable> Service Messages</term>
     <listitem>
      <para>
       The default behavior of the <command>status</command> subcommand is to
       display the last ten messages a service issued. To change the number of
       messages to show, use the
       <option>--lines=<replaceable>n</replaceable></option> parameter:
      </para>
<screen>systemctl status ntp
systemctl --lines=20 status ntp</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Show Service Messages in Append Mode</term>
     <listitem>
      <para>
       To display a <quote>live stream</quote> of service messages, use the
       <option>--follow</option> option, which works like
       <command>tail</command> <option>-f</option>:
      </para>
<screen>systemctl --follow status ntp</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Messages Output Format</term>
     <listitem>
      <para>
       The <option>--output=<replaceable>mode</replaceable></option> parameter
       allows you to change the output format of service messages. The most
       important modes available are:
      </para>
      <variablelist>
       <varlistentry>
        <term><option>short</option>
        </term>
        <listitem>
         <para>
          The default format. Shows the log messages with a human readable time
          stamp.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><option>verbose</option>
        </term>
        <listitem>
         <para>
          Full output with all fields.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><option>cat</option>
        </term>
        <listitem>
         <para>
          Terse output without time stamps.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.boot.systemd.info">
  <title>More Information</title>

  <para>
   For more information on systemd refer to the following online resources:
  </para>

  <variablelist>
   <varlistentry>
    <term>Homepage</term>
    <listitem>
     <para>
      <link xlink:href="http://www.freedesktop.org/wiki/Software/systemd"/>
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>systemd for Administrators</term>
    <listitem>
     <para>
      Lennart PÃ¶ttering, one of the systemd authors, has written a series of
      blog entries (13 at the time of writing this chapter). Find them at
      <link xlink:href="http://0pointer.de/blog/projects"/>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
</chapter>
