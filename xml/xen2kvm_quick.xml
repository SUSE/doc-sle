<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="urn:x-suse:xslt:profiling:docbook50-profile.xsl"
                 type="text/xml" 
                 title="Profiling step"?>
<!DOCTYPE article
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<!-- Converted by suse-upgrade version 1.1 -->
<?provo dirname="installquick/"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="art.sles.xen2kvmquick" xml:lang="en">
<?suse-quickstart color="suse"?>
 <title>&xen; to &kvm; Migration Guide</title>
 <subtitle>&productname; &productnumber;</subtitle>
 <info>
  <productnumber>&productnumber;</productnumber><productname>&productname;</productname>
  <abstract>
   <para>
    As the &kvm; virtualization solution is becoming more and more
    popular among server administrators, many of them need a path to migrate
    their existing &xen; based environments to &kvm;. As of now, there
    are no mature tools to automatically convert &xen; VMs to &kvm;.
    There is, however, a technical solution that helps convert &xen;
    virtual machines to &kvm;. Information and procedures introduced in
    this helps you smooth the migration.
   </para>
  </abstract>
 </info>
<?suse-quickstart color="suse"?>
 <important>
  <para>
   The migration procedure described in this document is not fully supported
   by SUSE. We provide it as a guidance only.
  </para>
 </important>
 <sect1 xml:id="v2v">
  <title>Migration to &kvm; Using <command>virt-v2v</command></title>

  <para>
   This section contains information to help you import virtual machines
   from foreign hypervisors (such as &xen;) to &kvm; managed by
   &libvirt;.
  </para>

  <tip>
   <title>Microsoft Windows Guests</title>
   <para>
    This section is focused on converting Linux guests. Converting Microsoft
    Windows guests using <command>virt-v2v</command> is the same as
    converting Linux guests, except in regards to handling the Virtual
    Machine Driver Pack (VMDP). Additional details on converting Windows
    guests with the VMDP can be found in the separate Virtual Machine Driver
    Pack documentation.
    <remark>2014-06-06 tbazant: FIXME - add link to real VMDP URL once it's
    ready</remark>
   </para>
  </tip>

  <sect2 xml:id="v2v.intro">
   <title>Introduction to <command>virt-v2v</command></title>
   <para>
    <command>virt-v2v</command> is a command line tool to convert
    &vmguest;s from a foreign hypervisor to run on &kvm; managed by
    &libvirt;. It enables paravirtualized virtio drivers in the converted
    virtual machine if possible. A list of supported operating systems and
    hypervisors follows:
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <title>Supported Guest Operating Systems</title>
    <listitem>
     <para>
      &sls;
     </para>
    </listitem>
    <listitem>
     <para>
      &opensuse;
     </para>
    </listitem>
    <listitem>
     <para>
      &rhel;
     </para>
    </listitem>
    <listitem>
     <para>
      Fedora
     </para>
    </listitem>
    <listitem>
     <para>
      Microsoft Windows Server 2003 and 2008
     </para>
    </listitem>
   </itemizedlist>
   <itemizedlist mark="bullet" spacing="normal">
    <title>Supported Source Hypervisor</title>
    <listitem>
     <para>
      &xen;
     </para>
    </listitem>
   </itemizedlist>
   <itemizedlist mark="bullet" spacing="normal">
    <title>Supported Target Hypervisor</title>
    <listitem>
     <para>
      &kvm; (managed by &libvirt;)
     </para>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 xml:id="v2v.install">
   <title>Installing <command>virt-v2v</command></title>
   <para>
    The installation of <command>virt-v2v</command> is simple:
   </para>
<screen>sudo zypper install virt-v2v</screen>
   <para>
    Remember that <command>virt-v2v</command> requires &rootuser;
    privileges, so you need to run it either as &rootuser;, or via
    <command>sudo</command>.
   </para>
  </sect2>

  <sect2 xml:id="v2v.convert">
   <title>Converting Virtual Machines to Run under &kvm; managed by &libvirt;</title>
   <para>
    <command>virt-v2v</command> converts virtual machines from the &xen;
    hypervisor to run under &kvm; managed by &libvirt;. To learn more
    about &libvirt; and <command>virsh</command>, see
    <xref linkend="part.virt.libvirt"/>. Additionally, all
    <command>virt-v2v</command> command line switches are explained in the
    related manual page <command>man 1 virt-v2v</command>.
   </para>
   <para>
    Before you convert a virtual machine, make sure you complete the
    following steps:
   </para>
   <procedure>
    <title>Prepare the Environment for Conversion</title>
    <step>
     <para>
      Create a new local storage pool.
     </para>
     <para>
      <command>virt-v2v</command> copies the storage of the source virtual
      machine to a local storage pool managed by &libvirt; (the original
      disk image remains unchanged). You can create the pool either with
      &vmm;, or <command>virsh</command>. For more information, see
      <xref linkend="sec.libvirt.storage.vmm"/> and
      <xref linkend="sec.libvirt.storage.virsh"/>.
     </para>
    </step>
    <step>
     <para>
      Prepare local network interface.
     </para>
     <para>
      Check that the converted virtual machine can use local network
      interface on the &vmhost;. It is usually a network bridge. If it is
      not defined yet, you can create it with
      <menuchoice><guimenu>&yast;</guimenu><guimenu>Network
      Devices</guimenu><guimenu>Network
      Settings</guimenu><guimenu>Add</guimenu><guimenu>Bridge</guimenu></menuchoice>.
     </para>
     <note>
      <para>
       Network devices on the source &xen; host can be mapped during the
       conversion process to corresponding network devices on the &kvm;
       target host (e.g. &xen; bridge <literal>br0</literal> can be
       mapped to KVM network default). Sample mappings can be found in
       <filename>/etc/virt-v2v.conf</filename>. To enable these mappings,
       modify the XML rule as necessary and ensure the section is not
       commented out with '&lt;!--' and '--&gt;' markers. For example:
      </para>
<screen>
 &lt;network type='bridge' name='br0'&gt;
   &lt;network type='network' name='default'/&gt;
 &lt;/network&gt;
</screen>
     </note>
     <tip>
      <para>
       When there is no network bridge available, &vmm; can optionally
       create one for you.
      </para>
     </tip>
    </step>
   </procedure>
   <para>
    <command>virt-v2v</command> has the following basic command syntax:
   </para>
<screen>virt-v2v -i <replaceable>input_method</replaceable> -os <replaceable>storage_pool</replaceable> <replaceable>source_vm</replaceable></screen>
   <variablelist>
    <varlistentry>
     <term>input_method</term>
     <listitem>
      <para>
       There are two input methods: <literal>libvirt</literal> or
       <literal>libvirtxml</literal>. See the
       <replaceable>source_vm</replaceable> parameter for more information.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>storage_pool</term>
     <listitem>
      <para>
       The storage pool you already prepared for the target virtual machine.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>source_vm</term>
     <listitem>
      <para>
       The source virtual machine to convert. It depends on the
       <replaceable>input_method</replaceable> parameter: for
       <literal>libvirt</literal>, specify the name of a libvirt domain,
       while for <literal>libvirtxml</literal>, specify the path to an XML
       file containing a libvirt domain specification.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <note>
    <para>
     Conversion of a virtual machine takes a lot of system resources, mainly
     for copying the whole disk image for a virtual machine. Converting a
     single virtual machine typically takes up to 10 minutes, although
     virtual machines using very large disk images can take much longer.
    </para>
   </note>
   <sect3 xml:id="v2v.convert.xml">
    <title>Conversion Based on &libvirt; XML Description File</title>
    <para>
     This section describes how to convert a local &xen; virtual machine
     using the &libvirt; XML configuration file. This method is suitable
     if the host is already running &kvm; hypervisor. Make sure that the
     &libvirt; XML file of the source virtual machine is available on the
     local host, as well as the &libvirt; storage pool referenced from
     it.
    </para>
    <procedure>
     <step>
      <para>
       Obtain the &libvirt; XML description of the source virtual
       machine.
      </para>
      <tip>
       <para>
        To obtain the &libvirt; XML files of the source virtual machine,
        you need to be running the host OS under &xen; kernel. If you
        already rebooted the host to &kvm;-enabled environment, reboot
        back to &xen; kernel, dump the &libvirt; XML file, and then
        reboot back to &kvm; environment.
       </para>
      </tip>
      <para>
       First identify the source virtual machine under virsh:
      </para>
<screen># virsh list
 Id    Name                           State
----------------------------------------------------
[...]
  2     sles12_xen                     running
[...]</screen>
      <para>
       <literal>sles12_xen</literal> is the source virtual machine to
       convert. Now export its XML and save it to
       <filename>sles12_xen.xml</filename>:
      </para>
<screen># virsh dumpxml sles12_xen &gt; sles12_xen.xml</screen>
     </step>
     <step>
      <para>
       Verify all disk image paths are correct from the &kvm; host's
       perspective. This is not a problem when converting on one machine,
       but may require manual changes when converting using a XML dump from
       another host.
      </para>
<screen>&lt;source file='/var/lib/libvirt/images/XenPool/SLES.qcow2'/&gt;</screen>
      <tip>
       <para>
        To avoid copying an image twice, manually copy the disk image(s)
        directly to the &libvirt; storage pool and update source file
        entries in the XML description file. The <command>virt-v2v</command>
        process will detect the existing disks and convert them in place.
       </para>
      </tip>
     </step>
     <step>
      <para>
       Run <command>virt-v2v</command> to convert to &kvm; virtual
       machine:
      </para>
<screen># virt-v2v sles12_xen.xml<co xml:id="v2v.xml"/> \
-i <replaceable>libvirtxml</replaceable><co xml:id="v2v.method"/> \
-os <replaceable>remote_host.example.com:/exported_dir</replaceable><co xml:id="v2v.pool"/> \
--bridge <replaceable>br0</replaceable><co xml:id="v2v.bridge"/> \
-on <replaceable>sles12_kvm</replaceable><co xml:id="v2v.name"/></screen>
      <calloutlist>
       <callout arearefs="v2v.xml">
        <para>
         The XML Description of the source &xen;-based virtual machine.
        </para>
       </callout>
       <callout arearefs="v2v.method">
        <para>
         <command>virt-v2v</command> will read the information about the
         source virtual machine form a &libvirt; XML file.
        </para>
       </callout>
       <callout arearefs="v2v.pool">
        <para>
         Storage pool where the target virtual machine disk image will be
         placed. In this example, the image will be placed on a NFS share
         <filename>/exported_dir</filename> on the
         <literal>remote_host.example.com</literal> server.
        </para>
       </callout>
       <callout arearefs="v2v.bridge">
        <para>
         The target &kvm;-based virtual machine will use network bridge
         <literal>br0</literal> on the host.
        </para>
       </callout>
       <callout arearefs="v2v.name">
        <para>
         The target virtual machine will be renamed to
         <literal>sles12_kvm</literal> to prevent name collision with the
         existing virtual machine of the same name.
        </para>
       </callout>
      </calloutlist>
     </step>
    </procedure>
   </sect3>
   <sect3 xml:id="v2v.convert.domain">
    <title>Conversion Based on &libvirt; Domain Name</title>
    <para>
     This method is useful if you are still running &libvirt; under
     &xen;, and plan to reboot to the &kvm; hypervisor later.
    </para>
    <procedure>
     <step>
      <para>
       Find the &libvirt; domain name of the virtual machine you need to
       convert.
      </para>
<screen># virsh list
 Id    Name                           State
----------------------------------------------------
[...]
  2     sles12_xen                     running
[...]</screen>
      <para>
       <literal>sles12_xen</literal> is the source virtual machine to
       convert.
      </para>
     </step>
     <step>
      <para>
       Run <command>virt-v2v</command> to convert to &kvm; virtual
       machine:
      </para>
<screen># virt-v2v sles12_xen<co xml:id="v2v.domain"/> \
-i <replaceable>libvirt</replaceable><co xml:id="v2v.method1"/> \
-os <replaceable>storage_pool</replaceable><co xml:id="v2v.pool1"/> \
--network <replaceable>eth0</replaceable><co xml:id="v2v.net"/> \
-of qcow2<co xml:id="v2v.qcow"/> \
-oa sparce<co xml:id="v2v.sparse"/> \
-on <replaceable>sles12_kvm</replaceable></screen>
      <calloutlist>
       <callout arearefs="v2v.domain">
        <para>
         The domain name of the &xen;-based virtual machine.
        </para>
       </callout>
       <callout arearefs="v2v.method1">
        <para>
         <command>virt-v2v</command> will read the information about the
         source virtual machine directly from the active &libvirt;
         connection.
        </para>
       </callout>
       <callout arearefs="v2v.pool1">
        <para>
         The target disk image image will be placed in a local &libvirt;
         storage pool.
        </para>
       </callout>
       <callout arearefs="v2v.net">
        <para>
         All guest bridges (or networks) will be connected to a locally
         managed network.
        </para>
       </callout>
       <callout arearefs="v2v.qcow">
        <para>
         Format for the disk image of the target virtual machine. Supported
         options are <option>raw</option> or <option>qcow2</option>.
        </para>
       </callout>
       <callout arearefs="v2v.sparse">
        <para>
         If the converted guest disk space will be <option>sparse</option>
         or <option>preallocated</option>.
        </para>
       </callout>
      </calloutlist>
     </step>
    </procedure>
   </sect3>
   <sect3 xml:id="v2v.convert.remote">
    <title>Converting a Remote &xen; Virtual Machine</title>
    <para>
     This method is useful if you need to convert a &xen; virtual machine
     running on a remote host. As <command>virt-v2v</command> connects to
     the remote host via <command>ssh</command>, ensure that SSH service is
     running on the host.
    </para>
    <para>
     To connect to a remote &libvirt; connection, you need to construct a
     valid connection URI relevant for your remote host. In the following
     example, the remote host name is
     <literal>remote_host.example.com</literal>, and the username for
     connection is &rootuser;. The connection URI then looks as follows:
    </para>
<screen>qemu+ssh://root@remote_host.example.com/system</screen>
    <tip>
     <para>
      For more information on &libvirt; connection URIs, see
      <link xlink:href="http://libvirt.org/uri.html"/>.
     </para>
    </tip>
    <procedure>
     <step>
      <para>
       Find the &libvirt; domain name of the remote virtual machine you
       need to convert.
      </para>
<screen># virsh -c qemu+ssh://root@remote_host.example.com/system list
 Id    Name                           State
----------------------------------------------------
  1     sles12_xen                     running
[...]</screen>
      <para>
       <literal>sles12_xen</literal> is the source virtual machine to
       convert.
      </para>
     </step>
     <step>
      <para>
       The <command>virt-v2v</command> command for the remote connection
       looks like this:
      </para>
<screen># virt-v2v sles12_xen \
-i <replaceable>libvirt</replaceable> \
-ic <replaceable>qemu+ssh://root@remote_host.example.com/system</replaceable> \
-os <replaceable>local_storage_pool</replaceable> \
--bridge  <replaceable>br0</replaceable></screen>
     </step>
    </procedure>
   </sect3>
  </sect2>

  <sect2 xml:id="v2v.run">
   <title>Running Converted Virtual Machines</title>
   <para>
    After <command>virt-v2v</command> completes successfully, a new
    &libvirt; domain will be created with the name specified with the
    <option>-on</option> option. If you did not specify
    <option>-on</option>, the same name as the source virtual machine will
    be used. The new guest can be normally managed with standard
    &libvirt; tools, such as <command>virsh</command> or &vmm;.
   </para>
   <tip>
    <para>
     You may need to reboot the machine and boot with the non-&xen;
     kernel if you just completed the conversion under &xen; as in the
     case of <xref linkend="v2v.convert.domain"/> .
    </para>
   </tip>
  </sect2>
 </sect1>
 <sect1>
  <title>&xen; to &kvm; Manual Migration</title>

  <para/>

  <sect2>
   <title>General Outline</title>
   <para>
    The preferred solution to manage virtual machines is based on
    &libvirt; (See <link xlink:href="http://libvirt.org/"/> for more
    details). It has several notable advantages over the manual way of
    defining/running virtual machines &mdash; &libvirt; is
    cross-platform, supports many hypervisors, secure remote management,
    virtual networking, and, most of all, provides a unified abstract layer
    to manage virtual machines. Therefore the main focus of this article is
    on the &libvirt; solution.
   </para>
   <para>
    Generally, the &xen; to &kvm; migration runs in the following
    basic steps:
   </para>
   <procedure>
    <step>
     <para>
      Make a backup copy of the original &xen; &vmguest;.
     </para>
    </step>
    <step>
     <para>
      OPTIONAL: Apply changes specific to paravirtualized guests.
     </para>
    </step>
    <step>
     <para>
      Obtain information about the original &xen; &vmguest; and update
      it to &kvm; equivalents.
     </para>
    </step>
    <step>
     <para>
      Shut down the guest on the &xen; host, and run the new one under
      the &kvm; hypervisor.
     </para>
    </step>
   </procedure>
   <warning>
    <title>No Live Migration</title>
    <para>
     The &xen; to &kvm; migration cannot be done live while the source
     &vmguest; is running. Before running the new &kvm;-ready
     &vmguest;, you are advised to shut down the original &xen;
     &vmguest;.
    </para>
   </warning>
  </sect2>

  <sect2>
   <title>Back Up the &xen; &vmguest;</title>
   <para>
    To back up your &xen; &vmguest;, follow these steps:
   </para>
   <procedure>
    <step>
     <para>
      Identify the relevant &xen; guest you want to migrate, and remember
      its ID/name.
     </para>
<screen># virsh list --all
Id Name                 State
----------------------------------
 0 Domain-0             running
 1 SLES11SP3            running 
[...]</screen>
    </step>
    <step>
     <para>
      Shut down the guest. You can do this either by shutting down the guest
      OS, or with <command>virsh</command>:
     </para>
<screen># virsh shutdown SLES11SP3</screen>
    </step>
    <step>
     <para>
      Backup its configuration to an XML file.
     </para>
<screen># virsh dumpxml SLES11SP3 &gt; sles11sp3.xml</screen>
    </step>
    <step>
     <para>
      Backup its disk image file. Use the <command>cp</command> or
      <command>rsync</command> commands to create the backup copy. Remember
      that it is always a good idea to check the copy with the
      <command>md5sum</command> command.
     </para>
    </step>
    <step>
     <para>
      After the image file is backed up, you can start the guest again with
     </para>
<screen># virsh start SLES11SP3</screen>
    </step>
   </procedure>
  </sect2>

  <sect2>
   <title>Changes Specific to Paravirtualized Guests</title>
   <para>
    Apply the following changes if you are migrating a paravirtualized
    &xen; guest. You can do it either on the running guest, or on the
    stopped guest using <literal>guestfs-tools</literal>.
<!-- toba: maybe add more info on guestfs-tools -->
   </para>
   <important>
    <para>
     After applying the changes described in this section, the image file
     related to the migrated &vmguest; will not be usable under &xen;
     anymore.
    </para>
   </important>
   <sect3>
    <title>Install the Default Kernel</title>
    <warning>
     <para>
      After you install the default kernel, do not try to boot the &xen;
      guest with it, the system will not boot.
     </para>
    </warning>
    <para>
     Before cloning the &xen; guest disk image for use under the &kvm;
     hypervisor, make sure it is bootable <emphasis>without</emphasis> the
     &xen; hypervisor. This is very important for paravirtualized
     &xen; guests as they usually contain a special &xen; kernel, and
     often do not have a complete &grub; boot loader installed.
    </para>
    <orderedlist spacing="normal">
     <listitem>
      <para>
       Update the <filename>/etc/sysconfig/kernel</filename> file. Change
       the <literal>INITRD_MODULES</literal> parameter by removing all
       &xen; drivers and replacing the with virtio drivers. Replace
      </para>
<screen>INITRD_MODULES="xenblk xennet"</screen>
      <para>
       with
      </para>
<screen>INITRD_MODULES="virtio_blk virtio_pci virtio_net virtio_balloon"</screen>
     </listitem>
     <listitem>
      <para>
       Paravirtualized &xen; guests are running a specific &xen;
       kernel. To run the guest under &kvm;, you need to install the
       default kernel.
      </para>
      <note>
       <para>
        You do not need to install the default kernel for a fully
        virtualized guests as it is already installed.
       </para>
      </note>
      <para>
       Enter <command>rpm -q kernel-default</command> on the &xen; guest
       to find out if the default kernel is installed. If not, install it
       with <command>zypper in kernel-default</command>.
      </para>
      <para>
       The kernel we are going to use to boot the guest under &kvm; must
       have <emphasis>virtio</emphasis> (paravirtualized) drivers available.
       Run the following command to find out. Do not forget to replace
       <literal>3.8.9-4</literal> with your kernel version:
      </para>
<screen># find /lib/modules/3.8.9-4-default/kernel/drivers/ -name virtio*
/lib/modules/3.8.9-4-default/kernel/drivers/net/virtio_net.ko
/lib/modules/3.8.9-4-default/kernel/drivers/scsi/virtio_scsi.ko
/lib/modules/3.8.9-4-default/kernel/drivers/block/virtio_blk.ko
/lib/modules/3.8.9-4-default/kernel/drivers/char/virtio_console.ko
/lib/modules/3.8.9-4-default/kernel/drivers/char/hw_random/virtio-rng.ko
/lib/modules/3.8.9-4-default/kernel/drivers/virtio
/lib/modules/3.8.9-4-default/kernel/drivers/virtio/virtio.ko
/lib/modules/3.8.9-4-default/kernel/drivers/virtio/virtio_pci.ko
/lib/modules/3.8.9-4-default/kernel/drivers/virtio/virtio_balloon.ko
/lib/modules/3.8.9-4-default/kernel/drivers/virtio/virtio_ring.ko
/lib/modules/3.8.9-4-default/kernel/drivers/virtio/virtio_mmio.ko</screen>
     </listitem>
     <listitem>
      <para>
       Update <filename>/etc/fstab</filename>. Change any storage devices
       from <literal>xvda</literal> to <literal>vda</literal>.
      </para>
     </listitem>
     <listitem>
      <para>
       Update the boot loader configuration. Enter <command>rpm -q
       grub2</command> on the &xen; guest to find out if &grub; is
       already installed. If not, install it with <command>zypper in
       grub2</command>.
      </para>
      <para>
       Now make the newly installed default kernel the default for booting
       the OS. Also remove/update the kernel command line options that may
       refer to &xen;-specific devices. You can do it either with
       &yast; (<menuchoice><guimenu>System</guimenu><guimenu>Boot
       Loader</guimenu></menuchoice>), or manually:
      </para>
      <itemizedlist mark="bullet" spacing="normal">
       <listitem>
        <para>
         Find the preferred Linux boot menu entry by listing them all:
        </para>
<screen>cat /boot/grub2/grub.cfg | grep 'menuentry '</screen>
        <para>
         Remember the order number (counted from zero) of the one you newly
         installed.
        </para>
       </listitem>
       <listitem>
        <para>
         Set it the default boot menu entry:
        </para>
<screen>grub2-set-default <replaceable>N</replaceable></screen>
        <para>
         Replace <replaceable>N</replaceable> with the number of the boot
         menu entry you previously discovered.
        </para>
       </listitem>
       <listitem>
        <para>
         Open <filename>/etc/default/grub</filename>for editing, and look
         for <option>GRUB_CMDLINE_LINUX_DEFAULT</option> and
         <option>GRUB_CMDLINE_LINUX_RECOVERY</option> options. Remove/update
         any reference to &xen;-specific devices. In the following
         example, you can replace
        </para>
<screen>root=/dev/xvda1 disk=/dev/xvda console=xvc</screen>
        <para>
         with
        </para>
<screen>root=/dev/vda1 disk=/dev/vda</screen>
        <para>
         Note that you need to remove all references to
         <literal>xvc</literal>-type consoles (such as
         <literal>xvc0</literal>).
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
     <listitem>
      <para>
       Update <filename>device.map</filename> in one of
       <filename>/boot/grub2</filename> or
       <filename>/boot/grub2-efi</filename> directories. Change any storage
       device from <literal>xvda</literal> to <literal>vda</literal>.
      </para>
     </listitem>
     <listitem>
      <para>
       To import new default settings, run
      </para>
<screen>grub2-mkconfig -o /boot/grub2/grub.cfg</screen>
     </listitem>
    </orderedlist>
   </sect3>
   <sect3>
    <title>Update the Guest for Boot under &kvm;</title>
    <orderedlist spacing="normal">
     <listitem>
      <para>
       Update the system to use default serial console. List the configured
       consoles, and remove symbolic links to <literal>xvc?</literal> ones.
      </para>
<screen># ls -l /etc/systemd/system/getty.target.wants/
getty@tty1.service -&gt; /usr/lib/systemd/system/getty@.service
getty@xvc0.service -&gt; /usr/lib/systemd/system/getty@xvc0.service
getty@xvc1.service -&gt; /usr/lib/systemd/system/getty@xvc1.service

# rm /etc/systemd/system/getty.target.wants/getty@xvc?.service</screen>
     </listitem>
     <listitem>
      <para>
       Update the <filename>/etc/securetty</filename> file. Replace
       <literal>xvc0</literal> with <literal>ttyS0</literal>.
      </para>
     </listitem>
    </orderedlist>
   </sect3>
  </sect2>

  <sect2>
   <title>Update the &xen; &vmguest; Configuration</title>
   <para>
    This section describes how to export the configuration of the original
    &xen; &vmguest;, and what particular changes to apply to it to be
    able to import it as a &kvm; guest into &libvirt;.
   </para>
   <sect3>
    <title>Export the &xen; &vmguest; Configuration</title>
    <para>
     First export the configuration of the guest and save it to a file. A
     typical one may look like this:
    </para>
<screen># virsh dumpxml SLES11SP3
&lt;domain type='xen'&gt;
  &lt;name&gt;SLES11SP3&lt;/name&gt;
  &lt;uuid&gt;fa9ea4d7-8f95-30c0-bce9-9e58ffcabeb2&lt;/uuid&gt;
  &lt;memory&gt;524288&lt;/memory&gt;
  &lt;currentMemory&gt;524288&lt;/currentMemory&gt;
  &lt;vcpu&gt;1&lt;/vcpu&gt;
  &lt;bootloader&gt;/usr/bin/pygrub&lt;/bootloader&gt;
  &lt;os&gt;
    &lt;type&gt;linux&lt;/type&gt;
  &lt;/os&gt;
  &lt;clock offset='utc'/&gt;
  &lt;on_poweroff&gt;destroy&lt;/on_poweroff&gt;
  &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
  &lt;on_crash&gt;restart&lt;/on_crash&gt;
  &lt;devices&gt;
    &lt;emulator&gt;/usr/lib/xen/bin/qemu-dm&lt;/emulator&gt;
    &lt;disk type='file' device='disk'&gt;
      &lt;driver name='file'/&gt;
      &lt;source file='/var/lib/libvirt/images/SLES_11_SP2_JeOS.x86_64-0.0.2_para.raw'/&gt;
      &lt;target dev='xvda' bus='xen'/&gt;
    &lt;/disk&gt;
    &lt;interface type='bridge'&gt;
      &lt;mac address='00:16:3e:2d:91:c3'/&gt;
      &lt;source bridge='br0'/&gt;
      &lt;script path='vif-bridge'/&gt;
    &lt;/interface&gt;
    &lt;console type='pty'&gt;
      &lt;target type='xen' port='0'/&gt;
    &lt;/console&gt;
    &lt;input type='mouse' bus='xen'/&gt;
    &lt;graphics type='vnc' port='-1' autoport='yes' keymap='en-us'/&gt;
  &lt;/devices&gt;
&lt;/domain&gt;
</screen>
    <tip>
     <para>
      You can find detailed information on the libvirt XML format for
      &vmguest; description at
      <link xlink:href="http://libvirt.org/formatdomain.html"/>.
     </para>
    </tip>
   </sect3>
   <sect3>
    <title>General Changes to the Guest Configuration</title>
    <para>
     You need to make a few general changes to the exported &xen; guest
     XML configuration to run it under the &kvm; hypervisor. The
     following applies to both fully virtualized and paravirtualized guests.
     Note that not all of the following XML elements need to be in your
     specific configuration.
    </para>
    <tip>
     <title>Conventions Used</title>
     <para>
      To refer to a node in the XML configuration file, an XPath syntax will
      be used throughout this document. For example, to refer to a
      <literal>&lt;name&gt;</literal> inside the
      <literal>&lt;domain&gt;</literal> tag
     </para>
<screen>&lt;domain&gt;
  &lt;name&gt;sles11sp3&lt;/name&gt;
&lt;/domain&gt;</screen>
     <para>
      an XPath equivalent <literal>/domain/name</literal> will be used.
     </para>
    </tip>
    <orderedlist spacing="normal">
     <listitem>
      <para>
       Change the <literal>type</literal> attribute of the
       <literal>/domain</literal> element from <literal>xen</literal>to
       <literal>kvm</literal>.
      </para>
     </listitem>
     <listitem>
      <para>
       Remove the <literal>/domain/bootloader</literal> element section.
      </para>
     </listitem>
     <listitem>
      <para>
       Remove the <literal>/domain/bootloader_args</literal> element
       section.
      </para>
     </listitem>
     <listitem>
      <para>
       Change the <literal>/domain/os/type</literal> element value from
       <literal>linux</literal> to <literal>hvm</literal>.
      </para>
     </listitem>
     <listitem>
      <para>
       Add <literal>&lt;boot dev="hd"/&gt;</literal> under the
       <literal>/domain/os</literal> element.
      </para>
     </listitem>
     <listitem>
      <para>
       Add the <literal>arch</literal> attribute to the
       <literal>/domain/os/type</literal> element. Acceptable values are
       <literal>arch=”x86_64”</literal> or
       <literal>arch=”i686”</literal>
      </para>
     </listitem>
     <listitem>
      <para>
       Change the <literal>/domain/devices/emulator</literal> element from
       <literal>/usr/lib/xen/bin/qemu-dm'</literal> to
       <literal>/usr/bin/qemu-kvm</literal>.
      </para>
     </listitem>
     <listitem>
      <para>
       For each disk associated with the paravirtualized (PV) guest, change
       the following:
      </para>
      <itemizedlist mark="bullet" spacing="normal">
       <listitem>
        <para>
         Change the <literal>name</literal> attribute of the
         <literal>/domain/devices/disk/driver</literal> element from
         <literal>file</literal> to <literal>qemu</literal>, and add a
         <literal>type</literal> attribute for the disk type. For example,
         valid options include <literal>raw</literal> or
         <literal>qcow2</literal>.
        </para>
       </listitem>
       <listitem>
        <para>
         Change the <literal>dev</literal> attribute of the
         <literal>/domain/devices/disk/target</literal> element from
         <literal>xvda</literal> to <literal>vda</literal>.
        </para>
       </listitem>
       <listitem>
        <para>
         Change the <literal>bus</literal> attribute of the
         <literal>/domain/devices/disk/target</literal> element from
         <literal>xen</literal> to <literal>virtio</literal>.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
     <listitem>
      <para>
       For each network interface card, do the following changes:
      </para>
      <itemizedlist mark="bullet" spacing="normal">
       <listitem>
        <para>
         If there is <literal>model</literal> defined in
         <literal>/domain/devices/interface</literal>, change its
         <literal>type</literal> attribute value to
         <literal>virtio</literal>
        </para>
<screen>&lt;model type=”virtio”&gt;</screen>
       </listitem>
       <listitem>
        <para>
         Delete all <literal>/domain/devices/interface/script</literal>
         sections.
        </para>
       </listitem>
       <listitem>
        <para>
         Delete all <literal>/domain/devices/interface/target</literal>
         elements if the <literal>dev</literal> attribute starts with
         <literal>vif</literal> or <literal>vnet</literal> or
         <literal>veth</literal>. If using a custom network then change the
         <literal>dev</literal> value to that target.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
     <listitem>
      <para>
       Remove the <literal>/domain/devices/console</literal> element section
       if it exists.
      </para>
     </listitem>
     <listitem>
      <para>
       Remove the <literal>/domain/devices/serial</literal> element section
       if it exists.
      </para>
     </listitem>
     <listitem>
      <para>
       Change the <literal>bus</literal> attribute on the
       <literal>/domain/devices/input</literal> element from
       <literal>xen</literal> to <literal>ps2</literal>.
      </para>
     </listitem>
     <listitem>
      <para>
       Add the following element for memory ballooning features under the
       <literal>/domain/devices</literal> element.
      </para>
<screen>&lt;memballoon model="virtio"/&gt;</screen>
     </listitem>
    </orderedlist>
    <tip>
     <para>
      <literal>&lt;target dev='hda' bus='ide'/&gt;</literal> controls
      the device under which the disk is exposed to the guest OS. The
      <literal>dev</literal> attribute indicates the "logical" device name.
      The actual device name specified is not guaranteed to map to the
      device name in the guest OS. Therefore you may need to change the disk
      mapping on the boot loader command line. For example if the boot
      loader expects a root disk to be <literal>hda2</literal> but &kvm;
      still sees it as <literal>sda2</literal>, change the boot loader
      command line from
     </para>
<screen>[...] root=/dev/hda2 resume=/dev/hda1 [...]</screen>
     <para>
      to
     </para>
<screen>[...] root=/dev/sda2 resume=/dev/sda1 [...]</screen>
     <para>
      or to
     </para>
<screen>[...] root=/dev/vda2 resume=/dev/vda1 [...]</screen>
     <para>
      in the case of paravirtualized <literal>xvda</literal> devices.
     </para>
     <para>
      Otherwise the &vmguest; will refuse to boot in the &kvm;
      environment.
     </para>
    </tip>
   </sect3>
   <sect3>
    <title>The Target &kvm; Guest Configuration</title>
    <para>
     After having applied all the modifications mentioned above, you end up
     with the following configuration for your &kvm; guest:
    </para>
<screen>
&lt;domain type='kvm'&gt;
  &lt;name&gt;SLES11SP3&lt;/name&gt;
  &lt;uuid&gt;fa9ea4d7-8f95-30c0-bce9-9e58ffcabeb2&lt;/uuid&gt;
  &lt;memory&gt;524288&lt;/memory&gt;
  &lt;currentMemory&gt;524288&lt;/currentMemory&gt;
  &lt;vcpu cpuset='0-3'&gt;1&lt;/vcpu&gt;
  &lt;os&gt;
    &lt;type arch=”x86_64”&gt;hvm&lt;/type&gt;
    &lt;boot dev="hd"/&gt;
  &lt;/os&gt;
  &lt;clock offset='utc'/&gt;
  &lt;on_poweroff&gt;destroy&lt;/on_poweroff&gt;
  &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
  &lt;on_crash&gt;restart&lt;/on_crash&gt;
  &lt;devices&gt;
    &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
    &lt;disk type='file' device='disk'&gt;
      &lt;driver name='qemu' type="raw"/&gt;
      &lt;source file='/var/lib/libvirt/images/SLES_11_SP2_JeOS.x86_64-0.0.2_para.raw'/&gt;
      &lt;target dev='vda' bus='virtio'/&gt;
    &lt;/disk&gt;
    &lt;interface type='bridge'&gt;
      &lt;mac address='00:16:3e:2d:91:c3'/&gt;
      &lt;source bridge='br0'/&gt;
    &lt;/interface&gt;
    &lt;input type='mouse' bus='usb'/&gt;
    &lt;graphics type='vnc' port='5900' autoport='yes' keymap='en-us'/&gt;
    &lt;memballoon model="virtio"/&gt;
  &lt;/devices&gt;
&lt;/domain&gt;

</screen>
    <para>
     Save the configuration to a file in your home directory. After you
     later import it, it will be copied to the default
     <filename>/etc/libvirt/qemu</filename>. Suppose you save the file as
     <filename>SLES11SP3.xml</filename>.
    </para>
   </sect3>
  </sect2>

  <sect2>
   <title>Migrate the &vmguest;</title>
   <para>
    After you updated the &vmguest; configuration, and applied necessary
    changes to the guest OS, it is time to shut down the original &xen;
    guest, and run its clone under the &kvm; hypervisor.
   </para>
   <procedure>
    <step>
     <para>
      Shut down the guest on the &xen; host by running <command>shutdown
      -h now</command> as &rootuser; from the console.
     </para>
    </step>
    <step>
     <para>
      Copy the disk files associated with the &vmguest; if needed. A
      default configuration will require the &xen; disk files to be
      copied from <filename>/var/lib/xen/images</filename> to
      <filename>/var/lib/kvm/images</filename>. The
      <filename>/var/lib/kvm/images</filename> directory may need to be
      created (as &rootuser;) if you have not previously created a
      &vmguest;.
     </para>
    </step>
    <step>
     <para>
      Create the new domain, and register it with &libvirt;:
     </para>
<screen># virsh define SLES11SP3.xml
 Domain SLES11SP3 defined from SLES11SP3.xml</screen>
    </step>
    <step>
     <para>
      Verify that the new guest is seen in the &kvm; configuration:
     </para>
<screen>virsh list –all</screen>
    </step>
    <step>
     <para>
      After the domain is created, you can start it:
     </para>
<screen># virsh start SLES11SP3
 Domain SLES11SP3 started</screen>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1>
  <title>For More Information</title>

  <para>
   For more information on libvirt, see
   <link xlink:href="http://libvirt.org"/>.
  </para>

  <para>
   You can find more details on &libvirt; XML format at
   <link xlink:href="http://libvirt.org/formatdomain.html"/>.
  </para>

  <para>
   For more information on virtualization with &xen; and &kvm;, see
   the &productname; documentation at
   <link xlink:href="http://www.suse.com/doc/"/>.
  </para>
 </sect1>
 <xi:include href="common_copyright_quick.xml"/>
 <xi:include href="common_gfdl1.2_i.xml"/>
</article>
