<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="net_basic.xml" version="5.0" xml:id="cha-network">
 <title>ネットワークの基礎</title>
 <info>
  <abstract>
   <para>
    Linuxには、あらゆるタイプのネットワークストラクチャに統合するために必要なネットワークツールと機能が用意されています。ネットワークカードを使用したネットワークアクセスは、YaSTによって設定できます。手動による環境設定も可能です。この章では、基本的メカニズムと関連のネットワーク設定ファイルのみを解説します。
   </para>
  </abstract>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>
 <para>
  Linuxおよび他のUnix系オペレーティングシステムは、TCP/IPプロトコルを使用します。これは1つのネットワークプロトコルではなく、さまざまなサービスを提供する複数のネットワークプロトコルのファミリです。TCP/IPを使用して2台のマシン間でデータをやり取りするために<xref linkend="tab-net-basic-tcpproto"/>に示した各プロトコルが提供されています。TCP/IPによって結び付けられた複数のネットワークから成る世界規模のネットワークは、<quote>インターネット</quote>とも呼ばれます。
 </para>
 <para>
  RFCは、<emphasis></emphasis>「Request for Comments」の略です。RFCは、さまざまなインターネットプロトコルとそれをオペレーティングシステムとそのアプリケーションに実装する手順を定めています。RFC文書ではインターネットプロトコルのセットアップについて説明しています。RFCの詳細については、<link xlink:href="https://datatracker.ietf.org/"/>を参照してください。
 </para>
 <variablelist xml:id="tab-net-basic-tcpproto">
  <title>TCP/IPプロトコルファミリを構成する主要なプロトコル</title>
  <varlistentry>
   <term>TCP</term>
   <listitem>
    <para>
     TCP(Transmission Control Protocol): 接続指向型の安全なプロトコルです。転送データは、まず、アプリケーションによってデータストリームとして送信され、オペレーティングシステム.によって適切なフォーマットに変換されます。データは、送信当初のデータストリーム形式で、宛先ホストのアプリケーションに着信します。TCPは転送中に損失したデータや順序が正しくないデータがないか、判定します。データの順序が意味を持つ場合は常にTCP/IPが実装されます。
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>UDP</term>
   <listitem>
    <para>
     UDP(User Datagram Protocol): コネクションレスで安全でないプロトコルです。転送されるデータは、アプリケーションで生成されたパケットの形で送信されます。データが受信側に到着する順序は保証されず、データの損失の可能性があります。UDPはレコード指向のアプリケーションに適しています。TCPよりも遅延時間が小さいことが特徴です。
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>ICMP</term>
   <listitem>
    <para>
     ICMP (Internet Control Message Protocol):これはエンドユーザ向けのプロトコルではありませんが、エラーレポートを発行し、TCP/IPデータ転送にかかわるマシンの動作を制御できる特別な制御プロトコルです。またICMPには特別なエコーモードがあります。エコーモードは、pingで使用されています。
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>IGMP</term>
   <listitem>
    <para>
     IGMP (Internet Group Management Protocol): このプロトコルは、IPマルチキャストを実装した場合のマシンの動作を制御します。
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
 <para>
  <xref linkend="fig-net-basic-OSI"/>に示したように、データのやり取りはさまざまなレイヤで実行されます。実際のネットワークレイヤは、IP (インターネットプロトコル)によって実現される確実性のないデータ転送です。IPの上で動作するTCP (転送制御プロトコル)によって、ある程度の確実性のあるデータ転送が保証されます。IP層の下層には、Ethernetなどのハードウェア依存プロトコルがあります。
 </para>
 <figure xml:id="fig-net-basic-OSI">
  <title>TCP/IPの簡易階層モデル</title>
  <mediaobject>
   <imageobject role="fo">
    <imagedata width="100%" fileref="net_basic_osi.svg"/>
   </imageobject>
   <imageobject role="html">
    <imagedata width="75%" fileref="net_basic_osi.png"/>
   </imageobject>
  </mediaobject>
 </figure>
 <para>
  図では、各レイヤに対応する例を1つまたは2つ示しています。レイヤは<emphasis>抽象化レベル</emphasis>に従って並べられています。最下位レイヤは最もハードウェアに近い部分です。一方、最上位レイヤは、ハードウェアがまったく見えないほぼ完全な抽象化になります。各レイヤにはそれぞれの固有の機能があります。各レイヤ固有の機能は、上記の主要プロトコルの説明を読めば大体わかります。データリンク層と物理層は、Ethernetなどの使用される物理ネットワークを表します。
 </para>
 <para>
  ほとんどすべてのハードウェアプロトコルは、パケット単位で動作します。転送されるデータは、<emphasis>パケット</emphasis>にまとめられます(一度に全部を送信できません)。TCP/IPパケットの最大サイズは約64KBです。パケットサイズは通常、かなり小さな値になります。これは、ネットワークハードウェアでサポートされているパケットサイズに制限があるからです。Ethernetの最大パケットサイズは、約1500バイトです。Ethernet上に送出されるTCP/IPパケットは、このサイズに制限されます。転送するデータ量が大きくなると、それだけ多くのパケットがオペレーティングシステムによって送信されます。
 </para>
 <para>
  すべてのレイヤがそれぞれの機能を果たすためには、各レイヤに対応する情報を各データパケットに追加する必要があります。この情報はパケットの<emphasis>ヘッダ</emphasis>として追加されます。各レイヤでは、プロトコルヘッダと呼ばれる小さなデータブロックが、作成されたパケットに付加されます。<xref linkend="fig-net-basic-TCPPaket"/>に、Ethernetケーブル上に送出されるTCP/IPデータパケットの例を示します。誤り検出のためのチェックサムは、パケットの先頭ではなく最後に付加されます。これによりネットワークハードウェアの処理が簡素化されます。
 </para>
 <figure xml:id="fig-net-basic-TCPPaket">
  <title>TCP/IPイーサネットパケット</title>
  <mediaobject>
   <imageobject role="fo">
    <imagedata width="80%" fileref="net_basic_tcppacket.svg"/>
   </imageobject>
   <imageobject role="html">
    <imagedata width="75%" fileref="net_basic_tcppacket.png"/>
   </imageobject>
  </mediaobject>
 </figure>
 <para>
  アプリケーションがデータをネットワーク経由で送信すると、データは各レイヤを通過します。これらのレイヤは、物理レイヤを除き、すべてLinuxカーネルに実装されています。各レイヤは、隣接する下位レイヤに渡せるようにデータを処理します。最下位レイヤは、最終的にデータを送信する責任を負います。データを受信したときには、この手順全体が逆の順序で実行されます。重なり合ったたまねぎの皮のように、各レイヤで伝送データからプロトコルヘッダが除去されていきます。最後に、トランスポートレイヤが、着信側のアプリケーションがデータを利用できるように処理します。この方法では、1つのレイヤが直接やり取りを行うのは隣接する上下のレイヤのみです。アプリケーションの場合、データが無線接続と有線接続のどちらで送信されるかは関係ありません。同様に、物理ネットワークは、パケットの形式さえ正しければよく、伝送されるデータの種類を意識することはありません。
 </para>
 <sect1 xml:id="sec-network-addresses">
  <title>IPアドレスとルーティング</title>

  <para>
   ここでは、IPv4ネットワークについてのみ説明しています。IPv4の後継バージョンであるIPv6については、<xref linkend="sec-network-ipv6"/>を参照してください。
  </para>

  <sect2 xml:id="sec-network-addresses-ip">
   <title>IPアドレス</title>
   <para>
    インターネット上のすべてのコンピュータは、固有の32ビットアドレスを持っています。この32ビット(4バイト)は、通常、<xref linkend="aus-net-basic-ipaddress"/>の2行目に示すような形式で表記されます。
   </para>
   <example xml:id="aus-net-basic-ipaddress">
    <title>IPアドレスの表記</title>
<screen>IP Address (binary):  11000000 10101000 00000000 00010100
IP Address (decimal):      192.     168.       0.      20</screen>
   </example>
   <para>
    10進表記では、4つの各バイトが10進数で表記され、ピリオドで区切られます。IPアドレスは、ホストまたはネットワークインタフェースに割り当てられます。使用できるのは1回のみです。このルールには例外もありますが、次の説明には直接関係していません。
   </para>
   <para>
    IPアドレスにあるピリオドは、階層構造を表しています。1990年代まで、IPアドレスは、各クラスに固定的に分類されていました。しかし、このシステムがあまりに柔軟性に乏しいことがわかったので、今日、そのような分類は行われていません。現在採用されているのは、<emphasis>クラスレスルーティング</emphasis>(CIDR: classless inter domain routing)です。
   </para>
  </sect2>

  <sect2 xml:id="sec-network-addresses-route">
   <title>ネットマスクとルーティング</title>
   <para>
    ネットマスクは、サブネットのアドレス範囲を定義するために用いられます。2台のホストが同じサブネットに存在する場合、相互に直接アクセスできます。同じサブネットにない場合は、サブネットのすべてのトラフィックを処理するゲートウェイのアドレスが必要です。2つのIPアドレスが同じサブネットワークに属しているかどうかを確認するには、両方のアドレスとネットマスクの<quote>AND</quote>を求めます。結果が同一であれば、両方のIPアドレスは同じローカルネットワークに属しています。相違があれば、それらのIPアドレス、そしてそれらに対応するインタフェースが連絡するには、ゲートウェイを通過する必要があります。
   </para>
   <para>
    ネットマスクの役割を理解するには、<xref linkend="tab-net-basic-netmask"/>を参照してください。ネットマスクは、そのネットワークにいくつのIPアドレスが属しているかを示す、32ビットの値から成っています。<literal>1</literal>になっているビットは、IPアドレスのうち、特定のネットワークに属することを示すビットに対応します。<literal>0</literal>になっているビットは、サブネット内での識別に使われるビットに対応します。これは、<literal>1</literal>になっているビット数が多いほど、サブネットが小さいことを意味します。ネットマスクは常に連続する<literal>1</literal>のビットから構成されているので、その数だけでネットマスクを指定することができます。<xref linkend="tab-net-basic-netmask"/>の、24ビットからなる第1のネットワークは、<literal>192.168.0.0/24</literal>と書くこともできます。
   </para>
   <example xml:id="tab-net-basic-netmask">
    <title>IPアドレスとネットマスクの論理積(AND)</title>
<screen>IP address (192.168.0.20):  11000000 10101000 00000000 00010100
Netmask   (255.255.255.0):  11111111 11111111 11111111 00000000
---------------------------------------------------------------
Result of the link:         11000000 10101000 00000000 00000000
In the decimal system:           192.     168.       0.       0

IP address (213.95.15.200): 11010101 10111111 00001111 11001000
Netmask    (255.255.255.0): 11111111 11111111 11111111 00000000
---------------------------------------------------------------
Result of the link:         11010101 10111111 00001111 00000000
In the decimal system:           213.      95.      15.       0</screen>
   </example>
   <para>
    また、たとえば同じEthernetケーブルに接続しているすべてのマシンは、普通同じサブネットに属し、直接アクセスできます。サブネットがスイッチまたはブリッジで物理的に分割されていても、これらのホストは直接アクセス可能です。
   </para>
   <para>
    ローカルサブネットの外部のIPアドレスには、ターゲットネットワーク用のゲートウェイが設定されている場合にのみ、連絡できます。最も一般的には、外部からのすべてのトラフィックを扱うゲートウェイを1台だけ設置します。ただし、異なるサブネット用に、複数のゲートウェイを設定することも可能です。
   </para>
   <para>
    ゲートウェイを設定すると、外部からのすべてのIPパケットは適切なゲートウェイに送信されます。このゲートウェイは、パケットを複数のホストを経由して転送し、それは最終的に宛先ホストに到着します。ただし、途中でTTL (存続期間)に達した場合は破棄されます。
   </para>
   <variablelist xml:id="net-basic-spezial-net">
    <title>特殊なアドレス</title>
    <varlistentry>
     <term>
      基本ネットワークアドレス
     </term>
     <listitem>
      <para>
       ネットマスクとネットワーク内の任意のアドレスの論理積をとったもの。<xref linkend="tab-net-basic-netmask"/>のANDをとった<literal>結果</literal>を参照。このアドレスは、どのホストにも割り当てることができません。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      ブロードキャストアドレス
     </term>
     <listitem>
      <para>
       これは、<quote>このサブネット上のすべてのホストにアクセスする」と言い換えることができます。</quote>このアドレスを生成するには、2進数形式のネットマスクを反転させ、基本ネットワークアドレスと論理和をとります。そのため上記の例では、192.168.0.255になります。このアドレスをホストに割り当てることはできません。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      ローカルホスト
     </term>
     <listitem>
      <para>
       アドレス<systemitem class="ipaddress">127.0.0.1</systemitem>は、各ホストの<quote>ループバックデバイス</quote>に割り当てられます。このアドレスと、IPv4で定義された完全な<systemitem class="ipaddress">127.0.0.0/8</systemitem>ループバックネットワークからのすべてのアドレスで、自分のマシンへの接続を設定できます。IPv6では、ループバックアドレスは1つだけです(<systemitem class="ipaddress">::1</systemitem>)。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    IPアドレスは、世界中で固有でなければならないので、自分勝手にアドレスを選択して使うことはできません。IPベースのプライベートネットワークをセットアップする場合のために、3つのアドレスドメインが用意されています。これらは、外部のインターネットに直接接続することはできません。インターネット上で転送されることがないからです。このようなアドレスドメインは、RFC  1597で、<xref linkend="tab-net-basic-privat-net"/>に示すとおりに定められています。
   </para>
   <table xml:id="tab-net-basic-privat-net">
    <title>プライベートIPアドレスドメイン</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>
        <para>
         ネットワーク/ネット\&apos;83\&apos;7dスク
        </para>
       </entry>
       <entry>
        <para>
         Domain
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         <systemitem class="ipaddress">10.0.0.0</systemitem>/<systemitem class="netmask">255.0.0.0</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         <systemitem class="ipaddress">10.x.x.x</systemitem>
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <systemitem class="ipaddress">172.16.0.0</systemitem>/<systemitem class="netmask">255.240.0.0</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         <systemitem class="ipaddress">172.16.x.x</systemitem> – <systemitem class="ipaddress">172.31.x.x</systemitem>
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <systemitem class="ipaddress">192.168.0.0</systemitem>/<systemitem class="netmask">255.255.0.0</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         <systemitem class="ipaddress">192.168.x.x</systemitem>
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-network-ipv6">
  <title>IPv6 - 次世代インターネット</title>

  <important arch="zseries" os="sles">
   <title>IBM Z: IPv6のサポート</title>
   <para>
    IPv6は、IBM ZハードウェアのCTCおよびIUCVネットワーク接続ではサポートされていません。
   </para>
  </important>

  <para>
   ワールドワイドウェブ(WWW)の出現により、ここ15年間でTCP/IP経由で通信を行うコンピュータの数が増大し、インターネットは爆発的に拡大しました。CERN (<link xlink:href="http://public.web.cern.ch"/>)のTim Berners-Leeが1990年にWWWを発明して以来、インターネットホストは、数千から約1億まで増加しました。
  </para>

  <para>
   前述のように、IPv4のアドレスはわずか32ビットで構成されています。しかも、多くのIPアドレスが失われています。というのは、ネットワークの編成方法のせいで、使われないIPアドレスが無駄に割り当てられてしまうからです。サブネットで利用できるアドレスの数は、(2のビット数乗 - 2)で与えられます。たとえば、1つのサブネットでは、2、6、または14個のアドレスが使用可能です。たとえば128台のホストをインターネットに接続するには、256個のIPアドレスを持つサブネットが必要ですが、そのうち2つのIPアドレスは、サブネット自体を構成するのに必要なブロードキャストアドレスと基本ネットワークアドレスになるので、実際に使用できるのは254個だけです。
  </para>

  <para>
   現在のIPv4プロトコルでは、アドレスの不足を避けるために、DHCPとNAT (ネットワークアドレス変換)の2つのメカニズムが使用されています。これらの方法をパブリックアドレスとプライベートアドレスを分離するという慣習と組み合わせて使用することで、確かにアドレス不足の問題を緩和することができます。問題は、セットアップが面倒で保守しにくいその環境設定方法にあります。IPv4ネットワークでホストを設定するには、ホスト自体のIPアドレス、サブネットマスク、ゲートウェイアドレス、そして場合によってはネームサーバアドレスなど、複数のアドレス項目が必要になります。管理者は、これらをすべて自分で設定しなければなりません。これらのアドレスをどこかから取得することはできません。
  </para>

  <para>
   IPv6では、アドレス不足と複雑な環境設定方法はもはや過去のものです。ここでは、IPv6がもたらした進歩と恩恵について説明し、古いプロトコルから新しいプロトコルへの移行について述べます。
  </para>

  <sect2 xml:id="sec-network-ipv6-adv">
   <title>長所</title>
   <para>
    このより新しいプロトコルがもたらした最大かつ最もわかりやすい進歩は、利用可能なアドレス空間の飛躍的な増加です。IPv6アドレスは、従来の32ビットではなく、128ビットで構成されています。これにより、2の128乗、つまり、約3.4×1038個のIPアドレスが得られます。
   </para>
   <para>
    しかしながら、IPv6アドレスがその先行プロトコルと異なるのはアドレス長だけではありません。IPv6アドレスは内部構造も異なっており、それが属するシステムやネットワークに関してより具体的な情報を有しています。詳細については、<xref linkend="sec-network-ipv6-address"/>を参照してください。
   </para>
   <para>
    次に、このより新しいプロトコルの他の利点を紹介します。
   </para>
   <variablelist>
    <varlistentry>
     <term>自動環境設定機能</term>
     <listitem>
      <para>
       IPv6を使用すると、ネットワークが<quote>プラグアンドプレイ</quote>対応になります。つまり、新しくシステムを設定すると、手動で環境設定しなくても、(ローカル)ネットワークに統合されます。新しいホストは自動環境設定メカニズムを使用して、<emphasis>ネイバーディスカバリ</emphasis> (ND)と呼ばれるプロトコルにより、近隣のルータから得られる情報を元に自身のアドレスを生成します。この方法は、管理者の介入が不要なだけでなく、アドレス割り当てを1台のサーバで一元的に管理する必要もありません。これもIPv4より優れている点の1つです。IPv4では、自動アドレス割り当てを行うために、DHCPサーバを実行する必要があります。
      </para>
      <para>
       それでもルータがスイッチに接続されていれば、ルータは、ネットワークのホストに相互に通信する方法を通知するフラグ付きの通知を定期的に送信します。詳細については、RFC 2462、<systemitem>radvd.conf(5)</systemitem>のマニュアルページ、およびRFC 3315を参照してください。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>モバイル性</term>
     <listitem>
      <para>
       IPv6を使用すると、複数のアドレスを1つのネットワークインタフェースに同時に割り当てることができます。これにより、ユーザは複数のネットワークに簡単にアクセスできます。これは携帯電話会社が提供する国際ローミングサービスに似ています。国際ローミングサービスとは、携帯電話を国外に持ち出し、現地サービスのサービス地域に入ると、電話が自動的に現地サービスにログインするというサービスで、これによりどこにいても同じ番号で電話を受けられ、また自国にいるのと同様に電話をかけることができます。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>セキュリティで保護された通信</term>
     <listitem>
      <para>
       IPv4では、ネットワークセキュリティは追加機能です。IPv6にはIPSecが中核的機能の1つとして含まれているので、システムが安全なトンネル経由で通信でき、インターネット上での部外者による通信傍受を防止します。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>後方互換性</term>
     <listitem>
      <para>
       現実的に考えて、インターネット全体を一気にIPv4からIPv6に切り替えるのは不可能です。したがって、両方のプロトコルが、インターネット上だけでなく1つのシステム上でも共存できることが不可欠です。このことは、互換アドレスであること(IPv4アドレスは簡単にIPv6アドレスに変換可能)により、および複数のトンネルを使用することにより、保証されます。<xref linkend="sec-network-ipv6-coexist"/>を参照してください。また、システムは<emphasis>デュアルスタックIP</emphasis>テクニックによって、両方のプロトコルを同時にサポートできるので、2つのプロトコルバージョン間に相互干渉のない、完全に分離された2つのネットワークスタックが作成されます。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>マルチキャストによるサービスの詳細なカスタマイズ</term>
     <listitem>
      <para>
       IPv4では、いくつかのサービス(SMBなど)が、ローカルネットワークのすべてのホストにパケットをブロードキャストする必要があります。IPv6では、サーバが、<emphasis>マルチキャスト</emphasis>によってホストのアドレス指定を行う、つまり、複数のホストを1つのグループの部分としてアドレス指定することで、より細かいアプローチが可能になります。これは、<emphasis>ブロードキャスト</emphasis>によるすべてのホストのアドレス指定や、<emphasis>ユニキャスト</emphasis>による各ホストの個別のアドレス指定とは異なります。どのホストを対象グループに含めるかは、個々のアプリケーションによって異なります。事前定義のグループには、たとえば、すべてのネームサーバを対象とするグループ(<emphasis>全ネームサーバマルチキャストグループ</emphasis>)やすべてのルータを対象とするグループ(<emphasis>全ルータマルチキャストグループ</emphasis>)があります。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="sec-network-ipv6-address">
   <title>アドレスのタイプと構造</title>
   <para>
    これまでに述べたように、現在のIPプロトコルには、IPアドレス数が急激に不足し始めているということと、ネットワーク設定とルーティングテーブルの管理がより複雑で煩雑な作業になっているという、2つの大きな制限があります。IPv6では、1つ目の問題を、アドレス空間を128ビットに拡張することによって解決しています。2番目の制限は、階層的なアドレス構造を導入し、ネットワークアドレスを割り当てる高度なテクニックと<emphasis>マルチホーミング</emphasis>(1つのデバイスに複数のアドレスを割り当てることによって、複数のネットワークへのアクセスを可能にします)を組み合わせて軽減されます。
   </para>
   <para>
    IPv6を扱う場合は、次の3種類のアドレスについて知っておくと役に立ちます。
   </para>
   <variablelist>
    <varlistentry>
     <term>ユニキャスト</term>
     <listitem>
      <para>
       このタイプのアドレスは、1つのネットワークインタフェースだけに関連付けられます。このようなアドレスを持つパケットは、1つの宛先にのみ配信されます。したがって、ユニキャストアドレスは、パケットをローカルネットワークまたはインターネット上の個々のホストに転送する場合に使用します。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>マルチキャスト</term>
     <listitem>
      <para>
       このタイプのアドレスは、ネットワークインタフェースのグループに関連します。このようなアドレスを持つパケットは、そのグループに属するすべての宛先に配信されます。\&apos;83\&apos;7dルチキャストアドレスは、主に、特定のネットワークサービスが、相手を特定のグループに属するホストに絞って通信を行う場合に使用されます。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>エニーキャスト</term>
     <listitem>
      <para>
       このタイプのアドレスは、インタフェースのグループに関連します。このようなアドレスを持つパケットは、基盤となるルーティングプロトコルの原則に従い、送信側に最も近いグループのメンバーに配信されます。エニーキャストアドレスは、特定のネットワーク領域で特定のサービスを提供するサーバについて、ホストが情報を得られるようにするために使用します。同じタイプのすべてのサーバは、エニキャストアドレスが同じになります。ホストがサービスを要求すると、ルーティングプロトコルによって最も近い場所にあるサーバが判断され、そのサーバが応答します。何らかの理由でこのサーバが応答できない場合、プロトコルが自動的に2番目のサーバを選択し、それが失敗した場合は3番目、4番目が選択されます。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    IPv6アドレスは、4桁の英数字が入った8つのフィールドで構成され、それぞれのフィールドが16進数表記の16ビットを表します。各フィールドは、コロン(<literal>:</literal>)で区切られます。各フィールドで先頭の0は省略できますが、数字の間にある0や末尾の0は省略できません。もう1つの規則として、0のバイトが5つ以上連続する場合は、まとめて2つのコロン(::)で表すことができます。ただし、アドレスごとに<literal>::</literal>は1回しか使用できません。この省略表記の例については、<xref linkend="aus-net-ipv6-add"/>を参照してください。この3行はすべて同じアドレスを表します。
   </para>
   <example xml:id="aus-net-ipv6-add">
    <title>IPv6アドレスの例</title>
<screen>fe80 : 0000 : 0000 : 0000 : 0000 : 10 : 1000 : 1a4
fe80 :    0 :    0 :    0 :    0 : 10 : 1000 : 1a4
fe80 :                           : 10 : 1000 : 1a4</screen>
   </example>
   <para>
    IPv6アドレスの各部の機能は個別に定められています。最初の4バイトはプレフィクスを形成し、アドレスのタイプを指定します。中間部分はアドレスのネットワーク部分ですが、使用しなくてもかまいません。アドレスの最後の4桁はホスト部分です。IPv6でのネットマスクは、アドレスの末尾のスラッシュの後にプレフィクスの長さを指定して定義します。<xref linkend="aus-net-ipv6-addpre"/>に示すアドレスには、最初の 64ビットがアドレスのネットワーク部分を構成する情報、最後の 64ビットにホスト部分を構成する情報が入っています。言い換えると、<literal>64</literal>は、ネットマスクに 64個の 1ビット値が左から埋められていることを意味します。IPv4と同様、IPアドレスとネットマスクのANDをとることにより、ホストが同じサブネットにあるかそうでないかを判定します。
   </para>
   <example xml:id="aus-net-ipv6-addpre">
    <title>プレフィクスの長さを指定したIPv6アドレス</title>
<screen>fe80::10:1000:1a4/64</screen>
   </example>
   <para>
    IPv6は、事前に定義された複数タイプのプレフィクスを認識します。一部を<xref linkend="list-net-basic-ipv6-prefix"/>に示します。
   </para>
   <variablelist xml:id="list-net-basic-ipv6-prefix">
    <title>さまざまなIPv6のプレフィクス</title>
    <varlistentry>
     <term><systemitem class="ipaddress">00</systemitem>
     </term>
     <listitem>
      <para>
       IPv4アドレスおよびIPv4 over IPv6互換性アドレス。これらは、IPv4との互換性を保つために使用します。これらを使用した場合でも、IPv6パケットをIPv4パケットに変換できるルータが必要です。いくつかの特殊なアドレス(たとえばループバックデバイスのアドレス)もこのプレフィクスを持ちます。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>先頭桁が<systemitem class="ipaddress">2</systemitem>または<systemitem class="ipaddress">3</systemitem>
     </term>
     <listitem>
      <para>
       集約可能なグローバルユニキャストアドレス。IPv4と同様、インタフェースを割り当てて特定のサブネットの一部を構成することができます。現在、<systemitem class="ipaddress">2001::/16</systemitem> (実稼動品質のアドレス空間)と<systemitem class="ipaddress">2002::/16</systemitem> (6to4アドレス空間)の2つのアドレス空間があります。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem class="ipaddress">fe80::/10</systemitem>
     </term>
     <listitem>
      <para>
       リンクローカルアドレス。このプレフィクスを持つアドレスは、ルーティングしてはなりません。したがって、同じサブネット内からのみ到達可能です。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem class="ipaddress">fec0::/10</systemitem>
     </term>
     <listitem>
      <para>
       サイトローカルアドレス。ルーティングはできますが、それが属する組織のネットワーク内に限られます。要するに、IPv6版のプライベートネットワークアドレス空間です(たとえば、<systemitem class="ipaddress">10.x.x.x</systemitem>)。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem class="ipaddress">ff</systemitem>
     </term>
     <listitem>
      <para>
       \&apos;83\&apos;7dルチキャストアドレス。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    ユニキャストアドレスは、以下の3つの基\&apos;96\&apos;7b\&apos;8d\&apos;5c成要素からなります。
   </para>
   <variablelist>
    <varlistentry>
     <term>パブリックトポロジ</term>
     <listitem>
      <para>
       最初の部分(前述のいずれかのプレフィクスが含まれる部分)は、パブリックインターネット内でパケットをルーティングするために使用します。ここには、インターネットアクセスを提供する企業または団体に関する情報が入っています。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>サイトトポロジ</term>
     <listitem>
      <para>
       2番目の部分には、パケットの配信先のサブネットに関するルーティング情報が入っています。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>インタフェースID</term>
     <listitem>
      <para>
       3番目の部分は、パケットの配信先のインタフェースを示します。これを使用して、MACをアドレスの一部に含めることができます。MACは、世界中で重複がない固定の識別子であり、ハードウェアメーカによってデバイスにコーディングされるので、環境設定手順が大幅に簡素化されます。実際には、最初の 64アドレスビットが統合されて<literal>EUI-64</literal>トークンを構成します。このうち、最後の 48ビットにはMACアドレス、残りの 24ビットにはトークンタイプに関する特別な情報が入ります。これにより、PPPのインタフェースのようにMACを持たないインタフェースに<literal>EUI-64</literal>トークンを割り当てられるようになります。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    IPv6は、この基本構造の上で、以下の5種類のユニキャストアドレスを区別します。
   </para>
   <variablelist>
    <varlistentry>
     <term><systemitem class="ipaddress">::</systemitem> (未指定) </term>
     <listitem>
      <para>
       このアドレスは、インタフェースが初めて初期化されるとき(すなわち、アドレスが他の方法で判定できないとき)に、ホストがそのソースアドレスとして使用します。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem class="ipaddress">::1</systemitem> (ループバック) </term>
     <listitem>
      <para>
       ループバックデバイスのアドレス。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>IPv4互換アドレス</term>
     <listitem>
      <para>
       IPv6アドレスが、IPv4アドレスおよび96個の0ビットからなるプレフィクスで作成されます。このタイプの互換アドレスは、IPv4とIPv6のホストが、純粋なIPv4環境で動作している他のホストと通信するためのトンネリング(<xref linkend="sec-network-ipv6-coexist"/>を参照)として使用されます。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>IPv6にマッピングされたIPv4アドレス</term>
     <listitem>
      <para>
       このタイプのアドレスは、IPv6\&apos;95\&apos;5c記で純粋なIPv4アドレスを指定します。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>ローカルアドレス</term>
     <listitem>
      <para>
       ローカルで使用するアドレスのタイプには、以下の2種類があります。
      </para>
      <variablelist>
       <varlistentry>
        <term>リンクローカル</term>
        <listitem>
         <para>
          このタイプのアドレスは、ローカルのサブネットでのみ使用できます。このタイプのソースまたは宛先アドレスを持つパケットをインターネットまたは他のサブネットにルーティングしてはなりません。これらのアドレスは、特別なプレフィクス(<systemitem class="ipaddress">fe80::/10</systemitem>)とネットワークカードのインタフェースID、およびゼロバイトからなる中間部分からなります。このタイプのアドレスは、自動環境設定のとき、同じサブネットに属する他のホストと通信するために使用されます。
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>サイトローカル</term>
        <listitem>
         <para>
          このタイプのアドレスを持つパケットは、他のサブネットにはルーティングできますが、それより広いインターネットにはルーティングしてはなりません。つまり、組織自体のネットワークの内側だけで使用するように制限する必要があります。このようなアドレスはイントラネット用に使用され、IPv4によって定義されているプライベートアドレス空間に相当します。これらのアドレスは、特殊なプレフィクス(<systemitem class="ipaddress">fec0::/10</systemitem>)とインタフェースID、およびサブネットIDを指定する16ビットのフィールドからなります。ここでも、残りはゼロバイトで埋められます。
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    IPv6では、各ネットワークインタフェースが複数のIPアドレスを持つことができるというたまったく新しい機能が導入されました。これにより、同じインタフェースで複数のネットワークにアクセスできます。これらのいずれかのネットワークを、MACと既知のプレフィクスを使用して完全に自動設定できるので、IPv6が有効になると、(リンクローカルアドレスを使用して)ローカルネットワーク上のすべてのホストに接続できるようになります。IPアドレスにMACが組み込まれているので、使用されるIPアドレスは世界中で唯一のアドレスになります。アドレスの唯一の可変部分は、ホストが現在動作している実際のネットワークによって、<emphasis>サイトトポロジ</emphasis>と<emphasis>パブリックトポロジ</emphasis>を指定する部分になります。
   </para>
   <para>
    複数のネットワークに接続するホストの場合、少なくとも2つのアドレスが必要です。1つは<emphasis>ホームアドレス</emphasis>です。ホームアドレスには、インタフェースIDだけでなく、それが通常属するホームネットワークの識別子(および対応するプレフィクス)も含まれています。ホームアドレスは静的アドレスなので、通常は変更されません。しかし、モバイルホスト宛てのパケットは、それがホームネットワーク内にあるかどうかにかかわらず、すべてそのホストに配信できます。これは、IPv6で導入された<emphasis>ステートレス自動環境設定</emphasis>や<emphasis>ネイバーディスカバリ</emphasis>のようなまったく新しい機能によって実現されました。モバイルホストは、ホームアドレスに加え、ローミング先の外部ネットワークに属するアドレスも取得します。これらは<emphasis>ケアオブ</emphasis>アドレスと呼ばれます。ホームネットワークには、ホストが対象エリア外をローミングしている間、そのホスト宛てのすべてのパケットを転送する機能があります。IPv6環境において、このタスクは、<emphasis>ホームエージェント</emphasis>によって実行されます。ホームエージェントは、ホームアドレスに届くすべてのパケットを取得してトンネルに リレーします。一方、ケアオブアドレスに届いたパケットは、特別迂回することなく、直接モバイルホストに転送されます。
   </para>
  </sect2>

  <sect2 xml:id="sec-network-ipv6-coexist">
   <title>IPv4とIPv6の共存</title>
   <para>
    インターネットに接続されている全ホストをIPv4からIPv6に移行する作業は、段階的に行われます。両方のプロトコルは今後しばらく共存することになります。両方のプロトコルを<emphasis>デュアルスタック</emphasis>で実装すれば、同じシステム上に共存することが保証されます。しかし、それでもなお、IPv6対応のホストがどのようにしてIPv4ホストと通信するか、また多くがIPv4ベースの現行ネットワークでIPv6パケットをどのように伝送するかなど、解決すべき問題が残ります。最善のソリューションは、トンネリングと互換アドレスです(<xref linkend="sec-network-ipv6-address"/>を参照)。
   </para>
   <para>
    ワールドワイドなIPv4ネットワークと隔離されているIPv6ホストは、トンネルを使って通信を行うことができます。IPv6パケットをIPv4パケットにカプセル化すれば、それをIPv4ネットワークに送ることができます。2つのIPv4ホスト間のこのような接続を<emphasis>トンネル</emphasis>と呼びます。そのためには、パケットにIPv6の宛先アドレス(または対応するプレフィクス)とともに、トンネルの受信側にあるリモートホストのIPv4アドレスも含める必要があります。基本的なトンネルは、ホストの管理者間が合意すれば、手動で設定が可能です。これは、<emphasis>静的トンネリング</emphasis>とも呼ばれます。
   </para>
   <para>
    ただし、静的トンネルの環境設定とメンテナンスは、あまりに手間がかかるので、多くの場合、日常の通信には向きません。そこで、IPv6は、<emphasis>動的トンネリング</emphasis>を実現する3つの異なる方法を提供しています。
   </para>
   <variablelist>
    <varlistentry>
     <term>6over4</term>
     <listitem>
      <para>
       IPv6パケットが自動的にIPv4パケットとしてカプセル化され、マルチキャスト対応のIPv4ネットワークによって送信されます。IPv6は、ネットワーク全体(インターネット)を巨大なLAN (local area network)だと思い込んで動作することになります。これにより、IPv4トンネルの着信側の端を自動的に判定できます。ただし、この方法では、拡張性に欠けることになるだけでなく、IPマルチキャストがインターネット上で広く普及しているとはいえないことが障害にもなります。したがってこの解決方法を採用できるのは、マルチキャストが利用できる小規模な企業内ネットワークだけです。この方式の仕様は、RFC 2529に規定されています。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>6to4</term>
     <listitem>
      <para>
       この方式では、IPv6アドレスからIPv4アドレスを自動的に生成することで、隔離されたIPv6ホストがIPv4ネットワーク経由で通信できるようにします。しかし、隔離されたIPv6ホストとインターネットの間の通信に関して、多くの問題が報告されています。この方式は、RFC 3056で規定されています。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>IPv6トンネルブローカ</term>
     <listitem>
      <para>
       この方式は、IPv6ホスト専用のトンネルを提供する特殊なサーバに依存します。この方式は、RFC 3053で規定されています。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="sec-network-ipv6-config">
   <title>IPv6の設定</title>

   <para>
    IPv6を設定するには、通常、個々のワークステーションの設定を変更する必要はありません。IPv6は、デフォルトで有効になっています。インストール済みシステムでIPv6を有効または無効にするには、YaSTの<guimenu>ネットワーク設定</guimenu>モジュールを使用します。<guimenu>グローバルオプション</guimenu>タブで、必要に応じて<guimenu>IPv6を有効にする</guimenu>オプションをオン/オフします。次回の再起動時まで一時的に有効にするには、<systemitem class="username">root</systemitem>として、「<command>modprobe</command> <option>-i ipv6</option>」と入力します。IPv6モジュールはロード後にアンロードすることはできません。
   </para>
   <para>
    IPv6の自動環境設定の概念があるため、ネットワークカードには、<emphasis>リンクローカル</emphasis>ネットワーク内のアドレスが割り当てられます。通常、ワークステーション上ではルーティングテーブルの管理を実行しません。ワークステーションは、<emphasis>ルータアドバタイズプロトコル</emphasis>を使用して、実装する必要のあるプレフィクスとゲートウェイをネットワークルータに問い合わせます。IPv6ルータは、radvdプログラムを使用して設定できます。このプログラムは、IPv6アドレスに使用するプレフィクスとルータをワークステーションに通知します。または、zebra/quaggaを使用してアドレスとルーティングの両方を自動設定することもできます。
   </para>

   <para>
    <filename>/etc/sysconfig/network</filename>ファイルを使用してさまざまなタイプのトンネルをセットアップする方法の詳細については、<literal>ifcfg-tunnel</literal>のマニュアルページ(<command>man ifcfg-tunnel</command>)を参照してください。
   </para>
  </sect2>

  <sect2 xml:id="sec-network-ipv6-moreinfo">
   <title>詳細情報</title>
   <para>
    ここでの概要は、IPv6に関する情報を網羅しているわけではありません。より新しいプロトコルの詳細については、次のオンラインドキュメントや書籍を参照してください。
   </para>
   <variablelist>
    <varlistentry>
     <term><link xlink:href="http://www.ipv6.org/"/>
     </term>
     <listitem>
      <para>
       IPv6のあらゆる情報にここからリンクできます。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link xlink:href="http://www.ipv6day.org"/>
     </term>
     <listitem>
      <para>
       独自のIPv6ネットワークを開始するには、すべての情報が必要です。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link xlink:href="http://www.ipv6-to-standard.org/"/>
     </term>
     <listitem>
      <para>
       IPv6対応製品のリスト。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link xlink:href="http://www.bieringer.de/linux/IPv6/"/>
     </term>
     <listitem>
      <para>
       Linux IPv6-HOWTOと多くの関連トピックへのリンクが用意されています。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>RFC2460</term>
     <listitem>
      <para>
       IPv6に関する基\&apos;96\&apos;7b的なRFCです。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>IPv6 Essentials</term>
     <listitem>
      <para>
       Silvia Hagenによる<emphasis>IPv6 Essentials</emphasis> (ISBN 0-596-00125-8)は、このトピックに関するあらゆる重要な面を扱っている本です。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-network-nameres">
  <title>ネームレゾリューション</title>

  <para>
   DNSはIPアドレスに1つまたは複数のホスト名を割り当てるとともに、ホスト名をIPアドレスに割り当てます。Linuxでは、この変換は通常、bindという特別な種類のソフトウェアによって行われます。また、この変換を行うマシンを<emphasis>ネームサーバ</emphasis>と呼びます。ホスト名は、その名前構成要素がピリオド(.)で区切られた階層システムを構成しています。しかしながら名前の階層構造は、先に述べたIPアドレスの階層構造とは無関係です。
  </para>

  <para>
   <systemitem class="fqdomainname">hostname.domain</systemitem>という形式で書かれた完全な名前、たとえば、<systemitem class="fqdomainname">jupiter.example.com</systemitem>を考えてみましょう。「完全修飾ドメイン名」<emphasis></emphasis>(FQDN)と呼ばれるフルネームは、ホスト名とドメイン名(<systemitem class="domainname">example.com</systemitem>)で構成されます。ドメイン名には<emphasis>最上位ドメイン</emphasis>(TLD) (<systemitem class="domainname">com</systemitem>)が含まれます。
  </para>

  <para>
   TLDの割り当ては、これまでの経緯もあって、非常に複雑になっています。従来から、米国では、3文字のドメイン名が使用されています。他の国では、ISOで制定された2文字の国コードが標準です。これに加えて、2000年には、特定の活動領域を表す、より長いTLDが導入されました(たとえば、<systemitem class="domainname">.info</systemitem>、<systemitem class="domainname">.name</systemitem>、<systemitem class="domainname">.museum</systemitem>)。
  </para>

  <para>
   インターネットの初期( 1990年より前)には、ファイル<filename>/etc/hosts</filename>に、インターネットで利用されるすべてのマシン名を記述していました。しかし、インターネットに接続されるコンピュータ数の急激な増加により、この方法はすぐに現実的でなくなりました。このため、ホスト名を広く分散して保存するための分散データベースが開発されました。このデータベースは、ネームサーバと同様、インターネット上のすべてのホストに関するデータがいつでも用意されているわけではなく、他のネームサーバに問い合わせを行います。
  </para>

  <para>
   この階層の最上位には、複数の<emphasis>ルートネームサーバ</emphasis>があります。ルートネームサーバは、Network Information Center (NIC)によって運用されており、最上位レベルドメインを管理します。各ルートネームサーバは、特定の最上位ドメインを管理するネームサーバについての情報を持っています。最上位ドメインNICの詳細については、<link xlink:href="http://www.internic.net"/>を参照してください。
  </para>

  <para>
   DNSには、ホスト名の解決以外の機能もあります。ネームサーバは、特定のドメイン宛の電子メールをどのホストに転送するかも管理しています(「メールエクスチェンジャ(MX)」<emphasis></emphasis>)。
  </para>

  <para>
   マシンがIPアドレスを解決するには、少なくとも1台のネームサーバとそのIPアドレスを知っている必要があります。そのようなネームサーバの指定は、YaSTを使用すれば簡単です。<phrase os="sles;osuse"><phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase>でのネームサーバアクセスの設定については、<xref linkend="sec-network-yast-change-host"/>に記載されています。独自のネームサーバの設定については、<xref linkend="cha-dns"/>に説明があります。</phrase>
  </para>

  <para>
   <literal>whois</literal>プロトコルは、DNSと密接な関係があります。このプログラムを使用すると、特定のドメインの登録者情報をすぐに検索できます。
  </para>



  <note>
   <title>MDNSおよび.localドメイン名</title>
   <para>
    <literal>.local</literal>トップレベルドメインは、リゾルバではリンクローカルドメインとして処理されます。DNS要求は通常のDNS要求ではなく、マルチキャスト要求として送信されます。ネームサーバ設定で<literal>.local</literal>ドメインをすでに使用している場合は、このオプションを<filename>/etc/host.conf</filename>でオフに変更する必要があります。詳細については、<filename>host.conf</filename>のマニュアルページを参照してください。
   </para>
   <para>
    インストール中にMDNSをオフにするには、<literal>nomdns=1</literal>をブートパラメータとして使用してください。
   </para>
   <para>
    マルチキャストDNSの詳細は、<link xlink:href="http://www.multicastdns.org"/>を参照してください。
   </para>
  </note>
 </sect1>
 <xi:include href="net_yast.xml"/>
 
 <xi:include href="net_wicked.xml"/>
 <xi:include href="net_router.xml"/>
 <xi:include href="net_bonding.xml"/>
 <xi:include href="net_teaming.xml"/>
 <xi:include href="net_sdn.xml"/>
</chapter>
