<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//Novell//DTD NovDoc XML V1.0//EN" "novdocx.dtd">
<!--
*********************************
Please see LICENSE.txt for this document's license.
*********************************
-->
<chapter xml:base="adm_shell.xml" id="cha.adm.shell">

 <title>Bash 和 Bash 脚本</title><indexterm> <primary>外壳</primary></indexterm><indexterm> <primary>Bash</primary> <see>外壳</see></indexterm>
 <abstract>
  <para>
   今天，许多人使用具有诸如 GNOME 的图形用户界面 (GUI) 的计算机。尽管它们提供了大量功能，但使用它们执行自动任务时，还是会有限制。外壳是对 GUI 的很好补充，本章提供关于外壳（在本例中为 Bash）的某些方面的概述。
  </para>
 </abstract>
 <sect1 id="sec.adm.whatistheshell">
  <title>什么是<quote>外壳</quote>？</title>



  <para>
   通常来说，外壳<emphasis>就是</emphasis>指 Bash（Bourne again 外壳）。在本章中提到<quote>外壳</quote>时，指的是 Bash。事实上，除了 Bash 还存在很多其他外壳（ash、csh、ksh、zsh 等），每种外壳都具备不同的功能和特征。如果需要关于其他外壳的更多信息，请在 YaST 中搜索<emphasis>外壳</emphasis>。
  </para>

  <sect2 id="sec.adm.configfiles">
   <title>了解 Bash 配置文件</title><indexterm> <primary>配置文件</primary> <see>Bash</see></indexterm>
   <para>
    外壳可调用为：
   </para>
   <orderedlist spacing="normal">
    <listitem>
     <formalpara>
      <title>交互式登录外壳</title>
      <para>
       当登录计算机时需要使用此方式，即使用 <option>--login</option> 选项调用 Bash 或通过 SSH 登录到远程计算机时。
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title><quote>普通</quote>交互式外壳</title>
      <para>
       这通常在启动 xterm、konsole、gnome 终端或类似工具时使用。
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>非交互式外壳</title>
      <para>
       当在命令行调用外壳脚本时使用。
      </para>
     </formalpara>
    </listitem>
   </orderedlist>
   <para>
    根据所用外壳的类型，会读取不同的配置文件。下表显示登录和非登录外壳的配置文件。
   </para>
   <table id="tab.adm.shell.config.loginshells">
    <title>登录外壳的 Bash 配置文件</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>
        <para>
         文件
        </para>
       </entry>
       <entry>
        <para>
         描述
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         <filename>/etc/profile</filename>
        </para>
       </entry>
       <entry>
        <para>
         不要修改此文件，否则在下一次更新时可能损坏您的修改！
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>/etc/profile.local</filename>
        </para>
       </entry>
       <entry>
        <para>
         如果扩展 <filename>/etc/profile</filename>，请使用此文件
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>/etc/profile.d/</filename>
        </para>
       </entry>
       <entry>
        <para>
         包含特定程序的系统范围配置文件
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>~/.profile</filename>
        </para>
       </entry>
       <entry>
        <para>
         在此处插入特定于用户的登录外壳配置
        </para>
       </entry>
      </row>

     </tbody>
    </tgroup>
   </table>
   <table id="tab.adm.shell.configs.nonloginshells">
    <title>非登录外壳的 Bash 配置文件</title>
    <tgroup cols="2">
     <tbody>
      <row>
       <entry>
        <para>
         <filename>/etc/bash.bashrc</filename>
        </para>
       </entry>
       <entry>
        <para>
         不要修改此文件，否则在下一次更新时可能损坏您的修改！
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>/etc/bash.bashrc.local</filename>
        </para>
       </entry>
       <entry>
        <para>
         使用此文件插入系统范围的修改（仅 Bash）
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>~/.bashrc</filename>
        </para>
       </entry>
       <entry>
        <para>
         在此处插入特定于用户的配置
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    此外，Bash 还使用更多文件：
   </para>
   <table>
    <title>用于 Bash 的特殊文件</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>
        <para>
         文件
        </para>
       </entry>
       <entry>
        <para>
         描述
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         <filename>~/.bash_history</filename>
        </para>
       </entry>
       <entry>
        <para>
         包含已键入的所有命令的列表
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>~/.bash_logout</filename>
        </para>
       </entry>
       <entry>
        <para>
         注销时执行
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>

  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="fs_structure_i.xml" parse="xml"/>
 </sect1>
 <sect1 id="sec.adm.shellscripts">
  <title>编写外壳脚本</title><indexterm> <primary>外壳脚本</primary></indexterm>

  <para>
   外壳脚本是执行所有类型任务的便捷方式：收集数据、在文本中搜索单词或短语以及许多其他有用的操作。以下示例显示用于打印文本的小外壳脚本：
  </para>

  <example>
   <title>用于打印文本的外壳脚本</title>
<screen>#!/bin/sh <co id="co.adm.shell.shebang"/>
# Output the following line: <co id="co.adm.shell.comment"/>
echo "Hello World" <co id="co.adm.shell.echo"/></screen>
   <calloutlist>
    <callout arearefs="co.adm.shell.shebang">
     <para>
      第一行开头是 <emphasis>Shebang</emphasis> <indexterm> <primary>Shebang</primary> </indexterm> 字符 (<literal>#!</literal>)，它表示此文件是一个脚本。该脚本使用 Shebang 后的指定解释程序执行，在本示例中为 <command>/bin/sh</command>。
     </para>
    </callout>
    <callout arearefs="co.adm.shell.comment">
     <para>
      第二行是一个以哈希符号开头的注释。建议对较难理解的行进行注释以记住它们的作用。
     </para>
    </callout>
    <callout arearefs="co.adm.shell.echo">
     <para>
      第三行使用内置命令 <command>echo</command> 打印相应文本。
     </para>
    </callout>
   </calloutlist>
  </example>

  <para>
   可以运行该脚本之前，需要一些先决条件：
  </para>

  <orderedlist spacing="normal">
   <listitem>
    <para>
     每个脚本都应包含一个 Shebang 行（始终和我们的上述示例一样）。如果脚本没有此行，则需要手动调用解释程序。
    </para>
   </listitem>
   <listitem>
    <para>
     可以将该脚本保存在任何位置。但是，建议将其保存在外壳可以找到的目录中。外壳中的搜索路径由环境变量 <envar>PATH</envar> 确定。通常，一般用户不具有对 <filename>/usr/bin</filename> 的写权限。因此，建议将脚本保存在用户目录 <filename>~/bin/</filename> 中。在上例中使用名称 <filename>hello.sh</filename>。
    </para>
   </listitem>
   <listitem>
    <para>
     该脚本需要可执行权限。使用以下命令设置权限：
    </para>
<screen>chmod +x ~/bin/hello.sh</screen>
   </listitem>
  </orderedlist>

  <para>
   如果已满足上述所有先决条件，则可以按如下方式执行此脚本：
  </para>

  <orderedlist spacing="normal">
   <listitem>
    <formalpara>
     <title>作为绝对路径</title>
     <para>
      可以使用绝对路径执行脚本。在本例中为 <command>~/bin/hello.sh</command>。
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>所有位置</title>
     <para>
      如果 <envar>PATH</envar> 环境变量包含脚本所在目录，则可以使用 <command>hello.sh</command> 来执行该脚本。
     </para>
    </formalpara>
   </listitem>
  </orderedlist>
 </sect1>
 <sect1 id="sec.adm.shell.redirect">
  <title>重定向命令事件</title>

  <para>
   每个命令都可以使用三个通道输入或输出：
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <formalpara>
     <title>标准输出</title>
     <para>
      这是默认的输出通道。在命令打印某些内容时都会使用标准输出通道。
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>标准输入</title>
     <para>
      如果一个命令需要用户或其他命令输入，则使用此通道。
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>标准错误</title>
     <para>
      命令使用此通道报告错误。
     </para>
    </formalpara>
   </listitem>
  </itemizedlist>

  <para>
   要重定向这些通道，有以下可行的操作方式：
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>命令 &gt; 文件</literal>
    </term>
    <listitem>
     <para>
      将该命令的输出保存为文件，将删除现有文件。例如，<command>ls</command> 命令会将其输出写入文件 <filename>listing.txt</filename>：
     </para>
<screen>ls &gt; listing.txt</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>命令 &gt;&gt; 文件</literal>
    </term>
    <listitem>
     <para>
      将命令输出追加到文件。例如，<command>ls</command> 命令会将其输出追加到文件 <filename>listing.txt</filename>：
     </para>
<screen>ls &gt;&gt; listing.txt</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>命令 &lt; 文件</literal>
    </term>
    <listitem>
     <para>
      读取该文件作为给定命令的输入。例如，<command>read</command> 命令会将此文件的内容读入变量：
     </para>
<screen>read a &lt; foo</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>命令 1 | 命令 2</literal>
    </term>
    <listitem>
     <para>
      将左侧命令的输出重定向为右侧命令的输入。例如，<command>cat</command> 命令会输出文件 <filename>/proc/cpuinfo</filename> 的内容。<command>grep</command> 使用此输出仅过滤出包含 <literal>cpu</literal> 的行：
     </para>
<screen>cat /proc/cpuinfo | grep cpu</screen>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   每个通道都有一个<emphasis>文件描述符</emphasis>：0（零）表示标准输入，1 表示标准输出，2 表示标准错误。允许在 <literal>&lt;</literal> 或 <literal>&gt;</literal> 字符前插入此文件描述符。例如，以下行搜索以 <filename>foo</filename> 开头的文件，但通过将错误重定向到 <filename>/dev/null</filename> 而抑制错误。
  </para>

<screen>find / -name "foo*" 2&gt;/dev/null</screen>
 </sect1>
 <sect1 id="sec.adm.alias">
  <title>使用别名</title><indexterm> <primary>aliases</primary></indexterm>

  <para>
   别名是一个或多个命令的快捷方式定义。别名的语法为：
  </para>

<screen>alias <replaceable>NAME</replaceable>=<replaceable>DEFINITION</replaceable></screen>

  <para>
   例如，以下行定义了一个别名 <command>lt</command>，它输出一个长列表（选项 <option>-l</option>），将其按修改时间排序 (<option>-t</option>)，并在排序后反向打印 (<option>-r</option>)：
  </para>

<screen>alias lt='ls -ltr'</screen>

  <para>
   要查看所有别名定义，请使用 <command>alias</command>。使用 <command>unalias</command> 和相应的别名删除别名。
  </para>
 </sect1>
 <sect1 id="sec.adm.variables">
  <title>在 Bash 中使用变量</title>

  <para>
   外壳变量可以是全局变量，也可以是局部变量。全局变量（或环境变量）可以在所有外壳中访问。而局部变量仅在当前外壳中可见。
  </para>

  <para>
   要查看所有环境变量，请使用 <command>printenv</command> 命令。如果需要知道变量的值，请将变量名称作为自变量插入：
  </para>

<screen>printenv PATH</screen>

  <para>
   也可以使用 <command>echo</command> 查看变量（无论是全局或本地变量）：
  </para>

<screen>echo $PATH</screen>

  <para>
   要设置局部变量，请使用变量名后加等号和值：
  </para>

<screen>PROJECT="SLED"</screen>

  <para>
   不要在等号两边插入空格，否则会出错。要设置环境变量，请使用 <command>export</command>：
  </para>

<screen>export NAME="tux"</screen>

  <para>
   要删除变量，请使用 <command>unset</command>：
  </para>

<screen>unset NAME</screen>

  <para>
   下表包含外壳脚本中可以使用的一些常见环境变量：
  </para>

  <table id="tab.adm.envars">
   <title>有用的环境变量</title>
   <tgroup cols="2">
    <tbody>
     <row>
      <entry>
       <para>
        <envar>HOME</envar>
       </para>
      </entry>
      <entry>
       <para>
        当前用户的用户主目录
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>HOST</envar>
       </para>
      </entry>
      <entry>
       <para>
        当前主机名
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>LANG</envar>
       </para>
      </entry>
      <entry>
       <para>
        当一个工具本地化后，它使用此环境变量中的语言。英语也可以设置为 <literal>C</literal>
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>PATH</envar>
       </para>
      </entry>
      <entry>
       <para>
        外壳的搜索路径，冒号分隔的目录列表
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>PS1</envar>
       </para>
      </entry>
      <entry>
       <para>
        指定在每个命令前打印的普通提示符
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>PS2</envar>
       </para>
      </entry>
      <entry>
       <para>
        指定在执行多行命令时打印的辅助提示符
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>PWD</envar>
       </para>
      </entry>
      <entry>
       <para>
        当前工作目录
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>USER</envar>
       </para>
      </entry>
      <entry>
       <para>
        当前用户
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <sect2 id="sec.adm.variables.argument">
   <title>使用自变量</title>

   <para>
    例如，如果具有脚本 <command>foo.sh</command>，则可以如下执行：
   </para>
<screen>foo.sh "Tux Penguin" 2000 </screen>
   <para>
    要访问传递给脚本的所有自变量，您需要定位参数。<envar>$1</envar> 表示第一个自变量，<envar>$2</envar> 表示第二个自变量，依此类推。至多可以有九个参数。要获取脚本名称，请使用 <envar>$0</envar>。
   </para>
   <para>
    以下脚本 <command>foo.sh</command> 打印从 1 到 4 的所有自变量：
   </para>
<screen>#!/bin/sh
echo \"$1\" \"$2\" \"$3\" \"$4\"</screen>
   <para>
    如果使用上述自变量执行此脚本，将获取：
   </para>
<screen>"Tux Penguin" "2000" "" ""</screen>

  </sect2>

  <sect2 id="sec.adm.shell.varsubst">
   <title>使用变量替换</title>
   <para>
    变量替换将一个模式应用于变量的内容（从左侧或从右侧）。以下列表包含可能的语法格式：
   </para>
   <variablelist>
    <varlistentry>
     <term><literal>${VAR#pattern}</literal>
     </term>
     <listitem>
      <para>
       从左侧删除可能的最短匹配：
      </para>
<screen>file=/home/tux/book/book.tar.bz2
echo ${file#*/}
home/tux/book/book.tar.bz2</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>${VAR##pattern}</literal>
     </term>
     <listitem>
      <para>
       从左侧删除可能的最长匹配：
      </para>
<screen>file=/home/tux/book/book.tar.bz2
echo ${file##*/}
book.tar.bz2</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>${VAR%pattern}</literal>
     </term>
     <listitem>
      <para>
       从右侧删除可能的最短匹配：
      </para>
<screen>file=/home/tux/book/book.tar.bz2
echo ${file%.*}
/home/tux/book/book.tar</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>${VAR%%pattern}</literal>
     </term>
     <listitem>
      <para>
       从右侧删除可能的最长匹配：
      </para>
<screen>file=/home/tux/book/book.tar.bz2
echo ${file%%.*}
/home/tux/book/book</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>${VAR/pattern_1/pattern_2}</literal>
     </term>
     <listitem>
      <para>
       将来自 <replaceable>pattern_1</replaceable> 的 <replaceable>VAR</replaceable> 的内容替代为 <replaceable>pattern_2</replaceable>：
      </para>
<screen>file=/home/tux/book/book.tar.bz2
echo ${file/tux/wilber}
/home/wilber/book/book.tar.bz2</screen>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>
 </sect1>
 <sect1 id="sec.adm.shell.grouping">
  <title>将命令分组和组合</title>

  <para>
   外壳允许您对命令执行连接和分组以有条件地执行。每个命令都返回一个退出码，该退出码确定操作是成功还是失败。如果是 0，则命令成功，任何其他值都表示特定于该命令的一个错误。
  </para>

  <para>
   以下列表显示可以如何将命令分组：
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>命令 1 ; 命令 2</literal>
    </term>
    <listitem>
     <para>
      顺序地执行这些命令。不检查退出码。以下行使用 <command>cat</command> 显示文件的内容，然后使用 <command>ls</command> 打印其文件属性，而不考虑退出码：
     </para>
<screen>cat filelist.txt ; ls -l filelist.txt</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>命令 1 &amp;&amp; 命令 2</literal>
    </term>
    <listitem>
     <para>
      如果左侧命令成功，则运行右侧命令（逻辑运算符 AND）。仅当上一个命令成功时，以下行才显示文件的内容并打印其文件属性（将其与列表中的上一项相比较）：
     </para>
<screen>cat filelist.txt &amp;&amp; ls -l filelist.txt</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>命令 1 || 命令 2</literal>
    </term>
    <listitem>
     <para>
      当左侧命令失败时运行右侧命令（逻辑运算符 OR）。以下行仅当在 <filename>/home/tux/foo</filename> 中创建目录失败时才会在 <filename>/home/wilber/bar</filename> 中创建目录：
     </para>
<screen>mkdir /home/tux/foo || mkdir /home/wilber/bar</screen>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>funcname(){ ... }</literal>
    </term>
    <listitem>
     <para>
      创建外壳函数。您可以使用定位参数访问其自变量。以下行定义用于打印短消息的函数 <literal>hello</literal>：
     </para>
<screen>hello() { echo "Hello $1"; }</screen>
     <para>
      您可以如下调用此函数：
     </para>
<screen>hello Tux</screen>
     <para>
      它会打印：
     </para>
<screen>Hello Tux</screen>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 id="sec.adm.shell.commonconstructs">
  <title>使用通用流程构造语句</title>

  <para>
   为了控制脚本的流程，外壳有 <command>while</command>、<command>if</command>、<command>for</command> 和 <command>case</command> 等构造语句。
  </para>



  <sect2 id="sec.adm.shell.if">
   <title>if 控制命令</title>
   <para>
    <command>if</command> 命令用于检查表达式。例如，以下代码测试当前用户是否是 Tux：
   </para>
<screen>if test $USER = "tux"; then
  echo "Hello Tux."
else
  echo "You are not Tux."
fi</screen>
   <para>
    测试表达式既可以复杂也可以简单。以下表达式检查文件 <filename>foo.txt</filename> 是否存在：
   </para>
<screen>if test -e /tmp/foo.txt ; then
  echo "Found foo.txt"
fi</screen>
   <para>
    测试表达式也可以缩写在角括号中：
   </para>
<screen>if [ -e /tmp/foo.txt ] ; then
  echo "Found foo.txt"
fi</screen>
   <para>
    在 <ulink url="http://www.cyberciti.biz/nixcraft/linux/docs/uniqlinuxfeatures/lsst/ch03sec02.html"/> 上可以找到更多有用表达式。
   </para>
  </sect2>

  <sect2 id="sec.adm.shell.for">
   <title>使用 For 命令创建循环</title>
   <para>
    <command>for</command> 循环允许您对一系列项执行命令。例如，以下代码打印关于当前工作目录中 PNG 文件的某些信息：
   </para>
<screen>for i in *.png; do
 ls -l $i
done</screen>
  </sect2>
 </sect1>
 <sect1 id="sec.adm.shell.moreinfo">
  <title>更多信息</title>

  <para>
   关于 Bash 的重要信息在手册页 <command>man bash</command> 中提供。可以在以下列表中找到关于此主题的更多信息：
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     <ulink url="http://tldp.org/LDP/Bash-Beginners-Guide/html/index.html"/> — Bash 入门者指南
    </para>
   </listitem>
   <listitem>
    <para>
     <ulink url="http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html"/> — BASH 编程 - 简介操作指南
    </para>
   </listitem>
   <listitem>
    <para>
     <ulink url="http://tldp.org/LDP/abs/html/index.html"/> — 高级 Bash 脚本编写指南
    </para>
   </listitem>
   <listitem>
    <para>
     <ulink url="http://www.grymoire.com/Unix/Sh.html"/> — Sh - Bourne 外壳
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
</chapter>
