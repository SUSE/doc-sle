<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>

<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="cha.qemu.running">
 <title>Running Virtual Machines with qemu-system-ARCH</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker></dm:bugtracker>
  </dm:docmanager>
 </info>
 <para>
  Once you have a virtual disk image ready (for more information on disk
  images, see <xref linkend="cha.qemu.guest_inst.qemu-img"/>), it is time to
  start the related virtual machine.
  <xref linkend="cha.qemu.guest_inst.qemu-kvm"/> introduced simple commands to
  install and run a &vmguest;. This chapter focuses on a more detailed
  explanation of <command>qemu-system-ARCH</command> usage, and shows solutions
  for more specific tasks. For a complete list of
  <command>qemu-system-ARCH</command>'s options, see its manual page
  (<command>man 1 qemu</command>).
 </para>
 <sect1 xml:id="cha.qemu.running.basic">
  <title>Basic <command>qemu-system-ARCH</command> Invocation</title>

  <para>
   The <command>qemu-system-ARCH</command> command uses the following syntax:
  </para>

<screen>qemu-system-ARCH options<co xml:id="co.qemu.running.basic.opts"/> disk_img<co xml:id="co.qemu.running.basic.img"/></screen>

  <calloutlist>
   <callout arearefs="co.qemu.running.basic.opts">
    <para>
     <command>qemu-system-ARCH</command> understands many options. Most of them
     define parameters of the emulated hardware, while others affect more
     general emulator behavior. If you do not supply any options, default
     values are used, and you need to supply the path to a disk image to be
     run.
    </para>
   </callout>
   <callout arearefs="co.qemu.running.basic.img">
    <para>
     Path to the disk image holding the guest system you want to virtualize.
     <command>qemu-system-ARCH</command> supports many image formats. Use
     <command>qemu-img</command> <option>--help</option> to list them. If you
     do not supply the path to a disk image as a separate argument, you need to
     use the <option>-drive file=</option> option.
    </para>
   </callout>
  </calloutlist>
 </sect1>
 <sect1 xml:id="cha.qemu.running.gen_opts">
  <title>General <command>qemu-system-ARCH</command> Options</title>

  <para>
   This section introduces general <command>qemu-system-ARCH</command> options
   and options related to the basic emulated hardware, such as the virtual
   machine's processor, memory, model type, or time processing methods.
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>-name <replaceable>NAME_OF_GUEST</replaceable></literal>
    </term>
    <listitem>
     <para>
      Specifies the name of the running guest system. The name is displayed in
      the window caption and used for the VNC server.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>-boot <replaceable>OPTIONS</replaceable></literal>
    </term>
    <listitem>
     <para>
      Specifies the order in which the defined drives will be booted. Drives
      are represented by letters, where <literal>a</literal> and
      <literal>b</literal> stand for the floppy drives 1 and 2,
      <literal>c</literal> stands for the first hard disk, <literal>d</literal>
      stands for the first CD-ROM drive, and <literal>n</literal> to
      <literal>p</literal> stand for Ether-boot network adapters.
     </para>
     <para>
      For example, <literal>qemu-system-ARCH [...] -boot order=ndc</literal>
      first tries to boot from network, then from the first CD-ROM drive, and
      finally from the first hard disk.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>-pidfile <replaceable>FILENAME</replaceable></literal>
    </term>
    <listitem>
     <para>
      Stores the &qemu;'s process identification number (PID) in a file. This
      is useful if you run &qemu; from a script.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>-nodefaults</literal>
    </term>
    <listitem>
     <para>
      By default &qemu; creates basic virtual devices even if you do not
      specify them on the command line. This option turns this feature off, and
      you must specify every single device manually, including graphical and
      network cards, parallel or serial ports, or virtual consoles. Even &qemu;
      monitor is not attached by default.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>-daemonize</literal>
    </term>
    <listitem>
     <para>
      <quote>Daemonizes</quote> the &qemu; process after it is started. &qemu;
      will detach from the standard input and standard output after it is ready
      to receive connections on any of its devices.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <note>
   <title>SeaBIOS BIOS Implementation</title>
   <para>
    SeaBIOS is the default BIOS used. You can boot USB devices, any drive
    (CD-ROM, Floppy, or a hard disk). It has USB mouse and keyboard support and
    supports multiple VGA cards. For more information about SeaBIOS, refer to
    the <link xlink:href="http://www.seabios.org/SeaBIOS">SeaBIOS
    Website</link>.
   </para>
  </note>

  <sect2 xml:id="cha.qemu.running.gen_opts.basic">
   <title>Basic Virtual Hardware</title>
   <para/>
   <sect3 xml:id="sec.qemu.running.gen_opts.machine">
    <title>Machine Type</title>
    <para>
     You can specifies the type of the emulated machine. Run
     <command>qemu-system-ARCH -M help</command> to view a list of supported
     machine types.
    </para>
    <note>
     <title>ISA-PC</title>
     <para>
      The machine type <emphasis>isapc: ISA-only-PC</emphasis> is unsupported.
     </para>
    </note>
   </sect3>
   <sect3 xml:id="cha.qemu.running.gen_opts.basic.cpu">
    <title>CPU Model</title>
    <para>
     To specify the type of the processor (CPU) model, run
     <command>qemu-system-ARCH -cpu</command> <replaceable>MODEL</replaceable>.
     Use <command>qemu-system-ARCH -cpu help</command> to view a list of
     supported CPU models.
    </para>
    <para>
     CPU flags information can be found at
     <link xlink:href="http://en.wikipedia.org/wiki/CPUID">CPUID
     Wikipedia</link>.
    </para>
   </sect3>
   <sect3 xml:id="cha.qemu.running.gen_opts.basic.others">
    <title>Other Basics Options</title>
    <para>
     The following is a list of most commonly used options while launching
     <emphasis>qemu</emphasis> from command line. To see all options available
     refer to <emphasis>qemu-doc</emphasis> man page.
    </para>
    <variablelist>
     <varlistentry>
      <term><literal>-m <replaceable>MEGABYTES</replaceable></literal>
      </term>
      <listitem>
       <para>
        Specifies how many megabytes are used for the virtual RAM size.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-balloon virtio</literal>
      </term>
      <listitem>
       <para>
        Specifies a paravirtualized device to dynamically change the amount of
        virtual RAM memory assigned to &vmguest;. The top limit is the amount
        of memory specified with <literal>-m</literal>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-smp <replaceable>NUMBER_OF_CPUS</replaceable></literal>
      </term>
      <listitem>
       <para>
        Specifies how many CPUs will be emulated. &qemu; supports up to 255
        CPUs on the PC platform (up to 64 with KVM acceleration used). This
        option also takes other CPU-related parameters, such as number of
        <emphasis>sockets</emphasis>, number of <emphasis>cores</emphasis> per
        socket, or number of <emphasis>threads</emphasis> per core.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     The following is an example of a working
     <command>qemu-system-ARCH</command> command line:
     <remark>cwickert 2017-09-01 calling qemu like this will yield a warning:
      <quote>
       Image format was not specified for 'sles12sp2.raw' and probing guessed
       raw. Automatically detecting the format is dangerous for raw images,
       write operations on block 0 will be restricted.
       Specify the 'raw' format explicitly to remove the restrictions.
      </quote>
      To avoid this, we should specify the image format like this:
      "-drive format=raw,file=/images/sles.raw"
      This however needs to be done consistently throughout the guide, therefor
      I'm not changing this for now.
     </remark>
    </para>
<screen>&prompt.user;qemu-system-x86_64 -name "SLES 12 SP2" -M pc-i440fx-2.7 -m 512 \
-machine accel=kvm -cpu kvm64 -smp 2 -drive /images/sles.raw</screen>
    <figure>
     <title>&qemu; Window with SLES 11 SP3 as &vmguest;</title>
     <mediaobject>
      <imageobject role="fo">
       <imagedata fileref="qemu_win_sles.png" width="70%" format="PNG"/>
      </imageobject>
      <imageobject role="html">
       <imagedata fileref="qemu_win_sles.png" width="70%" format="PNG"/>
      </imageobject>
     </mediaobject>
    </figure>
    <variablelist>
     <varlistentry>
      <term><literal>-no-acpi</literal>
      </term>
      <listitem>
       <para>
        Disables <xref linkend="gloss.vt.acpi"/> support.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-S</literal>
      </term>
      <listitem>
       <para>
        &qemu; starts with CPU stopped. To start CPU, enter
        <literal>c</literal> in &qemu; monitor. For more information, see
        <xref linkend="cha.qemu.monitor"/>.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
  </sect2>

  <sect2 xml:id="cha.qemu.running.gen_opts.storing_cong">
   <title>Storing and Reading Configuration of Virtual Devices</title>
   <variablelist>
    <varlistentry>
     <term><literal>-readconfig <replaceable>CFG_FILE</replaceable></literal>
     </term>
     <listitem>
      <para>
       Instead of entering the devices configuration options on the command
       line each time you want to run &vmguest;,
       <command>qemu-system-ARCH</command> can read it from a file that was
       either previously saved with <literal>-writeconfig</literal> or edited
       manually.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>-writeconfig <replaceable>CFG_FILE</replaceable></literal>
     </term>
     <listitem>
      <para>
       Dumps the current virtual machine's devices configuration to a text
       file. It can be consequently re-used with the
       <literal>-readconfig</literal> option.
      </para>
<screen>&prompt.user;qemu-system-x86_64 -name "SLES 12 SP2" -machine accel=kvm -M pc-i440fx-2.7 -m 512 -cpu kvm64 \
-smp 2 /images/sles.raw -writeconfig /images/sles.cfg
(exited)
&prompt.user;cat /images/sles.cfg
# qemu config file

[drive]
  index = "0"
  media = "disk"
  file = "/images/sles_base.raw"</screen>
      <para>
       This way you can effectively manage the configuration of your virtual
       machines' devices in a well-arranged way.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="cha.qemu.running.gen_opts.rtc">
   <title>Guest Real-Time Clock</title>
   <variablelist>
    <varlistentry>
     <term><literal>-rtc <replaceable>OPTIONS</replaceable></literal>
     </term>
     <listitem>
      <para>
       Specifies the way the RTC is handled inside a &vmguest;. By default, the
       clock of the guest is derived from that of the host system. Therefore,
       it is recommended that the host system clock is synchronized with an
       accurate external clock (for example, via NTP service).
      </para>
      <para>
       If you need to isolate the &vmguest; clock from the host one, specify
       <literal>clock=vm</literal> instead of the default
       <literal>clock=host</literal>.
      </para>
      <para>
       You can also specify the initial time of the &vmguest;'s clock with the
       <literal>base</literal> option:
      </para>
<screen>&prompt.user;qemu-system-x86_64 [...] -rtc clock=vm,base=2010-12-03T01:02:00</screen>
      <para>
       Instead of a time stamp, you can specify <literal>utc</literal> or
       <literal>localtime</literal>. The former instructs &vmguest; to start at
       the current UTC value (Coordinated Universal Time, see
       <link xlink:href="http://en.wikipedia.org/wiki/UTC"/>), while the latter
       applies the local time setting.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>
 </sect1>
 <sect1 xml:id="cha.qemu.running.devices">
  <title>Using Devices in &qemu;</title>

  <para>
   &qemu; virtual machines emulate all devices needed to run a &vmguest;.
   &qemu; supports, for example, several types of network cards, block devices
   (hard and removable drives), <phrase condition="kvm4x86">USB devices,
   </phrase>character devices (serial and parallel
   ports)<phrase condition="kvm4x86">, or multimedia devices (graphic and sound
   cards)</phrase>. This section introduces options to configure various types
   of supported devices.
  </para>

  <tip>
   <para>
    If your device, such as <literal>-drive</literal>, needs a special driver
    and driver properties to be set, specify them with the
    <literal>-device</literal> option, and identify with
    <literal>drive=</literal> suboption. For example:
   </para>
<screen>&prompt.user;sudo qemu-system-x86_64 [...] -drive if=none,id=drive0,format=raw \
-device virtio-blk-pci,drive=drive0,scsi=off ...</screen>
   <para>
    To get help on available drivers and their properties, use <option>-device
    ?</option> and <option>-device
    <replaceable>DRIVER</replaceable>,?</option>.
   </para>
  </tip>

  <sect2 xml:id="cha.qemu.running.devices.block">
   <title>Block Devices</title>
   <para>
    Block devices are vital for virtual machines. In general, these are fixed
    or removable storage media usually called <emphasis>drives</emphasis>. One
    of the connected hard disks typically holds the guest operating system to
    be virtualized.
   </para>
   <para>
    <xref linkend="gloss.vt.vm"/> drives are defined with
    <literal>-drive</literal>. This option has many sub-options, some of which
    are described in this section. For the complete list, see the manual page
    (<command>man 1 qemu</command>).
   </para>
   <variablelist>
    <title>Sub-options for the <literal>-drive</literal> Option</title>
    <varlistentry>
     <term><literal>file=image_fname</literal>
     </term>
     <listitem>
      <para>
       Specifies the path to the disk image that will be used with this drive.
       If not specified, an empty (removable) drive is assumed.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>if=drive_interface</literal>
     </term>
     <listitem>
      <para>
       Specifies the type of interface to which the drive is connected.
       Currently only <literal>floppy</literal>, <literal>scsi</literal>,
       <literal>ide</literal>, or <literal>virtio</literal> are supported by
       &suse;. <literal>virtio</literal> defines a paravirtualized disk driver.
       Default is <literal>ide</literal>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>index=index_of_connector</literal>
     </term>
     <listitem>
      <para>
       Specifies the index number of a connector on the disk interface (see the
       <literal>if</literal> option) where the drive is connected. If not
       specified, the index is automatically incremented.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>media=type</literal>
     </term>
     <listitem>
      <para>
       Specifies the type of media. Can be <literal>disk</literal> for hard
       disks, or <literal>cdrom</literal> for removable CD-ROM drives.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>format=img_fmt</literal>
     </term>
     <listitem>
      <para>
       Specifies the format of the connected disk image. If not specified, the
       format is autodetected. Currently, &suse; supports
       <literal>qcow2</literal>, <literal>qed</literal> and
       <literal>raw</literal> formats.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>cache=method</literal>
     </term>
     <listitem>
      <para>
       Specifies the caching method for the drive. Possible values are
       <literal>unsafe</literal>, <literal>writethrough</literal>,
       <literal>writeback</literal>, <literal>directsync</literal>, or
       <literal>none</literal>. To improve performance when using the
       <literal>qcow2</literal> image format, select
       <literal>writeback</literal>.
       <literal>none</literal> disables the host page cache and, therefore, is
       the safest option. Default for image files is
       <literal>writeback</literal>. For more information, see
       <xref linkend="cha.cachemodes"/>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <tip>
    <para>
     To simplify defining block devices, &qemu; understands several shortcuts
     which you may find handy when entering the
     <literal>qemu-system-ARCH</literal> command line.
    </para>
    <para>
     You can use
    </para>
<screen>&prompt.user;sudo qemu-system-x86_64 -cdrom /images/cdrom.iso</screen>
    <para>
     instead of
    </para>
<screen>&prompt.user;sudo qemu-system-x86_64 -drive file=/images/cdrom.iso,index=2,media=cdrom</screen>
    <para>
     and
    </para>
<screen>&prompt.user;sudo qemu-system-x86_64 -hda /images/imagei1.raw -hdb /images/image2.raw -hdc \
/images/image3.raw -hdd /images/image4.raw</screen>
    <para>
     instead of
    </para>
<screen>&prompt.user;sudo qemu-system-x86_64 -drive file=/images/image1.raw,index=0,media=disk \
-drive file=/images/image2.raw,index=1,media=disk \
-drive file=/images/image3.raw,index=2,media=disk \
-drive file=/images/image4.raw,index=3,media=disk</screen>
   </tip>
   <tip>
    <title>Using Host Drives Instead of Images</title>
    <para>
     As an alternative to using disk images (see
     <xref linkend="cha.qemu.guest_inst.qemu-img"/>) you can also use existing
     &vmhost; disks, connect them as drives, and access them from &vmguest;.
     Use the host disk device directly instead of disk image file names.
    </para>
    <para>
     To access the host CD-ROM drive, use
    </para>
<screen>&prompt.user;sudo qemu-system-x86_64 [...] -drive file=/dev/cdrom,media=cdrom</screen>
    <para>
     To access the host hard disk, use
    </para>
<screen>&prompt.user;sudo qemu-system-x86_64 [...] -drive file=/dev/hdb,media=disk</screen>
    <para>
     A host drive used by a &vmguest; must not be accessed concurrently by the
     &vmhost; or another &vmguest;.
    </para>
   </tip>
   <sect3 xml:id="kvm.freedisk">
    <title>Freeing Unused Guest Disk Space</title>
    <para>
     A <xref linkend="gloss.vt.storage.sparse"/> is a type of disk image file
     that grows in size as the user adds data to it, taking up only as much
     disk space as is stored in it. For example, if you copy 1 GB of data
     inside the sparse disk image, its size grows by 1 GB. If you then delete
     for example 500 MB of the data, the image size does not by default
     decrease as expected.
    </para>
    <para>
     That is why the <option>discard=on</option> option is introduced on the
     &kvm; command line. It tells the hypervisor to automatically free the
     <quote>holes</quote> after deleting data from the sparse guest image. Note
     that this option is valid only for the <literal>if=scsi</literal> drive
     interface:
    </para>
<screen>&prompt.user;sudo qemu-system-x86_64 [...] -drive file=/path/to/file.img,if=scsi,discard=on</screen>
    <important>
     <title>Support Status</title>
     <para>
      <option>if=scsi</option> is not supported. This interface does not map to
      <emphasis>virtio-scsi</emphasis>, but rather to the <emphasis>lsi SCSI
      adapter</emphasis>.
     </para>
    </important>
   </sect3>
   <sect3 xml:id="kvm.iothreads">
    <title>IOThreads</title>
    <para>
     IOThreads are dedicated event loop threads for virtio devices to perform
     I/O requests in order to improve scalability, especially on an SMP
     &vmhost; with SMP &vmguest;s using many disk devices. Instead of using
     &qemu;'s main event loop for I/O processing, IOThreads allow spreading
     I/O work across multiple CPUs and can improve latency when properly
     configured.
    </para>
    <para>
     IOThreads are enabled by defining IOThread objects. virtio devices can
     then use the objects for their I/0 event loops. Many virtio devices can
     use a single IOThread object, or virtio devices and IOThread objects
     can be configured in a 1:1 mapping. The following example creates a
     single IOThread with ID <literal>iothread0</literal> which is then used
     as the event loop for two virtio-blk devices.
    </para>
<screen>&prompt.user;qemu-system-x86_64 [...] -object iothread,id=iothread0\
-drive if=none,id=drive0,cache=none,aio=native,\
format=raw,file=filename -device virtio-blk-pci,drive=drive0,scsi=off,\
iothread=iothread0 -drive if=none,id=drive1,cache=none,aio=native,\
format=raw,file=filename -device virtio-blk-pci,drive=drive1,scsi=off,\
iothread=iothread0 [...]</screen>
    <para>
      The following qemu command line example illustrates a 1:1 virtio device
      to IOThread mapping:
    </para>
<screen>&prompt.user;qemu-system-x86_64 [...] -object iothread,id=iothread0\
-object iothread,id=iothread1 -drive if=none,id=drive0,cache=none,aio=native,\
format=raw,file=filename -device virtio-blk-pci,drive=drive0,scsi=off,\
iothread=iothread0 -drive if=none,id=drive1,cache=none,aio=native,\
format=raw,file=filename -device virtio-blk-pci,drive=drive1,scsi=off,\
    iothread=iothread1 [...]</screen>
   </sect3>
   <sect3 xml:id="kvm.virtio_blk.use_bio">
    <title>Bio-Based I/O Path for virtio-blk</title>
    <para>
     For better performance of I/O-intensive applications, a new I/O path was
     introduced for the virtio-blk interface in kernel version 3.7. This
     bio-based block device driver skips the I/O scheduler, and thus shortens
     the I/O path in guest and has lower latency. It is especially useful for
     high-speed storage devices, such as SSD disks.
    </para>
    <para>
     The driver is disabled by default. To use it, do the following:
    </para>
    <procedure>
     <step>
      <para>
       Append <option>virtio_blk.use_bio=1</option> to the kernel command
       line on the guest. You can do so via
       <menuchoice><guimenu>&yast;</guimenu><guimenu>System</guimenu><guimenu>Boot
       Loader</guimenu></menuchoice>.
      </para>
      <para>
       You can do it also by editing <filename>/etc/default/grub</filename>,
       searching for the line that contains
       <option>GRUB_CMDLINE_LINUX_DEFAULT=</option>, and adding the kernel
       parameter at the end. Then run <command>grub2-mkconfig
       &gt;/boot/grub2/grub.cfg</command> to update the grub2 boot menu.
      </para>
     </step>
     <step>
      <para>
       Reboot the guest with the new kernel command line active.
      </para>
     </step>
    </procedure>
    <tip>
     <title>Bio-Based Driver on Slow Devices</title>
     <para>
      The bio-based virtio-blk driver does not help on slow devices such as
      spin hard disks. The reason is that the benefit of scheduling is larger
      than what the shortened bio path offers. Do not use the bio-based driver
      on slow devices.
     </para>
    </tip>
   </sect3>
   <sect3 xml:id="sec.qemu.running.devices.block.iscsi">
    <title>Accessing iSCSI Resources Directly</title>
    <!-- fate#320080 -->
    <para>
     QEMU now integrates with <literal>libiscsi</literal>. This allows
     QEMU to access iSCSI resources directly and use them as virtual
     machine block devices.

     This feature does not require any host iSCSI initiator
     configuration, as is needed for a libvirt iSCSI target based storage
     pool setup. Instead it directly connects guest storage interfaces
     to an iSCSI target LUN by means of the user space library libiscsi.

     iSCSI-based disk devices can also be
     specified in the libvirt XML configuration.
    </para>
    <note>
     <title>RAW Image Format</title>
     <para>
     This feature is only available using the RAW image format, as the
     iSCSI protocol has some technical limitations.
     </para>
    </note>

     <!--
       SLE12SP2 QEMU acquired a new way of accessing iscsi based
       storage.

       virt-manager does not provide a U/I to assist with this setup, so
       manual libvirt domain xml changes for a guest are required.

       Initiator names are pre-defined, based on vm uuid or name.
     -->
    <para>
     The following is the QEMU command line interface for iSCSI connectivity.
    </para>

    <note>
     <title>virt-manager Limitation</title>
     <para>
      The use of libiscsi based storage provisioning is not yet exposed by
      the virt-manager interface, but instead it would be configured by
      directly editing the guest xml. This new way of accessing iSCSI
      based storage is to be done at the command line.
     </para>
    </note>

    <screen>&prompt.user;sudo qemu-system-x86_64 -machine accel=kvm \
  -drive file=iscsi://192.168.100.1:3260/iqn.2016-08.com.example:314605ab-a88e-49af-b4eb-664808a3443b/0,\
  format=raw,if=none,id=mydrive,cache=none \
  -device ide-hd,bus=ide.0,unit=0,drive=mydrive ...</screen>
<para>
Here is an example snippet of guest domain xml which uses the protocol
based iSCSI:
</para>

  <screen><![CDATA[<devices>
...
  <disk type='network' device='disk'>
    <driver name='qemu' type='raw'/>
    <source protocol='iscsi' name='iqn.2013-07.com.example:iscsi-nopool/2'>
      <host name='example.com' port='3260'/>
    </source>
    <auth username='myuser'>
      <secret type='iscsi' usage='libvirtiscsi'/>
    </auth>
    <target dev='vda' bus='virtio'/>
  </disk>
</devices>]]></screen>

  <para>
   Contrast that with an example which uses the host based iSCSI
   initiator which virt-manager sets up:
  </para>
  <screen><![CDATA[<devices>
...
  <disk type='block' device='disk'>
    <driver name='qemu' type='raw' cache='none' io='native'/>
    <source dev='/dev/disk/by-path/scsi-0:0:0:0'/>
    <target dev='hda' bus='ide'/>
    <address type='drive' controller='0' bus='0' target='0' unit='0'/>
  </disk>
  <controller type='ide' index='0'>
    <address type='pci' domain='0x0000' bus='0x00' slot='0x01'
             function='0x1'/>
  </controller>
</devices>]]></screen>
   </sect3>
   <sect3 xml:id="qemu.devices.block.rbd">
    <title>Using RADOS Block Devices with &qemu;</title>
     <para>
      RADOS Block Devices (RBD) store data in a Ceph cluster. They allow snapshotting,
      replication, and data consistency. You can use an RBD from your
      &kvm;-managed &vmguest;s similarly you use other block devices.
     </para>
     <para>
      Refer to <link
       xlink:href="https://www.suse.com/documentation/ses-4/book_storage_admin/data/cha_ceph_kvm.html">SUSE
       Enterprise Storage documentation</link> for more details.
     </para>
   </sect3>

  </sect2>

  <sect2 xml:id="cha.qemu.running.devices.graphic">
   <title>Graphic Devices and Display Options</title>
   <para>
    This section describes &qemu; options affecting the type of the emulated
    video card and the way &vmguest; graphical output is displayed.
   </para>
   <sect3 xml:id="cha.qemu.running.devices.graphic.vga">
    <title>Defining Video Cards</title>
    <para>
     &qemu; uses <literal>-vga</literal> to define a video card used to display
     &vmguest; graphical output. The <literal>-vga</literal> option understands
     the following values:
    </para>
    <variablelist>
     <varlistentry>
      <term><literal>none</literal>
      </term>
      <listitem>
       <para>
        Disables video cards on &vmguest; (no video card is emulated). You can
        still access the running &vmguest; via the serial console.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>std</literal>
      </term>
      <listitem>
       <para>
        Emulates a standard VESA 2.0 VBE video card. Use it if you intend to
        use high display resolution on &vmguest;.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>cirrus</literal>
      </term>
      <listitem>
       <para>
        Emulates Cirrus Logic GD5446 video card. Good choice if you insist on
        high compatibility of the emulated video hardware. Most operating
        systems (even Windows 95) recognize this type of card.
       </para>
       <tip>
        <para>
         For best video performance with the <literal>cirrus</literal> type,
         use 16-bit color depth both on &vmguest; and &vmhost;.
        </para>
       </tip>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3 xml:id="cha.qemu.running.devices.graphic.display">
    <title>Display Options</title>
    <para>
     The following options affect the way &vmguest; graphical output is
     displayed.
    </para>
    <variablelist>
     <varlistentry>
      <term><literal>-display gtk</literal>
      </term>
      <listitem>
       <para>
        Display video output in a GTK window. This interface provides UI
        elements to configure and control the VM during runtime.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-display sdl</literal>
      </term>
      <listitem>
       <para>
        Display video output via SDL, usually in a separate graphics window.
        For more information, see the SDL documentation.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-spice option[,option[,...]]</literal>
      </term>
      <listitem>
       <para>
        Enables the spice remote desktop protocol.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-display vnc</literal>
      </term>
      <listitem>
       <para>
        Refer to <xref linkend="cha.qemu.running.vnc"/> for more information.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-nographic</literal>
      </term>
      <listitem>
       <para>
        Disables &qemu;'s graphical output. The emulated serial port is
        redirected to the console.
       </para>
       <para>
        After starting the virtual machine with <literal>-nographic</literal>,
        press
        <keycombo><keycap function="control"/><keycap>A</keycap></keycombo>
        <keycap>H</keycap> in the virtual console to view the list of other
        useful shortcuts, for example, to toggle between the console and the
        &qemu; monitor.
       </para>
<screen>&prompt.user;qemu-system-x86_64 -hda /images/sles_base.raw -nographic

C-a h    print this help
C-a x    exit emulator
C-a s    save disk data back to file (if -snapshot)
C-a t    toggle console timestamps
C-a b    send break (magic sysrq)
C-a c    switch between console and monitor
C-a C-a  sends C-a
(pressed C-a c)

QEMU 2.3.1 monitor - type 'help' for more information
(qemu)</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-no-frame</literal>
      </term>
      <listitem>
       <para>
        Disables decorations for the &qemu; window. Convenient for dedicated
        desktop work space.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-full-screen</literal>
      </term>
      <listitem>
       <para>
        Starts &qemu; graphical output in full screen mode.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-no-quit</literal>
      </term>
      <listitem>
       <para>
        Disables the close button of the &qemu; window and prevents it from
        being closed by force.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-alt-grab</literal>, <literal>-ctrl-grab</literal>
      </term>
      <listitem>
       <para>
        By default, the &qemu; window releases the <quote>captured</quote> mouse
        after pressing
        <keycombo><keycap function="control"/><keycap
        function="alt"/></keycombo>. You can change the key combination to either
        <keycombo><keycap function="control"/><keycap
        function="alt"/><keycap function="shift"/></keycombo>
        (<literal>-alt-grab</literal>), or the right
        <keycap function="control"/> key (<literal>-ctrl-grab</literal>).
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
  </sect2>

  <sect2 xml:id="cha.qemu.running.devices.usb" condition="kvm4x86">
   <title>USB Devices</title>
   <para>
    There are two ways to create USB devices usable by the &vmguest; in &kvm;:
    you can either emulate new USB devices inside a &vmguest;, or assign an
    existing host USB device to a &vmguest;. To use USB devices in &qemu; you
    first need to enable the generic USB driver with the <option>-usb</option>
    option. Then you can specify individual devices with the
    <option>-usbdevice</option> option.
   </para>
   <sect3 xml:id="kvm.usb.emulate">
    <title>Emulating USB Devices in &vmguest;</title>
    <para>
     &suse; currently supports the following types of USB devices:
     <literal>disk</literal>, <literal>host</literal>,
     <literal>serial</literal>, <literal>braille</literal>,
     <literal>net</literal>, <literal>mouse</literal>, and
     <literal>tablet</literal>.
    </para>
    <variablelist>
     <title>Types of USB devices for the <literal>-usbdevice</literal> option</title>
     <varlistentry>
      <term><literal>disk</literal>
      </term>
      <listitem>
       <para>
        Emulates a mass storage device based on file. The optional
        <literal>format</literal> option is used rather than detecting the
        format.
       </para>
<screen>&prompt.user;qemu-system-x86_64 [...] -usbdevice
        disk:format=raw:/virt/usb_disk.raw</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>host</literal>
      </term>
      <listitem>
       <para>
        Pass through the host device (identified by bus.addr).
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>serial</literal>
      </term>
      <listitem>
       <para>
        Serial converter to a host character device.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>braille</literal>
      </term>
      <listitem>
       <para>
        Emulates a braille device using BrlAPI to display the braille output.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>net</literal>
      </term>
      <listitem>
       <para>
        Emulates a network adapter that supports CDC Ethernet and RNDIS
        protocols.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>mouse</literal>
      </term>
      <listitem>
       <para>
        Emulates a virtual USB mouse. This option overrides the default PS/2
        mouse emulation. The following example shows the hardware status of a
        mouse on &vmguest; started with <literal>qemu-system-ARCH [...]
        -usbdevice mouse</literal>:
       </para>
<screen>&prompt.user;sudo hwinfo --mouse
20: USB 00.0: 10503 USB Mouse
[Created at usb.122]
UDI: /org/freedesktop/Hal/devices/usb_device_627_1_1_if0
[...]
Hardware Class: mouse
Model: "Adomax QEMU USB Mouse"
Hotplug: USB
Vendor: usb 0x0627 "Adomax Technology Co., Ltd"
Device: usb 0x0001 "QEMU USB Mouse"
[...]</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>tablet</literal>
      </term>
      <listitem>
       <para>
        Emulates a pointer device that uses absolute coordinates (such as
        touchscreen). This option overrides the default PS/2 mouse emulation.
        The tablet device is useful if you are viewing &vmguest; via the VNC
        protocol. See <xref linkend="cha.qemu.running.vnc"/> for more
        information.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
  </sect2>

  <sect2 xml:id="cha.qemu.running.devices.char">
   <title>Character Devices</title>
   <para>
    Use <literal>-chardev</literal> to create a new character device. The
    option uses the following general syntax:
   </para>
<screen>qemu-system-x86_64 [...] -chardev <replaceable>BACKEND_TYPE</replaceable>,id=<replaceable>ID_STRING</replaceable></screen>
   <para>
    where <replaceable>BACKEND_TYPE</replaceable> can be one of
    <literal>null</literal>, <literal>socket</literal>, <literal>udp</literal>,
    <literal>msmouse</literal>, <literal>vc</literal>, <literal>file</literal>,
    <literal>pipe</literal>, <literal>console</literal>,
    <literal>serial</literal>, <literal>pty</literal>,
    <literal>stdio</literal>, <literal>braille</literal>,
    <literal>tty</literal>, or <literal>parport</literal>. All character
    devices must have a unique identification string up to 127 characters long.
    It is used to identify the device in other related directives. For the
    complete description of all back-end's sub-options, see the manual page
    (<command>man 1 qemu</command>). A brief description of the available
    <literal>back-ends</literal> follows:
   </para>
   <variablelist>
    <varlistentry>
     <term><literal>null</literal>
     </term>
     <listitem>
      <para>
       Creates an empty device that outputs no data and drops any data it
       receives.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>stdio</literal>
     </term>
     <listitem>
      <para>
       Connects to &qemu;'s process standard input and standard output.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>socket</literal>
     </term>
     <listitem>
      <para>
       Creates a two-way stream socket. If <replaceable>PATH</replaceable> is
       specified, a Unix socket is created:
      </para>
<screen>&prompt.user;sudo qemu-system-x86_64 [...] -chardev \
socket,id=unix_socket1,path=/tmp/unix_socket1,server</screen>
      <para>
       The <replaceable>SERVER</replaceable> suboption specifies that the
       socket is a listening socket.
      </para>
      <para>
       If <replaceable>PORT</replaceable> is specified, a TCP socket is
       created:
      </para>
<screen>&prompt.user;sudo qemu-system-x86_64 [...] -chardev \
socket,id=tcp_socket1,host=localhost,port=7777,server,nowait</screen>
      <para>
       The command creates a local listening (<literal>server</literal>) TCP
       socket on port 7777. &qemu; will not block waiting for a client to
       connect to the listening port (<literal>nowait</literal>).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>udp</literal>
     </term>
     <listitem>
      <para>
       Sends all network traffic from &vmguest; to a remote host over the UDP
       protocol.
      </para>
<screen>&prompt.user;sudo qemu-system-x86_64 [...] \
-chardev udp,id=udp_fwd,host=&wsIVname;,port=7777</screen>
      <para>
       The command binds port 7777 on the remote host &wsIVname; and sends
       &vmguest; network traffic there.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>vc</literal>
     </term>
     <listitem>
      <para>
       Creates a new &qemu; text console. You can optionally specify the
       dimensions of the virtual console:
      </para>
<screen>&prompt.user;sudo qemu-system-x86_64 [...] -chardev vc,id=vc1,width=640,height=480 \
-mon chardev=vc1</screen>
      <para>
       The command creates a new virtual console called <literal>vc1</literal>
       of the specified size, and connects the &qemu; monitor to it.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>file</literal>
     </term>
     <listitem>
      <para>
       Logs all traffic from &vmguest; to a file on &vmhost;. The
       <literal>path</literal> is required and will be created if it does not
       exist.
      </para>
<screen>&prompt.user;sudo qemu-system-x86_64 [...] \
-chardev file,id=qemu_log1,path=/var/log/qemu/guest1.log</screen>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    By default &qemu; creates a set of character devices for serial and
    parallel ports, and a special console for &qemu; monitor. However, you can
    create your own character devices and use them for the mentioned
    purposes. The following options will help you:
   </para>
   <variablelist>
    <varlistentry>
     <term><literal>-serial <replaceable>CHAR_DEV</replaceable></literal>
     </term>
     <listitem>
      <para>
       Redirects the &vmguest;'s virtual serial port to a character device
       <replaceable>CHAR_DEV</replaceable> on &vmhost;. By default, it is a
       virtual console (<literal>vc</literal>) in graphical mode, and
       <literal>stdio</literal> in non-graphical mode. The
       <literal>-serial</literal> understands many sub-options. See the manual
       page <command>man 1 qemu</command> for a complete list of them.
      </para>
      <para>
       You can emulate up to 4 serial ports. Use <literal>-serial
       none</literal> to disable all serial ports.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>-parallel <replaceable>DEVICE</replaceable></literal>
     </term>
     <listitem>
      <para>
       Redirects the &vmguest;'s parallel port to a
       <replaceable>DEVICE</replaceable>. This option supports the same devices
       as <literal>-serial</literal>.
      </para>
      <tip>
       <para>
        With <phrase os="sles;sled">&sls;</phrase><phrase os="osuse">&opensuse;
        Leap</phrase> as a &vmhost;, you can directly use the hardware parallel
        port devices <filename>/dev/parportN</filename> where
        <literal>N</literal> is the number of the port.
       </para>
      </tip>
      <para>
       You can emulate up to 3 parallel ports. Use <literal>-parallel
       none</literal> to disable all parallel ports.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>-monitor <replaceable>CHAR_DEV</replaceable></literal>
     </term>
     <listitem>
      <para>
       Redirects the &qemu; monitor to a character device
       <replaceable>CHAR_DEV</replaceable> on &vmhost;. This option supports
       the same devices as <literal>-serial</literal>. By default, it is a
       virtual console (<literal>vc</literal>) in a graphical mode, and
       <literal>stdio</literal> in non-graphical mode.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    For a complete list of available character devices back-ends, see the man
    page (<command>man 1 qemu</command>).
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="cha.qemu.running.networking">
  <title>Networking in &qemu;</title>

  <para>
   Use the <literal>-netdev</literal> option in combination with
   <option>-device</option> to define a specific type of networking and a
   network interface card for your &vmguest;. The syntax for the
   <option>-netdev</option> option is
  </para>

<screen>-netdev type[,prop[=value][,...]]</screen>

  <para>
   Currently, &suse; supports the following network types:
   <literal>user</literal>, <literal>bridge</literal>, and
   <literal>tap</literal>. For a complete list of <literal>-netdev</literal>
   sub-options, see the manual page (<command>man 1 qemu</command>).
  </para>

  <variablelist>
   <title>Supported <literal>-netdev</literal> Sub-options</title>
   <varlistentry>
    <term><literal>bridge</literal>
    </term>
    <listitem>
     <para>
      Uses a specified network helper to configure the TAP interface and attach
      it to a specified bridge. For more information, see
      <xref linkend="cha.qemu.running.networking.bridge"/>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>user</literal>
    </term>
    <listitem>
     <para>
      Specifies user-mode networking. For more information, see
      <xref linkend="cha.qemu.running.networking.usermode"/>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>tap</literal>
    </term>
    <listitem>
     <para>
      Specifies bridged or routed networking. For more information, see
      <xref linkend="cha.qemu.running.networking.bridge"/>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <sect2 xml:id="cha.qemu.running.networking.nic">
   <title>Defining a Network Interface Card</title>
   <para>
    Use <literal>-netdev</literal> together with the related
    <option>-device</option> option to add a new emulated network card:
   </para>
<screen>&prompt.user;sudo qemu-system-x86_64 [...] \
-netdev tap<co xml:id="co.qemu.running.networking.nic.tap"/>,id=hostnet0 \
-device virtio-net-pci<co xml:id="co.qemu.running.networking.nic.drv"/>,netdev=hostnet0,vlan=1<co xml:id="co.qemu.running.networking.nic.vlan"/>,\
macaddr=&wsIVmac;<co xml:id="co.qemu.running.networking.nic.mac"/>,name=ncard1</screen>
   <calloutlist>
    <callout arearefs="co.qemu.running.networking.nic.tap">
     <para>
      Specifies the network device type.
     </para>
    </callout>
    <callout arearefs="co.qemu.running.networking.nic.drv">
     <para>
      Specifies the model of the network card. Use
      <command>qemu-system-ARCH -device help</command> and search for the
      <literal>Network devices:</literal>section to get the list of all network
      card models supported by &qemu; on your platform.
     </para>
     <remark>cwickert 2017-09-01: still up to date?</remark>
     <para>
      Currently, &suse; supports the models <literal>rtl8139</literal>,
      <literal>e1000</literal> and its variants
      <literal>e1000-82540em</literal>, <literal>e1000-82544gc</literal> and
      <literal>e1000-82545em</literal>, and <literal>virtio-net-pci</literal>.
      To view a list of options for a specific driver, add
      <option>help</option> as a driver option:
     </para>
<screen>&prompt.user;sudo qemu-system-x86_64 -device e1000,help
e1000.mac=macaddr
e1000.vlan=vlan
e1000.netdev=netdev
e1000.bootindex=int32
e1000.autonegotiation=on/off
e1000.mitigation=on/off
e1000.addr=pci-devfn
e1000.romfile=str
e1000.rombar=uint32
e1000.multifunction=on/off
e1000.command_serr_enable=on/off</screen>
    </callout>
    <callout arearefs="co.qemu.running.networking.nic.vlan">
     <para>
      Connects the network interface to VLAN number 1. You can specify your own
      number&mdash;it is mainly useful for identification purpose. If you omit
      this suboption, &qemu; uses the default 0.
     </para>
    </callout>
    <callout arearefs="co.qemu.running.networking.nic.mac">
     <para>
      Specifies the Media Access Control (MAC) address for the network card. It
      is a unique identifier and you are advised to always specify it. If not,
      &qemu; supplies its own default MAC address and creates a possible MAC
      address conflict within the related VLAN.
     </para>
    </callout>
   </calloutlist>
  </sect2>

  <sect2 xml:id="cha.qemu.running.networking.usermode">
   <title>User-Mode Networking</title>
   <para>
    The <literal>-netdev user</literal> option instructs &qemu; to use
    user-mode networking. This is the default if no networking mode is
    selected. Therefore, these command lines are equivalent:
   </para>
<screen>&prompt.user;sudo qemu-system-x86_64 -hda /images/sles_base.raw</screen>
<screen>&prompt.user;sudo qemu-system-x86_64 -hda /images/sles_base.raw -netdev user,id=hostnet0</screen>
   <para>
    This mode is useful if you want to allow the &vmguest; to access the
    external network resources, such as the Internet. By default, no incoming
    traffic is permitted and therefore, the &vmguest; is not visible to other
    machines on the network. No administrator privileges are required in this
    networking mode. The user-mode is also useful for doing a network boot on
    your &vmguest; from a local directory on &vmhost;.
   </para>
   <para>
    The &vmguest; allocates an IP address from a virtual DHCP server. &vmhost;
    (the DHCP server) is reachable at 10.0.2.2, while the IP address range for
    allocation starts from 10.0.2.15. You can use <command>ssh</command> to
    connect to &vmhost; at 10.0.2.2, and <command>scp</command> to copy files
    back and forth.
   </para>
   <sect3 xml:id="cha.qemu.running.networking.usermode.examples">
    <title>Command Line Examples</title>
    <para>
     This section shows several examples on how to set up user-mode networking
     with &qemu;.
    </para>
    <example xml:id="ex.qemu.net.usermode.resctrict">
     <title>Restricted User-mode Networking</title>
<screen>&prompt.user;sudo qemu-system-x86_64 [...] \
-netdev user<co xml:id="co.usermode.user"/>,id=hostnet0 \
-device virtio-net-pci,netdev=hostnet0,vlan=1<co xml:id="co.usermode.vlan"/>,name=user_net1<co xml:id="co.usermode.name"/>,restrict=yes<co xml:id="co.usermode.restrict"/></screen>
     <calloutlist>
      <callout arearefs="co.usermode.user">
       <para>
        Specifies user-mode networking.
       </para>
      </callout>
      <callout arearefs="co.usermode.vlan">
       <para>
        Connects to VLAN number 1. If omitted, defaults to 0.
       </para>
      </callout>
      <callout arearefs="co.usermode.name">
       <para>
        Specifies a human-readable name of the network stack. Useful when
        identifying it in the &qemu; monitor.
       </para>
      </callout>
      <callout arearefs="co.usermode.restrict">
       <para>
        Isolates &vmguest;. It then cannot communicate with &vmhost;
        and no network packets will be routed to the external network.
       </para>
      </callout>
     </calloutlist>
    </example>
    <example xml:id="ex.qemu.net.usermode.iprange">
     <title>User-mode Networking with Custom IP Range</title>
<screen>&prompt.user;sudo qemu-system-x86_64 [...] \
-netdev user,id=hostnet0 \
-device virtio-net-pci,netdev=hostnet0,net=10.2.0.0/8<co xml:id="co.usermode.net"/>,host=10.2.0.6<co xml:id="co.usermode.host"/>,\
dhcpstart=10.2.0.20<co xml:id="co.usermode.dhcpstart"/>,hostname=tux_kvm_guest<co xml:id="co.usermode.hostname"/></screen>
     <calloutlist>
      <callout arearefs="co.usermode.net">
       <para>
        Specifies the IP address of the network that &vmguest; sees and
        optionally the netmask. Default is 10.0.2.0/8.
       </para>
      </callout>
      <callout arearefs="co.usermode.host">
       <para>
        Specifies the &vmhost; IP address that &vmguest; sees. Default is
        10.0.2.2.
       </para>
      </callout>
      <callout arearefs="co.usermode.dhcpstart">
       <para>
        Specifies the first of the 16 IP addresses that the built-in DHCP
        server can assign to &vmguest;. Default is 10.0.2.15.
       </para>
      </callout>
      <callout arearefs="co.usermode.hostname">
       <para>
        Specifies the host name that the built-in DHCP server will assign to
        &vmguest;.
       </para>
      </callout>
     </calloutlist>
    </example>
    <example xml:id="ex.qemu.net.usermode.netboot_tftp">
     <title>User-mode Networking with Network-boot and TFTP</title>
<screen>&prompt.user;sudo qemu-system-x86_64 [...] \
-netdev user,id=hostnet0 \
-device virtio-net-pci,netdev=hostnet0,tftp=/images/tftp_dir<co xml:id="co.usermode.tftp"/>,\
bootfile=/images/boot/pxelinux.0<co xml:id="co.usermode.bootfile"/></screen>
     <calloutlist>
      <callout arearefs="co.usermode.tftp">
       <para>
        Activates a built-in TFTP (a file transfer protocol with the
        functionality of a very basic FTP) server. The files in the specified
        directory will be visible to a &vmguest; as the root of a TFTP server.
       </para>
      </callout>
      <callout arearefs="co.usermode.bootfile">
       <para>
        Broadcasts the specified file as a BOOTP (a network protocol that
        offers an IP address and a network location of a boot image, often used
        in diskless workstations) file. When used together with
        <literal>tftp</literal>, the &vmguest; can boot from network from the
        local directory on the host.
       </para>
      </callout>
     </calloutlist>
    </example>
    <example xml:id="ex.qemu.net.usermode.hostfwd">
     <title>User-mode Networking with Host Port Forwarding</title>
<screen>&prompt.user;sudo qemu-system-x86_64 [...] \
-netdev user,id=hostnet0 \
-device virtio-net-pci,netdev=hostnet0,hostfwd=tcp::2222-:22</screen>
     <para>
      Forwards incoming TCP connections to the port 2222 on the host to the
      port 22 (<systemitem class="service">SSH</systemitem>) on &vmguest;. If
      <systemitem class="daemon">sshd</systemitem> is running on &vmguest;,
      enter
     </para>
<screen>&prompt.user;ssh qemu_host -p 2222</screen>
     <para>
      where <literal>qemu_host</literal> is the host name or IP address of the
      host system, to get a <systemitem class="daemon">SSH</systemitem> prompt
      from &vmguest;.
     </para>
    </example>
   </sect3>
  </sect2>

  <sect2 xml:id="cha.qemu.running.networking.bridge">
   <title>Bridged Networking</title>
   <para>
    With the <literal>-netdev tap</literal> option, &qemu; creates a network
    bridge by connecting the host TAP network device to a specified VLAN of
    &vmguest;. Its network interface is then visible to the rest of the
    network. This method does not work by default and needs to be explicitly
    specified.
   </para>
   <para>
    First, create a network bridge and add a &vmhost; physical network
    interface (usually <literal>eth0</literal>) to it:
   </para>
   <procedure>
    <step>
     <para>
      Start &yastcc; and select
      <menuchoice><guimenu>System</guimenu><guimenu>Network
      Settings</guimenu></menuchoice>.
     </para>
    </step>
    <step>
     <para>
      Click <guimenu>Add</guimenu> and select <guimenu>Bridge</guimenu> from
      the <guimenu>Device Type</guimenu> drop-down box in the
      <guimenu>Hardware Dialog</guimenu> window. Click <guimenu>Next</guimenu>.
     </para>
    </step>
    <step>
     <para>
      Choose whether you need a dynamically or statically assigned IP address,
      and fill the related network settings if applicable.
     </para>
    </step>
    <step>
     <para>
      In the <guimenu>Bridged Devices</guimenu> pane, select the Ethernet
      device to add to the bridge.
     </para>
     <figure>
      <title>Configuring Network Bridge with &yast;</title>
      <mediaobject>
       <imageobject role="fo">
        <imagedata fileref="qemu_yast_bridge_eth0.png" width="70%" format="PNG"/>
       </imageobject>
       <imageobject role="html">
        <imagedata fileref="qemu_yast_bridge_eth0.png" width="70%" format="PNG"/>
       </imageobject>
      </mediaobject>
     </figure>
     <para>
      Click <guimenu>Next</guimenu>. When asked about adapting an already
      configured device, click <guimenu>Continue</guimenu>.
     </para>
    </step>
    <step>
     <para>
      Click <guimenu>OK</guimenu> to apply the changes. Check if the bridge is
      created:
     </para>
<screen>&prompt.user;brctl show
bridge name bridge id          STP enabled  interfaces
br0         8000.001676d670e4  no           eth0</screen>
    </step>
   </procedure>
   <sect3 xml:id="cha.qemu.running.networking.bridge.manually">
    <title>Connecting to a Bridge Manually</title>
    <para>
     Use the following example script to connect &vmguest; to the newly created
     bridge interface <literal>br0</literal>. Several commands in the script
     are run via the <command>sudo</command> mechanism because they require
     &rootuser; privileges.
    </para>
    <note>
     <title>Required Packages</title>
     <para>
      Make sure the <systemitem>tunctl</systemitem> and
      <systemitem>bridge-utils</systemitem> packages are installed on the
      &vmhost;. If not, install them with <command>zypper in tunctl
      bridge-utils</command>.
     </para>
    </note>
<screen>
#!/bin/bash
bridge=br0<co xml:id="co.qemu.net.bridge.br"/>
tap=$(sudo tunctl -u $(whoami) -b)<co xml:id="co.qemu.net.bridge.tap"/>
sudo ip link set $tap up<co xml:id="co.qemu.net.bridge.up"/>
sleep 1s<co xml:id="co.qemu.net.bridge.sleep"/>
sudo brctl addif $bridge $tap<co xml:id="co.qemu.net.bridge.br3"/>
qemu-system-x86_64 -machine accel=kvm -m 512 -hda /images/sles_base.raw \
-netdev tap,id=hostnet0 \
-device virtio-net-pci,netdev=hostnet0,vlan=0,macaddr=&wsIVmac;,\
ifname=$tap<co xml:id="co.qemu.net.bridge.ifname"/>,script=no<co xml:id="co.qemu.net.bridge.script"/>,downscript=no
sudo brctl delif $bridge $tap<co xml:id="co.qemu.net.bridge.delif"/>
sudo ip link set $tap down<co xml:id="co.qemu.net.bridge.linkdown"/>
sudo tunctl -d $tap<co xml:id="co.qemu.net.bridge.deltap"/></screen>
    <calloutlist>
     <callout arearefs="co.qemu.net.bridge.br">
      <para>
       Name of the bridge device.
      </para>
     </callout>
     <callout arearefs="co.qemu.net.bridge.tap">
      <para>
       Prepare a new TAP device and assign it to the user who runs the script.
       TAP devices are virtual network devices often used for virtualization
       and emulation setups.
      </para>
     </callout>
     <callout arearefs="co.qemu.net.bridge.up">
      <para>
       Bring up the newly created TAP network interface.
      </para>
     </callout>
     <callout arearefs="co.qemu.net.bridge.sleep">
      <para>
       Make a 1-second pause to make sure the new TAP network interface is
       really up.
      </para>
     </callout>
     <callout arearefs="co.qemu.net.bridge.br3">
      <para>
       Add the new <literal>TAP</literal> device to the network bridge
       <literal>br0</literal>.
      </para>
     </callout>
     <callout arearefs="co.qemu.net.bridge.ifname">
      <para>
       The <literal>ifname=</literal> suboption specifies the name of the TAP
       network interface used for bridging.
      </para>
     </callout>
     <callout arearefs="co.qemu.net.bridge.script">
      <para>
       Before <command>qemu-system-ARCH</command> connects to a network bridge,
       it checks the <literal>script</literal> and
       <literal>downscript</literal> values. If it finds the specified scripts
       on the &vmhost; file system, it runs the <literal>script</literal>
       before it connects to the network bridge and
       <literal>downscript</literal> after it exits the network environment.
       You can use these scripts to first set up and bring up the bridged
       network devices, and then to deconfigure them.
       <!-- FIXME: "deconfigure" is not a word. Also, what does "them" refer
       to? the bridged devices or the scripts? - sknorr, 2016-08-24 -->
       By default,
       <filename>/etc/qemu-ifup</filename> and
       <filename>/etc/qemu-ifdown</filename> are examined. If
       <literal>script=no</literal> and <literal>downscript=no</literal> are
       specified, the script execution is disabled and you need to take care of
       it manually.
      </para>
     </callout>
     <callout arearefs="co.qemu.net.bridge.delif">
      <para>
       Deletes the TAP interface from a network bridge <literal>br0</literal>.
      </para>
     </callout>
     <callout arearefs="co.qemu.net.bridge.linkdown">
      <para>
       Sets the state of the TAP device to <literal>down</literal>.
      </para>
     </callout>
     <callout arearefs="co.qemu.net.bridge.deltap">
      <para>
       Deconfigures the TAP device.
       <!-- FIXME: "deconfigure" is not a word. - sknorr, 2016-08-24 -->
      </para>
     </callout>
    </calloutlist>
   </sect3>
   <sect3 xml:id="qemu.bridge.helper">
    <title>Connecting to a Bridge with qemu-bridge-helper</title>
    <para>
     Another way to connect &vmguest; to a network through a network bridge is
     by means of the <filename>qemu-bridge-helper</filename> helper program. It
     configures the TAP interface for you, and attaches it to the specified
     bridge. The default helper executable is
     <filename>/usr/lib/qemu-bridge-helper</filename>. The helper executable is
     setuid root, which is only executable by the members of the virtualization
     group (<literal>kvm</literal>). Therefore the
     <command>qemu-system-ARCH</command> command itself does not need to be run
     under &rootuser; privileges.
    </para>
    <para>
     The helper is automatically called when you specify a network bridge:
    </para>
<screen>qemu-system-x86_64 [...] \
 -netdev bridge,id=hostnet0,vlan=0,br=br0 \
 -device virtio-net-pci,netdev=hostnet0</screen>
    <para>
     You can specify your own custom helper script that will take care of the
     TAP device (de)configuration, with the
     <option>helper=/path/to/your/helper</option> option:
    </para>
<screen>qemu-system-x86_64 [...] \
 -netdev bridge,id=hostnet0,vlan=0,br=br0,helper=/path/to/bridge-helper \
 -device virtio-net-pci,netdev=hostnet0</screen>
    <tip>
     <para>
      To define access privileges to <literal>qemu-bridge-helper</literal>,
      inspect the <filename>/etc/qemu/bridge.conf</filename> file. For example
      the following directive
     </para>
<screen>allow br0</screen>
     <para>
      allows the <command>qemu-system-ARCH</command> command to connect its
      &vmguest; to the network bridge <literal>br0</literal>.
     </para>
    </tip>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="cha.qemu.running.vnc">
  <title>Viewing a &vmguest; with&nbsp;VNC</title>

  <para>
   By default &qemu; uses a GTK (a cross-platform toolkit library) window to
   display the graphical output of a &vmguest;.
   <remark condition="clarity">
    2014-08-06 - fs: feedback from brogers: We should explain the "display
    xxx" command line syntax to present the various display options before
    diving into the vnc details.
   </remark>
   With the <literal>-vnc</literal> option specified, you can make &qemu;
   listen on a specified VNC display and redirect its graphical output to the
   VNC session.
  </para>

  <tip>
   <para>
    When working with &qemu;'s virtual machine via VNC session, it is useful to
    work with the <literal>-usbdevice tablet</literal> option.
   </para>
   <para>
    Moreover, if you need to use another keyboard layout than the default
    <literal>en-us</literal>, specify it with the <literal>-k</literal> option.
   </para>
  </tip>

  <para>
   The first suboption of <literal>-vnc</literal> must be a
   <emphasis>display</emphasis> value. The <literal>-vnc</literal> option
   understands the following display specifications:
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>host:display</literal>
    </term>
    <listitem>
     <para>
      Only connections from <literal>host</literal> on the display number
      <literal>display</literal> will be accepted. The TCP port on which the
      VNC session is then running is normally a 5900 +
      <literal>display</literal> number. If you do not specify
      <literal>host</literal>, connections will be accepted from any host.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>unix:path</literal>
    </term>
    <listitem>
     <para>
      The VNC server listens for connections on Unix domain sockets. The
      <literal>path</literal> option specifies the location of the related Unix
      socket.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>none</literal>
    </term>
    <listitem>
     <para>
      The VNC server functionality is initialized, but the server itself is not
      started. You can start the VNC server later with the &qemu; monitor. For
      more information, see <xref linkend="cha.qemu.monitor"/>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Following the display value there may be one or more option flags separated
   by commas. Valid options are:
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>reverse</literal>
    </term>
    <listitem>
     <para>
      Connect to a listening VNC client via a <emphasis>reverse</emphasis>
      connection.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>websocket</literal>
    </term>
    <listitem>
     <para>
      Opens an additional TCP listening port dedicated to VNC Websocket
      connections. By definition the Websocket port is 5700+display.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>password</literal>
    </term>
    <listitem>
     <para>
      Require that password-based authentication is used for client
      connections.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>tls</literal>
    </term>
    <listitem>
     <para>
      Require that clients use TLS when communicating with the VNC server.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>x509=/path/to/certificate/dir</literal>
    </term>
    <listitem>
     <para>
      Valid if TLS is specified. Require that x509 credentials are used for
      negotiating the TLS session.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>x509verify=/path/to/certificate/dir</literal>
    </term>
    <listitem>
     <para>
      Valid if TLS is specified. Require that x509 credentials are used for
      negotiating the TLS session.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>sasl</literal>
    </term>
    <listitem>
     <para>
      Require that the client uses SASL to authenticate with the VNC server.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>acl</literal>
    </term>
    <listitem>
     <para>
      Turn on access control lists for checking of the x509 client certificate
      and SASL party.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>lossy</literal>
    </term>
    <listitem>
     <para>
      Enable lossy compression methods (gradient, JPEG, ...).
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>non-adaptive</literal>
    </term>
    <listitem>
     <para>
      Disable adaptive encodings. Adaptive encodings are enabled by default.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>share=[allow-exclusive|force-shared|ignore]</literal>
    </term>
    <listitem>
     <para>
      Set display sharing policy.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <note>
   <para>
    For more details about the display options, see the
    <emphasis>qemu-doc</emphasis> man page.
   </para>
  </note>

  <para>
   An example VNC usage:
  </para>

<screen>&prompt.user;qemu-system-x86_64 [...] -vnc :5
(on the client:)
&prompt.user2;:~&gt;vinagre &wsII;:5905 &amp;</screen>

  <figure>
   <title>&qemu; VNC Session</title>
   <mediaobject>
    <imageobject role="fo">
     <imagedata fileref="qemu_sles_vnc.png" width="70%" format="PNG"/>
    </imageobject>
    <imageobject role="html">
     <imagedata fileref="qemu_sles_vnc.png" width="70%" format="PNG"/>
    </imageobject>
   </mediaobject>
  </figure>

  <sect2 xml:id="cha.qemu.running.vnc.secure">
   <title>Secure VNC Connections</title>
   <para>
    The default VNC server setup does not use any form of authentication. In
    the previous example, any user can connect and view the &qemu; VNC session
    from any host on the network.
   </para>
   <para>
    There are several levels of security that you can apply to your VNC
    client/server connection. You can either protect your connection with a
    password, use x509 certificates, use SASL authentication, or even combine
    some authentication methods in one &qemu; command.
   </para>
   <para>
    See <xref linkend="app.kvm.certificates"/> for more information about the
    x509 certificates generation. For more information about configuring x509
    certificates on a &vmhost; and the client, see
    <xref linkend="sec.libvirt.connect.remote.tls"/> and
    <xref linkend="sec.libvirt.connect.remote.tls.client"/>.
   </para>
   <para>
    The Vinagre VNC viewer supports advanced authentication mechanisms.
    Therefore, it will be used to view the graphical output of &vmguest; in the
    following examples. For this example, let us assume that the server x509
    certificates <filename>ca-cert.pem</filename>,
    <filename>server-cert.pem</filename>, and
    <filename>server-key.pem</filename> are located in the
    <filename>/etc/pki/qemu</filename> directory on the host, while the
    client's certificates are distributed in the following locations on the
    client:
   </para>
   <simplelist>
    <member><filename>/etc/pki/CA/cacert.pem</filename>
    </member>
    <member><filename>/etc/pki/libvirt-vnc/clientcert.pem</filename>
    </member>
    <member><filename>/etc/pki/libvirt-vnc/private/clientkey.pem</filename>
    </member>
   </simplelist>
   <example xml:id="ex.running.vnc.secure.pwd">
    <title>Password Authentication</title>
<screen>qemu-system-x86_64 [...] -vnc :5,password -monitor stdio</screen>
    <para>
     Starts the &vmguest; graphical output on VNC display number 5 (usually
     port 5905). The <literal>password</literal> suboption initializes a simple
     password-based authentication method. There is no password set by default
     and you need to set one with the <command>change vnc password</command>
     command in &qemu; monitor:
    </para>
<screen>QEMU 2.3.1 monitor - type 'help' for more information
(qemu) change vnc password
Password: ****
</screen>
    <para>
     You need the <literal>-monitor stdio</literal> option here, because you
     would not be able to manage the &qemu; monitor without redirecting its
     input/output.
    </para>
   </example>
   <figure>
    <title>Authentication Dialog in Vinagre</title>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="qemu_vnc_pwd.png" width="70%" format="PNG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="qemu_vnc_pwd.png" width="70%" format="PNG"/>
     </imageobject>
    </mediaobject>
   </figure>
   <example xml:id="ex.running.vnc.secure.x509">
    <title>x509 Certificate Authentication</title>
    <para>
     The &qemu; VNC server can use TLS encryption for the session and x509
     certificates for authentication. The server asks the client for a
     certificate and validates it against the CA certificate. Use this
     authentication type if your company provides an internal certificate
     authority.
    </para>
<screen>qemu-system-x86_64 [...] -vnc :5,tls,x509verify=/etc/pki/qemu</screen>
   </example>
   <example xml:id="ex.running.vnc.secure.pwd_x509">
    <title>x509 Certificate and Password Authentication</title>
    <para>
     You can combine the password authentication with TLS encryption and x509
     certificate authentication to create a two-layer authentication model for
     clients. Remember to set the password in the &qemu; monitor after you run
     the following command:
    </para>
<screen>qemu-system-x86_64 [...] -vnc :5,password,tls,x509verify=/etc/pki/qemu \
-monitor stdio</screen>
   </example>
   <example xml:id="ex.running.vnc.secure.sasl">
    <title>SASL Authentication</title>
    <para>
     Simple Authentication and Security Layer (SASL) is a framework for
     authentication and data security in Internet protocols. It integrates
     several authentication mechanisms, like PAM, Kerberos, LDAP and more. SASL
     keeps its own user database, so the connecting user accounts do not need
     to exist on &vmhost;.
    </para>
    <para>
     For security reasons, you are advised to combine SASL authentication with
     TLS encryption and x509 certificates:
    </para>
<screen>qemu-system-x86_64 [...] -vnc :5,tls,x509,sasl -monitor stdio</screen>
   </example>
  </sect2>
 </sect1>
</chapter>
