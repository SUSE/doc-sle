<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
  [
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="cha-containers-basics">
  <title>Introduction to Linux Containers</title>
  <info>
    <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
      <dm:bugtracker/>
    </dm:docmanager>
  </info>
  <para>
    Linux containers offer a lightweight virtualization method to run multiple
    virtual environments (containers) simultaneously on a single host. Unlike
    technologies like &xen; or &kvm;, where the processor simulates a complete
    hardware environment and controls virtual machines, containers provide
    virtualization at the operating system level, where the kernel controls the
    isolated containers.
  </para>
  <itemizedlist mark="bullet" spacing="normal">
    <title>Advantages of Using Containers</title>
    <listitem>
      <para>
        Containers make it possible to solate applications through self-contained units.
      </para>
    </listitem>
    <listitem>
      <para>
        Containers provide nearly native performance, as containers manage
        allocation of resources in real time.
      </para>
    </listitem>
    <listitem>
      <para>
        It is possible to control network interfaces and apply resources inside
        containers through <xref linkend="gloss-vt-lxc-cgroups"/>.
      </para>
    </listitem>
  </itemizedlist>
  <itemizedlist mark="bullet" spacing="normal">
    <title>Limitations of Containers</title>
    <listitem>
      <para>
        Containers run inside the host system's kernel, and they cannot use
        different kernels or different kernel versions.
      </para>
    </listitem>
    <listitem>
      <para>
        Only Linux-based applications can be containerized.
      </para>
    </listitem>
    <listitem>
      <para>
        Containers are not secure, and the overall security depends on the host
        system. Containerized applications can be secured through &aa; or &selnx;
        profile.
      </para>
    </listitem>
  </itemizedlist>
  <sect1 xml:id="sec-concepts-workflow">
    <title>Key Concepts and Brief Introduction to &docker;</title>
    <para>
    &deng; is a well-established and mature container technology. While <xref
    linkend="cha-docker-overview" /> provides an in-depth information on &deng;,
    this chapter offers a quick introduction to key concepts and a basic
    procedure of creating a container image an using it to run a container.
    </para>
    <para>
      The basic &docker; workflow is as follows:
    </para>
    <para>
      Registry -> Base image -> Dockerfile -> Custom image -> Container
      <!--TODO replace with a figure-->
    </para>

    <para>
      Running a container on a local machine or cloud service, usually involves the following steps:
    </para>
    <orderedlist>
      <listitem>
        <para>
          Fetch a base image by pulling it from a registry to your local machine
        </para>
      </listitem>
      <listitem>
        <para>
          Create a Dockerfile and use it to build a custom image on top of the base image
        </para>
      </listitem>
      <listitem>
        <para>
          Use the created image to run one or multiple containers
        </para>
      </listitem>
    </orderedlist>
    <para>
      To run a container, you need an image. An image includes everything needed to run a container: the code or binaries, runtimes, dependencies, and any other required components. For example, the SLE base image contains a slimmed-down version of the SLE distribution.
    </para>
    <para>
      While it is possible to create an image from scratch, using an existing base image is more practical in most situations. Base image has no parent, meaning it is not based on another image.
    </para>
    <para>
      You can use a base image as it is for running containers, but the main purpose of base images is to serve as foundations for creating custom images that can run containers with specific applications, servers, services, and so on.
    </para>
    <para>
      Both base and custom images are usually available through a repository of images called registry. By default, when you fetch an image using the Docker client, you are actually pulling it from the Docker Hub registry.
    </para>
    <para>
      After you pull a base image, you can use it as a starting point for building a custom image. For example, you can use the SLE base image to generate an image that is configured to run a specific application. To build a custom image, you need to create a special file called Dockerfile, containing building instructions. For example, a Dockerfile can contain instructions to update the system software, install the desired application, open specific network ports, run commands, etc.
    </para>
    <para>
      Note that you can build images not only from base images, but also on top of custom images. So you can have an image consisting of multiple layers:
    </para>
    <para>
      Base image -> Custom image 1 -> Custom image 2 -> Custom image 3 (
      <!--TODO Replace with figure -->
    </para>
    <sect2 xml:id="sec-container-example">
      <title>Practical Example</title>
      <para>
        The following procedure shows how to build a custom &docker; image that
        can be used to run a container with a simple PHP application called
        <literal>example</literal>
        served using the built-in PHP development
        server.
      </para>
      <procedure>
        <title>Building an image and running container</title>
        <step>
          <para>
            Install Docker:
          </para>
<screen>sudo zypper in docker docker-compose</screen>
        </step>
        <step>
          <para>
            Enable or start Docker:
          </para>
<screen>sudo systemctl enable docker
sudo systemctl start docker</screen>
        </step>
        <step>
          <para>
            To run Docker as a regular user, add the user to the
            <literal>docker</literal>
            group:
          </para>
<screen>sudo usermod -G docker -a $USER</screen>
          <para>
            Log out, log in again.
          </para>
        </step>
        <step>
          <para>
            Switch to the PHP project's directory and create a file named
            <filename>Dockerfile</filename>
            :
          </para>
<screen>cd example
touch Dockerfile</screen>
        </step>
        <step>
          <para>
          </para>
        </step>
        <step>
          <para>
            Open the _Dockerfile_ file for editing, and add the following:
          </para>
<screen>
FROM php:7.4-cli
COPY . /usr/src/example
WORKDIR /usr/src/example
EXPOSE 8000
CMD [ "php", "-S", "0.0.0.0:8000" ]</screen>
        </step>
        <step>
          <para>
            Build a Docker image:
          </para>
<screen>docker build -t example .</screen>
        </step>
        <step>
          <para>
            Run a container:
          </para>
<screen>docker run -it -p8000:8000 --rm example</screen>
        </step>
        <step>
          <para>
            Point the browser to
            <literal>localhost:8000</literal>
            to access the application running in the container.
          </para>
        </step>
      </procedure>
    </sect2>
  </sect1>
</chapter>
