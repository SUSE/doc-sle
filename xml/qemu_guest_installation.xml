<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>

<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="cha.qemu.guest_inst">
 <title>Guest Installation</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker></dm:bugtracker>
  </dm:docmanager>
 </info>
 <para>
  The <systemitem class="library">libvirt</systemitem>-based tools such as
  <command>virt-manager</command> and <command>virt-install</command>
  offer convenient interfaces to set up and
  manage virtual machines. They act as a kind of wrapper for the
  <command>qemu-system-ARCH</command>command. However, it is also possible to
  use <command>qemu-system-ARCH</command> directly without using
  <systemitem class="library">libvirt</systemitem>-based tools.
 </para>
 <warning>
  <title><command>qemu-system-ARCH</command> and libvirt</title>
  <para>
   <xref linkend="gloss.vt.vm"/>s created with
   <command>qemu-system-ARCH</command> are not "visible" for the
   <systemitem class="library">libvirt</systemitem>-based tools.
  </para>
 </warning>
 <sect1 xml:id="cha.qemu.guest_inst.qemu-kvm">
  <title>Basic Installation with <command>qemu-system-ARCH</command></title>

  <para>
   In the following example, a virtual machine for a &sls; 11 installation is
   created. For detailed information on the commands, refer to the respective
   man pages.
  </para>

  <para>
   If you do not already have an image of a system that you want to run in a
   virtualized environment, you need to create one from the installation media.
   In such case, you need to prepare a hard disk image, and obtain an image of
   the installation media or the media itself.
  </para>

  <para>
   Create a hard disk with <command>qemu-img</command>.
  </para>

<screen>qemu-img create<co xml:id="co.qemu-img.create"/> -f raw<co xml:id="co.qemu-img.format"/> /images/sles/hda<co xml:id="co.qemu-img.path"/> 8G<co xml:id="co.qemu-img.size"/></screen>

  <calloutlist>
   <callout arearefs="co.qemu-img.create">
    <para>
     The subcommand <option>create</option> tells <command>qemu-img</command>
     to create a new image.
    </para>
   </callout>
   <callout arearefs="co.qemu-img.format">
    <para>
     Specify the disk's format with the <option>-f</option> parameter.
    </para>
   </callout>
   <callout arearefs="co.qemu-img.path">
    <para>
     The full path to the image file.
    </para>
   </callout>
   <callout arearefs="co.qemu-img.size">
    <para>
     The size of the image&mdash;8 GB in this case. The image is created as a
     <xref linkend="gloss.vt.storage.sparse"/> file that grows when the disk is
     filled with data. The specified size defines the maximum size to which the
     image file can grow.
    </para>
   </callout>
  </calloutlist>

  <para>
   After at least one hard disk image is created, you can set up a virtual
   machine with <command>qemu-system-ARCH</command> that will boot into the
   installation system:
  </para>

<screen>&prompt.root;qemu-system-x86_64 -name "sles"<co xml:id="co.qemu-kvn.name"/>-machine accel=kvm -M pc<co xml:id="co.qemu-kvm.type"/> -m 768<co xml:id="co.qemu-kvm.memory"/> \
-smp 2<co xml:id="co.qemu-kvm.cpu"/> -boot d<co xml:id="co.qemu-kvm.boot"/> \
-drive file=/images/sles/hda,if=virtio,index=0,media=disk,format=raw<co xml:id="co.qemu-kvm.hdd"/> \
-drive file=/isos/SLES-11-SP3-DVD-x86_64-GM-DVD1.iso,index=1,media=cdrom<co xml:id="co.qemu-kvm.cdrom"/> \
-net nic,model=virtio,macaddr=52:54:00:05:11:11<co xml:id="co.qemu-kvm.nic"/> -net user \
-vga cirrus<co xml:id="co.qemu-kvm.gfx"/> -balloon virtio<co xml:id="co.qemu-kvm.balloon"/></screen>

  <calloutlist>
   <callout arearefs="co.qemu-kvn.name">
    <para>
     Name of the virtual machine that will be displayed in the window caption
     and be used for the VNC server. This name must be unique.
    </para>
   </callout>
   <callout arearefs="co.qemu-kvm.type">
    <para>
     Specifies the machine type. Use <command>qemu-system-ARCH</command>
     <option>-M ?</option> to display a list of valid parameters.
     <literal>pc</literal> is the default <guimenu>Standard PC</guimenu>.
    </para>
   </callout>
   <callout arearefs="co.qemu-kvm.memory">
    <para>
     Maximum amount of memory for the virtual machine.
    </para>
   </callout>
   <callout arearefs="co.qemu-kvm.cpu">
    <para>
     Defines an SMP system with two processors.
    </para>
   </callout>
   <callout arearefs="co.qemu-kvm.boot">
    <para>
     Specifies the boot order. Valid values are <literal>a</literal>,
     <literal>b</literal> (floppy 1 and 2), <literal>c</literal> (first hard
     disk), d<literal/> (first CD-ROM), or <literal>n</literal> to
     <literal>p</literal> (Ether-boot from network adapter 1-3). Defaults to
     <literal>c</literal>.
    </para>
   </callout>
   <callout arearefs="co.qemu-kvm.hdd">
    <para>
     Defines the first (<literal>index=0</literal>) hard disk. It will be
     accessed as a paravirtualized (<literal>if=virtio</literal>) drive in
     <literal>raw</literal> format.
    </para>
   </callout>
   <callout arearefs="co.qemu-kvm.cdrom">
    <para>
     The second (<literal>index=1</literal>) image drive will act as a CD-ROM.
    </para>
   </callout>
   <callout arearefs="co.qemu-kvm.nic">
    <para>
     Defines a paravirtualized (<literal>model=virtio</literal>) network
     adapter with the MAC address <literal>52:54:00:05:11:11</literal>. Be sure
     to specify a unique MAC address, otherwise a network conflict may occur.
    </para>
   </callout>
   <callout arearefs="co.qemu-kvm.gfx">
    <para>
     Specifies the graphic card. If you specify
     <literal>none</literal>, the graphic card will be disabled.
    </para>
   </callout>
   <callout arearefs="co.qemu-kvm.balloon">
    <para>
     Defines the paravirtualized balloon device that allows to dynamically
     change the amount of memory (up to the maximum value specified with the
     parameter <option>-m</option>).
    </para>
   </callout>
  </calloutlist>

  <para>
   After the installation of the guest operating system finishes, you can
   start the related virtual machine without the need to specify the
   CD-ROM device:
  </para>

<screen>&prompt.root;qemu-system-x86_64 -name "sles" -machine type=pc,accel=kvm -m 768 \
-smp 2 -boot c \
-drive file=/images/sles/hda,if=virtio,index=0,media=disk,format=raw \
-net nic,model=virtio,macaddr=52:54:00:05:11:11 \
-vga cirrus -balloon virtio
</screen>
 </sect1>
 <sect1 xml:id="cha.qemu.guest_inst.qemu-img">
  <title>Managing Disk Images with <command>qemu-img</command></title>

  <para>
   In the previous section (see
   <xref linkend="cha.qemu.guest_inst.qemu-kvm"/>), we used the
   <command>qemu-img</command> command to create an image of a hard disk. You
   can, however, use <command>qemu-img</command> for general disk image
   manipulation. This section introduces <command>qemu-img</command>
   subcommands to help manage the disk images flexibly.
  </para>

  <sect2 xml:id="cha.qemu.guest_inst.qemu-img.general_invocation">
   <title>General Information on qemu-img Invocation</title>
   <para>
    <command>qemu-img</command> uses subcommands (like
    <command>zypper</command> does) to do specific tasks. Each subcommand
    understands a different set of options. Some options are general and used
    by more of these subcommands, while some are unique to the related
    subcommand. See the qemu-img manual page (<command>man 1
    qemu-img</command>) for a list of all supported options.
    <command>qemu-img</command> uses the following general syntax:
   </para>
<screen>&prompt.user;qemu-img subcommand [options]</screen>
   <para>
    and supports the following subcommands:
   </para>
   <variablelist>
    <varlistentry>
     <term><literal>create</literal>
     </term>
     <listitem>
      <para>
       Creates a new disk image on the file system.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>check</literal>
     </term>
     <listitem>
      <para>
       Checks an existing disk image for errors.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>compare</literal>
     </term>
     <listitem>
      <para>
       Check if two images have the same content.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>map</literal>
     </term>
     <listitem>
      <para>
       Dumps the metadata of the image file name and its backing file chain.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>amend</literal>
     </term>
     <listitem>
      <para>
       Amends the image format specific options for the image file name.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>convert</literal>
     </term>
     <listitem>
      <para>
       Converts an existing disk image to a new one in a different format.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>info</literal>
     </term>
     <listitem>
      <para>
       Displays information about the relevant disk image.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>snapshot</literal>
     </term>
     <listitem>
      <para>
       Manages snapshots of existing disk images.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>commit</literal>
     </term>
     <listitem>
      <para>
       Applies changes made to an existing disk image.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>rebase</literal>
     </term>
     <listitem>
      <para>
       Creates a new base image based on an existing image.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>resize</literal>
     </term>
     <listitem>
      <para>
       Increases or decreases the size of an existing image.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="cha.qemu.guest_inst.qemu-img.create">
   <title>Creating, Converting and Checking Disk Images</title>
   <para>
    This section describes how to create disk images, check their condition,
    convert a disk image from one format to another, and get detailed
    information about a particular disk image.
   </para>
   <sect3 xml:id="cha.qemu.guest_inst.qemu-img.create.create">
    <title>qemu-img create</title>
    <para>
     Use <command>qemu-img create</command> to create a new disk image for your
     &vmguest; operating system. The command uses the following syntax:
    </para>
<screen>&prompt.user;qemu-img create -f fmt<co xml:id="co.qemu_img.create.f"/> -o options<co xml:id="co.qemu_img.create.o"/> fname<co xml:id="co.qemu_img.create.filename"/> size<co xml:id="co.qemu_img.create.size"/></screen>
    <calloutlist>
     <callout arearefs="co.qemu_img.create.f">
      <para>
       The format of the target image. Supported formats are
       <literal>qed</literal>, <literal>qcow2</literal>, and
       <literal>raw</literal>.
      </para>
     </callout>
     <callout arearefs="co.qemu_img.create.o">
      <para>
       Some image formats support additional options to be passed on the
       command line. You can specify them here with the <literal>-o</literal>
       option. The <literal>raw</literal> image format supports only the
       <literal>size</literal> option, so it is possible to insert <literal>-o
       size=8G</literal> instead of adding the size option at the end of the
       command.
      </para>
     </callout>
     <callout arearefs="co.qemu_img.create.filename">
      <para>
       Path to the target disk image to be created.
      </para>
     </callout>
     <callout arearefs="co.qemu_img.create.size">
      <para>
       Size of the target disk image (if not already specified with the
       <literal>-o size=&lt;image_size&gt;</literal> option. Optional suffixes
       for the image size are <literal>K</literal> (kilobyte),
       <literal>M</literal> (megabyte), <literal>G</literal> (gigabyte), or
       <literal>T</literal> (terabyte).
      </para>
     </callout>
    </calloutlist>
    <para>
     To create a new disk image <filename>sles.raw</filename> in the directory
     <filename>/images</filename> growing up to a maximum size of 4 GB, run the
     following command:
    </para>
<screen>&prompt.user;qemu-img create -f raw -o size=4G /images/sles.raw
Formatting '/images/sles.raw', fmt=raw size=4294967296

&prompt.user;ls -l /images/sles.raw
-rw-r--r-- 1 tux users 4294967296 Nov 15 15:56 /images/sles.raw

&prompt.user;qemu-img info /images/sles.raw
image: /images/sles11.raw
file format: raw
virtual size: 4.0G (4294967296 bytes)
disk size: 0
</screen>
    <para>
     As you can see, the <emphasis>virtual</emphasis> size of the newly created
     image is 4 GB, but the actual reported disk size is 0 as no data has been
     written to the image yet.
    </para>
    <tip>
     <title>&vmguest; Images on the Btrfs File System</title>
     <para>
      If you need to create a disk image on the Btrfs file system, you can use
      <option>nocow=on</option> to reduce the performance overhead created by
      the copy-on-write feature of Btrfs:
     </para>
<screen>&prompt.user;qemu-img create -o nocow=on test.img 8G</screen>
     <para>
      If you, however, want to use copy-on-write (for example for creating
      snapshots or sharing them across virtual machines), then leave the
      command line without the <option>nocow</option> option.
     </para>
    </tip>
   </sect3>
   <sect3 xml:id="cha.qemu.guest_inst.qemu-img.create.convert">
    <title>qemu-img convert</title>
    <para>
     Use <command>qemu-img convert</command> to convert disk images to another
     format. To get a complete list of image formats supported by &qemu;, run
     <command>qemu-img</command> <option>-h</option> and look at the last line
     of the output. The command uses the following syntax:
    </para>
<screen>&prompt.user;qemu-img convert -c<co xml:id="co.qemu_img.convert.c"/> -f fmt<co xml:id="co.qemu_img.convert.fmt"/> -O out_fmt<co xml:id="co.qemu_img.convert.ofmt"/> -o options<co xml:id="co.qemu_img.convert.o"/> fname<co xml:id="co.qemu_img.convert.fname"/> out_fname<co xml:id="co.qemu_img.convert.ofname"/></screen>
    <calloutlist>
     <callout arearefs="co.qemu_img.convert.c">
      <para>
       Applies compression on the target disk image. Only
       <literal>qcow</literal> and <literal>qcow2</literal> formats support
       compression.
      </para>
     </callout>
     <callout arearefs="co.qemu_img.convert.fmt">
      <para>
       The format of the source disk image. It is usually autodetected and can
       therefore be omitted.
      </para>
     </callout>
     <callout arearefs="co.qemu_img.convert.ofmt">
      <para>
       The format of the target disk image.
      </para>
     </callout>
     <callout arearefs="co.qemu_img.convert.o">
      <para>
       Specify additional options relevant for the target image format. Use
       <literal>-o ?</literal> to view the list of options supported by the
       target image format.
      </para>
     </callout>
     <callout arearefs="co.qemu_img.convert.fname">
      <para>
       Path to the source disk image to be converted.
      </para>
     </callout>
     <callout arearefs="co.qemu_img.convert.ofname">
      <para>
       Path to the converted target disk image.
      </para>
     </callout>
    </calloutlist>
<screen>&prompt.user;qemu-img convert -O vmdk /images/sles.raw \
/images/sles.vmdk

&prompt.user;ls -l /images/
-rw-r--r-- 1 tux users 4294967296 16. lis 10.50 sles.raw
-rw-r--r-- 1 tux users 2574450688 16. lis 14.18 sles.vmdk
</screen>
    <para>
     To see a list of options relevant for the selected target image format,
     run the following command (replace <literal>vmdk</literal> with your image
     format):
    </para>
<screen>&prompt.user;qemu-img convert -O vmdk /images/sles.raw \
/images/sles.vmdk -o ?
Supported options:
size             Virtual disk size
backing_file     File name of a base image
compat6          VMDK version 6 image
subformat        VMDK flat extent format, can be one of {monolithicSparse \
    (default) | monolithicFlat | twoGbMaxExtentSparse | twoGbMaxExtentFlat}
scsi             SCSI image
</screen>
   </sect3>
   <sect3 xml:id="cha.qemu.guest_inst.qemu-img.create.check">
    <title>qemu-img check</title>
    <para>
     Use <command>qemu-img check</command> to check the existing disk image for
     errors. Not all disk image formats support this feature. The command uses
     the following syntax:
    </para>
<screen>&prompt.user;qemu-img check -f fmt<co xml:id="co.qemu_img.check.fmt"/> fname<co xml:id="co.qemu_img.check.fname"/></screen>
    <calloutlist>
     <callout arearefs="co.qemu_img.check.fmt">
      <para>
       The format of the source disk image. It is usually autodetected and can
       therefore be omitted.
      </para>
     </callout>
     <callout arearefs="co.qemu_img.check.fname">
      <para>
       Path to the source disk image to be checked.
      </para>
     </callout>
    </calloutlist>
    <para>
     If no error is found, the command returns no output. Otherwise, the type
     and number of errors found is shown.
    </para>
<screen>&prompt.user;qemu-img check -f qcow2 /images/sles.qcow2
ERROR: invalid cluster offset=0x2af0000
[...]
ERROR: invalid cluster offset=0x34ab0000
378 errors were found on the image.
</screen>
   </sect3>
   <sect3 xml:id="cha.qemu.guest_inst.qemu-img.create.incr">
    <title>Increasing the Size of an Existing Disk Image</title>
    <para>
     When creating a new image, you must specify its maximum size before the
     image is created (see
     <xref linkend="cha.qemu.guest_inst.qemu-img.create.create"/>). After you
     have installed the &vmguest; and have been using it for some time, the
     initial size of the image may no longer be sufficient. In that case,
     add more space to it.
    </para>
    <para>
     To increase the size of an existing disk image by 2 gigabytes, use:
    </para>
<screen>&prompt.user;qemu-img resize /images/sles.raw +2GB</screen>
    <note>
     <para>
      You can resize the disk image using the formats <literal>raw</literal>,
      <literal>qcow2</literal> and <literal>qed</literal>. To resize an image
      in another format, convert it to a supported format with
      <command>qemu-img convert</command> first.
     </para>
    </note>
    <para>
     The image now contains an empty space of 2 GB after the final partition.
     You can resize the existing partitions or add new ones.
    </para>
    <figure>
     <title>New 2 GB Partition in Guest &yast; Partitioner</title>
     <mediaobject>
      <imageobject role="fo">
       <imagedata fileref="qemu_guest_partman.png" width="75%" format="PNG"/>
      </imageobject>
      <imageobject role="html">
       <imagedata fileref="qemu_guest_partman.png" width="75%" format="PNG"/>
      </imageobject>
     </mediaobject>
    </figure>
   </sect3>
   <sect3 xml:id="qemu.qcow2.advanced_options">
    <title>Advanced Options for the qcow2 File Format</title>
    <para>
     <emphasis>qcow2</emphasis> is the main disk image format used by &qemu;.
     Its size grows on demand, and the disk space is only allocated when it is
     actually needed by the virtual machine.
    </para>
    <para>
     A qcow2 formatted file is organized in units of constant size. These units
     are called <emphasis>clusters</emphasis>. Viewed from the guest side, the
     virtual disk is also divided into clusters of the same size. &qemu;
     defaults to 64&nbsp;kB clusters, but you can specify a different value
     when creating a new image:
    </para>
<screen>&prompt.user;qemu-img create -f qcow2 -o cluster_size=128K virt_disk.qcow2 4G</screen>
    <para>
     A qcow2 image contains a set of tables organized in two levels that are
     called the L1 and L2 tables. There is just one L1 table per disk image,
     while there can be many L2 tables depending on how big the image is.
    </para>
    <para>
     To read or write data to the virtual disk, &qemu; needs to read its
     corresponding L2 table to find out the relevant data location. Because
     reading the table for each I/O operation consumes system resources, &qemu;
     keeps a cache of L2 tables in memory to speed up disk access.
    </para>
    <sect4>
     <title>Choosing the Right Cache Size</title>
     <para>
      The cache size relates to the amount of allocated space. L2 cache can map
      the following amount of virtual disk:
     </para>
<screen>disk_size = l2_cache_size * cluster_size / 8</screen>
     <para>
      With the default 64&nbsp;kB of cluster size, that is
     </para>
<screen>disk_size = l2_cache_size * 8192</screen>
     <para>
      Therefore, to have a cache that maps
      <literal>n</literal> gigabytes of disk space with the default cluster
      size, you need
     </para>
<screen>l2_cache_size = disk_size_GB * 131072</screen>
     <para>
      &qemu; uses 1&nbsp;MB (1048576 bytes) of L2 cache by default. Following
      the above formulas, 1&nbsp;MB of L2 cache covers 8&nbsp;GB (1048576 /
      131072) of virtual disk. This means that the performance is fine with the
      default L2 cache size if your virtual disk size is up to 8&nbsp;GB. For
      larger disks, you can speed up the disk access by increasing the L2 cache
      size.
     </para>
    </sect4>
    <sect4>
     <title>Configuring the Cache Size</title>
     <para>
      You can use the <option>-drive</option> option on the &qemu; command line
      to specify the cache sizes. Alternatively when communicating via QMP, use
      the <command>blockdev-add</command> command. For more information on QMP,
      see <xref linkend="qemu.monitor.qmp"/>.
     </para>
     <para>
      The following options configure the cache size for the virtual guest:
     </para>
     <variablelist>
      <varlistentry>
       <term>l2-cache-size</term>
       <listitem>
        <para>
         The maximum size of the L2 table cache.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>refcount-cache-size</term>
       <listitem>
        <para>
         The maximum size of the <emphasis>refcount</emphasis> block cache. For
         more information on <emphasis>refcount</emphasis>, see
         <link xlink:href="https://github.com/qemu/qemu/blob/master/docs/specs/qcow2.txt"/>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>cache-size</term>
       <listitem>
        <para>
         The maximum size of both caches combined.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
     <para>
      When specifying values for the options above, be aware of the following:
     </para>
     <itemizedlist>
      <listitem>
       <para>
        The size of both the L2 and refcount block caches needs to be a
        multiple of the cluster size.
       </para>
      </listitem>
      <listitem>
       <para>
        If you only set one of the options, &qemu; will automatically adjust
        the other options so that the L2 cache is 4 times bigger than the
        refcount cache.
       </para>
      </listitem>
     </itemizedlist>
     <para>
      The refcount cache is used much less often than the L2 cache, therefore you
      can keep it relatively small:
     </para>
<screen>&prompt.root;qemu-system-ARCH [...] \
 -drive file=disk_image.qcow2,l2-cache-size=4194304,refcount-cache-size=262144</screen>
    </sect4>
    <sect4>
     <title>Reducing the Memory Usage</title>
     <para>
      The larger the cache, the more memory it consumes. There is a separate L2
      cache for each qcow2 file. When using a lot of big disk images, you will
      probably need a considerably large amount of memory. Memory consumption
      is even worse if you add backing files
      (<xref linkend="cha.qemu.guest_inst.qemu-img.effect"/>) and snapshots
      (see <xref linkend="cha.qemu.guest_inst.qemu-img.snapshots"/>) to the
      guest's setup chain.
     </para>
     <para>
      That is why &qemu; introduced the <option>cache-clean-interval</option>
      setting. It defines an interval in seconds after which all cache entries
      that have not been accessed are removed from memory.
     </para>
     <para>
      The following example removes all unused cache entries every 10 minutes:
     </para>
<screen>&prompt.root;qemu-system-ARCH [...] -drive file=hd.qcow2,cache-clean-interval=600</screen>
     <para>
      If this option is not set, the default value is 0 and it disables this
      feature.
     </para>
    </sect4>
   </sect3>
  </sect2>

  <sect2 xml:id="cha.qemu.guest_inst.qemu-img.snapshots">
   <title>Managing Snapshots of Virtual Machines with qemu-img</title>
   <para>
    <xref linkend="gloss.vt.vm"/> snapshots are snapshots of the complete
    environment in which a &vmguest; is running. The snapshot includes the
    state of the processor (CPU), memory (RAM), devices, and all writable
    disks.
   </para>
   <para>
    Snapshots are helpful when you need to save your virtual machine in a
    particular state. For example, after you configured network services on a
    virtualized server and want to quickly start the virtual machine in the
    same state you last saved it. Or you can create a snapshot after the
    virtual machine has been powered off to create a backup state before you
    try something experimental and possibly make &vmguest; unstable. This
    section introduces the latter case, while the former is described in
    <xref linkend="cha.qemu.monitor"/>.
   </para>
   <para>
    To use snapshots, your &vmguest; must contain at least one writable hard
    disk image in <literal>qcow2</literal> format. This device is usually the
    first virtual hard disk.
   </para>
   <para>
    <xref linkend="gloss.vt.vm"/> snapshots are created with the
    <literal>savevm</literal> command in the interactive &qemu; monitor. To
    make identifying a particular snapshot easier, you can assign it a
    <emphasis>tag</emphasis>. For more information on &qemu; monitor, see
    <xref linkend="cha.qemu.monitor"/>.
   </para>
   <para>
    Once your <literal>qcow2</literal> disk image contains saved snapshots, you
    can inspect them with the <command>qemu-img snapshot</command> command.
   </para>
   <warning>
    <title>Shut Down the &vmguest;</title>
    <para>
     Do not create or delete virtual machine snapshots with the
     <command>qemu-img snapshot</command> command while the virtual machine is
     running. Otherwise, you may damage the disk image with the state of the
     virtual machine saved.
    </para>
   </warning>
   <sect3 xml:id="cha.qemu.guest_inst.qemu-img.snapshots.l">
    <title>Listing Existing Snapshots</title>
    <para>
     Use <command>qemu-img snapshot -l</command>
     <replaceable>DISK_IMAGE</replaceable> to view a list of all existing
     snapshots saved in the <literal>disk_image</literal> image. You can get
     the list even while the &vmguest; is running.
    </para>
<screen>&prompt.user;qemu-img snapshot -l /images/sles.qcow2
Snapshot list:
ID<co xml:id="co.qemu_img.snapshot.l.id"/>       TAG<co xml:id="co.qemu_img.snapshot.l.tag"/>               VM SIZE<co xml:id="co.qemu_img.snapshot.l.size"/>        DATE<co xml:id="co.qemu_img.snapshot.l.date"/>          VM CLOCK<co xml:id="co.qemu_img.snapshot.l.clock"/>
1         booting                4.4M 2013-11-22 10:51:10   00:00:20.476
2         booted                 184M 2013-11-22 10:53:03   00:02:05.394
3         logged_in              273M 2013-11-22 11:00:25   00:04:34.843
4         ff_and_term_running    372M 2013-11-22 11:12:27   00:08:44.965</screen>
    <calloutlist>
     <callout arearefs="co.qemu_img.snapshot.l.id">
      <para>
       Unique identification number of the snapshot. Usually auto-incremented.
      </para>
     </callout>
     <callout arearefs="co.qemu_img.snapshot.l.tag">
      <para>
       Unique description string of the snapshot. It is meant as a
       human-readable version of the ID.
      </para>
     </callout>
     <callout arearefs="co.qemu_img.snapshot.l.size">
      <para>
       The disk space occupied by the snapshot. Note that the more memory is
       consumed by running applications, the bigger the snapshot is.
      </para>
     </callout>
     <callout arearefs="co.qemu_img.snapshot.l.date">
      <para>
       Time and date the snapshot was created.
      </para>
     </callout>
     <callout arearefs="co.qemu_img.snapshot.l.clock">
      <para>
       The current state of the virtual machine's clock.
      </para>
     </callout>
    </calloutlist>
   </sect3>
   <sect3 xml:id="cha.qemu.guest_inst.qemu-img.snapshots.c">
    <title>Creating Snapshots of a Powered-Off Virtual Machine</title>
    <para>
     Use <command>qemu-img snapshot -c</command>
     <replaceable>SNAPSHOT_TITLE</replaceable>
     <replaceable>DISK_IMAGE</replaceable> to create a snapshot of the current
     state of a virtual machine that was previously powered off.
    </para>
<screen>&prompt.user;qemu-img snapshot -c backup_snapshot /images/sles.qcow2</screen>
<screen>&prompt.user;qemu-img snapshot -l /images/sles.qcow2
Snapshot list:
ID        TAG                 VM SIZE                DATE       VM CLOCK
1         booting                4.4M 2013-11-22 10:51:10   00:00:20.476
2         booted                 184M 2013-11-22 10:53:03   00:02:05.394
3         logged_in              273M 2013-11-22 11:00:25   00:04:34.843
4         ff_and_term_running    372M 2013-11-22 11:12:27   00:08:44.965
5         backup_snapshot           0 2013-11-22 14:14:00   00:00:00.000</screen>
    <para>
     If something breaks in your &vmguest; and you need to restore the state of
     the saved snapshot (ID 5 in our example), power off your &vmguest; and
     execute the following command:
    </para>
<screen>&prompt.user;qemu-img snapshot -a 5 /images/sles.qcow2</screen>
    <para>
     The next time you run the virtual machine with
     <command>qemu-system-ARCH</command>, it will be in the state of snapshot
     number 5.
    </para>
    <note>
     <para>
      The <command>qemu-img snapshot -c</command> command is not related to the
      <literal>savevm</literal> command of &qemu; monitor (see
      <xref linkend="cha.qemu.monitor"/>). For example, you cannot apply a
      snapshot with <command>qemu-img snapshot -a</command> on a snapshot
      created with <literal>savevm</literal> in &qemu;'s monitor.
     </para>
    </note>
   </sect3>
   <sect3 xml:id="cha.qemu.guest_inst.qemu-img.snapshots.d">
    <title>Deleting Snapshots</title>
    <para>
     Use <command>qemu-img snapshot -d</command>
     <replaceable>SNAPSHOT_ID</replaceable>
     <replaceable>DISK_IMAGE</replaceable> to delete old or unneeded snapshots
     of a virtual machine. This saves some disk space inside the
     <literal>qcow2</literal> disk image as the space occupied by the snapshot
     data is restored:
    </para>
<screen>&prompt.user;qemu-img snapshot -d 2 /images/sles.qcow2</screen>
   </sect3>
  </sect2>

  <sect2 xml:id="cha.qemu.guest_inst.qemu-img.effect">
   <title>Manipulate Disk Images Effectively</title>
   <para>
    Imagine the following real-life situation: you are a server administrator
    who runs and manages several virtualized operating systems. One group of
    these systems is based on one specific distribution, while another group
    (or groups) is based on different versions of the distribution or even on a
    different (and maybe non-Unix) platform. To make the case even more
    complex, individual virtual guest systems based on the same distribution
    usually differ according to the department and deployment. A file server
    typically uses a different setup and services than a Web server does, while
    both may still be based on <phrase os="sles;sled">&slsreg;</phrase><phrase
    os="osuse">&opensuse;</phrase>.
   </para>
   <para>
    With &qemu; it is possible to create <quote>base</quote> disk images. You
    can use them as template virtual machines. These base images will save you
    plenty of time because you will never need to install the same operating
    system more than once.
   </para>
   <sect3 xml:id="cha.qemu.guest_inst.qemu-img.effect.base_and_derived">
    <title>Base and Derived Images</title>
    <para>
     First, build a disk image as usual and install the target system on it.
     For more information, see <xref linkend="cha.qemu.guest_inst.qemu-kvm"/>
     and <xref linkend="cha.qemu.guest_inst.qemu-img.create"/>. Then build a
     new image while using the first one as a base image. The base image is
     also called a <emphasis>backing</emphasis> file. After your new
     <emphasis>derived</emphasis> image is built, never boot the base image
     again, but boot the derived image instead. Several derived images may
     depend on one base image at the same time. Therefore, changing the base
     image can damage the dependencies. While using your derived image, &qemu;
     writes changes to it and uses the base image only for reading.
    </para>
    <para>
     It is a good practice to create a base image from a freshly installed
     (and, if needed, registered) operating system with no patches applied and
     no additional applications installed or removed. Later on, you can create
     another base image with the latest patches applied and based on the
     original base image.
    </para>
   </sect3>
   <sect3 xml:id="cha.qemu.guest_inst.qemu-img.effect.create_derived">
    <title>Creating Derived Images</title>
    <note>
     <para>
      While you can use the <literal>raw</literal> format for base images, you
      cannot use it for derived images because the <literal>raw</literal>
      format does not support the <literal>backing_file</literal> option. Use
      for example the <literal>qcow2</literal> format for the derived images.
     </para>
    </note>
    <para>
     For example, <filename>/images/sles_base.raw</filename> is the base image
     holding a freshly installed system.
    </para>
<screen>&prompt.user;qemu-img info /images/sles_base.raw
image: /images/sles_base.raw
file format: raw
virtual size: 4.0G (4294967296 bytes)
disk size: 2.4G</screen>
    <para>
     The image's reserved size is 4 GB, the actual size is 2.4 GB, and its
     format is <literal>raw</literal>. Create an image derived from the
     <filename>/images/sles_base.raw</filename> base image with:
    </para>
<screen>&prompt.user;qemu-img create -f qcow2 /images/sles_derived.qcow2 \
-o backing_file=/images/sles_base.raw
Formatting '/images/sles_derived.qcow2', fmt=qcow2 size=4294967296 \
backing_file='/images/sles_base.raw' encryption=off cluster_size=0
</screen>
    <para>
     Look at the derived image details:
    </para>
<screen>&prompt.user;qemu-img info /images/sles_derived.qcow2
image: /images/sles_derived.qcow2
file format: qcow2
virtual size: 4.0G (4294967296 bytes)
disk size: 140K
cluster_size: 65536
backing file: /images/sles_base.raw \
(actual path: /images/sles_base.raw)</screen>
    <para>
     Although the reserved size of the derived image is the same as the size of
     the base image (4 GB), the actual size is 140 KB only. The reason is that
     only changes made to the system inside the derived image are saved. Run
     the derived virtual machine, register it, if needed, and apply the latest
     patches. Do any other changes in the system such as removing unneeded or
     installing new software packages. Then shut the &vmguest; down and examine
     its details once more:
    </para>
<screen>&prompt.user;qemu-img info /images/sles_derived.qcow2
image: /images/sles_derived.qcow2
file format: qcow2
virtual size: 4.0G (4294967296 bytes)
disk size: 1.1G
cluster_size: 65536
backing file: /images/sles_base.raw \
(actual path: /images/sles_base.raw)</screen>
    <para>
     The <literal>disk size</literal> value has grown to 1.1 GB, which is the
     disk space occupied by the changes on the file system compared to the base
     image.
    </para>
   </sect3>
   <sect3 xml:id="cha.qemu.guest_inst.qemu-img.effect.rebase">
    <title>Rebasing Derived Images</title>
    <para>
     After you have modified the derived image (applied patches, installed
     specific applications, changed environment settings, etc.), it reaches the
     desired state. At that point, you can merge the original base
     image and the derived image to create a new base image.
    </para>
    <para>
     Your original base image (<filename>/images/sles_base.raw</filename>)
     holds a freshly installed system. It can be a template for new modified
     base images, while the new one can contain the same system as the first
     one plus all security and update patches applied, for example. After you
     have created this new base image, you can use it as a template for more
     specialized derived images as well. The new base image becomes independent
     of the original one. The process of creating base images from derived ones
     is called <emphasis>rebasing</emphasis>:
    </para>
<screen>&prompt.user;qemu-img convert /images/sles_derived.qcow2 \
-O raw /images/sles_base2.raw</screen>
    <para>
     This command created the new base image
     <filename>/images/sles_base2.raw</filename> using the
     <literal>raw</literal> format.
    </para>
<screen>&prompt.user;qemu-img info /images/sles_base2.raw
image: /images/sles11_base2.raw
file format: raw
virtual size: 4.0G (4294967296 bytes)
disk size: 2.8G</screen>
    <para>
     The new image is 0.4 gigabytes bigger than the original base image. It
     uses no backing file, and you can easily create new derived images based
     upon it. This lets you create a sophisticated hierarchy of virtual disk
     images for your organization, saving a lot of time and work.
    </para>
   </sect3>
   <sect3 xml:id="cha.qemu.guest_inst.qemu-img.effect.mount">
    <title>Mounting an Image on a &vmhost;</title>
    <para>
     It can be useful to mount a virtual disk image under the host
     system. It is strongly recommended to read <xref linkend="chap.guestfs"/>
     and use dedicated tools to access a virtual machine image. However, if you
     need to do this manually, follow this guide.
    </para>
    <para>
     Linux systems can mount an internal partition of a <literal>raw</literal>
     disk image using a loopback device. The first example procedure is more
     complex but more illustrative, while the second one is straightforward:
    </para>
    <procedure>
     <title>Mounting Disk Image by Calculating Partition Offset</title>
     <step>
      <para>
       Set a <emphasis>loop</emphasis> device on the disk image whose partition
       you want to mount.
      </para>
<screen>&prompt.user;losetup /dev/loop0 /images/sles_base.raw</screen>
     </step>
     <step>
      <para>
       Find the <emphasis>sector size</emphasis> and the starting
       <emphasis>sector number</emphasis> of the partition you want to mount.
      </para>
<screen>&prompt.user;fdisk -lu /dev/loop0

Disk /dev/loop0: 4294 MB, 4294967296 bytes
255 heads, 63 sectors/track, 522 cylinders, total 8388608 sectors
Units = sectors of 1 * 512 = 512<co xml:id="co.qemu_img.loopback.sector_size"/> bytes
Disk identifier: 0x000ceca8

       Device Boot      Start         End      Blocks   Id  System
/dev/loop0p1              63     1542239      771088+  82  Linux swap
/dev/loop0p2   *     1542240<co xml:id="co.qemu_img.loopback.sector_start"/>    8385929     3421845   83  Linux</screen>
      <calloutlist>
       <callout arearefs="co.qemu_img.loopback.sector_size">
        <para>
         The disk sector size.
        </para>
       </callout>
       <callout arearefs="co.qemu_img.loopback.sector_start">
        <para>
         The starting sector of the partition.
        </para>
       </callout>
      </calloutlist>
     </step>
     <step>
      <para>
       Calculate the partition start offset:
      </para>
      <para>
       <literal>sector_size * sector_start = 512 * 1542240 = 789626880
       </literal>
      </para>
     </step>
     <step>
      <para>
       Delete the loop and mount the partition inside the disk image with the
       calculated offset on a prepared directory.
      </para>
<screen>&prompt.user;losetup -d /dev/loop0
&prompt.user;mount -o loop,offset=789626880 \
/images/sles_base.raw /mnt/sles/
&prompt.user;ls -l /mnt/sles/
total 112
drwxr-xr-x   2 root root  4096 Nov 16 10:02 bin
drwxr-xr-x   3 root root  4096 Nov 16 10:27 boot
drwxr-xr-x   5 root root  4096 Nov 16 09:11 dev
[...]
drwxrwxrwt  14 root root  4096 Nov 24 09:50 tmp
drwxr-xr-x  12 root root  4096 Nov 16 09:16 usr
drwxr-xr-x  15 root root  4096 Nov 16 09:22 var
</screen>
     </step>
     <step>
      <para>
       Copy one or more files onto the mounted partition and unmount it when
       finished.
      </para>
<screen>&prompt.user;cp /etc/X11/xorg.conf /mnt/sles/root/tmp
&prompt.user;ls -l /mnt/sles/root/tmp
&prompt.user;umount /mnt/sles/</screen>
     </step>
    </procedure>
    <warning>
     <title>Do not Write to Images Currently in Use</title>
     <para>
      Never mount a partition of an image of a running virtual machine in a
      <literal>read-write</literal> mode. This could corrupt the partition and
      break the whole &vmguest;.
     </para>
    </warning>
   </sect3>
  </sect2>
 </sect1>
</chapter>
