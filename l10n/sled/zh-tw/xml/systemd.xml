<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="systemd.xml" version="5.0" xml:id="cha-systemd">
  <title><systemitem class="daemon">systemd</systemitem> 精靈</title>
  <info>
    <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
      <dm:bugtracker/>
      <dm:translation>yes</dm:translation>
    </dm:docmanager>
  </info>
  <para>
    <systemitem class="daemon">systemd</systemitem> 用於啟始化系統。它的程序 ID 為 1。<systemitem class="daemon">systemd</systemitem> 由核心直接啟動，訊號 9 (通常會終止程序) 對它不起作用。所有其他程式要麼由 <systemitem class="daemon">systemd</systemitem> 直接啟動，要麼由它的其中一個子程序啟動。<systemitem class="daemon">systemd</systemitem> 取代了 System V init 精靈，並且透過支援 init 指令碼與 System V init 完全相容。
  </para>
  <para>
    <systemitem class="daemon">systemd</systemitem> 的主要優點是透過平行化服務啟動，大大加快了開機速度。另外，<systemitem class="daemon">systemd</systemitem> 僅在確實需要服務時才會啟動該服務。即不會在開機時無條件啟動精靈，而是在第一次需要時才會啟動。<systemitem class="daemon">systemd</systemitem> 還支援核心控制群組 (cgroup)、建立快照和還原系統狀態。如需詳細資訊，請造訪 <link xlink:href="https://www.freedesktop.org/wiki/Software/systemd/"/>。
  </para>
  <tip>
    <title>WSL 中的 <systemitem class="daemon">systemd</systemitem></title>
    <para>
      Windows 子系統 Linux 版 (WSL) 允許在 Microsoft Windows 作業系統下執行 Linux 應用程式和套裝作業系統。WSL 使用其 init 程序，而非 <systemitem class="daemon">systemd</systemitem>。若要在 WSL 中執行的 <phrase role="productname"><phrase os="sled">SLED</phrase></phrase> 中啟用 <systemitem class="daemon">systemd</systemitem>，請安裝自動執行該程序的 <literal>wsl_systemd</literal> 模式：
    </para>
<screen><prompt>&gt; </prompt><command>sudo</command> zypper in -t pattern wsl_systemd</screen>
    <para>
      或者，您可以手動編輯 <filename>/etc/wsl.conf</filename> 並新增以下幾行內容：
    </para>
<screen>[boot]
systemd=true</screen>
    <para>
      請注意，WSL 中僅對 <systemitem class="daemon">systemd</systemitem> 提供部分支援，即 <systemitem class="daemon">systemd</systemitem> 單元檔案必須具有合理的程序管理行為。
    </para>
  </tip>
  <sect1 xml:id="sec-boot-systemd-concept">
    <title><systemitem class="daemon">systemd</systemitem> 概念</title>

    <para>
      以下幾節介紹 <systemitem class="daemon">systemd</systemitem> 背後的概念。
    </para>

    <para>
      <systemitem class="daemon">systemd</systemitem> 是適用於 Linux 的系統和工作階段管理員，它與 System V 及 LSB init 指令碼相容。<systemitem class="daemon">systemd</systemitem> 的主要功能包括：
    </para>

    <itemizedlist mark="bullet" spacing="normal">
      <listitem>
        <para>
          平行化能力
        </para>
      </listitem>
      <listitem>
        <para>
          透過通訊端和 D-Bus 啟用來啟動服務
        </para>
      </listitem>
      <listitem>
        <para>
          依需求啟動精靈
        </para>
      </listitem>
      <listitem>
        <para>
          使用 Linux cgroup 追蹤程序
        </para>
      </listitem>
      <listitem>
        <para>
          建立快照和還原系統狀態
        </para>
      </listitem>
      <listitem>
        <para>
          維護掛接點和自動掛接點
        </para>
      </listitem>
      <listitem>
        <para>
          實作事務相關型複雜的服務控制邏輯
        </para>
      </listitem>
    </itemizedlist>

    <sect2 xml:id="sec-boot-systemd-unitfile">
      <title>單元檔案</title>
      <para>
        單元組態檔案包含有關以下項目的資訊：服務、通訊端、裝置、掛接點、自動掛接點、交換檔案或分割區、啟動目標、監控的檔案系統路徑、受 <systemitem class="daemon">systemd</systemitem> 控制和監督的計時器、暫時系統狀態快照、資源管理片段，或一組外部建立的程序。
      </para>
      <para>
        <quote>單元檔案</quote>是 <systemitem class="daemon">systemd</systemitem> 用於表示下列項目的通用術語：
      </para>
      <itemizedlist mark="bullet" spacing="normal">
        <listitem>
          <formalpara>
            <title>服務</title>
            <para>
              程序相關資訊 (例如執行精靈)；檔案名以 .service 結尾
            </para>
          </formalpara>
        </listitem>
        <listitem>
          <formalpara>
            <title>目標</title>
            <para>
              用於將單元分組以及在啟動期間用作同步點；檔案名以 .target 結尾
            </para>
          </formalpara>
        </listitem>
        <listitem>
          <formalpara>
            <title>插槽</title>
            <para>
              IPC 或網路插槽或檔案系統 FIFO 的相關資訊，適用於插槽型啟動 (如 <systemitem class="daemon">inetd</systemitem>)；檔案名以 .socket 結尾
            </para>
          </formalpara>
        </listitem>
        <listitem>
          <formalpara>
            <title>路徑</title>
            <para>
              用於觸發其他單元 (例如，在檔案變更後執行某個服務)；檔案名以 .path 結尾
            </para>
          </formalpara>
        </listitem>
        <listitem>
          <formalpara>
            <title>計時器</title>
            <para>
              受控計時器的相關資訊，適用於計時器型啟動；檔案名以 .timer 結尾
            </para>
          </formalpara>
        </listitem>
        <listitem>
          <formalpara>
            <title>掛接點</title>
            <para>
              通常由 fstab 產生器自動產生；檔案名稱以 .mount 結尾
            </para>
          </formalpara>
        </listitem>
        <listitem>
          <formalpara>
            <title>自動掛接點</title>
            <para>
              檔案系統自動掛接點的相關資訊；檔案名以 .automount 結尾
            </para>
          </formalpara>
        </listitem>
        <listitem>
          <formalpara>
            <title>Swap</title>
            <para>
              用於記憶體分頁之交換裝置或檔案相關資訊；檔案名以 .swap 結尾
            </para>
          </formalpara>
        </listitem>
        <listitem>
          <formalpara>
            <title>裝置</title>
            <para>
              sysfs/udev(7) 裝置樹中所展示之裝置的相關資訊；檔案名以 .automount 結尾
            </para>
          </formalpara>
        </listitem>
        <listitem>
          <formalpara>
            <title>範圍/片段</title>
            <para>
              分階層管理程序群組之資源的概念；檔案名以 .scope/.slice 結尾
            </para>
          </formalpara>
        </listitem>
      </itemizedlist>
      <para>
        如需 <systemitem class="daemon">systemd</systemitem> 單元檔案的詳細資訊，請參閱 <link xlink:href="https://www.freedesktop.org/software/systemd/man/latest/systemd.unit.html"/>
      </para>
    </sect2>
  </sect1>
  <sect1 xml:id="sec-boot-systemd-basics">
    <title>基本用法</title>

    <para>
      System V init 系統使用多個指令來處理服務：init 指令碼、<command>insserv</command>、<command>telinit</command> 及其他。<systemitem class="daemon">systemd</systemitem> 使服務管理變得更容易，因為您只需使用一個指令即可處理大多數與服務相關的任務，即 <command>systemctl</command> 指令。它使用<quote>
指令加子指令</quote>表示法，與 <command>git</command> 或 <command>zypper</command> 相似：
    </para>

<screen>systemctl <replaceable>GENERAL OPTIONS</replaceable> <replaceable>SUBCOMMAND</replaceable> <replaceable>SUBCOMMAND OPTIONS</replaceable></screen>

    <para>
      如需完整的手冊，請參閱 <command>man 1 systemctl</command>。
    </para>

    <tip>
      <title>終端機輸出和 Bash 補齊</title>
      <para>
        如果輸出傳遞到某個終端機 (而非某個管線或檔案等)，<systemitem class="daemon">systemd</systemitem> 指令預設會將長輸出傳送到頁面巡覽區。使用 <option>--no-pager</option> 選項可關閉分頁模式。
      </para>
      <para>
        <systemitem class="daemon">systemd</systemitem> 還支援 bash 補齊，這樣您只需輸入子指令的頭幾個字母，然後按 <keycap function="tab"/> 即可。僅可在 <systemitem>bash</systemitem> 外圍程序中使用此功能，並且需要安裝 <systemitem class="resource">bash-completion</systemitem> 套件。
      </para>
    </tip>

    <sect2 xml:id="sec-boot-systemd-basics-services">
      <title>管理正在執行系統中的服務</title>
      <para>
        用於管理服務的子指令與使用 System V init 管理服務的子指令相同 (<command>start</command>、<command>stop</command> 等)。下面列出了服務管理指令的通用語法：
      </para>
      <variablelist>
        <varlistentry>
          <term><systemitem class="daemon">systemd</systemitem></term>
          <listitem>
<screen>systemctl reload|restart|start|status|stop|<replaceable>...</replaceable> <replaceable>MY_SERVICE(S)</replaceable></screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>System V init</term>
          <listitem>
<screen>rc<replaceable>MY_SERVICE(S)</replaceable> reload|restart|start|status|stop|<replaceable>...</replaceable></screen>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
        <systemitem class="daemon">systemd</systemitem> 可讓您一次管理多個服務。它不是像 System V init 那樣依次執行 init 指令碼，而是執行類似如下的指令：
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl start <replaceable>MY_1ST_SERVICE</replaceable> <replaceable>MY_2ND_SERVICE</replaceable></screen>
      <para>
        若要列出系統上所有可用的服務：
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl list-unit-files --type=service</screen>
      <para>
        下表列出了 <systemitem class="daemon">systemd</systemitem> 和 System V init 最重要的服務管理指令：
      </para>
      <table rowsep="1">
        <title>服務管理指令</title>
        <tgroup cols="3">
          <colspec colnum="1" colname="1" colwidth="50*"/>
          <colspec colnum="2" colname="2" colwidth="30*"/>
          <colspec colnum="3" colname="3" colwidth="20*"/>
          <thead>
            <row>
              <entry colname="1">
                <para>
                  任務
                </para>
              </entry>
              <entry colname="2">
                <para>
                  <systemitem class="daemon">systemd</systemitem> 指令
                </para>
              </entry>
              <entry colname="3">
                <para>
                  System V init 指令
                </para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry colname="1">
                <formalpara>
                  <title>啟動</title>
                  <para/>
                </formalpara>
              </entry>
              <entry colname="2">
<screen>start</screen>
              </entry>
              <entry colname="3">
<screen>start</screen>
              </entry>
            </row>
            <row>
              <entry colname="1">
                <formalpara>
                  <title>停止</title>
                  <para/>
                </formalpara>
              </entry>
              <entry colname="2">
<screen>stop</screen>
              </entry>
              <entry colname="3">
<screen>stop</screen>
              </entry>
            </row>
            <row>
              <entry colname="1">
                <formalpara>
                  <title>重新啟動</title>
                  <para>
                    關閉服務，然後啟動這些服務。如果某項服務尚未執行，則會將其啟動。
                  </para>
                </formalpara>
              </entry>
              <entry colname="2">
<screen>restart</screen>
              </entry>
              <entry colname="3">
<screen>restart</screen>
              </entry>
            </row>
            <row>
              <entry colname="1">
                <formalpara>
                  <title>有條件地重新啟動</title>
                  <para>
                    如果服務目前正在執行中，則予以重新啟動。對於未在執行中的服務，則不執行任何動作。
                  </para>
                </formalpara>
              </entry>
              <entry colname="2">
<screen>try-restart</screen>
              </entry>
              <entry colname="3">
<screen>try-restart</screen>
              </entry>
            </row>
            <row>
              <entry colname="1">
                <formalpara>
                  <title>重新載入</title>
                  <para>
                    指示服務重新載入它們的組態檔案，而不中斷操作。使用案例：讓 Apache 重新載入修改過的 <filename>httpd.conf</filename> 組態檔案。並非所有服務都支援重新載入。
                  </para>
                </formalpara>
              </entry>
              <entry colname="2">
<screen>reload</screen>
              </entry>
              <entry colname="3">
<screen>reload</screen>
              </entry>
            </row>
            <row>
              <entry colname="1">
                <formalpara>
                  <title>重新載入或重新啟動</title>
                  <para>
                    如果服務支援重新載入，則重新載入服務，否則重新啟動服務。如果某項服務尚未執行，則會將其啟動。
                  </para>
                </formalpara>
              </entry>
              <entry colname="2">
<screen>reload-or-restart</screen>
              </entry>
              <entry colname="3">
<screen>n/a</screen>
              </entry>
            </row>
            <row>
              <entry colname="1">
                <formalpara>
                  <title>有條件地重新載入或重新啟動</title>
                  <para>
                    如果服務支援重新載入，則重新載入服務，否則重新啟動那些目前正在執行的服務。對於未在執行中的服務，則不執行任何動作。
                  </para>
                </formalpara>
              </entry>
              <entry colname="2">
<screen>reload-or-try-restart</screen>
              </entry>
              <entry colname="3">
<screen>n/a</screen>
              </entry>
            </row>
            <row>
              <entry colname="1">
                <formalpara>
                  <title>取得詳細的狀態資訊</title>
                  <para>
                    列出服務狀態的相關資訊。<systemitem class="daemon">systemd</systemitem> 指令會顯示詳細資料，例如描述、可執行檔、狀態、cgroup 及服務發出的最新訊息 (請參閱<xref linkend="sec-boot-systemd-basics-services-debugging"/>)。使用 System V init 顯示的詳細資料級別因服務而異。
                  </para>
                </formalpara>
              </entry>
              <entry colname="2">
<screen>status</screen>
              </entry>
              <entry colname="3">
<screen>status</screen>
              </entry>
            </row>
            <row>
              <entry colname="1">
                <formalpara>
                  <title>取得簡要的狀態資訊</title>
                  <para>
                    顯示服務是否處於使用中狀態。
                  </para>
                </formalpara>
              </entry>
              <entry colname="2">
<screen>is-active</screen>
              </entry>
              <entry colname="3">
<screen>status</screen>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-basics-services-enabling">
      <title>永久啟用/停用服務</title>
      <para>
        上一節中提及的服務管理指令可讓您操作目前工作階段的服務。<systemitem class="daemon">systemd</systemitem> 還可讓您永久啟用或停用服務，使之可以按要求自動啟動，或者始終無法使用。此操作可以透過 YaST 或在指令列上執行。
      </para>
      <sect3 xml:id="sec-boot-systemd-basics-services-enabling-cmd">
        <title>在指令列上啟用/停用服務</title>
        <para>
          下表列出了 <systemitem class="daemon">systemd</systemitem> 和 System V init 用於啟用和停用服務的指令：
        </para>
        <important>
          <title>服務啟動</title>
          <para>
            在指令列上啟用服務時，服務不會自動啟動。系統將其排定為下一次系統啟動或執行層級/目標變更時啟動。若要在啟用服務之後立即啟動它，請明確執行 <command>systemctl start
            <replaceable>MY_SERVICE</replaceable></command> 或 <command>rc
            <replaceable>MY_SERVICE</replaceable> start</command>。
          </para>
        </important>
        <table rowsep="1">
          <title>用於啟用和停用服務的指令</title>
          <tgroup cols="3">
            <colspec colnum="1" colname="1" colwidth="32*"/>
            <colspec colnum="2" colname="2" colwidth="40*"/>
            <colspec colnum="3" colname="3" colwidth="28*"/>
            <thead>
              <row>
                <entry colname="1">
                  <para>
                    任務
                  </para>
                </entry>
                <entry colname="2">
                  <para>
                    <systemitem class="daemon">systemd</systemitem> 指令
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    System V init 指令
                  </para>
                </entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry colname="1">
                  <formalpara>
                    <title>啟用</title>
                    <para/>
                  </formalpara>
                </entry>
                <entry colname="2">
                  <para>
                    <command>systemctl enable
                    <replaceable>MY_SERVICE(S)</replaceable></command>
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    <command>insserv
                    <replaceable>MY_SERVICE(S)</replaceable></command>、<command>chkconfig -a
                    <replaceable>MY_SERVICE(S)</replaceable></command>
                  </para>
                </entry>
              </row>
              <row>
                <entry colname="1">
                  <formalpara>
                    <title>停用</title>
                    <para/>
                  </formalpara>
                </entry>
                <entry colname="2">
                  <para>
                    <command>systemctl disable
                    <replaceable>MY_SERVICE(S)</replaceable>.service</command>
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    <command>insserv -r
                    <replaceable>MY_SERVICE(S)</replaceable></command>、<command>chkconfig -d
                    <replaceable>MY_SERVICE(S)</replaceable></command>
                  </para>
                </entry>
              </row>
              <row>
                <entry colname="1">
                  <formalpara>
                    <title>檢查</title>
                    <para>
                      顯示是否已啟用某個服務。
                    </para>
                  </formalpara>
                </entry>
                <entry colname="2">
                  <para>
                    <command>systemctl is-enabled
                    <replaceable>MY_SERVICE</replaceable></command>
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    <command>chkconfig
                    <replaceable>MY_SERVICE</replaceable></command>
                  </para>
                </entry>
              </row>
              <row>
                <entry colname="1">
                  <formalpara>
                    <title>重新啟用</title>
                    <para>
                      與重新啟動服務相似，此指令先停用服務，然後再啟用該服務。若要使用服務的預設值重新啟用服務，可使用此任務。
                    </para>
                  </formalpara>
                </entry>
                <entry colname="2">
                  <para>
                    <command>systemctl reenable
                    <replaceable>MY_SERVICE</replaceable></command>
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    無
                  </para>
                </entry>
              </row>
              <row>
                <entry colname="1">
                  <formalpara>
                    <title>遮罩</title>
                    <para>
                      <quote>
停用</quote>某項服務之後，仍然可以手動啟動它。若要停用服務，您需要對其進行遮罩。使用須謹慎。
                    </para>
                  </formalpara>
                </entry>
                <entry colname="2">
                  <para>
                    <command>systemctl mask
                    <replaceable>MY_SERVICE</replaceable></command>
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    無
                  </para>
                </entry>
              </row>
              <row>
                <entry colname="1">
                  <formalpara>
                    <title>取消遮罩</title>
                    <para>
                      遮罩某項服務之後，惟有先將其取消遮罩，才能再次予以使用。
                    </para>
                  </formalpara>
                </entry>
                <entry colname="2">
                  <para>
                    <command>systemctl unmask
                    <replaceable>MY_SERVICE</replaceable></command>
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    無
                  </para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </sect3>
    </sect2>
  </sect1>
  <sect1 xml:id="sec-boot-systemd-boot">
    <title>系統啟動和目標管理</title>

    <para>
      <systemitem class="daemon">systemd</systemitem> 負責維護啟動和關閉系統的整個過程。依此觀點，核心可以視為背景程序，以維護所有其他程序，並根據其他程式的要求來調整 CPU 時間和硬體存取。
    </para>

    <sect2 xml:id="sec-boot-systemd-targets">
      <title>目標與執行層級的比較</title>
      <para>
        使用 System V init 時，系統將開機進入<quote>
執行層級</quote>。執行層級定義了系統的啟動方式，以及在所執行的系統中可以使用哪些服務。執行層級標有編號；最常見的執行層級是 <literal>0</literal> (關閉系統)、<literal>3</literal> (多使用者，包含網路) 和 <literal>5</literal> (多使用者，包含網路及顯示管理員)。
      </para>
      <para>
        <systemitem class="daemon">systemd</systemitem> 使用所謂的<quote>目標單元</quote>引入新的概念。不過，它仍然與執行層級概念完全相容。目標單元是有名稱而不是有編號的，它有多個作用。例如，目標 <systemitem>local-fs.target</systemitem> 和 <systemitem>swap.target</systemitem> 會掛接本地檔案系統和交換空間。
      </para>
      <para>
        目標 <systemitem>graphical.target</systemitem> 提供包含網路和顯示管理員功能的多使用者系統，作用與執行層級 5 相當。複雜的目標，例如 <systemitem>graphical.target</systemitem> 透過結合其他目標的子集用作<quote>
中繼</quote>目標。因為 <systemitem class="daemon">systemd</systemitem> 能夠組合現有目標，便於建立自訂目標，因此提供了極大的靈活性。
      </para>
      <para>
        下列清單顯示了最重要的 <systemitem class="daemon">systemd</systemitem> 目標單元。如需完整清單，請參閱 <command>man 7 systemd.special</command>。
      </para>
      <variablelist>
        <title>選取的 <systemitem class="daemon">systemd</systemitem> 目標單元</title>
        <varlistentry>
          <term><systemitem>default.target</systemitem></term>
          <listitem>
            <para>
              預設開機的目標。這並非<quote>
真實</quote>目標，而是一個符號連結，指向 <systemitem>graphic.target</systemitem> 之類的另一個目標。可透過 YaST 永久變更 (請參閱<xref linkend="sec-boot-runlevel-edit"/>)。若要為某個工作階段變更它，請在開機提示處使用核心參數 <literal>systemd.unit=<replaceable>MY_TARGET.target</replaceable></literal>。
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><systemitem>emergency.target</systemitem></term>
          <listitem>
            <para>
              在主控台上啟動極簡緊急 <systemitem class="username">root</systemitem> 外圍程序。請僅在開機提示符處以如下格式使用它：<literal>systemd.unit=emergency.target</literal>。
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><systemitem>graphical.target</systemitem></term>
          <listitem>
            <para>
              啟動包含網路、多使用者支援和顯示管理員功能的系統。
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><systemitem>halt.target</systemitem></term>
          <listitem>
            <para>
              關閉系統。
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><systemitem>mail-transfer-agent.target</systemitem></term>
          <listitem>
            <para>
              啟動傳送和接收郵件所需的所有服務。
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><systemitem>multi-user.target</systemitem></term>
          <listitem>
            <para>
              啟動包含網路的多使用者系統。
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><systemitem>reboot.target</systemitem></term>
          <listitem>
            <para>
              系統重新開機。
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><systemitem>rescue.target</systemitem></term>
          <listitem>
            <para>
              啟動不包含網路的單一使用者 <systemitem class="username">root</systemitem> 工作階段。我們提了基本的系統管理工具。<literal>rescue</literal> 目標適用於解決多種系統問題，例如，登入失敗，或修復與顯示驅動程式有關的問題。
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
        為了與 System V init 執行層級系統保持相容，<systemitem class="daemon">systemd</systemitem> 提供了名為 <literal>runlevel<replaceable>X</replaceable>.target</literal> 的特殊目標，與編號為 <replaceable>X</replaceable> 的相應執行層級對應。
      </para>
      <para>
        若要檢查目前的目標，請使用指令 <command>systemctl
        get-default</command>。
      </para>
      <table rowsep="1">
        <title>System V 執行層級和 <systemitem class="daemon">systemd</systemitem> 目標單元</title>
        <tgroup cols="3">
          <colspec colnum="1" colname="1" colwidth="20*"/>
          <colspec colnum="2" colname="2" colwidth="40*"/>
          <colspec colnum="3" colname="3" colwidth="40*"/>
          <thead>
            <row>
              <entry>
                <para>
                  System V 執行層級
                </para>
              </entry>
              <entry>
                <para>
                  <systemitem class="daemon">systemd</systemitem> 目標
                </para>
              </entry>
              <entry>
                <para>
                  用途
                </para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>
                  0
                </para>
              </entry>
              <entry>
                <para>
                  <systemitem>runlevel0.target</systemitem>、<systemitem>halt.target</systemitem>、<systemitem>poweroff.target</systemitem>
                </para>
              </entry>
              <entry>
                <para>
                  關閉系統
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  1、S
                </para>
              </entry>
              <entry>
                <para>
                  <systemitem>runlevel1.target</systemitem>、<systemitem>rescue.target</systemitem>
                </para>
              </entry>
              <entry>
                <para>
                  單一使用者模式
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  2
                </para>
              </entry>
              <entry>
                <para>
                  <systemitem>runlevel2.target</systemitem>、<systemitem>multi-user.target</systemitem>
                </para>
              </entry>
              <entry>
                <para>
                  本地多使用者，不包含遠端網路
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  3
                </para>
              </entry>
              <entry>
                <para>
                  <systemitem>runlevel3.target</systemitem>、<systemitem>multi-user.target</systemitem>
                </para>
              </entry>
              <entry>
                <para>
                  完整的多使用者，包含網路
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  4
                </para>
              </entry>
              <entry>
                <para>
                  <systemitem>runlevel4.target</systemitem>
                </para>
              </entry>
              <entry>
                <para>
                  未使用/使用者定義
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  5
                </para>
              </entry>
              <entry>
                <para>
                  <systemitem>runlevel5.target</systemitem>、<systemitem>graphical.target</systemitem>
                </para>
              </entry>
              <entry>
                <para>
                  完整的多使用者，包含網路及顯示管理員
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  6
                </para>
              </entry>
              <entry>
                <para>
                  <systemitem>runlevel6.target</systemitem>、<systemitem>reboot.target</systemitem>
                </para>
              </entry>
              <entry>
                <para>
                  系統重新開機
                </para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <important>
        <title><systemitem class="daemon">systemd</systemitem> 會忽略 <filename>/etc/inittab</filename></title>
        <para>
          System V init 系統中的執行層級在 <filename>/etc/inittab</filename> 中設定。<systemitem class="daemon">systemd</systemitem> <emphasis>不</emphasis>使用此組態。如需如何建立您自己的可開機目標的指示，請參閱<xref linkend="sec-boot-systemd-custom-targets"/>。
        </para>
      </important>
      <sect3 xml:id="sec-boot-systemd-targets-commands">
        <title>用於變更目標的指令</title>
        <para>
          請使用下列指令來操作目標單元：
        </para>
        <informaltable rowsep="1">
          <tgroup cols="3">
            <colspec colnum="1" colname="1" colwidth="20*"/>
            <colspec colnum="2" colname="2" colwidth="50*"/>
            <colspec colnum="3" colname="3" colwidth="30*"/>
            <thead>
              <row>
                <entry colname="1">
                  <para>
                    任務
                  </para>
                </entry>
                <entry colname="2">
                  <para>
                    <systemitem class="daemon">systemd</systemitem> 指令
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    System V init 指令
                  </para>
                </entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry colname="1">
                  <para>
                    變更目前的目標/執行層級
                  </para>
                </entry>
                <entry colname="2">
                  <para>
                    <command>systemctl isolate</command>
                    <replaceable>MY_TARGET</replaceable>.target
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    <command>telinit</command> <replaceable>X</replaceable>
                  </para>
                </entry>
              </row>
              <row>
                <entry colname="1">
                  <para>
                    變更為預設目標/執行層級
                  </para>
                </entry>
                <entry colname="2">
                  <para>
                    <command>systemctl default</command>
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    無
                  </para>
                </entry>
              </row>
              <row>
                <entry colname="1">
                  <para>
                    取得目前的目標/執行層級
                  </para>
                </entry>
                <entry colname="2">
                  <para>
                    <command>systemctl list-units --type=target</command>
                  </para>
                  <para>
                    對於 <systemitem class="daemon">systemd</systemitem>，通常會有多個作用中目標。該指令列出目前處於使用中狀態的所有目標。
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    <command>who -r</command>
                  </para>
                  <para>
                    或
                  </para>
                  <para>
                    <command>runlevel</command>
                  </para>
                </entry>
              </row>
              <row>
                <entry colname="1">
                  <para>
                    永久性變更預設的執行層級
                  </para>
                </entry>
                <entry colname="2">
                  <para>
                    使用服務管理員或執行下列指令：
                  </para>
                  <para>
                    <command>ln -sf /usr/lib/systemd/system/</command>
                    <replaceable>MY_TARGET</replaceable>.target /etc/systemd/system/default.target
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    使用服務管理員或變更以下行
                  </para>
                  <para>
                    <command>id:</command>
                    <replaceable>X</replaceable>:initdefault:
                  </para>
                  <para>
                    <filename>/etc/inittab</filename> 中的
                  </para>
                </entry>
              </row>
              <row>
                <entry colname="1">
                  <para>
                    變更目前開機程序的預設執行層級
                  </para>
                </entry>
                <entry colname="2">
                  <para>
                    在開機提示的選項中輸入下列文字：
                  </para>
                  <para>
                    <command>systemd.unit=</command>
                    <replaceable>MY_TARGET</replaceable>.target
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    在開機提示中輸入所需的執行層級編號。
                  </para>
                </entry>
              </row>
              <row>
                <entry colname="1">
                  <para>
                    顯示目標/執行層級的相依性
                  </para>
                </entry>
                <entry colname="2">
                  <para>
                    <command>systemctl show -p "Requires"</command>
                    <replaceable>MY_TARGET</replaceable>.target
                  </para>
                  <para>
                    <command>systemctl show -p "Wants"</command>
                    <replaceable>MY_TARGET</replaceable>.target
                  </para>
                  <para>
                    <quote>Requires</quote> 會列出硬相依性 (必須解析的相依性)，而 <quote>Wants</quote> 則列出軟相依性 (可行時解析的相依性)。
                  </para>
                </entry>
                <entry colname="3">
                  <para>
                    無
                  </para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </sect3>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-debug">
      <title>系統啟動除錯</title>
      <para>
        <systemitem class="daemon">systemd</systemitem> 針對系統啟動過程提供了分析方法。您可以查看所有服務及其狀態的清單 (而不必剖析 <filename>/var/log/</filename>)。<systemitem class="daemon">systemd</systemitem> 還允許您掃描啟動程序，以瞭解每項服務耗費多長時間啟動。
      </para>
      <sect3 xml:id="sec-boot-systemd-debug-review">
        <title>檢視服務的啟動情況</title>
        <para>
          若要檢閱自從系統開機以來已啟動的完整服務清單，請輸入指令 <command>systemctl</command>。這將列出所有使用中的服務，如下方所述 (已縮短)。若要獲得特定服務的詳細資訊，請使用 <command>systemctl status
          <replaceable>MY_SERVICE</replaceable></command>。
        </para>
        <example>
          <title>列出作用中的服務</title>
<screen><prompt role="root"># </prompt>systemctl
UNIT                        LOAD   ACTIVE SUB       JOB DESCRIPTION
[...]
iscsi.service               loaded active exited    Login and scanning of iSC+
kmod-static-nodes.service   loaded active exited    Create list of required s+
libvirtd.service            loaded active running   Virtualization daemon
nscd.service                loaded active running   Name Service Cache Daemon
chronyd.service             loaded active running   NTP Server Daemon
polkit.service              loaded active running   Authorization Manager
postfix.service             loaded active running   Postfix Mail Transport Ag+
rc-local.service            loaded active exited    /etc/init.d/boot.local Co+
rsyslog.service             loaded active running   System Logging Service
[...]
LOAD   = Reflects whether the unit definition was properly loaded.
ACTIVE = The high-level unit activation state, i.e. generalization of SUB.
SUB    = The low-level unit activation state, values depend on unit type.

161 loaded units listed. Pass --all to see loaded but inactive units, too.
To show all installed unit files use 'systemctl list-unit-files'.</screen>
        </example>
        <para>
          若只想列出無法啟動的服務，請使用 <option>--failed</option> 選項：
        </para>
        <example>
          <title>列出失敗的服務</title>
<screen><prompt role="root"># </prompt>systemctl --failed
UNIT                   LOAD   ACTIVE SUB    JOB DESCRIPTION
apache2.service        loaded failed failed     apache
NetworkManager.service loaded failed failed     Network Manager
plymouth-start.service loaded failed failed     Show Plymouth Boot Screen

[...]</screen>
        </example>
      </sect3>
      <sect3 xml:id="sec-boot-systemd-debug-time">
        <title>啟動時間除錯</title>
        <para>
          為了對系統啟動時間除錯，<systemitem class="daemon">systemd</systemitem> 提供了 <command>systemd-analyze</command> 指令。它會顯示總啟動時間以及按啟動時間排序的服務清單，還可以產生 SVG 圖，其中顯示各服務相對於其他服務所耗費的啟動時間。
        </para>
        <variablelist>
          <varlistentry>
            <term>列出系統啟動時間</term>
            <listitem>
<screen><prompt role="root"># </prompt>systemd-analyze
Startup finished in 2666ms (kernel) + 21961ms (userspace) = 24628ms</screen>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>列出服務啟動時間</term>
            <listitem>
<screen><prompt role="root"># </prompt>systemd-analyze blame
    15.000s backup-rpmdb.service
    14.879s mandb.service
     7.646s backup-sysconfig.service
     4.940s postfix.service
     4.921s logrotate.service
     4.640s libvirtd.service
     4.519s display-manager.service
     3.921s btrfsmaintenance-refresh.service
     3.466s lvm2-monitor.service
     2.774s plymouth-quit-wait.service
     2.591s firewalld.service
     2.137s initrd-switch-root.service
     1.954s ModemManager.service
     1.528s rsyslog.service
     1.378s apparmor.service
    [...]
</screen>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>服務啟動時間圖</term>
            <listitem>
<screen><prompt role="root"># </prompt>systemd-analyze plot &gt; jupiter.example.com-startup.svg</screen>
              <informalfigure>
                <mediaobject>
                  <imageobject role="fo">
                    <imagedata fileref="systemd_startup.svg" width="75%"/>
                  </imageobject>
                  <imageobject role="html">
                    <imagedata fileref="systemd_startup.png" width="75%"/>
                  </imageobject>
                </mediaobject>
              </informalfigure>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect3>
      <sect3 xml:id="sec-boot-systemd-debug-complete">
        <title>檢視完整的啟動程序</title>
        <para>
          上面的指令列出了已啟動的服務及其啟動時間。如需更詳細的綜覽，請在開機提示符處指定以下參數，以指示 <systemitem class="daemon">systemd</systemitem> 建立完整啟動程序的詳細記錄。
        </para>
<screen>systemd.log_level=debug systemd.log_target=kmsg</screen>
        <para>
          現在，<systemitem class="daemon">systemd</systemitem> 會將記錄訊息寫入核心環緩衝區。可以使用 <command>dmesg</command> 檢視該緩衝區：
        </para>
<screen><prompt>&gt; </prompt>dmesg -T | less</screen>
      </sect3>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-sysv-compatibility">
      <title>System V 相容性</title>
      <para>
        <systemitem class="daemon">systemd</systemitem> 與 System V 相容，因此，您仍可以使用現有的 System V init 指令碼。但是，至少有一個已知問題會導致 System V init 指令碼無法立即與 <systemitem class="daemon">systemd</systemitem> 配合使用：透過 init 指令碼中的 <command>su</command> 或 <command>sudo</command>，以其他使用者身分啟動服務會導致指令碼失敗，產生<quote>拒絕存取</quote>錯誤。
      </para>
      <para>
        使用 <command>su</command> 或 <command>sudo</command> 變更使用者時，會啟動 PAM 工作階段。完成 init 指令碼後會終止此工作階段。因此，init 指令碼啟動的服務也會終止。若要解決此問題，請執行下列步驟：
      </para>
      <procedure>
        <step>
          <para>
            建立與 init 指令碼同名、副檔名為 <filename>.service</filename> 的服務檔案包裝程式：
          </para>
<screen>[Unit]
Description=<replaceable>DESCRIPTION</replaceable>
After=network.target

[Service]
User=<replaceable>USER</replaceable>
Type=forking<co xml:id="co-service-wrapper-type"/>
PIDFile=<replaceable>PATH TO PID FILE</replaceable><xref linkend="co-service-wrapper-type" xrefstyle="select:label nopage"/>
ExecStart=<replaceable>PATH TO INIT SCRIPT</replaceable> start
ExecStop=<replaceable>PATH TO INIT SCRIPT</replaceable> stop
ExecStopPost=/usr/bin/rm -f <replaceable>PATH TO PID FILE</replaceable><xref linkend="co-service-wrapper-type" xrefstyle="select:label nopage"/>

[Install]
WantedBy=multi-user.target<co xml:id="co-service-wrapper-target"/></screen>
          <para>
            以適當的值取代 <replaceable>UPPERCASE
            LETTERS</replaceable> 中寫入的所有值。
          </para>
          <calloutlist>
            <callout arearefs="co-service-wrapper-type">
              <para>
                選擇性 — 僅當 init 指令碼啟動精靈時才使用。
              </para>
            </callout>
            <callout arearefs="co-service-wrapper-target">
              <para>
                <literal>multi-user.target</literal> 在系統開機到 <literal>graphical.target</literal> 時也會啟動 init 指令碼。如果只應在開機到顯示管理員時才將它啟動，請使用 <literal>graphical.target</literal>。
              </para>
            </callout>
          </calloutlist>
        </step>
        <step>
          <para>
            使用 <command>systemctl start
            <replaceable>APPLICATION</replaceable></command> 啟動 精靈。
          </para>
        </step>
      </procedure>
    </sect2>
  </sect1>
  <sect1 xml:id="sec-boot-runlevel-edit">
    <title>使用 YaST 管理服務</title>

    <para>
      基本服務管理也可以透過 YaST 服務管理員模組實現。該模組不僅支援啟動、停止、啟用和停用服務，還可用於顯示服務的狀態以及變更預設目標。若要啟動 YaST 模組，請選取<menuchoice> <guimenu>YaST</guimenu>
      <guimenu> 系統</guimenu> <guimenu> 服務管理員</guimenu>
      </menuchoice>。
    </para>

    <figure xml:id="fig-yast2-runlevel">
      <title>服務管理員</title>
      <mediaobject>
        <imageobject role="fo">
          <imagedata fileref="yast2_runlevel.png" width="75%"/>
        </imageobject>
        <imageobject role="html">
          <imagedata fileref="yast2_runlevel.png" width="75%"/>
        </imageobject>
      </mediaobject>
    </figure>

    <variablelist>
      <varlistentry>
        <term>變更<guimenu>預設系統目標</guimenu></term>
        <listitem>
          <para>
            若要變更系統開機進入的目標，請從<guimenu>預設系統目標</guimenu>下拉方塊中選擇目標。最常用的目標是<guimenu>圖形介面</guimenu> (啟動圖形登入畫面) 和<guimenu>多使用者</guimenu> (以指令列模式啟動系統)。
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>啟動或停止服務</term>
        <listitem>
          <para>
            從表中選取服務。<guimenu>狀態</guimenu>欄顯示它目前是正在執行 (<guimenu>作用中</guimenu>) 還是未在執行 (<guimenu>非作用中</guimenu>)。透過選擇<guimenu>啟動</guimenu>或<guimenu>停止</guimenu>可切換其狀態。
          </para>
          <para>
            如果啟動或停止服務，會變更其對目前執行中工作階段而言的狀態。若要在整個重新開機期間變更服務的狀態，您需要啟用或停用服務。
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>定義服務啟動行為</term>
        <listitem>
          <para>
            服務可以在開機時自動啟動，也可以手動啟動。從表中選取服務。<guimenu>啟動</guimenu>欄顯示它目前是<guimenu>手動</guimenu>啟動還是<guimenu>開機時</guimenu>啟動。透過選擇<guimenu>啟動模式</guimenu>可切換其狀態。
          </para>
          <para>
            若要在目前工作階段中變更服務狀態，您需要依據上述方式啟動或停止服務。
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>檢視狀態訊息</term>
        <listitem>
          <para>
            若要檢視服務的狀態訊息，請從清單中選取該服務，然後選擇<guimenu>
顯示詳細資料</guimenu>。其輸出與 <command>systemctl</command>
            <option>-l</option> status <replaceable>MY_SERVICE</replaceable> 指令產生的輸出完全相同。
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
  </sect1>
  <sect1 xml:id="sec-boot-systemd-custom">
    <title>自訂 <systemitem>systemd</systemitem></title>

    <para>
      以下各節介紹如何自訂 <systemitem class="daemon">systemd</systemitem> 單元檔案。
    </para>
    <sect2 xml:id="systemd-unit-file-placement">
      <title>單元檔案儲存在哪裡？</title>
      <para>
        SUSE 隨附的 <systemitem class="daemon">systemd</systemitem> 單元檔案儲存在 <filename>/usr/lib/systemd/</filename> 中。自訂單元檔案和<emphasis>置入式</emphasis>單元檔案儲存在 <filename>/etc/systemd/</filename> 中。
      </para>
      <warning>
        <title>防止您的自訂被覆寫</title>
        <para>
          在自訂 <systemitem class="daemon">systemd</systemitem> 時，請務必使用目錄 <filename>/etc/systemd/</filename>，不要使用 <filename>/usr/lib/systemd/</filename>。否則，<systemitem class="daemon">systemd</systemitem> 下次更新時會覆寫您的變更。
        </para>
      </warning>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-custom-service">
      <title>使用置入式檔案覆寫</title>
      <para>
        置入式檔案 (或<emphasis>置入式</emphasis>) 是僅覆寫單元檔案特定設定的部分單元檔案。置入式檔案的優先程度高於主組態檔案。指令 <command>systemctl edit <replaceable>SERVICE</replaceable></command> 會啟動預設的文字編輯器，並在 <filename>/etc/systemd/system/<replaceable>NAME</replaceable>.service.d/</filename> 中建立一個包含空白 <filename>override.conf</filename> 檔案的目錄。該指令還確定會向正在執行的 <systemitem class="daemon">systemd</systemitem> 程序通知這些變更。
      </para>
      <para>
        例如，若要變更系統等待 MariaDB 啟動的時間，請執行 <command>sudo systemctl edit mariadb.service</command>，並編輯開啟的檔案以僅包含修改後的行：
      </para>
<screen>
# Configures the time to wait for start-up/stop
TimeoutSec=300
</screen>
      <para>
        調整 <literal>TimeoutSec</literal> 值並儲存變更。若要啟用變更，請執行 <command>sudo systemctl daemon-reload</command>。
      </para>
      <para>
        如需詳細資訊，請參閱可使用 <command>man 1 systemctl</command> 指令呼叫的手冊頁。
      </para>
      <warning>
        <title>建立完整單元檔案的副本</title>
        <para>
          如果在 <command>systemctl edit --full
          <replaceable>SERVICE</replaceable></command> 指令中使用 <option>--full</option> 選項，則會建立原始單元檔案的副本，您可以在該副本中修改特定選項。我們不建議進行此類自訂，因為當 SUSE 更新單元檔案時，<filename>/etc/systemd/system/</filename> 目錄中的自訂副本會覆寫該檔案的變更。此外，如果 SUSE 提供對套裝作業系統置入式檔案的更新，它們會覆寫使用 <option>--full</option> 建立的單元檔案副本。為了防止產生混淆並確保您的自訂設定永遠有效，請使用置入式檔案。
        </para>
      </warning>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-custom-drop-in">
      <title>手動建立置入式檔案</title>
      <para>
        除了使用 <command>systemctl edit</command> 指令，您還可以手動建立置入式檔案，以便更好地控制其優先程度。透過此類置入式檔案，您可以擴充單元和精靈組態檔案，而無需編輯或覆寫檔案自身。它們儲存在以下目錄中：
      </para>
      <variablelist>
        <varlistentry>
          <term><filename>/etc/systemd/*.conf.d/</filename>、<filename>/etc/systemd/system/*.service.d/</filename></term>
          <listitem>
            <para>
              系統管理員新增和自訂的置入式檔案。
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><filename>/usr/lib/systemd/*.conf.d/</filename>、<filename>/usr/lib/systemd/system/*.service.d/</filename></term>
          <listitem>
            <para>
              自訂套件安裝的置入式檔案，用於覆寫上游設定。例如，SUSE 會提供 <package>systemd-default-settings</package>。
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
      <tip>
        <para>
          如需單元搜尋路徑的完整清單，請參閱手冊頁 <command>man 5 systemd.unit</command>。
        </para>
      </tip>
      <para>
        例如，若要停用由 <systemitem class="daemon">systemd-journald</systemitem> 的預設設定強制執行的速率限制，請執行以下步驟：
      </para>
      <procedure>
        <step>
          <para>
            建立名為 <filename>/etc/systemd/journald.conf.d</filename> 的目錄。
          </para>
<screen><prompt>&gt; </prompt><command>sudo</command> mkdir /etc/systemd/journald.conf.d</screen>
          <note>
            <para>
              目錄名稱必須跟在要使用置入式檔案修補的服務名稱之後。
            </para>
          </note>
        </step>
        <step>
          <para>
            在該目錄中，建立一個包含要覆寫的選項的檔案 <filename>/etc/systemd/journald.conf.d/60-rate-limit.conf</filename>，例如：
          </para>
<screen><prompt>&gt; </prompt><command>cat /etc/systemd/journald.conf.d/60-rate-limit.conf</command>
# Disable rate limiting
RateLimitIntervalSec=0</screen>
        </step>
        <step>
          <para>
            儲存變更，然後重新啟動相應 <systemitem class="daemon">systemd</systemitem> 精靈的服務。
          </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl restart systemd-journald</screen>
        </step>
      </procedure>
      
      <note>
        <title>避免名稱衝突</title>
        <para>
          為避免置入式檔案與 SUSE 隨附的檔案衝突，建議在所有置入式檔案名稱前加上一個兩位數和一個破折號，例如，<filename>80-override.conf</filename>。
        </para>
        <para>
          以下範圍為保留值範圍：
        </para>
        <itemizedlist>
          <listitem>
            <para>
              <literal>0-19</literal>，為 <systemitem class="daemon">systemd</systemitem> 上游保留。
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>20-29</literal>，為 SUSE 隨附的 <systemitem class="daemon">systemd</systemitem> 保留。
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>30-39</literal>，為 SUSE 套件 (<systemitem class="daemon">systemd</systemitem> 除外) 保留。
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>40-49</literal>，為協力廠商套件保留。
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>50</literal>，為使用 <command>systemctl set-property</command> 建立的置入式單元檔案保留。
            </para>
          </listitem>
        </itemizedlist>
        <para>
          請使用大於此範圍的兩位數，以確保 SUSE 隨附的任何置入式檔案都不會覆寫您自己的置入式檔案。
        </para>
      </note>
      <tip>
        <para>
          您可以使用 <command>systemctl cat $UNIT</command> 來列出並驗證單元組態中將哪些檔案納入考量。
        </para>
      </tip>
      <tip>
        <para>
          由於 <systemitem class="daemon">systemd</systemitem> 元件的組態可能分散在檔案系統的不同位置，因此可能難以全面掌握情況。若要檢查 <systemitem class="daemon">systemd</systemitem> 元件的組態，請使用以下指令：
        </para>
        <itemizedlist>
          <listitem>
            <para>
              <command>systemctl cat
              <replaceable>UNIT_PATTERN</replaceable></command> 會列印與一或多個 <systemitem class="daemon">systemd</systemitem> 單元相關的組態檔案，例如：
            </para>
<screen><prompt>&gt; </prompt>systemctl cat atd.service</screen>
          </listitem>
          <listitem>
            <para>
              <command>systemd-analyze cat-config
              <replaceable>DAEMON_NAME_OR_PATH</replaceable></command> 會複製組態檔案的內容和 <systemitem class="daemon">systemd</systemitem> 精靈的置入式檔案，例如：
            </para>
<screen><prompt>&gt; </prompt>systemd-analyze cat-config systemd/journald.conf</screen>
          </listitem>
        </itemizedlist>
      </tip>
    </sect2>

    <sect2 xml:id="systemd-xinetd-conversion">
      <title>將 <systemitem>xinetd</systemitem> 服務轉換為 <systemitem class="daemon">systemd</systemitem></title>
      <para>
        從 <phrase role="productname"><phrase os="sled">SUSE Linux Enterprise Desktop</phrase></phrase> 15 版本開始，移除了 <systemitem>xinetd</systemitem> 基礎架構。本節概述如何將現有的自訂 <systemitem>xinetd</systemitem> 服務檔案轉換為 <systemitem class="daemon">systemd</systemitem> 通訊端。
      </para>
      <para>
        對於每個 <systemitem>xinetd</systemitem> 服務檔案，您至少需要兩個 <systemitem class="daemon">systemd</systemitem> 單元檔案：通訊端檔案 (<filename>*.socket</filename>) 和關聯的服務檔案 (<filename>*.service</filename>)。通訊端檔案告訴 <systemitem class="daemon">systemd</systemitem> 要建立哪個通訊端，服務檔案告訴 <systemitem class="daemon">systemd</systemitem> 要啟動哪個可執行檔。
      </para>
      <para>
        以下面的 <systemitem>xinetd</systemitem> 服務檔案為例：
      </para>
<screen><prompt role="root"># </prompt>cat /etc/xinetd.d/example
service example
{
  socket_type = stream
  protocol = tcp
  port = 10085
  wait = no
  user = user
  group = users
  groups = yes
  server = /usr/libexec/example/exampled
  server_args = -auth=bsdtcp exampledump
  disable = no
}</screen>
      <para>
        若要將它轉換為 <systemitem class="daemon">systemd</systemitem>，需要下面兩個相配的檔案：
      </para>
<screen><prompt role="root"># </prompt>cat /usr/lib/systemd/system/example.socket
[Socket]
ListenStream=0.0.0.0:10085
Accept=false

[Install]
WantedBy=sockets.target</screen>
<screen><prompt role="root"># </prompt>cat /usr/lib/systemd/system/example.service
[Unit]
Description=example

[Service]
ExecStart=/usr/libexec/example/exampled -auth=bsdtcp exampledump
User=user
Group=users
StandardInput=socket
</screen>
      <para>
        如需 <systemitem class="daemon">systemd</systemitem> <quote>socket</quote>和<quote>service</quote>檔案選項的完整清單，請參閱 systemd.socket 和 systemd.service 手冊頁 (<command>man 5 systemd.socket</command>、<command>man 5 systemd.service</command>)。
      </para>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-custom-targets">
      <title>建立自訂目標</title>
      <para>
        在 System V init SUSE 系統上並未使用執行層級 4，便於管理員自行建立執行層級組態。<systemitem class="daemon">systemd</systemitem> 可讓您建立任意個自訂目標。建議您在開始時先在 <systemitem>graphical.target</systemitem> 等現有的目標上調整。
      </para>
      <procedure>
        <step>
          <para>
            將組態檔案 <filename>/usr/lib/systemd/system/graphical.target</filename> 複製到 <filename>/etc/systemd/system/<replaceable>MY_TARGET</replaceable>.target</filename>，並根據需要調整該檔案。
          </para>
        </step>
        <step>
          <para>
            上一步中複製的組態檔案已涵蓋該目標的必要的 (<quote>硬</quote>) 相依性。如果還要涵蓋需要的 (<quote>軟性</quote>)相依項，請建立目錄 <filename>/etc/systemd/system/<replaceable>MY_TARGET</replaceable>.target.wants</filename>。
          </para>
        </step>
        <step>
          <para>
            對每個需要的服務，建立從 <filename>/usr/lib/systemd/system</filename> 指向 <filename>/etc/systemd/system/<replaceable>MY_TARGET</replaceable>.target.wants</filename> 的符號連結。
          </para>
        </step>
        <step>
          <para>
            設定好目標後，重新載入 <systemitem class="daemon">systemd</systemitem> 組態以使新目標可用：
          </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl daemon-reload</screen>
        </step>
      </procedure>
    </sect2>
  </sect1>
  <sect1 xml:id="sec-boot-systemd-advanced">
    <title>進階用法</title>

    <para>
      下列各節涵蓋進階主題，適用於系統管理員。如需更為進階的 <systemitem class="daemon">systemd</systemitem> 文件，請參閱 Lennart Pöttering 撰寫的適用於管理員的 <systemitem class="daemon">systemd</systemitem> 相關系列文章，網址為 <link xlink:href="https://0pointer.de/blog/projects/"/>。
    </para>

    <sect2 xml:id="sec-boot-systemd-advanced-tmp">
      <title>清理暫存目錄</title>
      <para>
        <systemitem class="daemon">systemd</systemitem> 支援定期清理暫存目錄。將會自動移轉並啟用前一系統版本中的組態。<literal>tmpfiles.d</literal> (負責管理暫存檔案) 會從 <filename>/etc/tmpfiles.d/*.conf</filename>、<filename>/run/tmpfiles.d/*.conf</filename> 和 <filename>/usr/lib/tmpfiles.d/*.conf</filename> 檔案中讀取其組態。<filename>/etc/tmpfiles.d/*.conf</filename> 中的組態會覆寫其他兩個目錄中的相關組態 (<filename>/usr/lib/tmpfiles.d/*.conf</filename> 是套件用於儲存其組態檔案的位置)。
      </para>
      <para>
        組態格式為每個路徑一行，該行包含動作與路徑、(選擇性) 模式、擁有權、期限和引數欄位，具體視動作而定。以下範例將取消連結 X11 鎖定檔案：
      </para>
<screen>Type Path               Mode UID  GID  Age Argument
r    /tmp/.X[0-9]*-lock</screen>
      <para>
        若要取得 tmpfile 計時器的狀態：
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl status systemd-tmpfiles-clean.timer
systemd-tmpfiles-clean.timer - Daily Cleanup of Temporary Directories
 Loaded: loaded (/usr/lib/systemd/system/systemd-tmpfiles-clean.timer; static)
 Active: active (waiting) since Tue 2018-04-09 15:30:36 CEST; 1 weeks 6 days ago
   Docs: man:tmpfiles.d(5)
         man:systemd-tmpfiles(8)

Apr 09 15:30:36 jupiter systemd[1]: Starting Daily Cleanup of Temporary Directories.
Apr 09 15:30:36 jupiter systemd[1]: Started Daily Cleanup of Temporary Directories.</screen>
      <para>
        如需有關暫存檔案處理的詳細資訊，請參閱 <command>man 5
        tmpfiles.d</command>。
      </para>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-advanced-logging">
      <title>系統記錄</title>
      <para>
        <xref linkend="sec-boot-systemd-basics-services-debugging"/>說明如何檢視給定服務的記錄訊息。然而，記錄的訊息顯示並不局限為服務記錄。您還可以存取和查詢 <systemitem class="daemon">systemd</systemitem> 寫入的完整記錄訊息，即所謂的<quote>日誌</quote>。使用 <command>journalctl</command> 指令可顯示從最舊項目開始的完整記錄訊息。如需套用過濾器或變更輸出格式等選項的資訊，請參閱 <command>man 1
        journalctl</command>。
      </para>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-advanced-snapshots">
      <title>快照</title>
      <para>
        您可以使用 <command>isolate</command> 子指令將 <systemitem class="daemon">systemd</systemitem> 的目前狀態儲存到指定快照中，並在日後還原到該狀態。此功能在測試服務或自訂目標時非常有用，因為它允許您隨時回到定義的狀態。快照僅在目前工作階段中可用，重新開機時將自動刪除。快照名稱必須以 <filename>.snapshot</filename> 結尾。
      </para>
      <variablelist>
        <varlistentry>
          <term>建立快照</term>
          <listitem>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl snapshot <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>刪除快照</term>
          <listitem>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl delete <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>檢視快照</term>
          <listitem>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl show <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>啟用快照</term>
          <listitem>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl isolate <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>

    

    

    <sect2 xml:id="sec-boot-systemd-advanced-kernel-modules">
      <title>載入核心模組</title>
      <para>
        將 <systemitem class="daemon">systemd</systemitem> 與 <filename>/etc/modules-load.d</filename> 中的組態檔案配合使用，可以在系統開機時自動載入核心模組。該檔案應該命名為 <replaceable>MODULE</replaceable>.conf 並包含以下內容：
      </para>
<screen># load module <replaceable>MODULE</replaceable> at boot time
<replaceable>MODULE</replaceable></screen>
      <para>
        如果某個套件安裝了用於載入核心模組的組態檔案，該檔案將安裝到 <filename>/usr/lib/modules-load.d</filename>。如果存在兩個同名的組態檔案，將以 <filename>/etc/modules-load.d</filename> 中的組態檔案為準。
      </para>
      <para>
        如需詳細資訊，請參閱 <systemitem>modules-load.d(5)</systemitem> 的手冊頁。
      </para>
    </sect2>

    

    <sect2 xml:id="sec-boot-systemd-advanced-before-local">
      <title>載入服務之前執行動作</title>
      <para>
        使用 System V init 時，需在 <filename>/etc/init.d/before.local
        </filename> 中指定需要在載入服務之前執行的動作。<systemitem class="daemon">systemd</systemitem> 不再支援此程序。如果您需要在啟動服務之前執行動作，請執行以下步驟：
      </para>
      <variablelist>
        <varlistentry>
          <term>載入核心模組</term>
          <listitem>
            <para>
              在 <filename>/etc/modules-load.d</filename> 目錄中建立一個置入式檔案 (如需語法，請參閱 <command>man modules-load.d</command>)
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>建立檔案或目錄，清理目錄，變更擁有權</term>
          <listitem>
            <para>
              在 <filename>/etc/tmpfiles.d</filename> 中建立一個置入式檔案(如需語法，請參閱 <command>man tmpfiles.d</command>)
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>其他任務</term>
          <listitem>
            <para>
              依據下面的範本建立一個系統服務檔案，例如 <filename>/etc/systemd/system/before.service</filename>：
            </para>
<screen>[Unit]
Before=<replaceable>NAME OF THE SERVICE YOU WANT THIS SERVICE TO BE STARTED BEFORE</replaceable>
[Service]
Type=oneshot
RemainAfterExit=true
ExecStart=<replaceable>YOUR_COMMAND</replaceable>
# beware, executable is run directly, not through a shell, check the man pages
# systemd.service and systemd.unit for full syntax
[Install]
# target in which to start the service
WantedBy=multi-user.target
#WantedBy=graphical.target</screen>
            <para>
              建立服務檔案後，應執行以下指令 (以 <systemitem class="username">root</systemitem> 身分)：
            </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl daemon-reload
<prompt>&gt; </prompt><command>sudo</command> systemctl enable before</screen>
            <para>
              每次修改服務檔案時，都需要執行：
            </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl daemon-reload</screen>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>

    

    <sect2 xml:id="sec-boot-systemd-advanced-cgroups">
      <title>核心控制群組 (cgroup)</title>
      <para>
        在傳統 System V init 系統上，程序並不總是能夠與產生它的服務相符。一些服務 (例如 Apache) 會產生大量協力廠商程序 (例如 CGI 或 Java 程序)，這些程序自身又會產生更多程序。這導致您很難明確指派，甚至根本無法明確指派。另外，服務可能不會正常結束，殘留某些子程序保持執行狀態。
      </para>
      <para>
        <systemitem class="daemon">systemd</systemitem> 將每個服務放入它自己的 cgroup 中，從而解決此問題。cgroup 是一項核心功能，允許將程序及其所有子程序聚合至分層組織的群組中。<systemitem class="daemon">systemd</systemitem> 根據相應的服務為每個 cgroup 命名。由於程序未經特許不得<quote>離開</quote>其 cgroup，因此這樣可以有效地使用服務名稱標記該服務繁衍的所有程序。
      </para>
      <para>
        若要列出屬於某個服務的所有程序，請使用指令 <command>systemd-cgls</command>，例如：
      </para>
      <example>
        <title>列出屬於某個服務的所有程序</title>
<screen><prompt role="root"># </prompt>systemd-cgls --no-pager
├─1 /usr/lib/systemd/systemd --switched-root --system --deserialize 20
├─user.slice
│ └─user-1000.slice
│   ├─session-102.scope
│   │ ├─12426 gdm-session-worker [pam/gdm-password]
│   │ ├─15831 gdm-session-worker [pam/gdm-password]
│   │ ├─15839 gdm-session-worker [pam/gdm-password]
│   │ ├─15858 /usr/lib/gnome-terminal-server

[...]

└─system.slice
  ├─systemd-hostnamed.service
  │ └─17616 /usr/lib/systemd/systemd-hostnamed
  ├─cron.service
  │ └─1689 /usr/sbin/cron -n
  ├─postfix.service
  │ ├─ 1676 /usr/lib/postfix/master -w
  │ ├─ 1679 qmgr -l -t fifo -u
  │ └─15590 pickup -l -t fifo -u
  ├─sshd.service
  │ └─1436 /usr/sbin/sshd -D

[...]</screen>
      </example>
      <para>
        如需 cgroup 的詳細資訊，請參閱<xref linkend="cha-tuning-cgroups"/>。
      </para>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-advanced-kill">
      <title>終止服務 (傳送訊號)</title>
      <para>
        如<xref linkend="sec-boot-systemd-advanced-cgroups"/>中所述，在 System V init 系統中不一定能將程序指派給其父服務，這導致難以停止服務及其子程序。尚未終止的子程序會保持為僵停狀態。
      </para>
      <para>
        <systemitem class="daemon">systemd</systemitem> 的概念是將每個服務限定在某個 cgroup 中，從而識別一個服務的所有子程序，這樣便可將訊號傳送給這些程序中的每一個程序。可使用 <command>systemctl kill</command> 將訊號傳送給服務。如需可用訊號的清單，請參閱 <command>man 7 signals</command>。
      </para>
      <variablelist>
        <varlistentry>
          <term>將 <systemitem>SIGTERM</systemitem> 傳送給服務</term>
          <listitem>
            <para>
              <systemitem>SIGTERM</systemitem> 是傳送的預設信號。
            </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl kill <replaceable>MY_SERVICE</replaceable></screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>將 <replaceable>SIGNAL</replaceable> 傳送給服務</term>
          <listitem>
            <para>
              可使用 <option>-s</option> 選項指定應該傳送的訊號。
            </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl kill -s <replaceable>SIGNAL</replaceable> <replaceable>MY_SERVICE</replaceable></screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>選取程序</term>
          <listitem>
            <para>
              依預設，<command>kill</command> 指令會將信號傳送給指定 cgroup 的 <option>all</option> 程序。您可以將傳送目標限制為 <option>control</option> 或 <option>main</option> 程序。例如，若要透過傳送 <systemitem>SIGHUP</systemitem> 來強制服務重新載入其組態時，便可使用後一個選項：
            </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl kill -s SIGHUP --kill-who=main <replaceable>MY_SERVICE</replaceable></screen>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-dbus">
      <title>有關 D-Bus 服務的重要說明</title>
      <para>
        D-Bus 服務是 <systemitem class="daemon">systemd</systemitem> 用戶端與做為 pid 1 執行的 systemd 管理員之間進行通訊的訊息匯流排。雖然 <systemitem class="daemon">dbus</systemitem> 是個獨立的精靈，但它也是 init 基礎架構的組成部分。
      </para>
      <para>
        在執行中的系統中停止或重新啟動 <systemitem class="daemon">dbus</systemitem> 的效果類似於嘗試停止或重新啟動 PID 1。此操作會中斷 <systemitem class="daemon">systemd</systemitem> 用戶端與伺服器間的通訊，並使大部分 <systemitem class="daemon">systemd</systemitem> 功能不可用。
      </para>
      <para>
        因此，不建議也不支援終止或重新啟動 <systemitem class="daemon">dbus</systemitem>。
      </para>
      <para>
        更新 <systemitem>dbus</systemitem> 或與 <systemitem>dbus</systemitem> 有關的套件需要重新開機。如果不確定是否需要重新開機，請執行 <command>sudo zypper ps
        -s</command>。如果 <literal>dbus</literal> 顯示在所列服務之中，則表明您需要將系統重新開機。
      </para>
      <para>
        請記住，即使自動更新設定為跳過需要重新開機的套件，<systemitem>dbus</systemitem> 仍會更新。
      </para>
    </sect2>

    

    <sect2 xml:id="sec-boot-systemd-basics-services-debugging">
      <title>服務除錯</title>
      <para>
        依預設，<systemitem class="daemon">systemd</systemitem> 的輸出不會太詳細。如果服務成功啟動，則不會產生任何輸出。如果服務啟動失敗，則會顯示簡短的錯誤訊息。不過，<command>systemctl
        status</command> 提供了對服務的啟動和操作進行除錯的方法。
      </para>
      <para>
        <systemitem class="daemon">systemd</systemitem> 隨附自己的記錄機製 (<quote>日誌</quote>)，可以記錄系統訊息，便於您一併顯示服務訊息與狀態訊息。<command>status</command> 指令的運作方式與 <command>tail</command> 相似，也可以採用不同的格式顯示記錄訊息，是一個功能強大的除錯工具。
      </para>
      <variablelist>
        <varlistentry>
          <term>顯示服務啟動失敗訊息</term>
          <listitem>
            <para>
              每當服務啟動失敗時，使用 <command>systemctl status
              <replaceable>MY_SERVICE</replaceable></command> 可獲得詳細的錯誤訊息：
            </para>
<screen><prompt role="root"># </prompt>systemctl start apache2
Job failed. See system journal and 'systemctl status' for details.
<prompt role="root"># </prompt>systemctl status apache2
   Loaded: loaded (/usr/lib/systemd/system/apache2.service; disabled)
   Active: failed (Result: exit-code) since Mon, 04 Apr 2018 16:52:26 +0200; 29s ago
   Process: 3088 ExecStart=/usr/sbin/start_apache2 -D SYSTEMD -k start (code=exited, status=1/FAILURE)
   CGroup: name=systemd:/system/apache2.service

Apr 04 16:52:26 g144 start_apache2[3088]: httpd2-prefork: Syntax error on line
205 of /etc/apache2/httpd.conf: Syntax error on li...alHost&gt;</screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>顯示最後 <replaceable>N</replaceable> 則服務訊息</term>
          <listitem>
            <para>
              <command>status</command> 子指令的預設行為是顯示服務發出的最近 10 條訊息。若要變更要顯示的訊息數量，請使用 <option>--lines=<replaceable>N</replaceable></option> 參數：
            </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl status chronyd
<prompt>&gt; </prompt><command>sudo</command> systemctl --lines=20 status chronyd</screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>以附加模式顯示服務訊息</term>
          <listitem>
            <para>
              若要顯示服務訊息的<quote>即時串流</quote>，請使用 <option>--follow</option> 選項，效果與 <command>tail</command> <option>-f</option> 相似：
            </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl --follow status chronyd</screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>訊息輸出格式</term>
          <listitem>
            <para>
              <option>--output=<replaceable>MODE</replaceable></option> 參數可讓您變更服務訊息的輸出格式。最重要的可用模式如下：
            </para>
            <variablelist>
              <varlistentry>
                <term><option>short</option></term>
                <listitem>
                  <para>
                    預設格式。顯示記錄訊息及易於理解的時戳。
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><option>verbose</option></term>
                <listitem>
                  <para>
                    完整輸出所有欄位。
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><option>cat</option></term>
                <listitem>
                  <para>
                    精簡輸出，不含時戳。
                  </para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>
  </sect1>
  <sect1 xml:id="sec-boot-systemd-timer-units">
    <title><systemitem class="daemon">systemd</systemitem> 計時器單元</title>

    <para>
      與 cron 類似，<systemitem class="daemon">systemd</systemitem> 計時器單元提供了一種在 Linux 上排程工作的機制。雖然 <systemitem class="daemon">systemd</systemitem> 計時器單元的用途與 cron 相同，但其具備幾項優點。
    </para>

    <itemizedlist>
      <listitem>
        <para>
          使用計時器單元排程的工作可以依賴於其他 <systemitem class="daemon">systemd</systemitem> 服務。
        </para>
      </listitem>
      <listitem>
        <para>
          計時器單元被視為一般 <systemitem class="daemon">systemd</systemitem> 服務，因此可以使用 <command>systemctl</command> 進行管理。
        </para>
      </listitem>
      <listitem>
        <para>
          計時器可以是即時計時器，也可以是單調計時器。
        </para>
      </listitem>
      <listitem>
        <para>
          時間單元會記錄到 <systemitem class="daemon">systemd</systemitem> 日誌中，更易於監控和疑難排解。
        </para>
      </listitem>
    </itemizedlist>

    <para>
      <systemitem class="daemon">systemd</systemitem> 計時器單元透過 <literal>.timer</literal> 副檔名識別。
    </para>

    <sect2 xml:id="sec-boot-systemd-timer-types">
      <title><systemitem class="daemon">systemd</systemitem> 計時器類型</title>
      <para>
        計時器單元可以使用單調和即時計時器。
      </para>
      <itemizedlist>
        <listitem>
          <para>
            與 cron 工作類似，即時計時器是依據行事曆事件觸發的。即時計時器使用選項 <option>OnCalendar</option> 進行定義。
          </para>
        </listitem>
        <listitem>
          <para>
            單調計時器將從某個特定起點開始經過指定時間後觸發。後者可以是系統開機或系統單元啟用事件。有幾個選項可用於定義單調計時器，包括 <option>OnBootSec</option>、<option>OnUnitActiveSec</option> 和 <option>OnTypeSec</option>。單調計時器不是永久的，每次重新開機後都會重設。
          </para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-timer-service-units">
      <title><systemitem class="daemon">systemd</systemitem> 計時器和服務單元</title>
      <para>
        每個計時器單元都必須有一個其所控制的相應 <systemitem class="daemon">systemd</systemitem> 單元檔案。也就是說，<filename>.timer</filename> 檔案負責啟用並管理對應的 <filename>.service</filename> 檔案。與計時器配合使用時，<filename>.service</filename> 檔案不需要 <literal>[Install]</literal> 區段，因為該服務由計時器管理。
      </para>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-timer-example">
      <title>具體範例</title>
      <para>
        為了理解 <systemitem class="daemon">systemd</systemitem> 計時器單元的基本知識，我們設定了一個觸發 <filename>foo.sh</filename> 外圍程序指令碼的計時器。
      </para>
      <para>
        第一步是建立用於控制外圍程序指令碼的 <systemitem class="daemon">systemd</systemitem> 服務單元。為此，請開啟一個新的文字檔案進行編輯，並新增以下服務單元定義：
      </para>
<screen>[Unit]
Description="Foo shell script"

[Service]
ExecStart=/usr/local/bin/foo.sh</screen>
      <para>
        將檔案以名稱 <filename>foo.service</filename> 儲存到目錄 <filename>/etc/systemd/system/</filename>。
      </para>
      <para>
        接下來，開啟一個新的文字檔案進行編輯，並新增以下計時器定義：
      </para>
<screen>[Unit]
Description="Run foo shell script"

[Timer]
OnBootSec=5min
OnUnitActiveSec=24h
Unit=foo.service

[Install]
WantedBy=multi-user.target</screen>
      <para>
        上述範例中的 <literal>[Timer]</literal> 區段指定了要觸發的服務 (<literal>foo.service</literal>) 以及觸發時間。在本例中，選項 <option>OnBootSec</option> 指定了一個在系統開機五分鐘後觸發服務的單調計時器，而選項 <option>OnUnitActiveSec</option> 會在服務啟用後 24 小時觸發服務 (即計時器會每天觸發一次服務)。最後，選項 <option>WantedBy</option> 指定應在系統達到多使用者目標時啟動計時器。
      </para>
      <para>
        您也可以不指定單調計時器，而是使用選項 <option>OnCalendar</option> 指定即時計時器。下面的即時計時器定義從星期一 12:00 開始，每週觸發一次相關服務單元。
      </para>
<screen>[Timer]
OnCalendar=weekly
Persistent=true</screen>
      <para>
        選項 <option>Persistent=true</option> 指示如果計時器錯過了上一次啟動時間 (例如，由於系統關閉)，則在計時器啟動後立即觸發服務。
      </para>
      <para>
        使用選項 <option>OnCalendar</option> 並採用以下格式還可以定義觸發服務的具體日期和時間：<literal>DayOfWeek Year-Month-Day Hour:Minute:Second</literal>。下面的範例會在每天早上 5 點觸發服務：
      </para>
<screen>OnCalendar=*-*-* 5:00:00</screen>
      <para>
        您可以使用星號指定任何值，使用逗號列出可能的值。使用由 .. 分隔的兩個值可表示一個連續的範圍。下面的範例會在每個月的星期五下午 6 點觸發服務：
      </para>
<screen>OnCalendar=Fri *-*-1..7 18:00:00</screen>
      <para>
        若要在不同的時間觸發服務，您可以指定多個 <option>OnCalendar</option> 項目：
      </para>
<screen>OnCalendar=Mon..Fri 10:00
OnCalendar=Sat,Sun 22:00</screen>
      <para>
        在上面的範例中，會在工作日的上午 10 點和週末的晚上 10 點觸發服務。
      </para>
      <para>
        編輯好計時器單元檔案後，使用名稱 <filename>foo.timer</filename> 將其儲存到 <filename>/etc/systemd/system/</filename> 目錄。若要檢查所建立的單元檔案是否正確，請執行以下指令：
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command>  systemd-analyze verify /etc/systemd/system/foo.*</screen>
      <para>
        如果指令未傳回任何輸出，則表示檔案成功通過驗證。
      </para>
      <para>
        若要啟動計時器，請使用指令 <command>sudo systemctl start
        foo.timer</command>。若要在開機時啟用計時器，請執行指令 <command>sudo systemctl enable foo.timer</command>。
      </para>
    </sect2>

    <sect2 xml:id="sec-boot-systemd-timer-manage">
      <title>管理 <systemitem class="daemon">systemd</systemitem> 計時器</title>
      <para>
        由於計時器被視為一般 <systemitem class="daemon">systemd</systemitem> 單元，因此您可以使用 <command>systemctl</command> 來管理它們。您可以使用 <command>systemctl start</command> 啟動計時器，使用 <command>systemctl enable</command> 啟用計時器，依此類推。此外，您還可以使用指令 <command>systemctl
        list-timers</command> 列出所有作用中計時器。若要列出所有計時器 (包括非作用中計時器)，請執行指令 <command>systemctl list-timers --all</command>。
      </para>
    </sect2>
  </sect1>
  <sect1 xml:id="sec-boot-systemd-info">
    <title>更多資訊</title>

    <para>
      如需 <systemitem class="daemon">systemd</systemitem> 的詳細資訊，請參閱以下線上資源：
    </para>

    <variablelist>
      <varlistentry>
        <term>首頁</term>
        <listitem>
          <para>
            <link xlink:href="https://systemd.io/"/>
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>面向管理員的 <systemitem class="daemon">systemd</systemitem></term>
        <listitem>
          <para>
            Lennart Pöttering 是 <systemitem class="daemon">systemd</systemitem> 的原著者之一，他撰寫了一系列部落格文章 (寫本章時已有 13 篇)。其網址為 <link xlink:href="https://0pointer.de/blog/projects/"/>。
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
  </sect1>
</chapter>
