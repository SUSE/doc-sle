<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="physical_security.xml" version="5.0" role="General" xml:id="cha-physical-security">
 <title>物理安全性</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>

   <para>
    物理安全性很重要。Linux 生产服务器应安放于加锁的数据中心之内，只有通过安全检查的人员才能访问。您也可以考虑使用引导加载程序口令，具体视环境和情况而定。
   </para>

   <para>
    此外，还要考虑如下问题：
   </para>

   <itemizedlist>
    <listitem>
     <para>
      哪些人拥有主机的直接物理访问权限？
     </para>
    </listitem>
    <listitem>
     <para>
      他们是否应拥有这些权限？
     </para>
    </listitem>
    <listitem>
     <para>
      是否可以保护主机不被篡改，以及是否应进行此保护？
     </para>
    </listitem>
   </itemizedlist>

   <para>
    特定系统上所需的物理安全措施数量视情况而定，并且可用资金不同，安全措施也可能会有很大差别。
   </para>

   <sect1 xml:id="sec-sec-prot-general-physical-locks">
    <title>系统锁</title>
    <para>
     数据中心内的大部分服务器机架都包含锁定功能。这是位于机架正面的搭扣锁/圆筒锁，可让您转动插入锁定（或未锁定）位置的钥匙，以允许（或拒绝）进入。笼锁可防止有人篡改或窃取服务器的设备/介质，或者开箱直接操作/破坏硬件。防止系统重引导或从替代设备（例如 CD、DVD、闪存盘等）引导也很重要。
    </para>
    <para>
     一些服务器还配有箱锁。根据系统供应商的设计和构造，这些锁可以发挥不同的作用。许多系统都设计为当尝试打开未开锁的系统时进行自我禁用。其他配有设备保护盖的系统将不允许插入或拔下键盘或鼠标。虽然有时锁是一项很实用的功能，但它们质量较差，很容易被恶意攻击者破坏。
    </para>
  </sect1>
    <sect1 xml:id="sec-sec-prot-general-bios">
   <title>锁定 BIOS</title>

   <tip>
    <title>安全引导</title>
    <para>
     本节介绍确保引导进程安全的基本方法。要了解使用 UEFI 和安全引导功能的更高级引导保护的相关信息，请参见<xref linkend="sec-uefi-secboot"/>。
    </para>
   </tip>

   <para>
    BIOS（基本输入/输出系统）或其继承者 UEFI（统一可扩展固件接口）是 PC 类系统上最低级别的软件/固件。运行 Linux 的其他硬件类型（POWER、IBM Z）配有执行与 PC BIOS 类似功能的低级别固件。当本文档提及 BIOS 时，指的是 BIOS 和/或 UEFI。BIOS 指示系统配置，使系统处于一个明确定义的状态，并提供访问低级别硬件的例程。BIOS 执行已配置的 Linux 引导加载程序（例如 GRUB 2）来引导主机。
   </para>

   <para>
    大部分 BIOS 实施都可配置为阻止未经授权的用户操作系统及引导设置。通常通过设置 BIOS 管理员或引导口令来完成。更改系统配置时需要输入管理员口令，而在每次正常引导时需要提供引导口令。对于大多数用例，设置管理员口令并将引导限制为内置硬盘便已足够。这样，攻击者便无法仅仅引导 Linux live CD 或闪存盘等设备。虽然这并不会提供高级别的安全（BIOS 可以被重置、去除或修改 — 假设用例访问权限），但它可以作为另一种保护措施。
   </para>

   <para>
    许多 BIOS 固件实现都提供其他安全相关设置。您可以咨询系统供应商，查阅系统文档或在系统引导时检查 BIOS，来了解更多信息。
   </para>

   <important>
    <title>在设置了 BIOS 引导口令的情况下引导</title>
    <para>
     如果为系统设置了引导口令，主机将不会在无人照管的情况下引导（例如当系统重引导或发生电源故障时）。这是一种权衡。
    </para>
   </important>
   <important>
    <title>丢失 BIOS 管理员口令</title>
    <para>
     首次设置系统时，通常不需要提供 BIOS 管理员口令。请勿忘记该口令，否则您将需要通过硬件操作清除 BIOS 内存来再次获得访问权限。
    </para>
   </important>
  </sect1>
  <sect1 xml:id="sec-sec-prot-general-bootloader">
   <title>通过引导加载程序提供的安全性</title>

   <para>
    <phrase role="productname"><phrase os="sled">SUSE Linux Enterprise Desktop</phrase></phrase> 中默认使用的 Linux 引导加载程序 GRUB 2 可设置引导口令。它还提供了口令功能，以便只有管理员才能启动交互操作（例如编辑菜单项和进入命令行界面）。如果指定了口令，在您按 <keycap>C</keycap> 键和 <keycap>E</keycap> 键并输入正确的口令之前，GRUB 2 将不允许进行任何交互控制。
   </para>

   <para>
    有关示例，请参见 GRUB 2 手册页。
   </para>

   <para>
    设置这些口令时请务必记住它们。此外，启用这些口令可能只会减缓入侵，而不一定能阻止入侵。同样，有些人可能会从移动设备引导，并挂载您的根分区。如果您使用的是 BIOS 级别安全性和引导加载程序，比较好的做法是禁用从您计算机 BIOS 中的可移动设备进行引导的功能，然后通过口令来保护 BIOS 本身。
   </para>

   <para>
    另请注意，需要将引导加载程序配置文件的模式更改为 <literal>600</literal>（仅限 <systemitem class="username">root</systemitem> 读取/写入）以对其进行保护，否则其他人将能够读取您的口令或哈希。
   </para>
  </sect1>

    <sect1 xml:id="sec-sec-prot-general-retiring">
   <title>淘汰包含敏感数据的 Linux 服务器</title>

   <para>

    安全策略包含即将被淘汰或被处置的存储媒体的特定处理过程。常常采用磁盘和媒体擦除过程，因为这会彻底销毁媒体。您可以在互联网上找到多个免费工具。搜索<quote>dod 磁盘擦除实用程序</quote>将返回多个搜索结果。要淘汰包含敏感数据的服务器，请务必确保无法从硬盘恢复数据。要确保已去除所有数据痕迹，可以使用 <command>scrub</command> 等擦除实用程序。许多擦除实用程序都会多次重写数据。这样可确保即使使用复杂的方法，也无法取回已擦除数据的任何部分。一些工具甚至可通过可引导移动设备来操作，并可根据美国国防部 (DoD) 标准去除数据。许多政府机构都会指定自己的数据安全标准。一些标准可能强于其他标准，但可能需要更多的实施时间。
   </para>

   <important>
    <title>擦除耗损均衡设备</title>
    <para>
     一些设备（例如 SSD）使用耗损均衡功能，不一定会在同一物理位置写入新数据。此类设备会提供自己的删除功能。
    </para>
   </important>

   <sect2 xml:id="sec-sec-prot-general-retiring-scrub">
    <title>scrub：磁盘重写实用程序</title>
    <para>
     <command>scrub</command> 利用重复模式来重写硬盘、文件和其他设备，旨在增加从这些设备恢复数据的难度。它有三种基本操作模式：针对字符或块设备、针对文件，或者针对指定目录。有关详细信息，请参见手册页 <command>man 1 scrub</command>。
    </para>
    <variablelist>
     <title>支持的擦除方法</title>
     <varlistentry>
      <term>nnsa</term>
      <listitem>
       <para>
        用于清理可移动和不可移动硬盘的 4 轮 NNSA Policy Letter NAP-14.1-C (XVI-8)，需要使用伪随机模式重写所有位置两次，然后使用一种已知模式：random(x2)、0x00、verify。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>dod</term>
      <listitem>
       <para>
        与 4 轮 DoD 522.22-M 第 8-306 节的过程 (d) 相同，用于清理可移动和不可移动加固磁盘。这需要使用一个字符、其补码、随机字符重写所有可寻址位置，然后进行校验。注意：scrub 首先执行一轮随机，以使校验更容易：random、0x00、0xff、verify。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>bsi</term>
      <listitem>
       <para>
        德国信息技术安全中心 (<link xlink:href="https://www.bsi.bund.de"/>) 建议的 9 轮方法：0xff、0xfe、0xfd、0xfb、0xf7、0xef、0xdf、0xbf、0x7f。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>gutmann</term>
      <listitem>
       <para>
        下面引述的 Gutmann 文献中对规范化 35 轮序列进行了说明。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>schneier</term>
      <listitem>
       <para>
        Bruce Schneier 在“Applied Cryptography”（应用密码学，1996）中介绍的 7 轮方法：0x00、0xff、random(x5)
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>pfitzner7</term>
      <listitem>
       <para>
        Roy Pfitzner 的 7 轮随机方法：random(x7)。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>pfitzner33</term>
      <listitem>
       <para>
        Roy Pfitzner 的 33 轮随机方法：random(x33)。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>usarmy</term>
      <listitem>
       <para>
        US Army AR380-19 方法：0x00、0xff、random。（注意：与 DoD 522.22-M 第 8-306 节的过程 (e) 相同，用于清理磁芯内存）。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>fillzero</term>
      <listitem>
       <para>
        1 轮模式：0x00。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>fillff</term>
      <listitem>
       <para>
        1 轮模式：0xff。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>random</term>
      <listitem>
       <para>
        1 轮模式：random(x1)。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>random2</term>
      <listitem>
       <para>
        2 轮模式：random(x2)。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>old</term>
      <listitem>
       <para>
        6 轮预发行版 1.7 擦除方法：0x00、0xff、0xaa、0x00、0x55、verify。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>fastold</term>
      <listitem>
       <para>
        5 轮模式：0x00、0xff、0xaa、0x55 和 verify。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>custom=string</term>
      <listitem>
       <para>
        1 轮自定义模式。字符串可能包含 C 样式数字转义符：\nnn（八进制）或 \xnn（十六进制）。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect2>
  </sect1>

    <sect1 xml:id="sec-sec-prot-general-removable-media">
    <title>限制对可移动媒体的访问</title>
    <para>
     在某些环境中，需要对可移动媒体的访问，例如 USB 存储设备或光学设备。<systemitem>udisks2</systemitem> 软件包随附的工具可帮助进行此类配置。
    </para>

    <procedure>
     <step>
      <para>
       创建允许用户挂载和弹出可移动设备的用户组，例如 <replaceable>mmedia_all</replaceable>：
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> groupadd <replaceable>mmedia_all</replaceable></screen>
     </step>
     <step>
      <para>
       向新组添加特定用户 <systemitem class="username">tux</systemitem>：
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> usermod -a -G <replaceable>mmedia_all</replaceable> <systemitem class="username">tux</systemitem></screen>
     </step>
     <step>
      <para>
       创建包含以下内容的 <filename>/etc/polkit-1/rules.d/10-mount.rules</filename> 文件：
      </para>
<screen>
<prompt>&gt; </prompt>cat /etc/polkit-1/rules.d/10-mount.rules
polkit.addRule(function(action, subject) {
 if (action.id =="org.freedesktop.udisks2.eject-media"
  &amp;&amp; subject.isInGroup("<replaceable>mmedia_all</replaceable>")) {
   return polkit.Result.YES;
  }
});

polkit.addRule(function(action, subject) {
 if (action.id =="org.freedesktop.udisks2.filesystem-mount"
  &amp;&amp; subject.isInGroup("<replaceable>mmedia_all</replaceable>")) {
   return polkit.Result.YES;
  }
});
</screen>
      <important>
       <title>规则文件命名</title>
       <para>
        规则文件的名称必须以数字开头，否则将忽略该名称。
       </para>
       <para>
        规则文件按字母顺序进行处理。函数按其添加的顺序进行调用，直到其中一个函数返回值为止。因此，要添加在其他规则之前处理的授权规则，请将其放入 /etc/polkit-1/rules.d 中名称排序在其他规则文件之前的某个文件中，例如 <filename>/etc/polkit-1/rules.d/10-mount.rules</filename>。每个函数应从 <literal>polkit.Result</literal> 返回值。
       </para>
      </important>
     </step>
     <step>
      <para>
       重启动 <systemitem>udisks2</systemitem>:
      </para>
<screen><prompt role="root"># </prompt>systemctl restart udisks2</screen>
     </step>
     <step>
      <para>
       重启动 <systemitem>polkit</systemitem>
      </para>
<screen><prompt role="root"># </prompt>systemctl restart polkit</screen>
     </step>
    </procedure>
   </sect1>
  <sect1 xml:id="sec-USBGuard">
<title>通过 <emphasis>USBGuard</emphasis> 强制执行 USB 设备授权，实现系统保护</title>
<para>
  USBGuard 软件框架通过强制执行的 USB 设备授权来帮助保护您的系统。它根据设备属性实现允许列表和阻止列表功能。
</para>
<para>USBGuard 提供以下功能：</para>
<itemizedlist>
  <listitem>
   <para>
    用于与正在运行的 USBGuard 守护程序交互的命令行界面
    </para>
  </listitem>
  <listitem>
   <para>具有进程间通讯 (IPC) 接口的守护程序组件，用于动态交互和策略实施</para>
  </listitem>
  <listitem>
   <para>用于编写 USB 设备授权策略的规则语言</para>
  </listitem>
  <listitem><para>用于与共享库中实施的守护程序组件交互的 C++ API</para></listitem>
   </itemizedlist>
   <sect2 xml:id="sec-installing-usbguard">
    <title>安装 USBGuard</title>
    <para> USBGuard 守护程序根据策略中定义的一组规则决定对哪个 USB 设备授权。要安装和配置 USBGuard，请使用以下命令：</para>
    <procedure>
      <step><para>要安装 USBGuard，请使用以下命令：</para>
      <screen><prompt>&gt; </prompt><command>sudo</command>  zypper install usbguard</screen>
    <para>系统会安装 USBGuard 和所需的依赖项。如果要与 USBGuard 服务进行交互，可以安装 <literal>usbguard-tools</literal>。</para>
    </step>
    <step><para>要根据当前连接的 USB 设备生成规则集，请切换到 <systemitem class="username">root</systemitem>： </para>
      <screen><prompt role="root"># </prompt>usbguard generate-policy &gt; /etc/usbguard/rules.conf</screen>
      <note><para>您可以通过编辑 <filename>/etc/usbguard/rules.conf</filename> 文件来自定义 USBGuard。
      </para></note>
    </step>
    <step><para> 您可以手动启动 USBGuard 守护程序，或者通过切换到 <systemitem class="username">root</systemitem> 来确保在系统启动时自动启用该守护程序：</para>
      <screen><prompt role="root"># </prompt>systemctl enable --now usbguard.service</screen>
        </step>
    <step><para> 您可以授权或取消授权设备与系统交互，具体取决于 <filename>usbguard-daemon.conf
      </filename> 文件中选项 <literal>ImplicitPolicyTarget</literal> 的值。此选项用于处理与策略中的任何规则都不匹配的设备。
    </para>
      <screen>usbguard allow-device 6</screen>
      <screen>usbguard block-device 6</screen>
      <para> 您还可以使用 <command>reject-device</command> 选项取消授权，并从系统中去除设备。
              </para>
      <note><para>可以使用 <command>usbguard --help </command> 命令查看所有选项。</para></note>
    </step>
    </procedure>
   </sect2>
<sect2 xml:id="sec-how-to-use-usbguard">
<title>如何使用 USBGuard</title>
<para>您可以配置安全策略，基于设备属性实现<emphasis>允许</emphasis>和<emphasis>阻止</emphasis>列表，从而通过强制执行的 USB 设备授权来保护您的系统。
</para>
<sect3><title>USBGuard 配置文件 </title>
  <para>当系统分析命令行选项并使用它们配置 USBGuard 守护程序的运行时参数后，USBGuard 守护程序会加载 <filename>usbguard-daemon.conf</filename> 文件。默认情况下，该文件位于 <filename>/etc/usbguard/usbguard-daemon.conf</filename>。文件中的一些选项包括：</para>
<variablelist>
  <title>选项</title>
  <varlistentry>
    <term><option>RuleFile=<replaceable>PATH</replaceable></option></term>
    <listitem>
    <para>USBGuard 守护程序会从此文件中加载策略规则集，并在其中编写通过 IPC（进程间通讯）接口接收的新规则。默认为 <filename>%sysconfdir%/usbguard/rules.conf</filename>。</para> </listitem>
   </varlistentry>
   <varlistentry>
    <term><option>ImplicitPolicyTarget= <replaceable>TARGET</replaceable></option></term>
   <listitem>
    <para> 如何处理与策略中的任何规则都不匹配的设备，例如： </para>
    <itemizedlist>
      <listitem>
         <para>允许 - 对每个现有设备授权</para>
      </listitem>
      <listitem>
         <para>阻止 - 取消对每个现有设备的授权</para>
      </listitem>
      <listitem>
        <para>拒绝 - 在逻辑上从系统中去除设备节点</para>
     </listitem>
      </itemizedlist>
    </listitem></varlistentry>
    <varlistentry>
      <term><option>PresentDevicePolicy= <replaceable>POLICY</replaceable></option></term>
     <listitem>
      <para>如何处理守护程序启动时已连接的设备。</para>
      <itemizedlist>
        <listitem>
           <para>允许 - 对每个现有设备授权</para>
        </listitem>
        <listitem>
           <para>阻止 - 取消对每个现有设备的授权</para>
        </listitem>
        <listitem>
          <para>拒绝 - 去除所有现有设备</para>
       </listitem>
       <listitem>
        <para>保留 - 同步内部状态 </para>
     </listitem>
     <listitem>
      <para>应用策略 - 评估所有现有设备的规则集 </para>
   </listitem>
    </itemizedlist>
      </listitem></varlistentry>
    <varlistentry>
      <term><option>IPCAllowedUsers= <replaceable>USERNAME</replaceable></option></term>
       <listitem>
      <para>以空格分隔的用户名列表，守护程序接受来自这些用户的 IPC 连接。</para>
      </listitem>
        </varlistentry>
        <varlistentry>
          <term><option>IPCAllowedGroups= <replaceable>GROUPNAME</replaceable></option></term>
           <listitem>
          <para>以空格分隔的组名列表，守护程序接受来自这些组的 IPC 连接。</para>
          </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>IPCAccessControlFiles= <replaceable>PATH</replaceable></option></term>
               <listitem>
              <para>文件路径，守护程序将这些文件解释为 IPC 访问控制定义文件。</para>
              </listitem>
                </varlistentry>
   </variablelist>
      <example xml:id="usbguard-config-file-ipcaccess">
    <title>配置</title>
 <screen>IPCAllowedUsers=root joe
IPCAllowedGroups=wheel</screen>
<para>该示例允许用户 <literal>root</literal>、<literal>joe</literal> 和组 <literal>wheel</literal> 的成员拥有完整的 IPC 权限。</para>
    </example>
</sect3>
</sect2>
<sect2 xml:id="sec-more-information-usbguard">
<title>更多信息</title>
<para>要了解 USBGuard 的详细信息，请参见： </para>
<itemizedlist>
  <listitem>
    <para>
      <link xlink:href="https://usbguard.github.io/"/> 中的上游文档
    </para>
  </listitem>
  <listitem>
    <para>
      <emphasis>Usbguard</emphasis> 手册页
    </para>
  </listitem>
  <listitem>
    <para>
      <emphasis>Usbguard-rules.conf</emphasis> 手册页
    </para>
  </listitem>
    <listitem>
    <para>
      <emphasis>usbguard-daemon</emphasis> 手册页
    </para>
  </listitem>
    <listitem>
    <para>
      <emphasis>usbguard-daemon.conf</emphasis> 手册页
    </para>
  </listitem>
</itemizedlist>
</sect2>
  </sect1>

  </chapter>
