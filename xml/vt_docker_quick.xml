<?xml version="1.0"?>
<?xml-stylesheet href="urn:x-suse:xslt:profiling:novdoc-profile.xsl" type="text/xml" title="Profiling step"?>
<!DOCTYPE article PUBLIC "-//Novell//DTD NovDoc XML V1.0//EN" "novdocx.dtd"
[
<!ENTITY % NOVDOC.DEACTIVATE.IDREF "INCLUDE">
<!ENTITY % entities SYSTEM "entity-decl.ent">
%entities;
]>
<article id="art.docker" lang="en">
<?suse-quickstart color="suse"?>
 <title>Docker Quick Start</title>
<!-- <subtitle>&productname; &productnumber;</subtitle> -->
 <articleinfo><productname>&productname;</productname>
  <productnumber>&productnumber;</productnumber><date>
<?dbtimestamp format="B d, Y"?></date>
 </articleinfo>
 <abstract>
  <para>
   This guide introduces Docker, a lightweight virtualization solution to
   run virtual units simultaneously on a single control host.
  </para>
 </abstract>
 <para>
  Docker is a lightweight virtualization solution to run multiple virtual
  units (containers) simultaneously on a single control host. Containers are
  isolated with Kernel Control Groups
  (<xref
  linkend="vle.docker.cgroup"/>) and
  <xref linkend="vle.docker.namespace"/>.
 </para>
 <para>
  Full virtualization solutions such as &xen;, &kvm;, or &libvirt; are based
  on the processor simulating a complete hardware environment and
  controlling the virtual machines. However, Docker only provides operating
  system-level virtualization where the Linux kernel controls isolated
  containers.
 </para>
 <sect1 id="sec.docker.term">
  <title>Terminology</title>

  <para>
   The following list contains important terminology and introduces you to
   certain fundamental concepts of Docker.
   <remark>taroth 2014-10-30: aginies,
    perhaps sort the terms alphabetically? like in a glossary?</remark>
  </para>

  <variablelist>
   <varlistentry id="vle.docker.cgroup">
    <term>cgroups</term>
    <listitem>
     <para>
      Control Groups is a Linux kernel feature that allows aggregating or
      partitioning tasks (processes) and all their children into
      hierarchically organized groups to isolate resources.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Image</term>
    <listitem>
     <para>
      A <emphasis>virtual machine</emphasis> on the host server that can run
      any Linux system, for example &sls;, &sled;, or &opensuse;. A Docker
      image is made by a series of layers built one over the other. Each
      layer corresponds to a permanent change committed from a container to
      the image. For more details, see the official Docker documentation at
      <ulink url="http://docs.docker.com/terms/image/"/>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Image Name</term>
    <listitem>
     <para>
      A name that refers to an image. The name is used by the Docker
      commands.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Container</term>
    <listitem>
     <para>
      A running Docker image.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Container ID</term>
    <listitem>
     <para>
      An ID that refers to a particular container. The ID is used by the
      Docker commands.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Tag</term>
    <listitem>
     <para>
      A string associated with an image. It is commonly used to identify a
      specific version of an image (similar to tags in version control
      systems). It is also possible to refer the same image with different
      tags.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry id="vle.docker.namespace">
    <term>Kernel Namespaces</term>
    <listitem>
     <para>
      Namespaces are a kernel feature to isolate some resources like
      network, users, and others for a group of processes.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Docker Host Server</term>
    <listitem>
     <para>
      The system that runs the Docker daemon, and provides images and
      management control capabilities through
      <xref linkend="vle.docker.cgroup"/>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Registry</term>
    <listitem>
     <para>
      A remote storage for Docker images.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Repository</term>
    <listitem>
     <para>
      Place where all the version of a Docker image are kept.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 id="sec.docker.overview">
  <title>Overview</title>

  <para>
   Docker is a platform that allows developers and system administrators to
   manage the complete life cycle of images. Docker makes it easy to build,
   ship and run images containing applications.
  </para>

  <itemizedlist>
   <title>Benefits of Docker</title>
   <listitem>
    <para>
     Isolation of applications and operating systems through containers.
    </para>
   </listitem>
   <listitem>
    <para>
     Near native performance, as Docker manages allocation of resources in
     real-time.
    </para>
   </listitem>
   <listitem>
    <para>
     Controls network interfaces and resources available inside containers
     through cgroups.
    </para>
   </listitem>
   <listitem>
    <para>
     Versioning of images.
    </para>
   </listitem>
   <listitem>
    <para>
     Allows building new images based on existing ones.
    </para>
   </listitem>
   <listitem>
    <para>
     Docker Hub allows sharing and storing of images on
     <ulink
     url="http://docs.docker.com/docker-hub/">public</ulink> or
     <ulink
     url="http://docs.docker.com/userguide/dockerrepos/#private-repositories">
     private</ulink> repositories.
    </para>
   </listitem>
  </itemizedlist>

  <itemizedlist>
   <title>Limitations of Docker</title>
   <listitem>
    <para>
     Containers run inside the host system's kernel and cannot use a
     different kernel.
    </para>
   </listitem>
   <listitem>
    <para>
     Only allows Linux <emphasis>guest</emphasis> operating systems.
    </para>
   </listitem>
   <listitem>
    <para>
     Docker is not a full virtualization stack like &xen;, &kvm;, or
     &libvirt;.
    </para>
   </listitem>
   <listitem>
    <para>
     Security depends on the host system. Refer to the
     <ulink url="http://docs.docker.com/articles/security/">official
     security documentation</ulink> for more details.
    </para>
   </listitem>
  </itemizedlist>

  <sect2 id="sec.docker.containerd">
   <title>Container Drivers</title>
   <para>
    Docker has different back-end drivers to handle containers:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      <ulink url="https://github.com/docker/libcontainer">libcontainer</ulink>:
      this is the recommended driver and the default choice.
     </para>
    </listitem>
    <listitem>
     <para>
      &lxc;: this driver handles the containers using the &lxc; tools.
      &productname; &productnumber; does not provide the &lxc; package,
      hence this driver cannot be used.
     </para>
    </listitem>
    <listitem>
     <para>
      <systemitem class="library">libvirt-lxc</systemitem>: this driver
      controls the containers using the
      <ulink url="http://libvirt.org/drvlxc.html">libvirt-lxc</ulink> tool.
      At the time of writing this driver is not yet mature as the others.
     </para>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 id="sec.docker.storaged">
   <title>Storage Drivers</title>
   <para>
    Docker supports different storage drivers:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      <systemitem class="resource">vfs</systemitem>: this driver is
      automatically used when the Docker host file system does not support
      copy-on-write. This is a simple driver which does not offer some of
      the advantages of Docker (like sharing layers, more on that in the
      next sections). It is highly reliable but also slow.
     </para>
    </listitem>
    <listitem>
     <para>
      <systemitem class="resource">devicemapper</systemitem>: this driver
      relies on the device-mapper thin provisioning module. It supports
      copy-on-write, hence it offers all the advantages of Docker.
     </para>
    </listitem>
    <listitem>
     <para>
      <systemitem class="resource">btrfs</systemitem>: this driver relies on
      Btrfs to provide all the features required by Docker. To use this
      driver the <filename>/var/lib/docker</filename> directory must be on a
      Btrfs file system.
     </para>
    </listitem>
    <listitem>
     <para>
      <systemitem class="resource">AUFS</systemitem>: this driver relies on
      AUFS union file system. Neither the upstream kernel nor the SUSE one
      supports this file system. Hence the AUFS driver is not built into the
      SUSE Docker package.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    &slea;&nbsp;12 uses the Btrfs file system by default, which leads Docker
    to use the <systemitem class="resource">btrfs</systemitem> driver.
   </para>
   <para>
    It is possible to specify which driver to use by changing the value of
    the <envar>DOCKER_OPTS</envar> variable defined inside of the
    <filename>/etc/sysconfig/docker</filename> file. This can be done either
    manually or using &yast; by browsing to <menuchoice>
    <guimenu>System</guimenu> <guimenu>/etc/sysconfig Editor</guimenu>
    <guimenu>System</guimenu> <guimenu>Management</guimenu>
    <guimenu>DOCKER_OPTS</guimenu> </menuchoice> menu and entering the
    <systemitem class="library">-s storage_driver</systemitem> string.
   </para>
   <para>
    For example, to force the usage of the
    <systemitem class="resource">devicemapper</systemitem> driver enter the
    following text:
   </para>
<screen>DOCKER_OPTS="-s devicemapper"</screen>
   <note>
    <para>
     It is recommended to have <filename>/var/lib/docker</filename> mounted
     on a different file system to not affect the Docker host operating
     system in case of a file system corruption.
    </para>
   </note>
  </sect2>
 </sect1>
 <sect1 id="sec.docker.setup">
  <title>Setting Up a Docker Host</title>

  <para></para>

  <sect2 id="sec.docker.setup.general">
   <title>General Preparation</title>
   <para>
    Prepare the host as described below. Before installing any
    Docker-related packages, you need to enable the container module:
   </para>
<!--taroth 2015-07-02: http://doccomments.provo.novell.com/comments/28724 -->
   <procedure>
    <title>Enabling the Container Module</title>
    <step>
     <para>
      Start &yast;, and select <menuchoice> <guimenu>Software</guimenu>
      <guimenu> Software Repositories</guimenu> </menuchoice>.
     </para>
    </step>
    <step>
     <para>
      Click <guimenu>Add</guimenu> to open the add-on dialog.
     </para>
    </step>
    <step>
     <para>
      Select <guimenu>Extensions and Modules from Registration
      Server</guimenu> and click <guimenu>Next</guimenu>.
     </para>
    </step>
    <step>
     <para>
      From the list of available extensions and modules, select
      <guimenu>Container Module 12 x86_64</guimenu> and click
      <guimenu>Next</guimenu>.
     </para>
     <para>
      The containers module and its repositories will be added to your
      system.
     </para>
    </step>
    <step>
     <para>
      If you use &smtool;, update the list of repositories at the &smt;
      server.
     </para>
    </step>
   </procedure>
   <procedure>
    <title>Installing and Setting Up Docker</title>
    <step>
     <para>
      Install the <systemitem>docker</systemitem> package:
     </para>
<screen>sudo zypper install docker</screen>
    </step>
    <step>
     <para>
      To automatically start the Docker service at boot time:
     </para>
<screen>sudo systemctl enable docker.service</screen>
     <para>
      This will automatically enable docker.socket in consequence.
     </para>
    </step>
    <step>
     <para>
      Start the Docker service:
     </para>
<screen>sudo systemctl start docker.service</screen>
     <para>
      This will automatically start docker.socket in consequence.
     </para>
    </step>
   </procedure>
   <para>
    The Docker daemon listens on a local socket which is accessible only by
    the <systemitem class="username">root</systemitem> user and by the
    members of the <systemitem class="groupname">docker</systemitem> group.
    The <systemitem class="groupname">docker</systemitem> group is
    automatically created at package installation time. To allow a certain
    user to connect to the local Docker daemon, use the following command:
   </para>
<screen>sudo /usr/sbin/usermod -aG docker <replaceable>USERNAME</replaceable></screen>
   <para>
    The user can communicate with the local Docker daemon upon his next
    login.
   </para>
  </sect2>

  <sect2 id="sec.docker.setup.net">
   <title>Networking</title>
   <para>
    If you want your containers to be able to access the external network,
    you must enable the <option>ipv4 ip_forward</option> rule. This can be
    done using &yast; by browsing to <menuchoice> <guimenu>Network
    Devices</guimenu> <guimenu>Network Settings</guimenu>
    <guimenu>Routing</guimenu> </menuchoice> menu and ensuring
    <option>Enable IPv4 Forwarding</option> is checked.
   </para>
   <para>
    This option cannot be changed when networking is handled by the Network
    Manager. In such cases the
    <filename>/etc/sysconfig/SuSEfirewall2</filename> file needs to be
    edited by hand to ensure the <option>FW_ROUTE</option> flag is set to
    <option>yes</option>:
   </para>
<screen>FW_ROUTE="yes"</screen>
  </sect2>
 </sect1>
 <sect1 id="sec.docker.basic">
  <title>Basic Docker Operations</title>

  <para>
   Images can be pulled from Docker's central index at
   <ulink url="http://index.docker.io"/> using the following command:
  </para>

<screen>docker pull <replaceable>IMAGE_NAME</replaceable></screen>

  <para>
   Containers can be started using the <command>docker run</command>
   command. Refer to the official documentation of Docker at
   <ulink url="http://docs.docker.com/"/> for more details.
  </para>
 </sect1>
 <sect1 id="sec.docker.building_images">
  <title>Building Docker Images</title>

  <para>
   Starting with version 5.06.8, &kiwi; can be used to build Docker images.
   Also see the official &kiwi; documentation, in particular
   <ulink url="https://doc.opensuse.org/projects/kiwi/doc/#chap.lxc"/>. The
   official <systemitem>kiwi-doc</systemitem> package contains examples of
   Docker images.
  </para>

  <para>
   Docker has an
   <ulink url="http://docs.docker.com/reference/builder/">internal build
   system</ulink> which can be used to create new images based on existing
   ones.
  </para>

  <para>
   Some users might be confused about which build system to use for what
   task. The recommended approach is to customize the official &slea; images
   for Docker using the Docker build system. This approach has two
   advantages:
  </para>

  <itemizedlist>
   <listitem>
    <para>
     You can use Docker-specific directives (like
     <literal>ENTRYPOINT</literal>, <literal>EXPOSE</literal>, ...).
    </para>
   </listitem>
   <listitem>
    <para>
     You can re-use existing layers.
    </para>
   </listitem>
  </itemizedlist>

  <para>
   Sharing the common layers between different images makes it possible to:
  </para>

  <itemizedlist>
   <listitem>
    <para>
     Use less disk space on the Docker hosts and on the remote registry
     service.
    </para>
   </listitem>
   <listitem>
    <para>
     Deploy faster: only the requested layers are sent over the network
     (this is similar to upgrading installed packages using delta RPMs).
    </para>
   </listitem>
   <listitem>
    <para>
     Take full advantage of caching while building Docker images: this will
     result in faster executions of the <command>docker build</command>
     command.
    </para>
   </listitem>
  </itemizedlist>

  <para>
   &suse; creates the official
   <ulink url="http://docs.docker.com/reference/glossary/#base-image">base
   images</ulink> using &kiwi; and publishes them to allow customers to use
   those as foundation blocks inside of the Docker build system. Only the
   Docker images built on top of our official ones via the Docker build
   system are going to be supported.
  </para>
 </sect1>
 <sect1 id="sec.docker.sle_images">
  <title>&sle; Images for Docker</title>

  <para>
   Currently we cannot distribute &slea; images for Docker because there is
   no way to associate an End-User License Agreement (EULA) to a Docker
   image. However, we provide official pre-built Docker images for &slea;
   and a convenience tool called
   <ulink url="https://github.com/SUSE/sle2docker">sle2docker</ulink> that
   can be used to activate these images locally.
  </para>

  <para>
   Pre-built images do not have repositories configured. But when the Docker
   host has a SLE subscription that provides access to the product used in
   the image, Zypper will automatically have access to the right
   repositories. For more details see
   <xref
   linkend="sec.docker.sle_images.customizing_the_images"/>.
  </para>

  <sect2 id="sec.docker.sle_images.sle2docker_install">
   <title>Installing sle2docker</title>
   <para>
    The <command>sle2docker</command> tool is part of the official container
    module. It can be installed using the following command:
   </para>
<screen>sudo zypper install sle2docker</screen>
   <note>
    <para>
     <command>sle2docker</command> requires the Docker daemon to be running
     on the system.
    </para>
   </note>
  </sect2>

  <sect2 id="sec.docker.sle_images.activate">
   <title>Activating the Pre-built Docker Images</title>
   <para>
    The official pre-built Docker images for &slea; are shipped as RPM
    packages inside of the <literal>containers</literal> module. They can be
    installed using Zypper:
   </para>
<screen>sudo zypper in sles11sp3-docker-image sles12-docker-image</screen>
   <para>
    <command>sle2docker</command> can list the available pre-built images
    with the following command:
   </para>
<screen>sle2docker list</screen>
   <para>
    To activate a pre-built image, use the following command:
   </para>
<screen>sle2docker activate <replaceable>PRE-BUILT_IMAGE_NAME</replaceable></screen>
   <para>
    At the end of the activation, <command>sle2docker</command> will print
    the name of the Docker image that has been created.
   </para>
  </sect2>

  <sect2 id="sec.docker.sle_images.customizing_the_images">
   <title>Customizing the Images</title>
   <para>
    To create custom Docker images based on the official ones use
    <ulink url="http://docs.docker.com/reference/builder/"> Docker's
    integrated build system </ulink>.
   </para>
   <para>
    The pre-built images do not have any repository configured. They contain
    a <ulink url="https://github.com/SUSE/container-suseconnect"> zypper
    service</ulink> that contacts either the &scc; (SCC) or your
    Subscription Management Tool (&smt;) server, according to the
    configuration of the &slea; host that runs the Docker container. The
    service obtains the list of repositories available for the product used
    by the Docker image.
   </para>
   <para>
    You do not need to add any credentials to the Docker image because the
    machine credentials are automatically injected into the container by the
    docker daemon. They are injected inside of the
    <filename>/run/secrets</filename> directory. The same applies to the
    <filename>/etc/SUSEConnect</filename> file of the host system, which is
    automatically injected into the <filename>/run/secrets</filename> file.
   </para>
   <note>
    <para>
     The contents of the <filename>/run/secrets</filename> directory are
     never committed to a Docker image, hence there's no risk of your
     credentials leaking.
    </para>
   </note>
   <para>
    To obtain the list of repositories use the following command:
   </para>
<screen>zypper ref -s</screen>
   <para>
    It will automatically add all the repositories to your container. For
    each repository added to the system a new file is going to be created
    under <command>/etc/zypp/repos.d</command>. The URLs of these
    repositories include an access token that automatically expires after 12
    hours. To renew the token call the <command>zypper ref -s</command>
    command. It is secure to commit these files to a Docker image.
   </para>
   <para>
    If you want to use a different set of credentials, place a custom
    <filename>/etc/zypp/credentials.d/SCCcredentials</filename> file inside
    of the Docker image. It contains the machine credentials that have the
    subscription you want to use. The same applies to the
    <filename>SUSEConnect</filename> file: to override the file available on
    the host system that is running the Docker container, add a custom
    <filename>/etc/SUSEConnect</filename> file inside of the Docker image.
   </para>
   <sect3 id="sec.docker.sle_images.customizing_the_images.sles12">
    <title>Creating a Custom &slea;&nbsp;12 Image</title>
    <para>
     The following Docker file creates a simple Docker image based on
     &slea;&nbsp;12:
    </para>
<screen>FROM suse/sles12:latest

RUN zypper --gpg-auto-import-keys ref -s
RUN zypper -n in vim</screen>
    <para>
     When the Docker host machine is registered against an internal &smt;
     server, the Docker image requires the SSL certificate used by &smt;:
    </para>
<screen>FROM suse/sles12:latest

# Import the crt file of our private SMT server
ADD http://smt.test.lan/smt.crt /etc/pki/trust/anchors/smt.crt
RUN update-ca-certificates

RUN zypper --gpg-auto-import-keys ref -s
RUN zypper -n in vim</screen>
   </sect3>
   <sect3 id="sec.docker.sle_images.customizing_the_images.sles11sp3">
    <title>Creating a Custom &slea;&nbsp;11 SP3 Image</title>
    <para>
     The following Docker file creates a simple Docker image based on
     &slea;&nbsp;11 SP3:
    </para>
<screen>FROM suse/sles11sp3:latest

RUN zypper --gpg-auto-import-keys ref -s
RUN zypper -n in vim</screen>
    <para>
     When the Docker host machine is registered against an internal &smt;
     server, the Docker image requires the SSL certificate used by &smt;:
    </para>
<screen>FROM suse/sles11sp3:latest

# Import the crt file of our private SMT server
ADD http://smt.test.lan/smt.crt /etc/ssl/certs/smt.pem
RUN c_rehash /etc/ssl/certs

RUN zypper --gpg-auto-import-keys ref -s
RUN zypper -n in vim</screen>
   </sect3>
  </sect2>
 </sect1>
 <sect1 id="sec.docker.registry">
  <title>Hosting Docker Images On-premise</title>

  <para>
   This section addresses some common questions like: what can be done with
   the custom Docker images I created? How can they be shared within my
   organization?
  </para>

  <para>
   The easiest solution would be to push these images to the Docker Hub.
   However, there are a couple of important matters to keep in mind: By
   default, all the images pushed to the Docker Hub are public. To keep them
   private you need to pay a subscription-based fee. Moreover you do not
   have control over the servers where your data is stored. This may not
   comply with your organization's or company's policies to have full
   control over their intellectual property. The solution to this problem is
   simple: To avoid the use of Docker Hub, you can run an on-site Docker
   registry where to store all the Docker images used by your organization
   or company.
  </para>

  <sect2 id="sec.docker.registry.definition">
   <title>What is a Docker Registry?</title>
   <para>
    The Docker registry is an open source project created by Docker Inc. It
    allows the storage and retrieval of Docker images. By running a local
    instance of the Docker registry it is possible to completely avoid the
    usage of the Docker Hub.
   </para>
   <para>
    The Docker registry is also used by the Docker Hub. However, the Docker
    Hub, as seen from the user perspective, is made of the following parts
    at least:
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>
      The user interface (UI): The part that is accessed by users with their
      browser. The UI provides a nice and intuitive way to browse the
      contents of the Docker Hub either manually or by using a search
      feature. It also allows to create organizations made by different
      users.
     </para>
     <para>
      This component is closed source.
     </para>
    </listitem>
    <listitem>
     <para>
      The authentication component: It is used to protect the images stored
      inside of the Docker Hub. It validates all push, pull and search
      requests.
     </para>
     <para>
      This component is closed source.
     </para>
    </listitem>
    <listitem>
     <para>
      The storage back-end: This is where the Docker images are sent and
      downloaded from. It is provided by the Docker registry.
     </para>
     <para>
      This component is open source.
     </para>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 id="sec.docker.registry.installation">
   <title>Installing and Setting Up Docker Registry</title>
   <procedure>
    <step>
     <para>
      Install the <systemitem>docker-distribution-registry</systemitem>
      package:
     </para>
<screen>sudo zypper install docker-distribution-registry</screen>
    </step>
    <step>
     <para>
      To automatically start the Docker registry at boot time:
     </para>
<screen>sudo systemctl enable registry</screen>
    </step>
    <step>
     <para>
      Start the Docker registry:
     </para>
<screen>sudo systemctl start registry</screen>
    </step>
   </procedure>
   <para>
    The Docker registry configuration is defined inside of
    <filename>/etc/registry/config.yml</filename>.
   </para>
   <para>
    With the default configuration the registry listens on ports
    <literal>5000</literal> and stores the Docker images under
    <filename>/var/lib/docker-registry</filename>.
   </para>
<!--
      fcastelli 2015-07-08: TODO: update once we create a TID illustrating the secure setup of
      Docker registry and Portus.
     -->
   <para>
    For more details about Docker registry and its configuration, see the
    official documentation at:
    <ulink
       url="https://docs.docker.com/registry/"/>.
   </para>
  </sect2>

  <sect2 id="sec.docker.registry.limitations">
   <title>Limitations</title>
   <para>
    The Docker registry has two major limitations:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      It lacks any form of authentication. That means everybody with access
      to the Docker registry can push and pull images to it. That also
      includes the possibility to overwrite already existing images.
     </para>
    </listitem>
    <listitem>
     <para>
      There is no way to see which images have been pushed to the Docker
      registry. You can
      <remark>taroth 2015-07-09: maybe replace "can" with
       "need to"?</remark>
      manually take notes of what is being stored inside of it. There is
      also no search functionality, which makes collaboration harder.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    The next section is going to introduce Portus, the solution to all of
    the problems above.
   </para>
  </sect2>
 </sect1>
 <sect1 id="sec.docker.portus">
  <title>Portus</title>

  <para>
   Portus is an authentication service and user interface for the Docker
   registry. It is an open source project created by &suse; to address all
   the limitations faced by the local instances of Docker registry.
  </para>

  <para>
   By combining Portus and Docker registry, it is possible to have a secure
   and enterprise ready on-premise version of the Docker Hub.
  </para>

  <important>
   <title>Technology Preview (No Support)</title>
   <para>
    Currently, Portus is part of &suse;'s Docker offer as a technology
    preview.
   </para>
  </important>

  <para>
   For more information and documentation about Portus, see
   <ulink url="http://suse.github.io/Portus/"/>.
  </para>
 </sect1>
</article>
