<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="cha-libvirt-config">
 <title>Configuring Virtual Machines</title>
 <info>
  <abstract>
   <para>
    &vmm;'s <guimenu>Details</guimenu> view offers in-depth information about
    the &vmguest;'s complete configuration and hardware equipment. Using this
    view, you can also change the guest configuration or add and modify virtual
    hardware. To access this view, open the guest's console in &vmm; and either
    choose <menuchoice> <guimenu>View</guimenu> <guimenu>Details</guimenu>
    </menuchoice> from the menu, or click <guimenu>Show virtual hardware
    details</guimenu> in the toolbar.
   </para>
  </abstract>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker></dm:bugtracker>
  </dm:docmanager>
 </info>
 <para/>
 <figure>
  <title><guimenu>Details</guimenu> View of a &vmguest;</title>
  <mediaobject>
   <imageobject role="fo">
    <imagedata fileref="libvirt_vmm_details.png" width="75%" format="PNG"/>
   </imageobject>
   <imageobject role="html">
    <imagedata fileref="libvirt_vmm_details.png" width="75%" format="PNG"/>
   </imageobject>
  </mediaobject>
 </figure>
 <para>
  The left panel of the window lists &vmguest; overview and already installed
  hardware. After clicking an item in the list, you can access its detailed
  settings in the details view. You can change the hardware parameters to match
  your needs, then click <guimenu>Apply</guimenu> to confirm them. Some changes
  take effect immediately, while others need a reboot of the machine&mdash;and
  <systemitem>virt-manager</systemitem> warns you about that fact.
 </para>
 <para>
  To remove installed hardware from a &vmguest;, select the appropriate list
  entry in the left panel and then click <guimenu>Remove</guimenu> in the
  bottom right of the window.
 </para>
 <para>
  To add new hardware, click <guimenu>Add Hardware</guimenu> below the left
  panel, then select the type of the hardware you want to add in the
  <guimenu>Add New Virtual Hardware</guimenu> window. Modify its parameters and
  confirm with <guimenu>Finish</guimenu>.
 </para>
 <para>
  The following sections describe configuration options for the specific
  hardware type <emphasis>being added</emphasis>. They do not focus on
  modifying an existing piece of hardware as the options are identical.
 </para>
 <sect1 xml:id="sec-libvirt-config-machine-setup">
  <title>Machine Setup</title>

  <para>
   This section describes the setup of the virtualized processor and memory
   hardware. These components are vital to a &vmguest;, therefore you cannot
   remove them. It also shows how to view the overview and performance
   information, and how to change boot options.
  </para>

  <sect2>
   <title>Overview</title>
   <para>
    <guimenu>Overview</guimenu> shows basic details about &vmguest; and the
    hypervisor.
   </para>
   <figure>
    <title>Overview details</title>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="libvirt_vmm_overview.png" width="70%" format="PNG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="libvirt_vmm_overview.png" width="70%" format="PNG"/>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    <guimenu>Name</guimenu>, <guimenu>Title</guimenu>, and
    <guimenu>Description</guimenu> are editable and help you identify &vmguest;
    in the <guimenu>Virtual Machine Manager</guimenu> list of machines.
   </para>
   <figure>
    <title>&vmguest; Title and Description</title>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="libvirt_vmm_desc.png" width="40%" format="PNG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="libvirt_vmm_desc.png" width="40%" format="PNG"/>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    <guimenu>UUID</guimenu> shows the universally unique identifier of the
    virtual machine, while <guimenu>Status</guimenu> shows its current
    status&mdash;<guimenu>Running</guimenu>, <guimenu>Paused</guimenu>, or
    <guimenu>Shutoff</guimenu>.
   </para>
   <para>
    The <guimenu>Hypervisor Details</guimenu> section shows the hypervisor
    type, CPU architecture, used emulator, and chipset type. None of the
    hypervisor parameters can be changed.
   </para>
  </sect2>

  <sect2>
   <title>Performance</title>
   <para>
    <guimenu>Performance</guimenu> shows regularly updated charts of CPU and
    memory usage, and disk and network I/O.
   </para>
   <figure>
    <title>Performance</title>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="libvirt_vmm_performance.png" width="70%" format="PNG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="libvirt_vmm_performance.png" width="70%" format="PNG"/>
     </imageobject>
    </mediaobject>
   </figure>
   <tip>
    <title>Enabling Disabled Charts</title>
    <para>
     Not all the charts in the <guimenu>Graph</guimenu> view are enabled by
     default. To enable these charts, go to
     <menuchoice><guimenu>File</guimenu><guimenu>View
     Manager</guimenu></menuchoice>, then select
     <menuchoice><guimenu>Edit</guimenu><guimenu>Preferences</guimenu>
     <guimenu>Polling</guimenu></menuchoice>, and check the charts that you
     want to see regularly updated.
    </para>
   </tip>
   <figure>
    <title>Statistics Charts</title>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="libvirt_vmm_polling_charts.png" width="40%" format="PNG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="libvirt_vmm_polling_charts.png" width="40%" format="PNG"/>
     </imageobject>
    </mediaobject>
   </figure>
  </sect2>

  <sect2>
   <title>Processor</title>
   <para>
    <guimenu>Processor</guimenu> includes detailed information about &vmguest;
    processor configuration.
   </para>
   <figure>
    <title>Processor View</title>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="libvirt_vmm_processor.png" width="70%" format="PNG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="libvirt_vmm_processor.png" width="70%" format="PNG"/>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    In the <guimenu>CPUs</guimenu> section, you can configure several
    parameters related to the number of allocated CPUs.
   </para>
   <variablelist>
    <varlistentry>
     <term><guimenu>Logical host CPUs</guimenu></term>
     <listitem>
      <para>
       The real number of CPUs installed on &vmhost;.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><guimenu>Current allocation</guimenu></term>
     <listitem>
      <para>
       The number of currently allocated CPUs. You can hotplug more CPUs by
       increasing this value up to the <guimenu>Maximum allocation</guimenu>
       value.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><guimenu>Maximum allocation</guimenu></term>
     <listitem>
      <para>
       Maximum number of allocatable CPUs for the current session. Any change
       to this value will take effect after the next &vmguest; reboot.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    The <guimenu>Configuration</guimenu> section lets you configure the CPU
    model and topology.
   </para>
   <para>
    When activated, the <guimenu>Copy host CPU configuration</guimenu> option
    uses the host CPU model for &vmguest;. Otherwise you need to specify the
    CPU model from the drop-down box.
   </para>
   <para>
    After you activate <guimenu>Manually set CPU topology</guimenu>, you can
    specify a custom number of sockets, cores and threads for the CPU.
   </para>
  </sect2>

  <sect2>
   <title>Memory</title>
   <para>
    <guimenu>Memory</guimenu> contains information about the memory that is
    available to &vmguest;.
   </para>
   <figure>
    <title>Memory View</title>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="libvirt_vmm_memory.png" width="70%" format="PNG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="libvirt_vmm_memory.png" width="70%" format="PNG"/>
     </imageobject>
    </mediaobject>
   </figure>
   <variablelist>
    <varlistentry>
     <term><guimenu>Total host memory</guimenu></term>
     <listitem>
      <para>
       Total amount of memory installed on &vmhost;.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><guimenu>Current allocation</guimenu></term>
     <listitem>
      <para>
       The amount of memory currently available to &vmguest;. You can hotplug
       more memory by increasing this value up to the value of <guimenu>Maximum
       allocation</guimenu>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><guimenu>Maximum allocation</guimenu></term>
     <listitem>
      <para>
       The maximum value to which you can hotplug the currently available
       memory. Any change to this value will take effect after the next
       &vmguest; reboot.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2>
   <title>Boot Options</title>
   <para>
    <guimenu>Boot Options</guimenu> introduces options affecting the &vmguest;
    boot process.
   </para>
   <figure>
    <title>Boot Options</title>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="libvirt_vmm_boot.png" width="70%" format="PNG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="libvirt_vmm_boot.png" width="70%" format="PNG"/>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    In the <guimenu>Autostart</guimenu> section, you can specify whether the
    virtual machine should automatically start during the &vmhost; boot phase.
   </para>
   <para>
    In the <guimenu>Boot device order</guimenu>, activate the devices that will
    be used for booting &vmguest;. You can change their order with the up and
    down arrow buttons on the right side of the list. To choose from a list of
    bootable devices on &vmguest; start, activate <guimenu>Enable boot
    menu</guimenu>.
   </para>
   <para>
    To boot a different kernel than the one on the boot device, activate
    <guimenu>Enable direct kernel boot</guimenu> and specify the paths to the
    alternative kernel and initrd placed on the &vmhost; file system. You can
    also specify kernel arguments that will be passed to the loaded kernel.
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-libvirt-config-storage">
  <title>Storage</title>

  <para>
   This section gives you a detailed description of configuration options for
   storage devices. It includes both hard disks and removable media, such as
   USB or CD-ROM drives.
  </para>

  <procedure>
   <title>Adding a New Storage Device</title>
   <step>
    <para>
     Click <guimenu>Add Hardware</guimenu> below the left panel, then select
     <guimenu>Storage</guimenu> from the <guimenu>Add New Virtual
     Hardware</guimenu> window.
    </para>
    <figure>
     <title>Add a New Storage</title>
     <mediaobject>
      <imageobject role="fo">
       <imagedata fileref="libvirt_vmm_storage1.png" width="70%" format="PNG"/>
      </imageobject>
      <imageobject role="html">
       <imagedata fileref="libvirt_vmm_storage1.png" width="70%" format="PNG"/>
      </imageobject>
     </mediaobject>
    </figure>
   </step>
   <step>
    <para>
     To create a <literal>qcow2</literal> disk image in the default location,
     activate <guimenu>Create a disk image for the virtual machine</guimenu>
     and specify its size in gigabytes.
    </para>
    <para>
     To gain more control over the disk image creation, activate
     <guimenu>Select or create custom storage</guimenu> and click
     <guimenu>Manage</guimenu> to manage storage pools and images. The window
     <guimenu>Choose Storage Volume</guimenu> opens which has almost identical
     functionality as the <guimenu>Storage</guimenu> tab described in
     <xref linkend="sec-libvirt-storage-vmm"/>.
    </para>
    <tip>
     <title>Supported Storage Formats</title>
     <para>
      &suse; only supports the following storage formats:
      <literal>raw</literal>, <literal>qcow2</literal>, and
      <literal>qed</literal>.
     </para>
    </tip>
   </step>
   <step>
    <para>
     After you manage to create and specify the disk image file, specify the
     <guimenu>Device type</guimenu>. It can be one of the following options:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <guimenu>Disk device</guimenu>
      </para>
     </listitem>
     <listitem>
      <para>
       <guimenu>CDROM device</guimenu>: Does not allow using <guimenu>Create a
       disk image for the virtual machine</guimenu>.
      </para>
     </listitem>
     <listitem>
      <para>
       <guimenu>Floppy device</guimenu>: Does not allow using <guimenu>Create a
       disk image for the virtual machine</guimenu>.
      </para>
     </listitem>
     <listitem>
      <para>
       <guimenu>LUN Passthrough</guimenu>: Required to use an existing SCSI
       storage directly without adding it into a storage pool.
      </para>
     </listitem>
    </itemizedlist>
   </step>
   <step>
    <para>
     Select the <guimenu>Bus type</guimenu> for your device. The list of
     available options depends on the device type you selected in the previous
     step. The types based on <guimenu>VirtIO</guimenu> use paravirtualized
     drivers.
    </para>
   </step>
   <step>
    <para>
     In the <guimenu>Advanced options</guimenu> section, select the preferred
     <guimenu>Cache mode</guimenu>. For more information on cache modes, see
     <xref linkend="cha-cachemodes"/>.
    </para>
   </step>
   <step>
    <para>
     Confirm your settings with <guimenu>Finish</guimenu>. A new storage device
     appears in the left panel.
    </para>
   </step>
  </procedure>
 </sect1>
 <sect1 xml:id="sec-libvirt-config-controllers">
  <title>Controllers</title>

  <para>
   This section focuses on adding and configuring new controllers.
  </para>

  <procedure>
   <title>Adding a New Controller</title>
   <step>
    <para>
     Click <guimenu>Add Hardware</guimenu> below the left panel, then select
     <guimenu>Controller</guimenu> from the <guimenu>Add New Virtual
     Hardware</guimenu> window.
    </para>
    <figure>
     <title>Add a New Controller</title>
     <mediaobject>
      <imageobject role="fo">
       <imagedata fileref="libvirt_vmm_controller.png" width="70%" format="PNG"/>
      </imageobject>
      <imageobject role="html">
       <imagedata fileref="libvirt_vmm_controller.png" width="70%" format="PNG"/>
      </imageobject>
     </mediaobject>
    </figure>
   </step>
   <step>
    <para>
     Select the type of the controller. You can choose from
     <guimenu>IDE</guimenu>, <guimenu>Floppy</guimenu>,
     <guimenu>SCSI</guimenu>, <guimenu>SATA</guimenu>, <guimenu>VirtIO
     Serial</guimenu> (paravirtualized), <guimenu>USB</guimenu>, or
     <guimenu>CCID</guimenu> (smart card devices).
    </para>
   </step>
   <step>
    <para>
     Optionally, in the case of a USB or SCSI controller, select a controller
     model.
    </para>
   </step>
   <step>
    <para>
     Confirm your settings with <guimenu>Finish</guimenu>. A new controller
     appears in the left panel.
    </para>
   </step>
  </procedure>
 </sect1>
 <sect1 xml:id="sec-libvirt-config-networking">
  <title>Networking</title>

  <para>
   This section describes how to add and configure new network devices.
  </para>

  <procedure>
   <title>Adding a New Network Device</title>
   <step>
    <para>
     Click <guimenu>Add Hardware</guimenu> below the left panel, then select
     <guimenu>Network</guimenu> from the <guimenu>Add New Virtual
     Hardware</guimenu> window.
    </para>
    <figure>
     <title>Add a New Controller</title>
     <mediaobject>
      <imageobject role="fo">
       <imagedata fileref="libvirt_vmm_network.png" width="70%" format="PNG"/>
      </imageobject>
      <imageobject role="html">
       <imagedata fileref="libvirt_vmm_network.png" width="70%" format="PNG"/>
      </imageobject>
     </mediaobject>
    </figure>
   </step>
   <step>
    <para>
     From the <guimenu>Network source</guimenu> list, select the source for the
     network connection. The list includes &vmhost;'s available physical
     network interfaces, network bridges, or network bonds. You can also assign
     the &vmguest; to an already defined virtual network. See
     <xref linkend="cha-libvirt-networks"/> for more information on setting up
     virtual networks with &vmm;.
    </para>
   </step>
   <step>
    <para>
     Specify a <guimenu>MAC address</guimenu> for the network device. While
     &vmm; pre-fills a random value for your convenience, it is recommended to
     supply a MAC address appropriate for your network environment to avoid
     network conflicts.
    </para>
   </step>
   <step>
    <para>
     Select a device model from the list. You can either leave the
     <guimenu>Hypervisor default</guimenu>, or specify one of
     <guimenu>e1000</guimenu>, <guimenu>rtl8139</guimenu>, or
     <guimenu>virtio</guimenu> models. Note that <emphasis>virtio</emphasis>
     uses paravirtualized drivers.
    </para>
   </step>
   <step>
    <para>
     Confirm your settings with <guimenu>Finish</guimenu>. A new network device
     appears in the left panel.
    </para>
   </step>
  </procedure>
 </sect1>
<!-- 2016-03-03 tbazant: not ready yet
 <sect1 xml:id="sec-libvirt-config-input">
  <title>Input Devices</title>

  <para></para>
 </sect1>
 <sect1 xml:id="sec-libvirt-config-video">
  <title>Display and Video</title>

  <para></para>
 </sect1>
 <sect1 xml:id="sec-libvirt-config-ioio">
  <title>I/O Devices</title>

  <para></para>
 </sect1>
 <sect1 xml:id="sec-libvirt-config-misc">
  <title>Miscellaneous</title>

  <para></para>
 </sect1>
 -->
 <sect1 xml:id="sec-libvirt-config-tablet">
  <title>Enabling Seamless and Synchronized Mouse Pointer Movement</title>

  <para>
   When you click within a &vmguest;'s console with the mouse, the pointer is
   captured by the console window and cannot be used outside the console unless
   it is explicitly released (by pressing <keycombo> <keycap function="alt"/>
   <keycap function="control"/> </keycombo>). To prevent the console from
   grabbing the key and to enable seamless pointer movement between host and
   guest instead, add a tablet to the &vmguest;.
  </para>

  <para>
   Adding a tablet has the additional advantage of synchronizing the mouse
   pointer movement between &vmhost; and &vmguest; when using a graphical
   environment on the guest. With no tablet configured on the guest, you will
   often see two pointers with one dragging behind the other.
  </para>

  <procedure>
   <step>
    <para>
     Double-click a &vmguest; entry in the &vmm; to open its console and switch
     to the <guimenu>Details</guimenu> view with <menuchoice>
     <guimenu>View</guimenu> <guimenu>Details</guimenu> </menuchoice>.
    </para>
   </step>
   <step>
    <para>
     Click <guimenu>Add Hardware</guimenu> and choose <guimenu>Input</guimenu>
     and then <guimenu>EvTouch USB Graphics Tablet</guimenu> in the pop-up
     window. Proceed with <guimenu>Finish</guimenu>.
    </para>
   </step>
   <step>
    <para>
     If the guest is running, you will be asked whether to enable the tablet
     after the next reboot. Confirm with <guimenu>Yes</guimenu>.
    </para>
   </step>
   <step>
    <para>
     When you start or restart the &vmguest;, the tablet becomes available in
     the &vmguest;.
    </para>
   </step>
  </procedure>
 </sect1>
 <sect1 xml:id="sec-libvirt-config-cdrom" condition="kvm4x86">
  <title>Adding a CD/DVD-ROM Device with &vmm;</title>

  <para>
   &kvm; supports CD or DVD-ROMs in &vmguest; either by directly accessing a
   physical drive on the &vmhost; or by accessing ISO images. To create an ISO
   image from an existing CD or DVD, use <command>dd</command>:
  </para>

<screen>dd if=/dev/<replaceable>CD_DVD_DEVICE</replaceable> of=my_distro.iso bs=2048</screen>

  <para>
   To add a CD/DVD-ROM device to your &vmguest;, proceed as follows:
  </para>

  <procedure>
   <step>
    <para>
     Double-click a &vmguest; entry in the &vmm; to open its console and switch
     to the <guimenu>Details</guimenu> view with <menuchoice>
     <guimenu>View</guimenu> <guimenu>Details</guimenu> </menuchoice>.
    </para>
   </step>
   <step>
    <para>
     Click <guimenu>Add Hardware</guimenu> and choose
     <guimenu>Storage</guimenu> in the pop-up window.
    </para>
   </step>
   <step>
    <para>
     Change the <guimenu>Device Type</guimenu> to <guimenu>IDE CDROM</guimenu>.
    </para>
   </step>
   <step>
    <para>
     Select <guimenu>Select or create custom storage</guimenu>.
    </para>
    <substeps performance="required">
     <step>
      <para>
       To assign the device to a physical medium, enter the path to the
       &vmhost;'s CD/DVD-ROM device (for example,
       <filename>/dev/cdrom</filename>) next to <guimenu>Manage</guimenu>.
       Alternatively, use <guimenu>Manage</guimenu> to open a file browser and
       then click <guimenu>Browse Local</guimenu> to select the device.
       Assigning the device to a physical medium is only possible when the
       &vmm; was started on the &vmhost;.
      </para>
     </step>
     <step>
      <para>
       To assign the device to an existing image, click
       <guimenu>Manage</guimenu> to choose an image from a storage pool. If the
       &vmm; was started on the &vmhost;, alternatively choose an image from
       another location on the file system by clicking <guimenu>Browse
       Local</guimenu>. Select an image and close the file browser with
       <guimenu>Choose Volume</guimenu>.
      </para>
     </step>
    </substeps>
   </step>
   <step>
    <para>
     Save the new virtualized device with <guimenu>Finish</guimenu>.
    </para>
   </step>
   <step>
    <para>
     Reboot the &vmguest; to make the new device
     available.<phrase condition="kvm4x86"> For more information, see
     <xref linkend="sec-libvirt-config-cdrom-media-change"/>.</phrase>
    </para>
   </step>
  </procedure>
 </sect1>
 <sect1 xml:id="sec-libvirt-config-floppy" condition="kvm4x86">
  <title>Adding a Floppy Device with &vmm;</title>

  <para>
   Currently &kvm; only supports the use of floppy disk images&mdash;using a
   physical floppy drive is not supported. Create a floppy disk image from an
   existing floppy using <command>dd</command>:
  </para>

<screen>dd if=/dev/fd0 of=/var/lib/libvirt/images/floppy.img</screen>

  <para>
   To create an empty floppy disk image use one of the following commands:
  </para>

  <variablelist>
   <varlistentry>
    <term>Raw Image</term>
    <listitem>
<screen>dd if=/dev/zero of=/var/lib/libvirt/images/floppy.img bs=512 count=2880</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>FAT Formatted Image</term>
    <listitem>
<screen>mkfs.msdos -C /var/lib/libvirt/images/floppy.img 1440</screen>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   To add a floppy device to your &vmguest;, proceed as follows:
  </para>

  <procedure>
   <step>
    <para>
     Double-click a &vmguest; entry in the &vmm; to open its console and switch
     to the <guimenu>Details</guimenu> view with <menuchoice>
     <guimenu>View</guimenu> <guimenu>Details</guimenu> </menuchoice>.
    </para>
   </step>
   <step>
    <para>
     Click <guimenu>Add Hardware</guimenu> and choose
     <guimenu>Storage</guimenu> in the pop-up window.
    </para>
   </step>
   <step>
    <para>
     Change the <guimenu>Device Type</guimenu> to <guimenu>Floppy
     Disk</guimenu>.
    </para>
   </step>
   <step>
    <para>
     Choose <guimenu>Select or create custom storage</guimenu> and click
     <guimenu>Manage</guimenu> to choose an existing image from a storage pool.
     If &vmm; was started on the &vmhost;, alternatively choose an image from
     another location on the file system by clicking <guimenu>Browse
     Local</guimenu>. Select an image and close the file browser with
     <guimenu>Choose Volume</guimenu>.
    </para>
   </step>
   <step>
    <para>
     Save the new virtualized device with <guimenu>Finish</guimenu>.
    </para>
   </step>
   <step>
    <para>
     Reboot the &vmguest; to make the new device
     available.<phrase condition="kvm4x86"> For more information, see
     <xref linkend="sec-libvirt-config-cdrom-media-change"/>.</phrase>
    </para>
   </step>
  </procedure>
 </sect1>
 <sect1 xml:id="sec-libvirt-config-cdrom-media-change" condition="kvm4x86">
  <title>Ejecting and Changing Floppy or CD/DVD-ROM Media with &vmm;</title>

  <para>
   Whether you are using the &vmhost;'s physical CD/DVD-ROM device or an
   ISO/floppy image: Before you can change the media or image of an existing
   device in the &vmguest;, you first need to <literal>disconnect</literal> the
   media from the guest.
  </para>

  <procedure>
   <step>
    <para>
     Double-click a &vmguest; entry in the &vmm; to open its console and switch
     to the <guimenu>Details</guimenu> view with <menuchoice>
     <guimenu>View</guimenu> <guimenu>Details</guimenu> </menuchoice>.
    </para>
   </step>
   <step>
    <para>
     Choose the Floppy or CD/DVD-ROM device and <quote>eject</quote> the medium
     by clicking <guimenu>Disconnect</guimenu>.
    </para>
   </step>
   <step>
    <para>
     To <quote>insert</quote> a new medium, click <guimenu>Connect</guimenu>.
    </para>
    <substeps performance="required">
     <step>
      <para>
       If using the &vmhost;'s physical CD/DVD-ROM device, first change the
       media in the device (this may require unmounting it on the &vmhost;
       before it can be ejected). Then choose <guimenu>CD-ROM or DVD</guimenu>
       and select the device from the drop-down box.
      </para>
     </step>
     <step>
      <para>
       If you are using an ISO image, choose <guimenu>ISO image
       Location</guimenu> and select an image by clicking
       <guimenu>Manage</guimenu>. When connecting from a remote host, you may
       only choose images from existing storage pools.
      </para>
     </step>
    </substeps>
   </step>
   <step>
    <para>
     Click <guimenu>OK</guimenu> to finish. The new media can now be accessed
     in the &vmguest;.
    </para>
   </step>
  </procedure>
 </sect1>
 <sect1 xml:id="sec-libvirt-config-editing-virsh">
  <title>Editing VM Configuration with &virsh;</title>

  <para>
   The configuration of a VM is stored in an XML file in
   <filename>/etc/libvirtd/qemu/</filename> and looks like this:
  </para>

  <example>
   <title>Example XML Configuration File</title>
<screen>
&lt;domain type='kvm'&gt;
  &lt;name&gt;sles15&lt;/name&gt;
  &lt;uuid&gt;ab953e2f-9d16-4955-bb43-1178230ee625&lt;/uuid&gt;
  &lt;memory unit='KiB'&gt;2097152&lt;/memory&gt;
  &lt;currentMemory unit='KiB'&gt;2097152&lt;/currentMemory&gt;
  &lt;vcpu placement='static'&gt;2&lt;/vcpu&gt;
  &lt;os&gt;
    &lt;type arch='x86_64' machine='pc-i440fx-2.11'&gt;hvm&lt;/type&gt;
  &lt;/os&gt;
  &lt;features&gt;...&lt;/features&gt;
  &lt;cpu mode='custom' match='exact' check='partial'&gt;
    &lt;model fallback='allow'&gt;Skylake-Client-IBRS&lt;/model&gt;
  &lt;/cpu&gt;
  &lt;clock&gt;...&lt;/clock&gt;
  &lt;on_poweroff&gt;destroy&lt;/on_poweroff&gt;
  &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
  &lt;on_crash&gt;destroy&lt;/on_crash&gt;
  &lt;pm&gt;
    &lt;suspend-to-mem enabled='no'/&gt;
    &lt;suspend-to-disk enabled='no'/&gt;
  &lt;/pm&gt;
  &lt;devices&gt;
    &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
    &lt;disk type='file' device='disk'&gt;...&lt;/disk&gt;
  &lt;/devices&gt;
  ...
&lt;/domain&gt;
</screen>
  </example>

  <para>
   If you want to edit the configuration of a &vmguest;, check if it is
   offline:
  </para>

<screen>&prompt.sudo;<command>virsh list --inactive</command></screen>

  <para>
   If your &vmguest; is in this list, you can safely edit its configuration:
  </para>

<screen>&prompt.sudo;<command>virsh edit <replaceable>NAME_OF_VM_GUEST</replaceable></command>
    </screen>

  <para>
   Before saving the changes, &virsh; validates your input against a RelaxNG
   schema.
  </para>
 </sect1>
 <sect1 xml:id="sec-libvirt-config-mahcinetype-virsh">
  <title>Changing the Machine Type with <command>virsh</command></title>

  <para>
   By default, when installing with the <command>virt-install</command> tool,
   the machine type for &vmguest; is <emphasis>pc-i440fx</emphasis>. The
   machine type is stored in the &vmguest;'s xml configuration file in
   <filename>/etc/libvirt/qemu/</filename> in the tag <tag>type</tag>:
  </para>

<screen>&lt;type arch='x86_64' machine='pc-i440fx-2.3'&gt;hvm&lt;/type&gt;</screen>

  <para>
   As an example, the following procedure shows how to change this value to the
   machine type <literal>q35</literal>. <literal>q35</literal> is an Intel*
   chipset. It includes <xref linkend="gloss-vt-acronym-pcie"/>, supports up to
   12 USB ports, and has support for <xref linkend="gloss-vt-acronym-sata"/>
   and <xref linkend="gloss-vt-acronym-iommu"/>. IRQ routing has also been
   improved.
  </para>

  <procedure>
   <step>
    <para>
     Check whether your &vmguest; is inactive:
    </para>
<screen>virsh list --inactive
Id    Name                           State
----------------------------------------------------
-     sles11                         shut off</screen>
   </step>
   <step>
    <para>
     Edit the configuration for this &vmguest;:
    </para>
<screen>virsh edit sles11</screen>
   </step>
   <step>
    <para>
     Change the value of the <tag class="attribute">machine</tag> attribute:
    </para>
<screen>&lt;type arch='x86_64' machine='pc-q35-2.0'&gt;hvm&lt;/type&gt;</screen>
   </step>
   <step>
    <para>
     Restart the &vmguest;.
    </para>
<screen>&prompt.root;<command>virsh start sles11</command></screen>
   </step>
   <step>
    <para>
     Check that the machine type has changed. Log in to the &vmguest; as root
     and run the following command:
    </para>
<screen>&prompt.root;<command>dmidecode | grep Product</command>
Product Name: Standard PC (Q35 + ICH9, 2009)</screen>
   </step>
  </procedure>

  <tip>
   <title>Machine Type Update Recommendations</title>
   <para>
    Whenever the &qemu; version on the host system is upgraded (for example,
    when upgrading the &vmhost; to a new service pack), upgrade the machine
    type of the &vmguest;s to the latest available version. To check, use the
    command <command>qemu-system-x86_64 -M help</command> on the &vmhost;.
   </para>
   <para>
    The default machine type <literal>pc-i440fx</literal>, for example, is
    regularly updated. If your &vmguest; still runs with a machine type of
    <literal>pc-i440fx-1.<replaceable>X</replaceable></literal>, an update to
    <literal>pc-i440fx-2.<replaceable>X</replaceable></literal> is strongly
    recommended. This allows taking advantage of the most recent updates and
    corrections in machine definitions, and ensures better future
    compatibility.
   </para>
  </tip>
 </sect1>
 <sect1 xml:id="sec-libvirt-config-pci">
  <title>Assigning a Host PCI Device to a &vmguest;</title>

  <para>
   You can directly assign host-PCI devices to guests (PCI pass-through). When
   the PCI device is assigned to one &vmguest;, it cannot be used on the host
   or by another &vmguest; unless it is re-assigned. A prerequisite for this
   feature is a &vmhost; configuration as described in
   <xref linkend="ann-vt-io-require"/>.
  </para>

  <sect2 xml:id="sec-libvirt-config-pci-vmm">
   <title>Adding a PCI Device with &vmm;</title>
   <para>
    The following procedure describes how to add a PCI device to a &vmguest;
    using &vmm;:
   </para>
   <procedure>
    <step>
     <para>
      Double-click a &vmguest; entry in the &vmm; to open its console and
      switch to the <guimenu>Details</guimenu> view with <menuchoice>
      <guimenu>View</guimenu> <guimenu>Details</guimenu> </menuchoice>.
     </para>
    </step>
    <step>
     <para>
      Click <guimenu>Add Hardware</guimenu> and choose the <guimenu>PCI Host
      Device</guimenu> category in the left panel. A list of available PCI
      devices appears in the right part of the window.
     </para>
     <figure>
      <title>Adding a PCI Device</title>
      <mediaobject>
       <imageobject role="fo">
        <imagedata fileref="virt_add_pcidevice.png" width="75%" format="PNG"/>
       </imageobject>
       <imageobject role="html">
        <imagedata fileref="virt_add_pcidevice.png" width="75%" format="PNG"/>
       </imageobject>
      </mediaobject>
     </figure>
    </step>
    <step>
     <para>
      From the list of available PCI devices, choose the one you want to pass
      to the guest. Confirm with <guimenu>Finish</guimenu>.
     </para>
    </step>
   </procedure>
   <tip>
    <title>Assigning a PCI Device Requires a &vmguest; Shutdown</title>
    <para>
     Although it is possible to assign a PCI device to a running &vmguest; as
     described above, the device will not become available until you shut down
     the &vmguest; and reboot it afterward.
    </para>
   </tip>
  </sect2>

  <sect2 xml:id="sec-libvirt-config-pci-virsh">
   <title>Adding a PCI Device with <command>virsh</command></title>
   <para>
    To assign a PCI device to &vmguest; with <command>virsh</command>, follow
    these steps:
   </para>
   <procedure>
    <step>
     <para>
      Identify the host PCI device to assign to the guest. In the following
      example, we are assigning a DEC network card to the guest:
     </para>
<screen>&prompt.user;<command>sudo lspci -nn</command>
[...]
03:07.0 Ethernet controller [0200]: Digital Equipment Corporation DECchip \
21140 [FasterNet] [1011:0009] (rev 22)
[...]</screen>
     <para>
      Note down the device ID (<literal>03:07.0</literal> in this case).
     </para>
    </step>
    <step>
     <para>
      Gather detailed information about the device using <command>virsh
      nodedev-dumpxml <replaceable>ID</replaceable></command>. To get the
      <replaceable>ID</replaceable>, you need to replace colon and period in
      the device ID (<literal>03:07.0</literal>) with underscore and prefix the
      result with <quote>pci_0000_</quote>
      (<literal>pci_0000_03_07_0</literal>).
     </para>
<screen>&prompt.user;virsh nodedev-dumpxml pci_0000_03_07_0
&lt;device&gt;
  &lt;name&gt;pci_0000_03_07_0&lt;/name&gt;
  &lt;path&gt;/sys/devices/pci0000:00/0000:00:14.4/0000:03:07.0&lt;/path&gt;
  &lt;parent&gt;pci_0000_00_14_4&lt;/parent&gt;
  &lt;driver&gt;
    &lt;name&gt;tulip&lt;/name&gt;
  &lt;/driver&gt;
  &lt;capability type='pci'&gt;
    <emphasis role="bold">&lt;domain&gt;0&lt;/domain&gt;
    &lt;bus&gt;3&lt;/bus&gt;
    &lt;slot&gt;7&lt;/slot&gt;
    &lt;function&gt;0&lt;/function&gt;</emphasis>
    &lt;product id='0x0009'&gt;DECchip 21140 [FasterNet]&lt;/product&gt;
    &lt;vendor id='0x1011'&gt;Digital Equipment Corporation&lt;/vendor&gt;
    &lt;numa node='0'/&gt;
  &lt;/capability&gt;
&lt;/device&gt;</screen>
     <para>
      Note down the values for domain, bus, and function.
     </para>
    </step>
    <step>
     <para>
      Detach the device from the host system prior to attaching it to
      &vmguest;.
     </para>
<screen>&prompt.user;virsh nodedev-detach pci_0000_03_07_0
  Device pci_0000_03_07_0 detached</screen>
     <tip>
      <title>Multi-Function PCI Devices</title>
      <para>
       When using a multi-function PCI device that does not support FLR
       (function level reset) or PM (power management) reset, you need to
       detach all its functions from the &vmhost;. The whole device must be
       reset for security reasons. <systemitem>libvirt</systemitem> will refuse
       to assign the device if one of its functions is still in use by the
       &vmhost; or another &vmguest;.
      </para>
     </tip>
    </step>
    <step>
     <para>
      Convert the domain, bus, slot, and function value from decimal to
      hexadecimal, and prefix with <literal>0x</literal> to tell the system
      that the value is hexadecimal. In our example, domain = 0, bus = 3, slot
      = 7, and function = 0. Their hexadecimal values are:
     </para>
<screen>&prompt.user;printf %x 0
0
&prompt.user;printf %x 3
3
&prompt.user;printf %x 7
7</screen>
     <para>
      This results in domain = 0x0000, bus = 0x03, slot = 0x07 and function =
      0x00.
     </para>
    </step>
    <step>
     <para>
      Run <command>virsh edit</command> on your domain, and add the following
      device entry in the <literal>&lt;devices&gt;</literal> section using the
      values from the previous step:
     </para>
<screen>&lt;hostdev mode='subsystem' type='pci' managed='yes'&gt;
  &lt;source&gt;
    &lt;address domain='0x0000' bus='0x03' slot='0x07' function='0x00'/&gt;
  &lt;/source&gt;
&lt;/hostdev&gt;</screen>
     <tip xml:id="tip-libvirt-config-pci-virsh-managed">
      <title><literal>managed</literal> Compared to <literal>unmanaged</literal></title>
      <para>
       <systemitem>libvirt</systemitem> recognizes two modes for handling PCI
       devices: they can be either <literal>managed</literal> or
       <literal>unmanaged</literal>. In the managed case,
       <systemitem>libvirt</systemitem> handles all details of unbinding the
       device from the existing driver if needed, resetting the device, binding
       it to <systemitem>vfio-pci</systemitem> before starting the domain, etc.
       When the domain is terminated or the device is removed from the domain,
       <systemitem>libvirt</systemitem> will unbind from
       <systemitem>vfio-pci</systemitem> and rebind to the original driver in
       the case of a managed device. If the device is unmanaged, the user must
       ensure all of these management aspects of the device are done before
       assigning it to a domain, and after the device is no longer used by the
       domain.
      </para>
      <para>
       In the example above, the <literal>managed='yes'</literal> option means
       that the device is managed. To switch the device mode to unmanaged, set
       <literal>managed='no'</literal> in the listing above. If you do so, you
       need to take care of the related driver with the <command>virsh
       nodedev-detach</command> and <command>virsh nodedev-reattach</command>
       commands. That means you need to run <command>virsh nodedev-detach
       pci_0000_03_07_0</command> prior to starting the &vmguest; to detach the
       device from the host. In case the &vmguest; is not running, you can make
       the device available for the host by running <command>virsh
       nodedev-reattach pci_0000_03_07_0</command>.
      </para>
     </tip>
    </step>
    <step>
     <para>
      Shut down the &vmguest; and restart it to make the assigned PCI device
      available.
     </para>
     <tip>
      <title>&selnx;</title>
      <para>
       If you are running &selnx; on your &vmhost;, you need to disable it
       prior to starting the &vmguest; with
      </para>
<screen>setsebool -P virt_use_sysfs 1</screen>
     </tip>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-libvirt-config-usb">
  <title>Assigning a Host USB Device to a &vmguest;</title>

  <para>
   Analogous to assigning host PCI devices (see
   <xref
    linkend="sec-libvirt-config-pci"/>), you can directly assign host
   USB devices to guests. When the USB device is assigned to one &vmguest;, it
   cannot be used on the host or by another &vmguest; unless it is re-assigned.
  </para>

  <sect2 xml:id="sec-libvirt-config-usb-vmm">
   <title>Adding a USB Device with &vmm;</title>
   <para>
    To assign a host USB device to &vmguest; using &vmm;, follow these steps:
   </para>
   <procedure>
    <step>
     <para>
      Double-click a &vmguest; entry in the &vmm; to open its console and
      switch to the <guimenu>Details</guimenu> view with <menuchoice>
      <guimenu>View</guimenu> <guimenu>Details</guimenu> </menuchoice>.
     </para>
    </step>
    <step>
     <para>
      Click <guimenu>Add Hardware</guimenu> and choose the <guimenu>USB Host
      Device</guimenu> category in the left panel. A list of available USB
      devices appears in the right part of the window.
     </para>
     <figure>
      <title>Adding a USB Device</title>
      <mediaobject>
       <imageobject role="fo">
        <imagedata fileref="virt_add_usbdevice.png" width="75%" format="PNG"/>
       </imageobject>
       <imageobject role="html">
        <imagedata fileref="virt_add_usbdevice.png" width="75%" format="PNG"/>
       </imageobject>
      </mediaobject>
     </figure>
    </step>
    <step>
     <para>
      From the list of available USB devices, choose the one you want to pass
      to the guest. Confirm with <guimenu>Finish</guimenu>. The new USB device
      appears in the left pane of the <guimenu>Details</guimenu> view.
     </para>
     <tip>
      <title>USB Device Removal</title>
      <para>
       To remove the host USB device assignment, click it in the left pane of
       the <guimenu>Details</guimenu> view and confirm with
       <guimenu>Remove</guimenu>.
      </para>
     </tip>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="sec-libvirt-config-usb-virsh">
   <title>Adding a USB Device with <command>virsh</command></title>
   <para>
    To assign a USB device to &vmguest; using <command>virsh</command>, follow
    these steps:
   </para>
   <procedure>
    <step>
     <para>
      Identify the host USB device to assign to the guest:
     </para>
<screen>&prompt.user;<command>sudo lsusb</command>
[...]
Bus 001 Device 003: ID 0557:2221 ATEN International Co., Ltd Winbond Hermon
[...]</screen>
     <para>
      Note down the vendor and product IDs. In our example, the vendor ID is
      <literal>0557</literal> and the product ID is <literal>2221</literal>.
     </para>
    </step>
    <step>
     <para>
      Run <command>virsh edit</command> on your domain, and add the following
      device entry in the <literal>&lt;devices&gt;</literal> section using the
      values from the previous step:
     </para>
<screen>&lt;hostdev mode='subsystem' type='usb'&gt;
  &lt;source startupPolicy='optional'&gt;
   &lt;vendor id='0557'/&gt;
   &lt;product id='2221'/&gt;
  &lt;/source&gt;
&lt;/hostdev&gt;</screen>
     <tip>
      <title>Vendor/Product or Device's Address</title>
      <para>
       Instead of defining the host device with &lt;vendor/> and &lt;product/>
       IDs, you can use the &lt;address/> element as described for host PCI
       devices in <xref
     linkend="sec-libvirt-config-pci-virsh"/>.
      </para>
     </tip>
    </step>
    <step>
     <para>
      Shut down the &vmguest; and restart it to make the assigned USB device
      available.
     </para>
     <tip>
      <title>&selnx;</title>
      <para>
       If you are running &selnx; on your &vmhost;, you need to disable it
       prior to starting the &vmguest; with
      </para>
<screen>setsebool -P virt_use_sysfs 1</screen>
     </tip>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-libvirt-config-io">
  <title>Adding SR-IOV Devices</title>

  <para>
   Single Root I/O Virtualization (<xref linkend="vt-io-sriov"/>) capable
   <xref linkend="gloss-vt-acronym-pcie"/> devices can replicate their
   resources, so they appear to be multiple devices. Each of these
   "pseudo-devices" can be assigned to a &vmguest;.
  </para>

  <para>
   <xref linkend="vt-io-sriov"/> is an industry specification that was created
   by the Peripheral Component Interconnect Special Interest Group (PCI-SIG)
   consortium. It introduces physical functions (PF) and virtual functions
   (VF). PFs are full <xref linkend="gloss-vt-acronym-pcie"/> functions used to
   manage and configure the device. PFs also can move data. VFs lack the
   configuration and management part&mdash;they only can move data and a
   reduced set of configuration functions. Since VFs do not have all
   <xref
   linkend="gloss-vt-acronym-pcie"/> functions, the host operating
   system or the <xref linkend="gloss-vt-hypervisor"/> must support
   <xref
   linkend="vt-io-sriov"/> to be able to access and initialize VFs.
   The theoretical maximum for VFs is 256 per device (consequently the maximum
   for a dual-port Ethernet card would be 512). In practice this maximum is
   much lower, since each VF consumes resources.
  </para>

  <sect2 xml:id="sec-libvirt-config-io-requirements">
   <title>Requirements</title>
   <para>
    The following requirements must be met to be able to use
    <xref linkend="vt-io-sriov"/>:
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>
      An <xref linkend="vt-io-sriov"/>-capable network card (as of
      &productname; &productnumber;, only network cards support
      <xref linkend="vt-io-sriov"/>)
     </para>
    </listitem>
    <listitem>
     <para>
      An &x86-64; host supporting hardware virtualization (AMD-V or Intel
      VT-x)<phrase os="sles;sled">, see
      <xref
      linkend="sec-kvm-requires-hardware"/> for more
      information</phrase>
     </para>
    </listitem>
    <listitem>
     <para>
      A chipset that supports device assignment (AMD-Vi or Intel
      <xref linkend="gloss-vt-acronym-vtd"/>)
     </para>
    </listitem>
    <listitem>
     <para>
      libvirt-0.9.10 or better
     </para>
    </listitem>
    <listitem>
     <para>
      <xref linkend="vt-io-sriov"/> drivers must be loaded and configured on
      the host system
     </para>
    </listitem>
    <listitem>
     <para>
      A host configuration that meets the requirements listed at
      <xref
      linkend="ann-vt-io-require"/>
     </para>
    </listitem>
    <listitem>
     <para>
      A list of the PCI addresses of the VF(s) that will be assigned to
      &vmguest;s
     </para>
    </listitem>
   </itemizedlist>
   <tip>
    <title>Checking if a Device is SR-IOV-Capable</title>
    <para>
     The information whether a device is SR-IOV-capable can be obtained from
     its PCI descriptor by running <command>lspci</command>. A device that
     supports <xref linkend="vt-io-sriov"/> reports a capability similar to the
     following:
    </para>
<screen>Capabilities: [160 v1] Single Root I/O Virtualization (<xref linkend="vt-io-sriov"/>)</screen>
   </tip>
   <note>
    <title>Adding an SR-IOV Device at &vmguest; Creation</title>
    <para>
     Before adding an SR-IOV device to a &vmguest; when initially setting it
     up, the &vmhost; already needs to be configured as described in
     <xref linkend="sec-libvirt-config-io-config"/>.
    </para>
   </note>
  </sect2>

  <sect2 xml:id="sec-libvirt-config-io-config">
   <title>Loading and Configuring the SR-IOV Host Drivers</title>
   <para>
    To be able to access and initialize VFs, an SR-IOV-capable driver needs to
    be loaded on the host system.
<!-- See <xref linkend="???"/> for a
    list of supported cards and theit corresponding drivers. -->
   </para>
   <procedure>
    <step>
     <para>
      Before loading the driver, make sure the card is properly detected by
      running <command>lspci</command>. The following example shows the
      <command>lspci</command> output for the dual-port Intel 82576NS network
      card:
     </para>
<screen>&prompt.user;sudo /sbin/lspci | grep 82576
01:00.0 Ethernet controller: Intel Corporation 82576NS Gigabit Network Connection (rev 01)
01:00.1 Ethernet controller: Intel Corporation 82576NS Gigabit Network Connection (rev 01)
04:00.0 Ethernet controller: Intel Corporation 82576NS Gigabit Network Connection (rev 01)
04:00.1 Ethernet controller: Intel Corporation 82576NS Gigabit Network Connection (rev 01)</screen>
     <para>
      In case the card is not detected, it is likely that the hardware
      virtualization support in the BIOS/EFI has not been enabled.
     </para>
    </step>
    <step>
     <para>
      Check whether the <xref linkend="vt-io-sriov"/> driver is already loaded
      by running <command>lsmod</command>. In the following example a check for
      the igb driver (for the Intel 82576NS network card) returns a result.
      That means the driver is already loaded. If the command returns nothing,
      the driver is not loaded.
     </para>
<screen>&prompt.user;sudo /sbin/lsmod | egrep "^igb "
igb                   185649  0</screen>
    </step>
    <step>
     <para>
      Skip this step if the driver is already loaded.
     </para>
     <para>
      If the <xref linkend="vt-io-sriov"/> driver is not yet loaded, the
      non-<xref linkend="vt-io-sriov"/> driver needs to be removed first,
      before loading the new driver. Use <command>rmmod</command> to unload a
      driver. The following example unloads the
      non-<xref linkend="vt-io-sriov"/> driver for the Intel 82576NS network
      card:
     </para>
<screen>sudo /sbin/rmmod igbvf</screen>
<!-- the following by a mail from Nefi Munoz <NMunoz> -->
<!-- https://trello.com/c/1wTAuMOU/353-loading-igb-driver -->
     <para>
      Load the <xref linkend="vt-io-sriov"/> driver subsequently using the
      <command>modprobe</command> command&mdash;the VF parameter
      (<literal>max_vfs</literal>) is mandatory:
     </para>
<screen>sudo /sbin/modprobe igb max_vfs=8</screen>
     <para>
      Or load the driver via SYSFS:
     </para>
     <para>
      Find the PCI ID of the physical NIC by listing Ethernet devices:
     </para>
<screen>&prompt.user;sudo lspci | grep Eth
06:00.0 Ethernet controller: Emulex Corporation OneConnect NIC (Skyhawk) (rev 10)
06:00.1 Ethernet controller: Emulex Corporation OneConnect NIC (Skyhawk) (rev 10)</screen>
     <para>
      To enable VFs, echo the number of desired VFs to load to the
      <literal>sriov_numvfs</literal> parameter:
     </para>
<screen>&prompt.user;sudo echo 1 > /sys/bus/pci/devices/0000:06:00.1/sriov_numvfs</screen>
     <para>
      Verify that the VF NIC was loaded:
     </para>
<screen>&prompt.user;sudo lspci | grep Eth
06:00.0 Ethernet controller: Emulex Corporation OneConnect NIC (Skyhawk) (rev 10)
06:00.1 Ethernet controller: Emulex Corporation OneConnect NIC (Skyhawk) (rev 10)
06:08.0 Ethernet controller: Emulex Corporation OneConnect NIC (Skyhawk) (rev 10)</screen>
     <para>
      Obtain the maximum number of VFs available:
     </para>
<screen>&prompt.user;sudo lspci -vvv -s 06:00.1 | grep 'Initial VFs'
                       Initial VFs: 32, Total VFs: 32, Number of VFs: 0,
Function Dependency Link: 01</screen>
    </step>
    <step>
     <para>
      Create a <filename>before.service</filename> file which loads VF via
      SYSFS on boot:
     </para>
<screen>[Unit]
Before=
After=network-online.target
[Service]
Type=oneshot
RemainAfterExit=true
ExecStart=/bin/bash -c "echo 1 > /sys/bus/pci/devices/0000:06:00.1/sriov_numvfs"
# beware, executable is run directly, not through a shell, check the man pages
# systemd.service and systemd.unit for full syntax
[Install]
# target in which to start the service
WantedBy=multi-user.target
#WantedBy=graphical.target</screen>
     <para>
      And copy it to <filename>/etc/systemd/system</filename>.
     </para>
     <para>
      Additionally, it is required to create another service file
      (<filename>after-local.service</filename>) pointing to
      <filename>/etc/init.d/after.local</filename> script that detaches the NIC
      prior to starting the VM, otherwise the VM would fail to start:
     </para>
<screen>[Unit]
Description=/etc/init.d/after.local Compatibility
After=libvirtd.service
Requires=libvirtd.service
[Service]
Type=oneshot
ExecStart=/etc/init.d/after.local
RemainAfterExit=true

[Install]
WantedBy=multi-user.target</screen>
     <para>
      And copy it to <filename>/etc/systemd/system</filename>.
     </para>
<screen>#! /bin/sh
#
# Copyright (c) 2010 SuSE LINUX Products GmbH, Germany.  All rights reserved.
# ...
virsh nodedev-detach pci_0000_06_08_0</screen>
     <para>
      Then save it as <filename>/etc/init.d/after.local</filename>.
     </para>
    </step>
    <step>
     <para>
      Reboot the machine and check if the SR-IOV driver is loaded by re-running
      the <command>lspci</command> command from the first step of this
      procedure. If the SR-IOV driver was loaded successfully you should see
      additional lines for the VFs:
     </para>
<screen>01:00.0 Ethernet controller: Intel Corporation 82576NS Gigabit Network Connection (rev 01)
01:00.1 Ethernet controller: Intel Corporation 82576NS Gigabit Network Connection (rev 01)
01:10.0 Ethernet controller: Intel Corporation 82576 Virtual Function (rev 01)
01:10.1 Ethernet controller: Intel Corporation 82576 Virtual Function (rev 01)
01:10.2 Ethernet controller: Intel Corporation 82576 Virtual Function (rev 01)
[...]
04:00.0 Ethernet controller: Intel Corporation 82576NS Gigabit Network Connection (rev 01)
04:00.1 Ethernet controller: Intel Corporation 82576NS Gigabit Network Connection (rev 01)
04:10.0 Ethernet controller: Intel Corporation 82576 Virtual Function (rev 01)
04:10.1 Ethernet controller: Intel Corporation 82576 Virtual Function (rev 01)
04:10.2 Ethernet controller: Intel Corporation 82576 Virtual Function (rev 01)
[...]</screen>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="sec-libvirt-config-io-attach">
   <title>Adding a VF Network Device to an Existing &vmguest;</title>
   <para>
    When the <xref linkend="vt-io-sriov"/> hardware is properly set up on the
    &vmhost;, you can add VFs to &vmguest;s. To do so, you need to collect some
    data first.
   </para>
   <procedure>
    <para>
     Note: The following procedure is using example data. Make sure to replace
     it by appropriate data from your setup.
    </para>
    <step>
     <para>
      Use the <command>virsh nodedev-list</command> command to get the PCI
      address of the VF you want to assign and its corresponding PF. Numerical
      values from the <command>lspci</command> output shown in
      <xref linkend="sec-libvirt-config-io-config"/> (for example
      <literal>01:00.0</literal> or <literal>04:00.1</literal>) are transformed
      by adding the prefix "pci_0000_" and by replacing colons and dots with
      underscores. So a PCI ID listed as "04:00.0" by <command>lspci</command>
      is listed as "pci_0000_04_00_0" by virsh. The following example lists the
      PCI IDs for the second port of the Intel 82576NS network card:
     </para>
<screen>&prompt.user;sudo virsh nodedev-list | grep 0000_04_
pci_0000_04_00_0
pci_0000_04_00_1
pci_0000_04_10_0
pci_0000_04_10_1
pci_0000_04_10_2
pci_0000_04_10_3
pci_0000_04_10_4
pci_0000_04_10_5
pci_0000_04_10_6
pci_0000_04_10_7
pci_0000_04_11_0
pci_0000_04_11_1
pci_0000_04_11_2
pci_0000_04_11_3
pci_0000_04_11_4
pci_0000_04_11_5</screen>
     <para>
      The first two entries represent the PFs, whereas the other entries
      represent the VFs.
     </para>
    </step>
    <step>
     <para>
      Get more data that will be needed by running the command <command>virsh
      nodedev-dumpxml</command> on the PCI ID of the VF you want to add:
     </para>
<screen>&prompt.user;sudo virsh nodedev-dumpxml pci_0000_04_10_0
&lt;device&gt;
  &lt;name&gt;pci_0000_04_10_0&lt;/name&gt;
  &lt;parent&gt;pci_0000_00_02_0&lt;/parent&gt;
  &lt;capability type='pci'&gt;
    &lt;domain&gt;0&lt;/domain&gt;
    &lt;bus&gt;4&lt;/bus&gt;
    &lt;slot&gt;16&lt;/slot&gt;
    &lt;function&gt;0&lt;/function&gt;
    &lt;product id='0x10ca'&gt;82576 Virtual Function&lt;/product&gt;
    &lt;vendor id='0x8086'&gt;Intel Corporation&lt;/vendor&gt;
    &lt;capability type='phys_function'&gt;
      &lt;address domain='0x0000' bus='0x04' slot='0x00' function='0x0'/&gt;
    &lt;/capability&gt;
  &lt;/capability&gt;
&lt;/device&gt;</screen>
     <para>
      The following data is needed for the next step:
     </para>
     <itemizedlist mark="bullet" spacing="normal">
      <listitem>
       <para>
        &lt;domain&gt;0&lt;/domain&gt;
       </para>
      </listitem>
      <listitem>
       <para>
        &lt;bus&gt;4&lt;/bus&gt;
       </para>
      </listitem>
      <listitem>
       <para>
        &lt;slot&gt;16&lt;/slot&gt;
       </para>
      </listitem>
      <listitem>
       <para>
        &lt;function&gt;0&lt;/function&gt;
       </para>
      </listitem>
     </itemizedlist>
    </step>
    <step>
     <para>
      Create a temporary XML file (for example
      <filename>/tmp/vf-interface.xml</filename> containing the data necessary
      to add a VF network device to an existing &vmguest;. The minimal content
      of the file needs to look like the following:
     </para>
<screen>&lt;interface type='hostdev'&gt;<co xml:id="sriov-iface"/>
 &lt;source&gt;
  &lt;address type='pci' domain='0' bus='11' slot='16' function='0'2/&gt;<co xml:id="sriov-data"/>
 &lt;/source&gt;
&lt;/interface&gt;</screen>
     <calloutlist>
      <callout arearefs="sriov-iface">
       <para>
        VFs do not get a fixed MAC address; it changes every time the host
        reboots. When adding network devices the <quote>traditional</quote> way
        with &lt;hostdev&gt;, it would require to reconfigure the &vmguest;'s
        network device after each reboot of the host, because of the MAC
        address change. To avoid this kind of problem, libvirt introduced the
        <quote>interface type='hostdev'</quote> directive, which sets up
        network-specific data <emphasis>before</emphasis> assigning the device.
       </para>
      </callout>
      <callout arearefs="sriov-data">
       <para>
        Specify the data you acquired in the previous step here.
       </para>
      </callout>
     </calloutlist>
    </step>
    <step>
     <para>
      In case a device is already attached to the host, it cannot be attached
      to a guest. To make it available for guests, detach it from the host
      first:
     </para>
<screen>virsh nodedev-detach pci_0000_04_10_0</screen>
    </step>
    <step>
     <para>
      Last, add the VF interface to an existing &vmguest;:
     </para>
<screen>virsh attach-device <replaceable>GUEST</replaceable> /tmp/vf-interface.xml --<replaceable>OPTION</replaceable></screen>
     <para>
      <replaceable>GUEST</replaceable> needs to be replaced by the domain name,
      ID or UUID of the &vmguest; and --<replaceable>OPTION</replaceable> can
      be one of the following:
     </para>
     <variablelist>
      <varlistentry>
       <term><option>--persistent</option></term>
       <listitem>
        <para>
         This option will always add the device to the domain's persistent XML.
         In addition, if the domain is running, it will be hotplugged.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><option>--config</option></term>
       <listitem>
        <para>
         This option will only affect the persistent XML, even if the domain is
         running. The device will only show up in the guest on next boot.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><option>--live</option></term>
       <listitem>
        <para>
         This option will only affect a running domain. If the domain is
         inactive, the operation will fail. The device is not persisted in the
         XML and will not be available in the guest on next boot.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>--current</term>
       <listitem>
        <para>
         This option affects the current state of the domain. If the domain is
         inactive, the device is added to the persistent XML and will be
         available on next boot. If the domain is active, the device is
         hotplugged but not added to the persistent XML.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
     <para>
      To detach a VF interface, use the <command>virsh detach-device</command>
      command, which also takes the options listed above.
     </para>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="libvirt-config-io-pool">
   <title>Dynamic Allocation of VFs from a Pool</title>
   <para>
    If you define the PCI address of a VF into a guest's configuration
    statically as described in <xref linkend="sec-libvirt-config-io-attach"/>,
    it is hard to migrate such guest to another host. The host must have
    identical hardware in the same location on the PCI bus, or the guest
    configuration must be modified prior to each start.
   </para>
   <para>
    Another approach is to create a &libvirt; network with a device pool that
    contains all the VFs of an <xref linkend="vt-io-sriov"/> device. The guest
    then references this network, and each time it is started, a single VF is
    dynamically allocated to it. When the guest is stopped, the VF is returned
    to the pool, available for another guest.
   </para>
   <sect3 xml:id="libvirt-config-io-pool-host">
    <title>Defining Network with Pool of VFs on &vmhost;</title>
    <para>
     The following example of network definition creates a pool of all VFs for
     the <xref linkend="vt-io-sriov"/> device with its physical function (PF)
     at the network interface eth0 on the host:
    </para>
<screen>&lt;network&gt;
  &lt;name&gt;passthrough&lt;/name&gt;
    &lt;forward mode='hostdev' managed='yes'&gt;
      &lt;pf dev='eth0'/&gt;
    &lt;/forward&gt;
  &lt;/network&gt;</screen>
    <para>
     To use this network on the host, save the above code to a file, for
     example <filename>/tmp/passthrough.xml</filename>, and execute the
     following commands. Remember to replace eth0 with the real network
     interface name of your <xref linkend="vt-io-sriov"/> device's PF:
    </para>
<screen>virsh net-define /tmp/passthrough.xml
virsh net-autostart passthrough
virsh net-start passthrough</screen>
   </sect3>
   <sect3 xml:id="libvirt-config-io-pool-guest">
    <title>Configuring &vmguest; to Use VF from the Pool</title>
    <para>
     The following example of guest device interface definition uses a VF of
     the <xref linkend="vt-io-sriov"/> device from the pool created in
     <xref linkend="libvirt-config-io-pool-host"/>. &libvirt; automatically
     derives the list of all VFs associated with that PF the first time the
     guest is started.
    </para>
<screen>&lt;interface type='network'&gt;
  &lt;source network='passthrough'&gt;
&lt;/interface&gt;</screen>
    <para>
     To verify the list of associated VFs, run <command>virsh net-dumpxml
     passthrough</command> on the host after the first guest that uses the
     network with the pool of VFs starts.
    </para>
<screen>&lt;network connections='1'&gt;
  &lt;name&gt;passthrough&lt;/name&gt;
  &lt;uuid&gt;a6a26429-d483-d4ed-3465-4436ac786437&lt;/uuid&gt;
  &lt;forward mode='hostdev' managed='yes'&gt;
    &lt;pf dev='eth0'/&gt;
    &lt;address type='pci' domain='0x0000' bus='0x02' slot='0x10' function='0x1'/&gt;
    &lt;address type='pci' domain='0x0000' bus='0x02' slot='0x10' function='0x3'/&gt;
    &lt;address type='pci' domain='0x0000' bus='0x02' slot='0x10' function='0x5'/&gt;
    &lt;address type='pci' domain='0x0000' bus='0x02' slot='0x10' function='0x7'/&gt;
    &lt;address type='pci' domain='0x0000' bus='0x02' slot='0x11' function='0x1'/&gt;
    &lt;address type='pci' domain='0x0000' bus='0x02' slot='0x11' function='0x3'/&gt;
    &lt;address type='pci' domain='0x0000' bus='0x02' slot='0x11' function='0x5'/&gt;
  &lt;/forward&gt;
  &lt;/network&gt;</screen>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-libvirt-config-direct">
  <title>Using Macvtap to Share &vmhost; Network Interfaces</title>

  <para>
   Macvtap provides direct attachment of a &vmguest; virtual interface to a
   host network interface. The macvtap-based interface extends the &vmhost;
   network interface and has its own MAC address on the same Ethernet segment.
   Typically, this is used to make both the &vmguest; and the &vmhost; show up
   directly on the switch that the &vmhost; is connected to.
  </para>

  <note>
   <title>Macvtap Cannot Be Used with a Linux Bridge</title>
   <para>
    Macvtap cannot be used with network interfaces already connected to a Linux
    bridge. Before attempting to create the macvtap interface, remove the
    interface from the bridge.
   </para>
  </note>

  <note>
   <title>&vmguest; to &vmhost; Communication with Macvtap</title>
   <para>
    When using macvtap, a &vmguest; can communicate with other &vmguest;s, and
    with other external hosts on the network. But it cannot communicate with
    the &vmhost; on which the &vmguest; runs. This is the defined behavior of
    macvtap, because of the way the &vmhost;'s physical Ethernet is attached to
    the macvtap bridge. Traffic from the &vmguest; into that bridge that is
    forwarded to the physical interface cannot be bounced back up to the
    &vmhost;'s IP stack. Similarly, traffic from the &vmhost;'s IP stack that
    is sent to the physical interface cannot be bounced back up to the macvtap
    bridge for forwarding to the &vmguest;.
   </para>
  </note>

  <para>
   Virtual network interfaces based on macvtap are supported by libvirt by
   specifying an interface type of <literal>direct</literal>. For example:
  </para>

<screen>&lt;interface type='direct'&gt;
  &lt;mac address='aa:bb:cc:dd:ee:ff'/&gt;
  &lt;source dev='eth0' mode='bridge'/&gt;
  &lt;model type='virtio'/&gt;
  &lt;/interface&gt;</screen>

  <para>
   The operation mode of the macvtap device can be controlled with the
   <literal>mode</literal> attribute. The following list shows its possible
   values and a description for each:
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     <literal>vepa</literal>: All &vmguest; packets are sent to an external
     bridge. Packets whose destination is a &vmguest; on the same &vmhost; as
     where the packet originates from are sent back to the &vmhost; by the VEPA
     capable bridge (today's bridges are typically not VEPA capable).
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>bridge</literal>: Packets whose destination is on the same
     &vmhost; as where they originate from are directly delivered to the target
     macvtap device. Both origin and destination devices need to be in
     <literal>bridge</literal> mode for direct delivery. If either one of them
     is in <literal>vepa</literal> mode, a VEPA capable bridge is required.
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>private</literal>: All packets are sent to the external bridge
     and will only be delivered to a target &vmguest; on the same &vmhost; if
     they are sent through an external router or gateway and that device sends
     them back to the &vmhost;. This procedure is followed if either the source
     or destination device is in private mode.
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>passthrough</literal>: A special mode that gives more power to
     the network interface. All packets will be forwarded to the interface,
     allowing virtio &vmguest;s to change the MAC address or set promiscuous
     mode to bridge the interface or create VLAN interfaces on top of it. Note
     that a network interface is not shareable in
     <literal>passthrough</literal> mode. Assigning an interface to a &vmguest;
     will disconnect it from the &vmhost;. For this reason SR-IOV virtual
     functions are often assigned to the &vmguest; in
     <literal>passthrough</literal> mode.
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
 <sect1 xml:id="sec-libvirt-config-maxgrantframes-virsh">
  <title>Managing Guest Memory Allocation (&xen; only)</title>

  <para>
   <command>libvirt</command> now includes support for adjusting memory
   allocation per guest with <command>virsh</command>. &xen; paravirtual
   devices connect to the <literal>xenbus </literal> controller, which is
   analogous to a physical device bus such as a PCI controller. &xen;'s
   <literal>max_grant_frames</literal> attribute sets how many frames, which
   are analogous to memory, are allocated to the <literal>xenbus </literal>
   controller for each guest.
  </para>

  <para>
   The default is 32, and this can be increased as needed, up to the amount set
   for dom0, or decreased. How much is enough? This depends on the number of
   devices and workload demand, such as a saturated network interface or heavy
   I/O. Use <command>xen-diag</command> to see your current used and maximum
   <literal>max_grant_frames</literal> values for dom0 and your guests. The
   guests must be running:
  </para>

<screen>&prompt.sudo;virsh list
 Id   Name             State
--------------------------------
 0    Domain-0         running
 3    sle15sp1         running

 &prompt.sudo;xen-diag gnttab_query_size 0
domid=0: nr_frames=1, max_nr_frames=256

&prompt.sudo;xen-diag gnttab_query_size 3
domid=3: nr_frames=3, max_nr_frames=32
</screen>

  <para>
   The sle15sp1 guest is using only 3 frames out of 32. If you are seeing
   performance issues, and log entries that point to insufficient frames,
   increase the value with <command>virsh</command>. Look for the
   <literal>&lt;controller type='xenbus'</literal> line in the guest's
   configuration file and add the <literal>maxGrantFrames</literal> control
   element:
  </para>

<screen>&prompt.sudo;virsh edit sle15sp1
 &lt;controller type='xenbus' index='0' maxGrantFrames='40'/>
</screen>

  <para>
   Save your changes and restart the guest. Now it should show your change:
  </para>

<screen>&prompt.sudo;xen-diag gnttab_query_size 3
domid=3: nr_frames=3, max_nr_frames=40
</screen>

  <para>
   See the <citetitle>Controllers</citetitle> section of the libvirt
   <citetitle>Domain XML format</citetitle> manual at
   <link xlink:href="https://libvirt.org/formatdomain.html#elementsControllers"/>
   for more information.
  </para>
 </sect1>
 <sect1 xml:id="sec-libvirt-config-disable-virtio-mellon">
  <title>Disabling a Memory Balloon Device</title>

  <para>
   Memory Balloon has become a default option for KVM. The device will be added
   to the &vmguest; explicitly, so you do not need to add this element in the
   &vmguest;'s XML configuration. However, if you want to disable Memory
   Balloon in the &vmguest; for any reason, you need to set
   <literal>model='none'</literal> as shown below:
  </para>

<screen>&lt;devices&gt;
   &lt;memballoon model='none'/&gt;
&lt;/device&gt;</screen>
 </sect1>
 <sect1 xml:id="virsh-video-dual-head">
  <title>Configuring Multiple Monitors (Dual Head)</title>

  <para>
   &libvirt; supports a dual head configuration to display the video output of
   the &vmguest; on multiple monitors.
  </para>

  <important>
   <title>No Support for &xen;</title>
   <para>
    The &xen; hypervisor does not support dual head configuration.
   </para>
  </important>

  <procedure>
   <title>Configuring Dual Head</title>
   <step>
    <para>
     While the virtual machine is running, verify that the
     <package>xf86-video-qxl</package> package is installed in the &vmguest;:
    </para>
<screen>&prompt.user;rpm -q xf86-video-qxl</screen>
   </step>
   <step>
    <para>
     Shutdown the &vmguest; and start editing its configuration XML as
     described in <xref linkend="sec-libvirt-config-editing-virsh"/>.
    </para>
   </step>
   <step>
    <para>
     Verify that the model of the virtual graphics card is 'qxl':
    </para>
<screen>
&lt;video>
 &lt;model type='qxl' ... />
</screen>
   </step>
   <step>
    <para>
     Increase the <option>heads</option> parameter in the graphics card model
     specification from the default '1' to for example '2':
    </para>
<screen>
&lt;video>
 &lt;model type='qxl' ram='65536' vram='65536' vgamem='16384' heads='2' primary='yes'/>
 &lt;alias name='video0'/>
 &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x0'/>
&lt;/video>
</screen>
   </step>
   <step>
    <para>
     Configure the virtual machine to use the Spice display instead of VNC:
    </para>
<screen>
&lt;graphics type='spice' port='5916' autoport='yes' listen='0.0.0.0'>
 &lt;listen type='address' address='0.0.0.0'/>
&lt;/graphics>
</screen>
   </step>
   <step>
    <para>
     Start the virtual machine and connect to its display with
     <command>virt-viewer</command>, for example:
    </para>
<screen>&prompt.user;virt-viewer --connect qemu+ssh://<replaceable>USER@VM_HOST</replaceable>/system</screen>
   </step>
   <step>
    <para>
     From the list of VMs, select the one whose configuration you have modified
     and confirm with <guimenu>Connect</guimenu>.
    </para>
   </step>
   <step>
    <para>
     After the graphical subsystem (Xorg) loads in the &vmguest;, select
     <menuchoice><guimenu>View</guimenu><guimenu>Displays</guimenu><guimenu>Display
     2</guimenu></menuchoice> to open a new window with the second monitor's
     output.
    </para>
   </step>
  </procedure>
 </sect1>
</chapter>
