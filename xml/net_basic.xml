<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<!-- Converted by suse-upgrade version 1.1 -->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="cha.basicnet">
 <title>Basic Networking</title>
 <info>
      <abstract>
        <para>
    Linux offers the necessary networking tools and features for integration
    into all types of network structures. Network access using a network
    card can be configured with &yast;. Manual configuration is also
    possible. In this chapter only the fundamental mechanisms and the
    relevant network configuration files are covered.
   </para>
      </abstract>
      <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
        <dm:bugtracker>
          </dm:bugtracker>
        <dm:translation>yes</dm:translation>
      </dm:docmanager>
    </info>
    <indexterm>
 <primary>networks</primary></indexterm><indexterm>
 <primary>Linux</primary>
 <secondary>networks and</secondary></indexterm><indexterm>
 <primary>TCP/IP</primary></indexterm><indexterm>
 <primary>networks</primary>
 <secondary>TCP/IP</secondary></indexterm>
 <para>
  Linux and other Unix operating systems use the TCP/IP protocol. It is not
  a single network protocol, but a family of network protocols that offer
  various services. The protocols listed in
  <xref linkend="tab.net.basic.tcpproto"/>, are provided for the purpose of
  exchanging data between two machines via TCP/IP. Networks combined by
  TCP/IP, comprising a worldwide network, are also referred to as <quote>the
  Internet.</quote>
 </para>
 <para>
  <indexterm>
  <primary>RFCs</primary>
  </indexterm>RFC stands for <emphasis>Request for Comments</emphasis>. RFCs
  are documents that describe various Internet protocols and implementation
  procedures for the operating system and its applications. The RFC
  documents describe the setup of Internet protocols. For more information
  about RFCs, see <link xlink:href="http://www.ietf.org/rfc.html"/>.
 </para>
 <variablelist xml:id="tab.net.basic.tcpproto">
  <title>Several Protocols in the TCP/IP Protocol Family</title>
  <varlistentry>
   <term>TCP
    <indexterm>
    <primary>TCP/IP</primary>
    <secondary>TCP</secondary></indexterm>
   </term>
   <listitem>
    <para>
     Transmission Control Protocol: a connection-oriented secure protocol.
     The data to transmit is first sent by the application as a stream of
     data and converted into the appropriate format by the operating system.
     The data arrives at the respective application on the destination host
     in the original data stream format it was initially sent. TCP
     determines whether any data has been lost or jumbled during the
     transmission. TCP is implemented wherever the data sequence matters.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>
       UDP <indexterm>
    <primary>TCP/IP</primary>
    <secondary>UDP</secondary></indexterm>
   </term>
   <listitem>
    <para>
     User Datagram Protocol: a connectionless, insecure protocol. The data
     to transmit is sent in the form of packets generated by the
     application. The order in which the data arrives at the recipient is
     not guaranteed and data loss is possible. UDP is suitable for
     record-oriented applications. It features a smaller latency period than
     TCP.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>
    ICMP <indexterm>
    <primary>TCP/IP</primary>
    <secondary>ICMP</secondary></indexterm>
   </term>
   <listitem>
    <para>
     Internet Control Message Protocol: Essentially, this is not a protocol
     for the end user, but a special control protocol that issues error
     reports and can control the behavior of machines participating in
     TCP/IP data transfer. In addition, it provides a special echo mode that
     can be viewed using the program ping.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>
    IGMP <indexterm>
    <primary>TCP/IP</primary>
    <secondary>IGMP</secondary></indexterm>
   </term>
   <listitem>
    <para>
     Internet Group Management Protocol: This protocol controls machine
     behavior when implementing IP multicast.
    </para>
   </listitem>
  </varlistentry>
 </variablelist><indexterm>
 <primary>TCP/IP</primary>
 <secondary>layer model</secondary></indexterm>
 <para>
  As shown in <xref linkend="fig.net.basic.OSI"/>, data exchange takes place
  in different layers. The actual network layer is the insecure data
  transfer via IP (Internet protocol). On top of IP, TCP (transmission
  control protocol) guarantees, to a certain extent, security of the data
  transfer. The IP layer is supported by the underlying hardware-dependent
  protocol, such as Ethernet.
 </para>
 <figure xml:id="fig.net.basic.OSI">
  <title>Simplified Layer Model for TCP/IP</title>
  <mediaobject>
   <imageobject role="fo">
    <imagedata width="100%" fileref="net_basic_osi.svg" format="SVG"/>
   </imageobject>
   <imageobject role="html">
    <imagedata width="75%" fileref="net_basic_osi.png" format="PNG"/>
   </imageobject>
  </mediaobject>
 </figure>
 <para>
  The diagram provides one or two examples for each layer. The layers are
  ordered according to <emphasis>abstraction levels</emphasis>. The lowest
  layer is very close to the hardware. The uppermost layer, however, is
  almost a complete abstraction from the hardware. Every layer has its own
  special function. The special functions of each layer are mostly implicit
  in their description. The data link and physical layers represent the
  physical network used, such as Ethernet.
 </para><indexterm>
 <primary>TCP/IP</primary>
 <secondary>packets</secondary></indexterm>
 <para>
  Almost all hardware protocols work on a packet-oriented basis. The data to
  transmit is collected into <emphasis>packets</emphasis> (it cannot be sent
  all at once). The maximum size of a TCP/IP packet is approximately 64 KB.
  Packets are normally quite smaller, as the network hardware can be a
  limiting factor. The maximum size of a data packet on an Ethernet is about
  fifteen hundred bytes. The size of a TCP/IP packet is limited to this
  amount when the data is sent over an Ethernet. If more data is
  transferred, more data packets need to be sent by the operating system.
 </para>
 <para>
  For the layers to serve their designated functions, additional information
  regarding each layer must be saved in the data packet. This takes place in
  the <emphasis>header</emphasis> of the packet. Every layer attaches a
  small block of data, called the protocol header, to the front of each
  emerging packet. A sample TCP/IP data packet traveling over an Ethernet
  cable is illustrated in <xref linkend="fig.net.basic.TCPPaket"/>. The
  proof sum is located at the end of the packet, not at the beginning. This
  simplifies things for the network hardware. <indexterm>
  <primary>TCP/IP</primary>
  <secondary>packets</secondary>
  </indexterm>
 </para>
 <figure xml:id="fig.net.basic.TCPPaket">
  <title>TCP/IP Ethernet Packet</title>
  <mediaobject>
   <imageobject role="fo">
    <imagedata width="80%" fileref="net_basic_tcppacket.svg" format="SVG"/>
   </imageobject>
   <imageobject role="html">
    <imagedata width="75%" fileref="net_basic_tcppacket.png" format="PNG"/>
   </imageobject>
  </mediaobject>
 </figure>
 <para>
  When an application sends data over the network, the data passes through
  each layer, all implemented in the Linux Kernel except the physical layer.
  Each layer is responsible for preparing the data so it can be passed to
  the next layer. The lowest layer is ultimately responsible for sending the
  data. The entire procedure is reversed when data is received. Like the
  layers of an onion, in each layer the protocol headers are removed from
  the transported data. Finally, the transport layer is responsible for
  making the data available for use by the applications at the destination.
  In this manner, one layer only communicates with the layer directly above
  or below it. For applications, it is irrelevant whether data is
  transmitted via a 100 Mbit/s FDDI network or via a 56-Kbit/s modem line.
  Likewise, it is irrelevant for the data line which kind of data is
  transmitted, as long as packets are in the correct format.
 </para>
 <sect1 xml:id="sec.basicnet.addresses">
  <title>IP Addresses and Routing</title><indexterm>

  <primary>IP addresses</primary></indexterm><indexterm>

  <primary>networks</primary>

  <secondary>routing</secondary></indexterm><indexterm>

  <primary>routing</primary></indexterm>

  <para>
   The discussion in this section is limited to IPv4 networks. For
   information about IPv6 protocol, the successor to IPv4, refer to
   <xref linkend="sec.basicnet.ipv6"/>.
  </para>

  <sect2 xml:id="sec.basicnet.addresses.ip">
   <title>IP Addresses</title>
   <para>
    Every computer on the Internet has a unique 32-bit address. These
    32 bits (or 4 bytes) are normally written as illustrated in the second
    row in <xref linkend="aus.net.basic.ipaddress"/>.
   </para>
   <example xml:id="aus.net.basic.ipaddress">
    <title>Writing IP Addresses</title>
<screen>IP Address (binary):  11000000 10101000 00000000 00010100
IP Address (decimal):      192.     168.       0.      20</screen>
   </example>
   <para>
    In decimal form, the four bytes are written in the decimal number
    system, separated by periods. The IP address is assigned to a host or a
    network interface. It can be used only once throughout the world. There
    are exceptions to this rule, but these are not relevant to the following
    passages.
   </para><indexterm>
   <primary>IP addresses</primary>
   <secondary>classes</secondary></indexterm>
   <para>
    The points in IP addresses indicate the hierarchical system. Until the
    1990s, IP addresses were strictly categorized in classes. However, this
    system proved too inflexible and was discontinued. Now,
    <emphasis>classless routing</emphasis> (CIDR, classless interdomain
    routing) is used.
   </para>
  </sect2>

  <sect2 xml:id="sec.basicnet.addresses.route">
   <title>Netmasks and Routing</title><indexterm>
   <primary>routing</primary>
   <secondary>netmasks</secondary></indexterm><indexterm>
   <primary>networks</primary>
   <secondary>routing</secondary></indexterm><indexterm>
   <primary>networks</primary>
   <secondary>netmasks</secondary></indexterm>
   <para>
    Netmasks are used to define the address range of a subnet. If two hosts
    are in the same subnet, they can reach each other directly. If they are
    not in the same subnet, they need the address of a gateway that handles
    all the traffic for the subnet. To check if two IP addresses are in the
    same subnet, simply <quote>AND</quote> both addresses with the netmask.
    If the result is identical, both IP addresses are in the same local
    network. If there are differences, the remote IP address, and thus the
    remote interface, can only be reached over a gateway.
   </para>
   <para>
    To understand how the netmask works, look at
    <xref linkend="tab.net.basic.netmask"/>. The netmask consists of
    32 bits that identify how much of an IP address belongs to the network.
    All those bits that are <literal>1</literal> mark the corresponding bit
    in the IP address as belonging to the network. All bits that are
    <literal>0</literal> mark bits inside the subnet. This means that the
    more bits are <literal>1</literal>, the smaller the subnet is. Because
    the netmask always consists of several successive <literal>1</literal>
    bits, it is also possible to count the number of bits in the netmask. In
    <xref linkend="tab.net.basic.netmask"/> the first net with 24 bits
    could also be written as <literal>192.168.0.0/24</literal>.
   </para>
   <example xml:id="tab.net.basic.netmask">
    <title>Linking IP Addresses to the Netmask</title>
<screen>IP address (192.168.0.20):  11000000 10101000 00000000 00010100
Netmask   (255.255.255.0):  11111111 11111111 11111111 00000000
---------------------------------------------------------------
Result of the link:         11000000 10101000 00000000 00000000
In the decimal system:           192.     168.       0.       0

IP address (213.95.15.200): 11010101 10111111 00001111 11001000
Netmask    (255.255.255.0): 11111111 11111111 11111111 00000000
---------------------------------------------------------------
Result of the link:         11010101 10111111 00001111 00000000
In the decimal system:           213.      95.      15.       0</screen>
   </example>
   <para>
    To give another example: all machines connected with the same Ethernet
    cable are usually located in the same subnet and are directly
    accessible. Even when the subnet is physically divided by switches or
    bridges, these hosts can still be reached directly.
   </para>
   <para>
    IP addresses outside the local subnet can only be reached if a gateway
    is configured for the target network. In the most common case, there is
    only one gateway that handles all traffic that is external. However, it
    is also possible to configure several gateways for different subnets.
   </para>
   <para>
    If a gateway has been configured, all external IP packets are sent to
    the appropriate gateway. This gateway then attempts to forward the
    packets in the same manner&mdash;from host to host&mdash;until it
    reaches the destination host or the packet's TTL (time to live) expires.
   </para>
   <variablelist xml:id="net.basic.spezial.net">
    <title>Specific Addresses</title>
    <varlistentry>
     <term>
      Base Network Address <indexterm>
      <primary>networks</primary>
      <secondary>base network address</secondary></indexterm>
     </term>
     <listitem>
      <para>
       This is the netmask AND any address in the network, as shown in
       <xref linkend="tab.net.basic.netmask"/> under
       <literal>Result</literal>. This address cannot be assigned to any
       hosts.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      Broadcast Address <indexterm>
      <primary>networks</primary>
      <secondary>broadcast address</secondary></indexterm>
     </term>
     <listitem>
      <para>
       This could be paraphrased as: <quote>Access all hosts in this
       subnet.</quote> To generate this, the netmask is inverted in binary
       form and linked to the base network address with a logical OR. The
       above example therefore results in 192.168.0.255. This address cannot
       be assigned to any hosts.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      Local Host <indexterm>
      <primary>networks</primary>
      <secondary>localhost</secondary></indexterm>
     </term>
     <listitem>
      <para>
       The address <systemitem class="ipaddress">127.0.0.1</systemitem> is
       assigned to the <quote>loopback device</quote> on each host. A
       connection can be set up to your own machine with this address and
       with all addresses from the complete
       <systemitem class="ipaddress">127.0.0.0/8</systemitem> loopback
       network as defined with IPv4. With IPv6 there is only one loopback
       address (<systemitem class="ipaddress">::1</systemitem>).
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Because IP addresses must be unique all over the world, you cannot
    select random addresses. There are three address domains to use if you
    want to set up a private IP-based network. These cannot get any
    connection from the rest of the Internet, because they cannot be
    transmitted over the Internet. These address domains are specified in
    RFC&nbsp;1597 and listed in
    <xref linkend="tab.net.basic.privat.net"/>. <indexterm>
    <primary>IP addresses</primary>
    <secondary>private</secondary>
    </indexterm>
   </para>
   <table xml:id="tab.net.basic.privat.net">
    <title>Private IP Address Domains</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>
        <para>
         Network/Netmask
        </para>
       </entry>
       <entry>
        <para>
         Domain
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         <systemitem class="ipaddress">10.0.0.0</systemitem>/<systemitem class="netmask">255.0.0.0</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         <systemitem class="ipaddress">10.x.x.x</systemitem>
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <systemitem class="ipaddress">172.16.0.0</systemitem>/<systemitem class="netmask">255.240.0.0</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         <systemitem class="ipaddress">172.16.x.x</systemitem> &ndash;
         <systemitem class="ipaddress">172.31.x.x</systemitem>
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <systemitem class="ipaddress">192.168.0.0</systemitem>/<systemitem class="netmask">255.255.0.0</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         <systemitem class="ipaddress">192.168.x.x</systemitem>
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.basicnet.ipv6">
  <title>IPv6&mdash;The Next Generation Internet</title><indexterm>

  <primary>IP addresses</primary>

  <secondary>IPv6</secondary></indexterm><indexterm>

  <primary>protocols</primary>

  <secondary>IPv6</secondary></indexterm>

  <important arch="zseries" os="sles">
<!--FIXME check-->
   <title>IBM &zseries;: IPv6 Support</title>
   <para>
    IPv6 is not supported by the CTC and IUCV network connections of the IBM
    &zseries; hardware.
   </para>
  </important>

  <para>
   Because of the emergence of the WWW (World Wide Web), the Internet has
   experienced explosive growth, with an increasing number of computers
   communicating via TCP/IP in the past fifteen years. Since Tim Berners-Lee
   at CERN (<link xlink:href="http://public.web.cern.ch"/>) invented the WWW
   in 1990, the number of Internet hosts has grown from a few thousand to
   about a hundred million.
  </para>

  <para>
   As mentioned, an IPv4 address consists of only 32 bits. Also, quite a
   few IP addresses are lost&mdash;they cannot be used because of the way
   in which networks are organized. The number of addresses available in
   your subnet is two to the power of the number of bits, minus two. A
   subnet has, for example, 2, 6, or 14 addresses available. To connect 128
   hosts to the Internet, for example, you need a subnet with 256 IP
   addresses, from which only 254 are usable, because two IP addresses are
   needed for the structure of the subnet itself: the broadcast and the base
   network address.
  </para>

  <para>
   Under the current IPv4 protocol, DHCP or NAT (network address
   translation) are the typical mechanisms used to circumvent the potential
   address shortage. Combined with the convention to keep private and public
   address spaces separate, these methods can certainly mitigate the
   shortage. The problem with them lies in their configuration, which is a
   chore to set up and a burden to maintain. To set up a host in an IPv4
   network, you need a number of address items, such as the host's own IP
   address, the subnetmask, the gateway address and maybe a name server
   address. All these items need to be known and cannot be derived from
   somewhere else.
  </para>

  <para>
   With IPv6, both the address shortage and the complicated configuration
   should be a thing of the past. The following sections tell more about the
   improvements and benefits brought by IPv6 and about the transition from
   the old protocol to the new one.
  </para>

  <sect2 xml:id="sec.basicnet.ipv6.adv">
   <title>Advantages</title>
   <para>
    The most important and most visible improvement brought by the new
    protocol is the enormous expansion of the available address space. An
    IPv6 address is made up of 128 bit values instead of the traditional
    32 bits. This provides for as many as several quadrillion IP addresses.
   </para>
   <para>
    However, IPv6 addresses are not only different from their predecessors
    with regard to their length. They also have a different internal
    structure that may contain more specific information about the systems
    and the networks to which they belong. More details about this are found
    in <xref linkend="sec.basicnet.ipv6.address"/>.
   </para>
   <para>
    The following is a list of some other advantages of the new protocol:
   </para>
   <variablelist>
    <varlistentry>
     <term>Autoconfiguration</term>
     <listitem>
      <para>
       IPv6 makes the network <quote>plug and play</quote> capable, which
       means that a newly set up system integrates into the (local) network
       without any manual configuration. The new host uses its automatic
       configuration mechanism to derive its own address from the
       information made available by the neighboring routers, relying on a
       protocol called the <emphasis>neighbor discovery</emphasis> (ND)
       protocol. This method does not require any intervention on the
       administrator's part and there is no need to maintain a central
       server for address allocation&mdash;an additional advantage over
       IPv4, where automatic address allocation requires a DHCP server.
      </para>
      <para>
       Nevertheless if a router is connected to a switch, the router should
       send periodic advertisements with flags telling the hosts of a
       network how they should interact with each other. For more
       information, see RFC 2462 and the
       <systemitem>radvd.conf(5)</systemitem> man page, and RFC 3315.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Mobility</term>
     <listitem>
      <para>
       IPv6 makes it possible to assign several addresses to one network
       interface at the same time. This allows users to access several
       networks easily, something that could be compared with the
       international roaming services offered by mobile phone companies:
       when you take your mobile phone abroad, the phone automatically logs
       in to a foreign service as soon as it enters the corresponding area,
       so you can be reached under the same number everywhere and are able
       to place an outgoing call, as you would in your home area.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Secure Communication</term>
     <listitem>
      <para>
       With IPv4, network security is an add-on function. IPv6 includes
       IPsec as one of its core features, allowing systems to communicate
       over a secure tunnel to avoid eavesdropping by outsiders on the
       Internet.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Backward Compatibility</term>
     <listitem>
      <para>
       Realistically, it would be impossible to switch the entire Internet
       from IPv4 to IPv6 at one time. Therefore, it is crucial that both
       protocols are able to coexist not only on the Internet, but also on
       one system. This is ensured by compatible addresses (IPv4 addresses
       can easily be translated into IPv6 addresses) and through the use of
       a number of tunnels. See <xref linkend="sec.basicnet.ipv6.coexist"/>.
       Also, systems can rely on a <emphasis>dual stack IP</emphasis>
       technique to support both protocols at the same time, meaning that
       they have two network stacks that are completely separate, such that
       there is no interference between the two protocol versions.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Custom Tailored Services through Multicasting</term>
     <listitem>
      <para>
       With IPv4, some services, such as SMB, need to broadcast their
       packets to all hosts in the local network. IPv6 allows a much more
       fine-grained approach by enabling servers to address hosts through
       <emphasis>multicasting</emphasis>&mdash;by addressing a number of
       hosts as parts of a group (which is different from addressing all
       hosts through <emphasis>broadcasting</emphasis> or each host
       individually through <emphasis>unicasting</emphasis>). Which hosts
       are addressed as a group may depend on the concrete application.
       There are some predefined groups to address all name servers (the
       <emphasis>all name servers multicast group</emphasis>), for example,
       or all routers (the <emphasis>all routers multicast
       group</emphasis>).
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="sec.basicnet.ipv6.address">
   <title>Address Types and Structure</title>
   <para>
    As mentioned, the current IP protocol is lacking in two important
    aspects: there is an increasing shortage of IP addresses and configuring
    the network and maintaining the routing tables is becoming a more
    complex and burdensome task. IPv6 solves the first problem by expanding
    the address space to 128 bits. The second one is countered by
    introducing a hierarchical address structure, combined with
    sophisticated techniques to allocate network addresses, as well as
    <emphasis>multihoming</emphasis> (the ability to assign several
    addresses to one device, giving access to several networks).
   </para>
   <para>
    When dealing with IPv6, it is useful to know about three different types
    of addresses:
   </para>
   <variablelist>
    <varlistentry>
     <term>Unicast</term>
     <listitem>
      <para>
       Addresses of this type are associated with exactly one network
       interface. Packets with such an address are delivered to only one
       destination. Accordingly, unicast addresses are used to transfer
       packets to individual hosts on the local network or the Internet.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Multicast</term>
     <listitem>
      <para>
       Addresses of this type relate to a group of network interfaces.
       Packets with such an address are delivered to all destinations that
       belong to the group. Multicast addresses are mainly used by certain
       network services to communicate with certain groups of hosts in a
       well-directed manner.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Anycast</term>
     <listitem>
      <para>
       Addresses of this type are related to a group of interfaces. Packets
       with such an address are delivered to the member of the group that is
       closest to the sender, according to the principles of the underlying
       routing protocol. Anycast addresses are used to make it easier for
       hosts to find out about servers offering certain services in the
       given network area. All servers of the same type have the same
       anycast address. Whenever a host requests a service, it receives a
       reply from the server with the closest location, as determined by the
       routing protocol. If this server should fail for some reason, the
       protocol automatically selects the second closest server, then the
       third one, and so forth.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    An IPv6 address is made up of eight four-digit fields, each representing
    16 bits, written in hexadecimal notation. They are separated by colons
    (<literal>:</literal>). Any leading zero bytes within a given field may
    be dropped, but zeros within the field or at its end may not. Another
    convention is that more than four consecutive zero bytes may be
    collapsed into a double colon. However, only one such
    <literal>::</literal> is allowed per address. This kind of shorthand
    notation is shown in <xref linkend="aus.netz.ipv6.add"/>, where all
    three lines represent the same address.
   </para>
   <example xml:id="aus.netz.ipv6.add">
    <title>Sample IPv6 Address</title>
<screen>fe80 : 0000 : 0000 : 0000 : 0000 : 10 : 1000 : 1a4
fe80 :    0 :    0 :    0 :    0 : 10 : 1000 : 1a4
fe80 :                           : 10 : 1000 : 1a4</screen>
   </example>
   <para>
    Each part of an IPv6 address has a defined function. The first bytes
    form the prefix and specify the type of address. The center part is the
    network portion of the address, but it may be unused. The end of the
    address forms the host part. With IPv6, the netmask is defined by
    indicating the length of the prefix after a slash at the end of the
    address. An address, as shown in <xref linkend="aus.netz.ipv6.addpre"/>,
    contains the information that the first 64 bits form the network part of
    the address and the last 64 form its host part. In other words, the
    <literal>64</literal> means that the netmask is filled with 64 1-bit
    values from the left. As with IPv4, the IP address is combined with AND
    with the values from the netmask to determine whether the host is
    located in the same subnet or in another one.
   </para>
   <example xml:id="aus.netz.ipv6.addpre">
    <title>IPv6 Address Specifying the Prefix Length</title>
<screen>fe80::10:1000:1a4/64</screen>
   </example>
   <para>
    IPv6 knows about several predefined types of prefixes. Some of these are
    shown in <xref linkend="list.net.basic.ipv6.prefix"/>.
   </para>
   <variablelist xml:id="list.net.basic.ipv6.prefix">
    <title>Various IPv6 Prefixes</title>
    <varlistentry>
     <term><systemitem class="ipaddress">00</systemitem>
     </term>
     <listitem>
      <para>
       IPv4 addresses and IPv4 over IPv6 compatibility addresses. These are
       used to maintain compatibility with IPv4. Their use still requires a
       router able to translate IPv6 packets into IPv4 packets. Several
       special addresses, such as the one for the loopback device, have this
       prefix as well.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem class="ipaddress">2</systemitem> or
      <systemitem class="ipaddress">3</systemitem> as the
      first digit
     </term>
     <listitem>
      <para>
       Aggregateable global unicast addresses. As is the case with IPv4, an
       interface can be assigned to form part of a certain subnet.
       Currently, there are the following address spaces:
       <systemitem class="ipaddress">2001::/16</systemitem> (production
       quality address space) and
       <systemitem class="ipaddress">2002::/16</systemitem> (6to4 address
       space).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem class="ipaddress">fe80::/10</systemitem>
     </term>
     <listitem>
      <para>
       Link-local addresses. Addresses with this prefix should not be routed
       and should therefore only be reachable from within the same subnet.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem class="ipaddress">fec0::/10</systemitem>
     </term>
     <listitem>
      <para>
       Site-local addresses. These may be routed, but only within the
       network of the organization to which they belong. In effect, they are
       the IPv6 equivalent of the current private network address space,
       such as <systemitem class="ipaddress">10.x.x.x</systemitem>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem class="ipaddress">ff</systemitem>
     </term>
     <listitem>
      <para>
       These are multicast addresses.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    A unicast address consists of three basic components:
   </para>
   <variablelist>
    <varlistentry>
     <term>Public Topology</term>
     <listitem>
      <para>
       The first part (which also contains one of the prefixes mentioned
       above) is used to route packets through the public Internet. It
       includes information about the company or institution that provides
       the Internet access.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Site Topology</term>
     <listitem>
      <para>
       The second part contains routing information about the subnet to
       which to deliver the packet.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Interface ID</term>
     <listitem>
      <para>
       The third part identifies the interface to which to deliver the
       packet. This also allows for the MAC to form part of the address.
       Given that the MAC is a globally unique, fixed identifier coded into
       the device by the hardware maker, the configuration procedure is
       substantially simplified. In fact, the first 64 address bits are
       consolidated to form the <literal>EUI-64</literal> token, with the
       last 48 bits taken from the MAC, and the remaining 24 bits containing
       special information about the token type. This also makes it possible
       to assign an <literal>EUI-64</literal> token to interfaces that do
       not have a MAC, such as those based on PPP.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    On top of this basic structure, IPv6 distinguishes between five
    different types of unicast addresses:
   </para>
   <variablelist>
    <varlistentry>
     <term><systemitem class="ipaddress">::</systemitem> (unspecified) </term>
     <listitem>
      <para>
       This address is used by the host as its source address when the
       interface is initialized for the first time&mdash;when the address
       cannot yet be determined by other means.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem class="ipaddress">::1</systemitem> (loopback) </term>
     <listitem>
      <para>
       The address of the loopback device.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>IPv4 Compatible Addresses</term>
     <listitem>
      <para>
       The IPv6 address is formed by the IPv4 address and a prefix
       consisting of 96 zero bits. This type of compatibility address is
       used for tunneling (see <xref linkend="sec.basicnet.ipv6.coexist"/>)
       to allow IPv4 and IPv6 hosts to communicate with others operating in
       a pure IPv4 environment.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>IPv4 Addresses Mapped to IPv6</term>
     <listitem>
      <para>
       This type of address specifies a pure IPv4 address in IPv6 notation.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Local Addresses</term>
     <listitem>
      <para>
       There are two address types for local use:
      </para>
      <variablelist>
       <varlistentry>
        <term>link-local</term>
        <listitem>
         <para>
          This type of address can only be used in the local subnet. Packets
          with a source or target address of this type should not be routed
          to the Internet or other subnets. These addresses contain a
          special prefix
          (<systemitem class="ipaddress">fe80::/10</systemitem>) and the
          interface ID of the network card, with the middle part consisting
          of zero bytes. Addresses of this type are used during automatic
          configuration to communicate with other hosts belonging to the
          same subnet.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>site-local</term>
        <listitem>
         <para>
          Packets with this type of address may be routed to other subnets,
          but not to the wider Internet&mdash;they must remain inside the
          organization's own network. Such addresses are used for intranets
          and are an equivalent of the private address space defined by
          IPv4. They contain a special prefix
          (<systemitem class="ipaddress">fec0::/10</systemitem>), the
          interface ID, and a 16 bit field specifying the subnet ID. Again,
          the rest is filled with zero bytes.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    As a completely new feature introduced with IPv6, each network interface
    normally gets several IP addresses, with the advantage that several
    networks can be accessed through the same interface. One of these
    networks can be configured completely automatically using the MAC and a
    known prefix with the result that all hosts on the local network can be
    reached as soon as IPv6 is enabled (using the link-local address). With
    the MAC forming part of it, any IP address used in the world is unique.
    The only variable parts of the address are those specifying the
    <emphasis>site topology</emphasis> and the <emphasis>public
    topology</emphasis>, depending on the actual network in which the host
    is currently operating.
   </para>
   <para>
    For a host to go back and forth between different networks, it needs at
    least two addresses. One of them, the <emphasis>home address</emphasis>,
    not only contains the interface ID but also an identifier of the home
    network to which it normally belongs (and the corresponding prefix). The
    home address is a static address and, as such, it does not normally
    change. Still, all packets destined to the mobile host can be delivered
    to it, regardless of whether it operates in the home network or
    somewhere outside. This is made possible by the completely new features
    introduced with IPv6, such as <emphasis>stateless
    autoconfiguration</emphasis> and <emphasis>neighbor
    discovery</emphasis>. In addition to its home address, a mobile host
    gets one or more additional addresses that belong to the foreign
    networks where it is roaming. These are called
    <emphasis>care-of</emphasis> addresses. The home network has a facility
    that forwards any packets destined to the host when it is roaming
    outside. In an IPv6 environment, this task is performed by the
    <emphasis>home agent</emphasis>, which takes all packets destined to the
    home address and relays them through a tunnel. On the other hand, those
    packets destined to the care-of address are directly transferred to the
    mobile host without any special detours.
   </para>
  </sect2>

  <sect2 xml:id="sec.basicnet.ipv6.coexist">
   <title>Coexistence of IPv4 and IPv6</title>
   <para>
    The migration of all hosts connected to the Internet from IPv4 to IPv6
    is a gradual process. Both protocols will coexist for some time to come.
    The coexistence on one system is guaranteed where there is a
    <emphasis>dual stack</emphasis> implementation of both protocols. That
    still leaves the question of how an IPv6 enabled host should communicate
    with an IPv4 host and how IPv6 packets should be transported by the
    current networks, which are predominantly IPv4 based. The best solutions
    offer tunneling and compatibility addresses (see
    <xref linkend="sec.basicnet.ipv6.address"/>).
   </para>
   <para>
    IPv6 hosts that are more or less isolated in the (worldwide) IPv4
    network can communicate through tunnels: IPv6 packets are encapsulated
    as IPv4 packets to move them across an IPv4 network. Such a connection
    between two IPv4 hosts is called a <emphasis>tunnel</emphasis>. To
    achieve this, packets must include the IPv6 destination address (or the
    corresponding prefix) as well as the IPv4 address of the remote host at
    the receiving end of the tunnel. A basic tunnel can be configured
    manually according to an agreement between the hosts' administrators.
    This is also called <emphasis>static tunneling</emphasis>.
   </para>
   <para>
    However, the configuration and maintenance of static tunnels is often
    too labor-intensive to use them for daily communication needs.
    Therefore, IPv6 provides for three different methods of
    <emphasis>dynamic tunneling</emphasis>:
   </para>
   <variablelist>
    <varlistentry>
     <term>6over4</term>
     <listitem>
      <para>
       IPv6 packets are automatically encapsulated as IPv4 packets and sent
       over an IPv4 network capable of multicasting. IPv6 is tricked into
       seeing the whole network (Internet) as a huge local area network
       (LAN). This makes it possible to determine the receiving end of the
       IPv4 tunnel automatically. However, this method does not scale very
       well and is also hampered by the fact that IP multicasting is far
       from widespread on the Internet. Therefore, it only provides a
       solution for smaller corporate or institutional networks where
       multicasting can be enabled. The specifications for this method are
       laid down in RFC 2529.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>6to4</term>
     <listitem>
      <para>
       With this method, IPv4 addresses are automatically generated from
       IPv6 addresses, enabling isolated IPv6 hosts to communicate over an
       IPv4 network. However, a number of problems have been reported
       regarding the communication between those isolated IPv6 hosts and the
       Internet. The method is described in RFC 3056.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>IPv6 Tunnel Broker</term>
     <listitem>
      <para>
       This method relies on special servers that provide dedicated tunnels
       for IPv6 hosts. It is described in RFC 3053.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="sec.basicnet.ipv6.config">
   <title>Configuring IPv6</title><indexterm>
   <primary>configuring</primary>
   <secondary>IPv6</secondary></indexterm><indexterm>
   <primary>networks</primary>
   <secondary>configuring</secondary>
   <tertiary>IPv6</tertiary></indexterm><indexterm>
   <primary>IP addresses</primary>
   <secondary>IPv6</secondary>
   <tertiary>configuring</tertiary></indexterm>
<!--
-    To disable or enable IPv6 on an installed system, start &yast;, open the
-    <menuchoice><guimenu>Network Devices</guimenu><guimenu>Network
-      Card</guimenu></menuchoice> dialog and in the <guimenu>Global
-     Options</guimenu> tab, check or uncheck <guimenu>Enable IPv6</guimenu>. 
-    <remark>TODO: Find out what the "disable autoload of the Kernel module for
-     ipv6" means - is this a required manual step to be done outside of network
-    configuration?</remark>
+    To disable or enable IPv6 on an installed system, use &yast; 
+    <guimenu>Network Card</guimenu>. Do not change the method and click
+    <guimenu>Next</guimenu>. 
+    Then select a card and click <menuchoice>
+     <guimenu>Advanced</guimenu>
+     <guimenu>IPv6</guimenu></menuchoice>
+    in the <guimenu>Address</guimenu> tab.

-->
   <para>
    To configure IPv6, you normally do not need to make any changes on the
    individual workstations. IPv6 is enabled by default. To disable or
    enable IPv6 on an installed system, use the &yast; <guimenu>Network
    Settings</guimenu> module. On the <guimenu>Global Options</guimenu> tab,
    check or uncheck the <guimenu>Enable IPv6</guimenu> option as necessary.
<!--To enable or disable IPv6 manually, edit
    <filename>/etc/modprobe.d/50-ipv6.conf</filename> and restart the
    system.-->
    If you want to enable it temporarily until the next reboot, enter
    <command>modprobe</command> <option>-i ipv6</option> as
    <systemitem class="username">root</systemitem>. It is impossible to
    unload the IPv6 module after is has been loaded.
   </para>
   <para>
    Because of the autoconfiguration concept of IPv6, the network card is
    assigned an address in the <emphasis>link-local</emphasis> network.
    Normally, no routing table management takes place on a workstation. The
    network routers can be queried by the workstation, using the
    <emphasis>router advertisement protocol</emphasis>, for what prefix and
    gateways should be implemented. The radvd program can be used to set up
    an IPv6 router. This program informs the workstations which prefix to
    use for the IPv6 addresses and which routers. Alternatively, use
    zebra/quagga for automatic configuration of both addresses and routing.
   </para>
<!-- 2014-04-15, ke: Karol will add this man page to the wicked
   package as well -->
   <para>
    For information about how to set up various types of tunnels using the
    <filename>/etc/sysconfig/network</filename> files, see the man page of
    <literal>ifcfg-tunnel</literal> (<command>man ifcfg-tunnel</command>).
   </para>
  </sect2>

  <sect2 xml:id="sec.basicnet.ipv6.moreinfo">
   <title>For More Information</title>
   <para>
    The above overview does not cover the topic of IPv6 comprehensively. For
    a more in-depth look at the new protocol, refer to the following online
    documentation and books:
   </para>
   <variablelist>
    <varlistentry>
     <term><link xlink:href="http://www.ipv6.org/"/>
     </term>
     <listitem>
      <para>
       The starting point for everything about IPv6.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link xlink:href="http://www.ipv6day.org"/>
     </term>
     <listitem>
      <para>
       All information needed to start your own IPv6 network.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link xlink:href="http://www.ipv6-to-standard.org/"/>
     </term>
     <listitem>
      <para>
       The list of IPv6-enabled products.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link xlink:href="http://www.bieringer.de/linux/IPv6/"/>
     </term>
     <listitem>
      <para>
       Here, find the Linux IPv6-HOWTO and many links related to the topic.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>RFC 2640</term>
     <listitem>
      <para>
       The fundamental RFC about IPv6.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>IPv6 Essentials</term>
     <listitem>
      <para>
       A book describing all the important aspects of the topic is
       <emphasis>IPv6 Essentials</emphasis> by Silvia Hagen (ISBN
       0-596-00125-8).
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.basicnet.nameres">
  <title>Name Resolution</title><indexterm>

  <primary>DNS</primary></indexterm><indexterm>

  <primary>networks</primary>

  <secondary>DNS</secondary></indexterm>

  <para>
   DNS assists in assigning an IP address to one or more names and assigning
   a name to an IP address. In Linux, this conversion is usually carried out
   by a special type of software known as bind. The machine that takes care
   of this conversion is called a <emphasis>name server</emphasis>. The
   names make up a hierarchical system in which each name component is
   separated by a period. The name hierarchy is, however, independent of the
   IP address hierarchy described above.
  </para>

  <para>
   Consider a complete name, such as
   <systemitem class="fqdomainname">&wsIname;</systemitem>, written in
   the format <systemitem class="fqdomainname">hostname.domain</systemitem>.
   A full name, referred to as a <emphasis>fully qualified domain
   name</emphasis> (FQDN), consists of a host name and a domain name
   (<systemitem class="domainname">&exampledomain;</systemitem>). The
   latter also includes the <emphasis>top level domain</emphasis> or TLD
   (<systemitem class="domainname">com</systemitem>).
  </para><indexterm>

  <primary>DNS</primary>

  <secondary>top level domain</secondary></indexterm>

  <para>
   TLD assignment has become quite confusing for historical reasons.
   Traditionally, three-letter domain names are used in the USA. In the rest
   of the world, the two-letter ISO national codes are the standard. In
   addition to that, longer TLDs were introduced in 2000 that represent
   certain spheres of activity (for example,
   <systemitem class="domainname">.info</systemitem>,
   <systemitem class="domainname">.name</systemitem>,
   <systemitem class="domainname">.museum</systemitem>).
  </para>

  <para>
   In the early days of the Internet (before 1990), the file
   <filename>/etc/hosts</filename> was used to store the names of all the
   machines represented over the Internet. This quickly proved to be
   impractical in the face of the rapidly growing number of computers
   connected to the Internet. For this reason, a decentralized database was
   developed to store the host names in a widely distributed manner. This
   database, similar to the name server, does not have the data pertaining
   to all hosts in the Internet readily available, but can dispatch requests
   to other name servers.
  </para><indexterm>

  <primary>configuration files</primary>

  <secondary>hosts</secondary></indexterm>

  <para>
   The top of the hierarchy is occupied by <emphasis>root name
   servers</emphasis>. These root name servers manage the top level domains
   and are run by the Network Information Center (NIC). Each root name
   server knows about the name servers responsible for a given top level
   domain. Information about top level domain NICs is available at
   <link xlink:href="http://www.internic.net"/>.
  </para><indexterm>

  <primary>DNS</primary>

  <secondary>NIC</secondary></indexterm>

  <para>
   DNS can do more than resolve host names. The name server also knows which
   host is receiving e-mails for an entire domain&mdash;the
   <emphasis>mail exchanger (MX)</emphasis>.
  </para><indexterm>

  <primary>DNS</primary>

  <secondary>mail exchanger</secondary></indexterm>

  <para>
   For your machine to resolve an IP address, it must know about at least
   one name server and its IP address. Easily specify such a name server
   with the help of &yast;. If you have a modem dial-up connection, you
   may not need to configure a name server manually at all. The dial-up
   protocol provides the name server address as the connection is made.
   <phrase os="sles">The configuration of name server access with
   &productnamereg; is described in
   <xref linkend="sec.basicnet.yast.change.host"/>. Setting up your own name
   server is described in <xref linkend="cha.dns"/>.</phrase>
  </para><indexterm>

  <primary>whois</primary></indexterm>

  <para>
   The protocol <literal>whois</literal> is closely related to DNS. With
   this program, quickly find out who is responsible for any given domain.
  </para>

<!-- bug 349467 -->

  <note>
   <title>MDNS and .local Domain Names</title>
   <para>
    The <literal>.local</literal> top level domain is treated as link-local
    domain by the resolver. DNS requests are send as multicast DNS requests
    instead of normal DNS requests. If you already use the
    <literal>.local</literal> domain in your name server configuration, you
    must switch this option off in <filename>/etc/host.conf</filename>. For
    more information, see the <filename>host.conf</filename> manual page.
   </para>
   <para>
    If you want to switch off MDNS during installation, use
    <literal>nomdns=1</literal> as a boot parameter.
   </para>
   <para>
    For more information on multicast DNS, see
    <link xlink:href="http://www.multicastdns.org"/>.
   </para>
  </note>
 </sect1>
 <xi:include href="net_yast.xml"/>
 <xi:include os="sled" href="networkmanager.xml"/>
 <xi:include href="net_wicked.xml"/>
 <xi:include href="net_bonding.xml"/>
</chapter>