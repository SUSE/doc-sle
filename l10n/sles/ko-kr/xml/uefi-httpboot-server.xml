<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="uefi-httpboot-server.xml" version="5.0" xml:id="cha-deployment-prep-uefi-httpboot">
 <title>UEFI HTTP 부팅 서버 설정</title>
 <info>
  <abstract>
   <para>
    이 장에서는 UEFI HTTP 부팅 서버를 설정하고 구성하는 방법에 대해 설명합니다.
   </para>
  </abstract>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>
 <sect1 xml:id="httpboot-intro">
  <title>소개</title>

  <para>
   HTTP Boot는 네트워크를 통해 시스템을 부팅하고 배포할 수 있도록 DHCP, DNS 및 HTTP를 결합합니다. HTTP Boot는 PXE에 대한 고성능 대체 수단으로 사용할 수 있습니다. HTTP Boot를 사용하면 HTTP를 통해 URI에서 서버를 부팅할 수 있습니다. 따라서 로컬 네트워크 밖에 있는 서버에서 Linux 커널, 루트 파일 시스템과 같은 대규모 파일을 빠르게 전송할 수 있습니다.
  </para>

  <sect2 xml:id="httpboot-client">
   <title>클라이언트 시스템 구성</title>
   <para>
    물리적 클라이언트 시스템에서 HTTP Boot를 활성화할지 여부는 하드웨어에 따라 달라집니다. 특정 시스템에서 HTTP Boot를 활성화하는 방법에 관한 자세한 내용은 문서를 참조하십시오.
   </para>
  </sect2>

  <sect2 xml:id="httpboot-preparation">
   <title>준비</title>
   <para>
    여기에서 설명한 설정은 192.168.111.0/24(IPv4) 및 2001:db8:f00f:cafe::/64 (IPv6) IP 서브넷을 사용하고, 서버 IP 주소는 예시 주소인 192.168.111.1(IPv4) 및 2001:db8:f00f:cafe::1/64(IPv6)입니다. 이 값이 특정 설정에 부합하도록 조정하십시오.
   </para>
   <para>
    HTTP Boot 서버로 사용하려는 시스템에 <package>dhcp-server</package>, <package>apache2</package>(또는 <package>lighttpd</package>) 및 <package>dnsmasq</package> 패키지를 설치합니다.
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="httpboot-configure-server">
  <title>서버 구성</title>

  <sect2 xml:id="httpboot-dns-server">
   <title>DNS 서버</title>
   <para>
    DNS 서버 구성은 옵션이지만 이를 통해 HTTP Boot 서버에 사용자에게 친숙한 이름을 할당할 수 있습니다. DNS 서버를 설정하려면 <filename>/etc/dnsmasq.conf</filename> 파일에 다음 코드를 추가하십시오.
   </para>
<screen>interface=eth0
addn-hosts=/etc/dnsmasq.d/hosts.conf</screen>
   <para>
    <filename>/etc/dnsmasq.d/hosts.conf</filename> 파일에서 다음과 같이 IP 주소에 도메인 이름을 할당하십시오.
   </para>
<screen>192.168.111.1 www.httpboot.local
2001:db8:f00f:cafe::1 www.httpboot.local</screen>
   <para>
    DNS 서버를 시작하십시오.
   </para>
<screen>systemctl start dnsmasq</screen>
   <note>
    <title><phrase role="productname">shim</phrase> 부트 로더 사용</title>
    <para>
     UEFI 2.7이 변경되었으므로 SLE 15 이상 버전에서 shim 부트 로더를 사용해 추가 DNS 노드로 인해 발생할 수 있는 오류를 피하는 것이 좋습니다.
    </para>
   </note>
   <sect3 xml:id="httpboot-dhcpv4-server">
    <title>DHCPv4 서버 구성</title>
    <para>
     DHCP 서버를 설정하기 전에 다음과 같이 <filename>/etc/sysconfig/dhcpd</filename>에서 DHCP 서버에 대한 네트워크 인터페이스를 지정하십시오.
    </para>
<screen>DHCPD_INTERFACE="eth0"
DHCPD6_INTERFACE="eth0"</screen>
    <para>
     이렇게 하면 DHCP 서버가 <literal>eth0</literal> 인터페이스에서만 서비스를 제공합니다.
    </para>
    <para>
     PXE Boot와 HTTP Boot에 대해 모두 DHCPv4 서버를 설정하려면 다음 구성을 <filename>/etc/dhcpd.conf</filename> 파일에 추가하십시오.
    </para>
<screen>option domain-name-servers 192.168.111.1;
option routers 192.168.111.1;
default-lease-time 14400;
ddns-update-style none;
  subnet 192.168.111.0 netmask 255.255.255.0 {
    range dynamic-bootp 192.168.111.100 192.168.111.120;
    default-lease-time 14400;
    max-lease-time 172800;
    class "pxeclients"{
      match if substring (option vendor-class-identifier, 0, 9) = "PXEClient";
      next-server 192.168.111.1;
      filename "/bootx64.efi";
    }
    class "httpclients" {
      match if substring (option vendor-class-identifier, 0, 10) = "HTTPClient";
      option vendor-class-identifier "HTTPClient";
      filename "http://www.httpboot.local/sle/EFI/BOOT/bootx64.efi";
    }
}</screen>
    <para>
     DHCPv4 서버는 벤더 클래스 ID에 대해 <literal>HTTPClient</literal> 파라미터를 사용해야 합니다. 클라이언트가 이 파라미터를 사용해 HTTP Boot 오퍼를 식별하기 때문입니다.
    </para>
    <para>
     다음과 같이 DHCP 데몬을 시작하십시오.
    </para>
    <para>
     <literal>systemctl start dhcpd</literal>
    </para>
   </sect3>
   <sect3 xml:id="httpboot-dhcpv6-server">
    <title>DHCPv6 서버 구성</title>
    <para>
     DHCPv6 서버를 설정하려면 <filename>/etc/dhcpd6.conf</filename>에 다음 구성을 추가하십시오.
    </para>
<screen>option dhcp6.bootfile-url code 59 = string;
option dhcp6.vendor-class code 16 = {integer 32, integer 16, string};
subnet6 2001:db8:f00f:cafe::/64 {
        range6 2001:db8:f00f:cafe::42:10 2001:db8:f00f:cafe::42:99;
        option dhcp6.bootfile-url "http://www.httpboot.local/sle/EFI/BOOT/bootx64.efi";
        option dhcp6.name-servers 2001:db8:f00f:cafe::1;
        option dhcp6.vendor-class 0 10 "HTTPClient";
}</screen>
    <para>
     이 구성은 부팅 URL의 형식, 벤더 클래스, 기타 필수 옵션을 정의합니다. DHCPv4 설정과 유사하게 부팅 URL을 제공해야 하며, 이 URL에는 IPv6 주소가 있어야 합니다. 벤더 클래스 옵션도 지정해야 합니다. DHCPv6의 경우 엔터프라이즈 번호 및 벤더 클래스 데이터(길이 및 내용)로 구성됩니다. HTTP Boot 드라이버는 엔터프라이즈 번호를 무시하므로 <literal>0</literal>으로 설정할 수 있습니다. 벤더 클래스 데이터의 내용은 <literal>HTTPClient</literal>여야 합니다. 그렇지 않으면 클라이언트가 오퍼를 무시합니다.
    </para>
    <para>
     <link xlink:href="https://datatracker.ietf.org/doc/html/rfc3315">RFC 3315</link>를 따르지 않는 이전의 HTTP Boot 구현에는 다음과 같이 다른 구성이 필요합니다.
    </para>
<screen>option dhcp6.bootfile-url code 59 = string;
option dhcp6.vendor-class code 16 = string;
        subnet6 2001:db8:f00f:cafe::/64 {
        range6 2001:db8:f00f:cafe::42:10 2001:db8:f00f:cafe::42:99;
        option dhcp6.bootfile-url "http://www.httpboot.local/sle/EFI/BOOT/bootx64.efi;
	option dhcp6.name-servers 2001:db8:f00f:cafe::1;
	option dhcp6.vendor-class "HTTPClient";
}</screen>
    <para>
     <literal>dhcpv6</literal> 데몬을 시작하십시오.
    </para>
<screen>systemctl start dhcpd6</screen>
    <sect4 xml:id="httpboot-dhcpv6-pxe-server">
     <title>PXE 및 HTTP Boot에 모두 DHCPv6 서버 설정</title>
     <para>
      다음 구성을 사용하면 PXE Boot 및 HTTP Boot에 모두 DHCPv6 서버를 구성할 수 있습니다.
     </para>
<screen>option dhcp6.bootfile-url code 59 = string;
option dhcp6.vendor-class code 16 = {integer 32, integer 16, string};

subnet6 2001:db8:f00f:cafe::/64 {
        range6 2001:db8:f00f:cafe::42:10 2001:db8:f00f:cafe::42:99;

        class "PXEClient" {
	        match substring (option dhcp6.vendor-class, 6, 9);
	}

        subclass "PXEClient" "PXEClient" {
	        option dhcp6.bootfile-url "tftp://[2001:db8:f00f:cafe::1]/bootloader.efi";
	}

	class "HTTPClient"; {
	        match substring (option dhcp6.vendor-class, 6, 10);
	}

	subclass "HTTPClient" "HTTPClient" {
	        option dhcp6.bootfile-url "http://www.httpboot.local/sle/EFI/BOOT/bootx64.efi";
		option dhcp6.name-servers 2001:db8:f00f:cafe::1;
		option dhcp6.vendor-class 0 10 "HTTPClient";
	}
}</screen>
     <para>
      다음과 같이 벤더 클래스를 특정 아키텍처에 일치시킬 수도 있습니다.
     </para>
<screen>class "HTTPClient" {
        match substring (option dhcp6.vendor-class, 6, 21);
	}

subclass "HTTPClient" "HTTPClient":Arch:00016 {
        option dhcp6.bootfile-url "http://www.httpboot.local/sle/EFI/BOOT/bootx64.efi";
	option dhcp6.name-servers 2001:db8:f00f:cafe::1;
	option dhcp6.vendor-class 0 10 "HTTPClient";
}</screen>
     <para>
      이 예에서 <literal>HTTPClient:Arch:00016</literal>은 AMD64/Intel 64 HTTP Boot 클라이언트를 가리킵니다. 이 구성을 통해 서버는 다양한 아키텍처를 동시에 제공할 수 있습니다.
     </para>
    </sect4>
    <sect4 xml:id="httpboot-firewall">
     <title>방화벽 구성</title>
     <para>
      DHCPv6 패킷이 방화벽의 RP 필터로 삭제되는 경우 로그를 확인하십시오. <literal>rpfilter_DROP</literal> 항목이 포함되어 있는 경우 <filename>/etc/firewalld/firewalld.conf</filename>에서 다음 구성을 사용해 필터를 비활성화하십시오.
     </para>
     <para>
      <literal>IPv6_rpfilter=no</literal>
     </para>
    </sect4>
   </sect3>
   <sect3 xml:id="httpboot-tftp-server">
    <title>TFTP 서버 배포(옵션)</title>
    <para>
     PXE Boot 및 HTTP Boot에 대해 모두 지원을 제공하려면 TFTP 서버를 배포하십시오. <package>tftp</package>를 설치하고 해당 서비스를 시작합니다.
    </para>
<screen> systemctl start tftp.socket
systemctl start tftp.service</screen>
    <para>
     PXE Boot와 함께 사용할 특정 <package>tftpboot-installation</package> 패키지도 설치해야 합니다. <command>zypper se tftpboot</command> 명령어를 실행하여 사용 가능한 <package>tftp-installation</package> 패키지 목록을 표시한 다음 원하는 시스템 버전 및 아키텍처의 패키지를 설치합니다(예: <package>tftpboot-installation-SLE-15-SP3-x86_64</package>). 예: <package os="sles;sled">tftpboot-installation-SLE-<replaceable>VERSION</replaceable>-x86_64</package>(<replaceable>VERSION</replaceable>을 실제 버전으로 대체). 다음과 같이 <filename os="sles;sled">SLE-<replaceable>VERSION</replaceable>-x86_64</filename> 디렉토리의 내용을 TFTP 서버의 루트 디렉토리에 복사하십시오.
    </para>


    <para>
     자세한 내용은 <filename os="sles;sled">/usr/share/tftpboot-installation/SLE-<replaceable>VERSION</replaceable>-x86_64/README</filename>를 참조하십시오.
    </para>
   </sect3>
   <sect3 xml:id="httpboot-http-server">
    <title>HTTP 서버 설정</title>
    <para>
     첫 번째 시스템 ISO 이미지의 전체 내용을 <filename os="sles;sled">/srv/www/htdocs/sle/</filename> 디렉토리에 복사하십시오. 그런 다음, <filename os="sles;sled">/srv/www/htdocs/sle/grub.cfg</filename> 파일을 편집하십시오. 다음 예를 참조로 사용하십시오.
    </para>
<screen>timeout=60
default=1

menuentry 'Installation IPv4' --class opensuse --class gnu-linux --class gnu --class os {
    set gfxpayload=keep
    echo 'Loading kernel ...'
    linuxefi /sle/boot/x86_64/loader/linux install=http://www.httpboot.local/sle
    echo 'Loading initial ramdisk ...'
    initrdefi /sle/boot/x86_64/loader/initrd
}

menuentry 'Installation IPv6' --class opensuse --class gnu-linux --class gnu --class os {
    set gfxpayload=keep
    echo 'Loading kernel ...'
    linuxefi /sle/boot/x86_64/loader/linux install=install=http://www.httpboot.local/sle ipv6only=1 ifcfg=*=dhcp6,DHCLIENT6_MODE=managed
    echo 'Loading initial ramdisk ...'
    initrdefi /sle/boot/x86_64/loader/initrd
}</screen>
    <sect4 xml:id="httpboot-lighttpd">
     <title>lighttpd 구성</title>
     <para>
      Lighttpd에서 IPv4 및 IPv6 모두에 대한 지원을 활성화하려면 <filename>/etc/lighttpd/lighttpd.conf</filename>를 다음과 같이 수정하십시오.
     </para>
<screen>##
## Use IPv6?
##
#server.use-ipv6 = "enable"
$SERVER["socket"] == "[::]:80" {  }</screen>
     <para>
      다음과 같이 <literal>lighttpd</literal> 데몬을 시작하십시오.
     </para>
<screen>systemctl start lighttpd</screen>
    </sect4>
    <sect4 xml:id="httpboot-apache2">
     <title>apache2 구성</title>
     <para>
      Apache에는 추가 구성이 필요 없습니다. 다음과 같이 <literal>apache2</literal> 데몬을 시작하십시오.
     </para>
<screen>systemctl start apache2</screen>
    </sect4>
   </sect3>
   <sect3 xml:id="httpboot-http-server-ssl-support">
    <title>HTTP 서버에 대한 SSL 지원 활성화(옵션)</title>
    <para>
     HTTPS Boot를 사용하려면 기존 서버 인증서를 <literal>DER</literal> 형식으로 변환하여 클라이언트의 펌웨어에 등록해야 합니다.
    </para>
    <para>
     서버에 이미 인증서가 설치되어 있다고 가정하고 다음 명령을 사용해 인증서를 클라이언트에서 사용할 수 있도록 <literal>DER</literal> 형식으로 변환하십시오.
    </para>
<screen>openssl x509 -in <replaceable>CERTIFICATE</replaceable>.crt -outform der -out <replaceable>CERTIFICATE</replaceable>.der</screen>
    <sect4 xml:id="httpboot-enroll-certificate-physical-machine">
     <title>서버 인증서를 클라이언트 펌웨어에 등록</title>
     <para>
      변환한 인증서를 등록하는 정확한 절차는 클라이언트 펌웨어 구현에 따라 달라집니다. 어떤 하드웨어의 경우 외부 저장소 장치를 이 장치에 있는 인증서와 함께 사용하여 펌웨어 UI를 통해 인증서를 수동으로 등록해야 합니다. Redfish를 지원하는 시스템은 인증서를 원격으로 등록할 수 있습니다. 인증서 등록에 관한 자세한 내용은 해당 하드웨어의 문서를 참조하십시오.
     </para>
    </sect4>
    <sect4 xml:id="httpboot-ssl-lighttpd">
     <title>lighttpd에서 SSL 지원 활성화</title>
     <para>
      lighttpd의 경우 개인 키와 인증서가 동일한 파일에 있어야 하므로 다음 명령을 사용해 두 가지를 통합하십시오.
     </para>
<screen>cat <replaceable>CERTIFICATE</replaceable>.crt server.key &gt; <replaceable>CERTIFICATE</replaceable>.pem</screen>
     <para>
      <filename><replaceable>CERTIFICATE</replaceable>.pem</filename>을 <filename>/etc/ssl/private/</filename> 디렉토리에 복사하십시오.
     </para>
<screen>cp server-almighty.pem /etc/ssl/private/
chown -R root:lighttpd /etc/ssl/private/server-almighty.pem
chmod 640 /etc/ssl/private/server-almighty.pem</screen>
     <para>
      예를 들어 다음과 같이 <literal>mod_openssl</literal>이 <filename>/etc/lighttpd/modules.conf</filename> 파일의 <literal>server.modules</literal> 섹션에 나열되어 있는지 확인하십시오.
     </para>
<screen>server.modules = (
  "mod_access",
  "mod_openssl",
)</screen>
     <para>
      <filename>/etc/lighttpd/lighttpd.conf</filename>의 <literal>SSL Support</literal> 섹션에 다음 줄을 추가하십시오.
     </para>
<screen># IPv4
$SERVER["socket"] == ":443" {
    ssl.engine                 = "enable"
    ssl.pemfile                = "/etc/ssl/private/server-almighty.pem"
}
# IPv6
$SERVER["socket"] == "[::]:443" {
    ssl.engine                 = "enable"
    ssl.pemfile                = "/etc/ssl/private/server-almighty.pem"
}</screen>
     <para>
      다음과 같이 lighttpd를 재시작하여 SSL 지원을 활성화하십시오.
     </para>
<screen>systemctl restart lighttpd</screen>
    </sect4>
    <sect4 xml:id="http-ssl-apache">
     <title>Apache에서 SSL 지원 활성화</title>
     <para>
      <filename>/etc/sysconfig/apache2</filename> 파일을 열고 다음과 같이 SSL 플래그를 추가하십시오.
     </para>
<screen>APACHE_SERVER_FLAGS="SSL"</screen>
     <para>
      예를 들어 <literal>ssl</literal> 모듈이 <literal>APACHE_MODULES</literal>에 나열되어 있는지 확인하십시오.
     </para>
     <para>
      그런 다음 개인 키 및 인증서를 <filename>/etc/apache2/</filename> 디렉토리에 복사하십시오.
     </para>
<screen>cp server.key /etc/apache2/ssl.key/
chown wwwrun /etc/apache2/ssl.key/server.key
chmod 600 /etc/apache2/ssl.key/server.key
cp server.crt /etc/apache2/ssl.crt/</screen>
     <para>
      ssl vhost 구성을 생성하십시오.
     </para>
<screen>cd /etc/apache2/vhosts.d
cp vhost-ssl.template vhost-ssl.conf</screen>
     <para>
      다음과 같이 <filename>/etc/apache2/vhosts.d/vhost-ssl.conf</filename>를 편집하여 개인 키 및 인증서를 변경하십시오.
     </para>
<screen>SSLCertificateFile /etc/apache2/ssl.crt/server.crt
 SSLCertificateKeyFile /etc/apache2/ssl.key/server.key</screen>
     <para>
      다음과 같이 apache를 재시작하여 SSL 지원을 활성화하십시오.
     </para>
<screen>systemctl restart apache2</screen>
    </sect4>
    <sect4 xml:id="httpboot-modify-dhcp-configuration">
     <title>DHCP 구성 수정</title>
     <para>
      <filename>dhcpd.conf/dhcpd6.conf</filename>에서 <literal>http://</literal> 접두사를 <literal>https://</literal>로 변경하고 DHCP 서버를 재시작하십시오.
     </para>
<screen>systemctl restart dhcpd
systemctl restart dhcpd6</screen>
    </sect4>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="httpboot-client-boot">
  <title>HTTP Boot를 통한 클라이언트 부팅</title>

  <para>
   펌웨어가 이미 HTTP Boot를 지원하는 경우 케이블을 연결하고 올바른 부팅 옵션을 선택하십시오.
  </para>
 </sect1>
</chapter>
