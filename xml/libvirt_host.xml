<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "generic-entities.ent">
    %entities;
]>
<chapter xmlns="http://docbook.org/ns/docbook"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
         xml:id="cha-libvirt-host">
 <info>
  <title>Preparing the &vmhost;</title>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>
 <para>
  Before you can install guest virtual machines, you need to prepare the
  &vmhost; to provide the guests with the resources that they need for their
  operation. Specifically, you need to configure:
 </para>
 <itemizedlist>
  <listitem>
   <para>
    <emphasis>Networking</emphasis> so that guests can make use of the network
    connection provided the host.
   </para>
  </listitem>
  <listitem>
   <para>
    A <emphasis>storage pool</emphasis> reachable from the host so that the
    guests can store their disk images.
   </para>
  </listitem>
 </itemizedlist>
 <sect1 xml:id="libvirt-host-network">
  <title>Configuring networks</title>

  <para>
   There are two common network configurations to provide a &vmguest; with a
   network connection:
  </para>

  <itemizedlist>
   <listitem>
    <para>
     A <emphasis>network bridge</emphasis>. This is the default and recommended
     way of providing the guests with network connection.
    </para>
   </listitem>
   <listitem>
    <para>
     A <emphasis>virtual network</emphasis> with forwarding enabled.
    </para>
   </listitem>
  </itemizedlist>

  <sect2 xml:id="libvirt-networks-bridged">
   <title>Network bridge</title>
   <para>
    The network bridge configuration provides a Layer 2 switch for &vmguest;s,
    switching Layer 2 Ethernet packets between ports on the bridge based on MAC
    addresses associated with the ports. This gives the &vmguest; Layer 2
    access to the &vmhost;'s network. This configuration is analogous to
    connecting the &vmguest;'s virtual Ethernet cable into a hub that is shared
    with the host and other &vmguest;s running on the host. The configuration
    is often referred to as <emphasis>shared physical device</emphasis>.
   </para>
   <para>
    The network bridge configuration is the default configuration of
    &productname; when configured as a &kvm; or &xen; hypervisor. It is the
    preferred configuration when you simply want to connect &vmguest;s to the
    &vmhost;'s LAN.
   </para>
   <para>
    Which tool to use to create the network bridge depends on the service you
    use to manage the network connection on the &vmhost;:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      If a network connection is managed by <systemitem>wicked</systemitem>,
      use either &yast; or the command line to create the network bridge.
      <systemitem>wicked</systemitem> is the default on server hosts.
     </para>
    </listitem>
    <listitem>
     <para>
      If a network connection is managed by &nm;, use the &nm; command line tool
      <command>nmcli</command> to create the network bridge.
      &nm; is the default on desktop and laptops.
     </para>
    </listitem>
   </itemizedlist>
   <sect3 xml:id="libvirt-networks-bridged-yast">
    <title>Managing network bridges with &yast;</title>
    <para>
     This section includes procedures to add or remove network bridges with
     &yast;.
    </para>
    <sect4 xml:id="libvirt-networks-bridged-yast-add">
     <title>Adding a network bridge</title>
     <para>
      To add a network bridge on &vmhost;, follow these steps:
     </para>
     <procedure>
      <step>
       <para>
        Start
        <menuchoice><guimenu>&yast;</guimenu><guimenu>System</guimenu><guimenu>Network
        Settings</guimenu></menuchoice>.
       </para>
      </step>
      <step>
       <para>
        Activate the <guimenu>Overview</guimenu> tab and click
        <guimenu>Add</guimenu>.
       </para>
      </step>
      <step>
       <para>
        Select <guimenu>Bridge</guimenu> from the <guimenu>Device
        Type</guimenu> list and enter the bridge device interface name in the
        <guimenu>Configuration Name</guimenu> entry. Click the
        <guimenu>Next</guimenu> button to proceed.
       </para>
      </step>
      <step>
       <para>
        In the <guimenu>Address</guimenu> tab, specify networking details such
        as DHCP/static IP address, subnet mask or host name.
       </para>
       <para>
        Using <guimenu>Dynamic Address</guimenu> is only useful when also
        assigning a device to a bridge that is connected to a DHCP server.
       </para>
       <para>
        If you intend to create a virtual bridge that has no connection to a
        real network device, use <guimenu>Statically assigned IP
        Address</guimenu>. In this case, it is a good idea to use addresses
        from the private IP address ranges, for example,
        <literal>192.168.0.0/16</literal>, <literal>172.16.0.0/12</literal>, or
        <literal>10.0.0.0/8</literal>.
       </para>
       <para>
        To create a bridge that should only serve as a connection between the
        different guests without connection to the host system, set the IP
        address to <literal>0.0.0.0</literal> and the subnet mask to
        <literal>255.255.255.255</literal>. The network scripts handle this
        special address as an unset IP address.
       </para>
      </step>
      <step>
       <para>
        Activate the <guimenu>Bridged Devices</guimenu> tab and activate the
        network devices you want to include in the network bridge.
       </para>
      </step>
      <step>
       <para>
        Click <guimenu>Next</guimenu> to return to the
        <guimenu>Overview</guimenu> tab and confirm with <guimenu>OK</guimenu>.
        The new network bridge should now be active on &vmhost;.
       </para>
      </step>
     </procedure>
    </sect4>
    <sect4 xml:id="libvirt-networks-bridged-yast-rm">
     <title>Deleting a network bridge</title>
     <para>
      To delete an existing network bridge, follow these steps:
     </para>
     <procedure>
      <step>
       <para>
        Start
        <menuchoice><guimenu>&yast;</guimenu><guimenu>System</guimenu><guimenu>Network
        Settings</guimenu></menuchoice>.
       </para>
      </step>
      <step>
       <para>
        Select the bridge device you want to delete from the list in the
        <guimenu>Overview</guimenu> tab.
       </para>
      </step>
      <step>
       <para>
        Delete the bridge with <guimenu>Delete</guimenu> and confirm with
        <guimenu>OK</guimenu>.
       </para>
      </step>
     </procedure>
    </sect4>
   </sect3>
   <sect3 xml:id="libvirt-networks-bridged-add-brctl">
    <title>Managing network bridges from the command line</title>
    <para>
     This section includes procedures to add or remove network bridges using
     the command line.
    </para>
    <sect4 xml:id="libvirt-networks-bridged-add-brctl-add">
     <title>Adding a network bridge</title>
     <para>
      To add a new network bridge device on &vmhost;, follow these steps:
     </para>
     <procedure>
      <step>
       <para>
        Log in as &rootuser; on the &vmhost; where you want to create a new
        network bridge.
       </para>
      </step>
      <step>
       <para>
        Choose a name for the new
        bridge&mdash;<replaceable>virbr_test</replaceable> in our
        example&mdash;and run
       </para>
<screen>&prompt.root;ip link add name <replaceable>VIRBR_TEST</replaceable> type bridge</screen>
      </step>
      <step>
       <para>
        Check if the bridge was created on &vmhost;:
       </para>
<screen>&prompt.root;bridge vlan
[...]
virbr_test  1 PVID Egress Untagged
</screen>
       <para>
        <literal>virbr_test</literal> is present, but is not associated with
        any physical network interface.
       </para>
      </step>
      <step>
       <para>
        Bring the network bridge up and add a network interface to the bridge:
       </para>
<screen>
&prompt.root;ip link set virbr_test up
&prompt.root;ip link set eth1 master virbr_test
</screen>
       <important>
        <title>Network interface must be unused</title>
        <para>
         You can only assign a network interface that is not yet used by
         another network bridge.
        </para>
       </important>
      </step>
      <step>
       <para>
        Optionally, enable STP (see
        <link xlink:href="https://en.wikipedia.org/wiki/Spanning_Tree_Protocol">Spanning
        Tree Protocol</link>):
       </para>
<screen>&prompt.root;bridge link set dev virbr_test cost 4</screen>
      </step>
     </procedure>
    </sect4>
    <sect4 xml:id="libvirt-networks-bridged-add-brctl-del">
     <title>Deleting a network bridge</title>
     <para>
      To delete an existing network bridge device on &vmhost; from the command
      line, follow these steps:
     </para>
     <procedure>
      <step>
       <para>
        Log in as &rootuser; on the &vmhost; where you want to delete an
        existing network bridge.
       </para>
      </step>
      <step>
       <para>
        List existing network bridges to identify the name of the bridge to
        remove:
       </para>
<screen>&prompt.root;bridge vlan
[...]
virbr_test  1 PVID Egress Untagged
</screen>
      </step>
      <step>
       <para>
        Delete the bridge:
       </para>
<screen>&prompt.root;ip link delete dev virbr_test</screen>
      </step>
     </procedure>
    </sect4>
   </sect3>
   <sect3 xml:id="libvirt-networks-bridged-add-nm">
    <title>Adding a network bridge with <command>nmcli</command></title>
    <para>
     This section includes procedures to add a network bridge with &nm;'s
     command line tool <command>nmcli</command>.
    </para>
    <procedure>
     <step>
      <para>
       List active network connections:
      </para>
<screen>
&prompt.sudo;nmcli connection show --active
NAME                   UUID                                  TYPE      DEVICE
Ethernet connection 1  84ba4c22-0cfe-46b6-87bb-909be6cb1214  ethernet  eth0
</screen>
     </step>
     <step>
      <para>
       Add a new bridge device named <literal>br0</literal> and verify its
       creation:
      </para>
<screen>
&prompt.sudo;nmcli connection add type bridge ifname br0
Connection 'bridge-br0' (36e11b95-8d5d-4a8f-9ca3-ff4180eb89f7) \
successfully added.
&prompt.sudo;nmcli connection show --active
NAME                   UUID                                  TYPE      DEVICE
bridge-br0             36e11b95-8d5d-4a8f-9ca3-ff4180eb89f7  bridge    br0
Ethernet connection 1  84ba4c22-0cfe-46b6-87bb-909be6cb1214  ethernet  eth0
</screen>
     </step>
     <step>
      <para>
       Optionally, you can view the bridge settings:
      </para>
<screen>
&prompt.sudo;nmcli -f bridge connection show bridge-br0
bridge.mac-address:                     --
bridge.stp:                             yes
bridge.priority:                        32768
bridge.forward-delay:                   15
bridge.hello-time:                      2
bridge.max-age:                         20
bridge.ageing-time:                     300
bridge.group-forward-mask:              0
bridge.multicast-snooping:              yes
bridge.vlan-filtering:                  no
bridge.vlan-default-pvid:               1
bridge.vlans:                           --
</screen>
     </step>
     <step>
      <para>
       Link the bridge device to the physical Ethernet device
       <literal>eth0</literal>:
      </para>
<screen>&prompt.sudo;nmcli connection add type bridge-slave ifname eth0 master br0</screen>
     </step>
     <step>
      <para>
       Disable the <literal>eth0</literal> interface and enable the new
       bridge:
      </para>
<screen>
&prompt.sudo;nmcli connection down "Ethernet connection 1"
&prompt.sudo;nmcli connection up bridge-br0
Connection successfully activated (master waiting for slaves) \
(D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/9)
</screen>
     </step>
    </procedure>
   </sect3>
   <sect3 xml:id="sec-xen-net-vlan">
    <title>Using VLAN interfaces</title>
    <para>
     Sometimes it is necessary to create a private connection either between
     two &vmhost;s or between &vmguest; systems. For example, to migrate
     a &vmguest; to hosts in a different network segment. Or to create a private
     bridge that only &vmguest; systems may connect to (even when running on
     different &vmhost; systems). An easy way to build such connections is to
     set up VLAN networks.
    </para>
    <para>
     VLAN interfaces are commonly set up on the &vmhost;. They either
     interconnect the different &vmhost; systems, or they may be set up as a
     physical interface to an otherwise virtual-only bridge. It is even
     possible to create a bridge with a VLAN as a physical interface that has
     no IP address in the &vmhost;. That way, the guest systems have no
     possibility to access the host over this network.
    </para>
    <para>
     Run the &yast; module
     <menuchoice><guimenu>System</guimenu><guimenu>Network
     Settings</guimenu></menuchoice>. Follow this procedure to set up the VLAN
     device:
    </para>
    <procedure>
     <title>Setting up VLAN interfaces with &yast;</title>
     <step>
      <para>
       Click <guimenu>Add</guimenu> to create a new network interface.
      </para>
     </step>
     <step>
      <para>
       In the <guimenu>Hardware Dialog</guimenu>, select <guimenu>Device
       Type</guimenu> <guimenu>VLAN</guimenu>.
      </para>
     </step>
     <step>
      <para>
       Change the value of <guimenu>Configuration Name</guimenu> to the ID of
       your VLAN. Note that VLAN ID <literal>1</literal> is commonly used for
       management purposes.
      </para>
     </step>
     <step>
      <para>
       Click <guimenu>Next</guimenu>.
      </para>
     </step>
     <step>
      <para>
       Select the interface that the VLAN device should connect to below
       <guimenu>Real Interface for VLAN</guimenu>. If the desired interface
       does not appear in the list, first set up this interface without an IP
       address.
      </para>
     </step>
     <step>
      <para>
       Select the desired method for assigning an IP address to the VLAN
       device.
      </para>
     </step>
     <step>
      <para>
       Click <guimenu>Next</guimenu> to finish the configuration.
      </para>
     </step>
    </procedure>
    <para>
     It is also possible to use the VLAN interface as a physical interface of a
     bridge. This makes it possible to connect several &vmhost;-only networks
     and allows live migration of &vmguest; systems that are connected to such
     a network.
    </para>
    <para>
     &yast; does not always allow setting no IP address. However, this may be a
     desired feature, especially if &vmhost;-only networks should be connected.
     In this case, use the special address <literal>0.0.0.0</literal> with
     netmask <literal>255.255.255.255</literal>. The system scripts handle this
     address as no IP address set.
    </para>
   </sect3>
  </sect2>

  <sect2 xml:id="libvirt-networks-virtual">
   <title>Virtual networks</title>
   <para>
    &libvirt;-managed virtual networks are similar to bridged networks, but
    typically have no Layer 2 connection to the &vmhost;. Connectivity to the
    &vmhost;'s physical network is accomplished with Layer 3 forwarding, which
    introduces additional packet processing on the &vmhost; as compared to a
    Layer 2 bridged network. Virtual networks also provide DHCP and DNS
    services for &vmguest;s. For more information on &libvirt; virtual
    networks, see the <citetitle>Network XML format</citetitle> documentation
    at <link xlink:href="https://libvirt.org/formatnetwork.html"/>.
   </para>
   <para>
    A standard &libvirt; installation on &productname; already comes with a
    predefined virtual network named <literal>default</literal>. It provides
    DHCP and DNS services for the network, along with connectivity to the
    &vmhost;'s physical network using the network address translation (NAT)
    forwarding mode. Although it is predefined, the <literal>default</literal>
    virtual network needs to be explicitly enabled by the administrator. For more
    information on the forwarding modes supported by &libvirt;, see the
    <citetitle>Connectivity</citetitle> section of the <citetitle>Network XML
    format</citetitle> documentation at
    <link xlink:href="https://libvirt.org/formatnetwork.html#elementsConnect"/>.
   </para>
   <para>
    &libvirt;-managed virtual networks can be used to satisfy a wide range of
    use cases, but are commonly used on &vmhost;s that have a wireless
    connection or dynamic/sporadic network connectivity, such as laptops.
    Virtual networks are also useful when the &vmhost;'s network has limited IP
    addresses, allowing forwarding of packets between the virtual network and
    the &vmhost;'s network. However, most server use cases are better suited
    for the network bridge configuration, where &vmguest;s are connected to the
    &vmhost;'s LAN.
   </para>
   <warning>
    <title>Enabling forwarding mode</title>
    <para>
     Enabling forwarding mode in a &libvirt; virtual network enables forwarding
     in the &vmhost; by setting
     <filename>/proc/sys/net/ipv4/ip_forward</filename> and
     <filename>/proc/sys/net/ipv6/conf/all/forwarding</filename> to 1, which
     essentially turns the &vmhost; into a router. Restarting the &vmhost;'s
     network may reset the values and disable forwarding. To avoid this
     behavior, explicitly enable forwarding in the &vmhost; by editing the
     <filename>/etc/sysctl.conf</filename> file and adding:
    </para>
<screen>net.ipv4.ip_forward = 1</screen>
<screen>net.ipv6.conf.all.forwarding = 1</screen>
   </warning>
   <sect3 xml:id="libvirt-networks-virtual-vmm">
    <title>Managing virtual networks with &vmm;</title>
    <para>
     You can define, configure, and operate virtual networks with &vmm;.
    </para>
    <sect4 xml:id="libvirt-networks-virtual-vmm-define">
     <title>Defining virtual networks</title>
     <procedure>
      <step>
       <para>
        Start &vmm;. In the list of available connections, right-click the name
        of the connection for which you need to configure the virtual network,
        and then select <guimenu>Details</guimenu>.
       </para>
      </step>
      <step>
       <para>
        In the <guimenu>Connection Details</guimenu> window, click the
        <guimenu>Virtual Networks</guimenu> tab. You can see the list of all
        virtual networks available for the current connection. On the right,
        there are details of the selected virtual network.
       </para>
       <figure>
        <title>Connection details</title>
        <mediaobject>
         <imageobject role="fo">
          <imagedata fileref="libvirt_vmm_conndetails.png" width="45%"/>
         </imageobject>
         <imageobject role="html">
          <imagedata fileref="libvirt_vmm_conndetails.png" width="45%"/>
         </imageobject>
        </mediaobject>
       </figure>
      </step>
      <step>
       <para>
        To add a new virtual network, click <guimenu>Add</guimenu>.
       </para>
      </step>
      <step>
       <para>
        Specify a name for the new virtual network.
       </para>
       <figure>
        <title>Create virtual network</title>
        <mediaobject>
         <imageobject role="fo">
          <imagedata fileref="libvirt_vmm_vnet_ipv4.png" width="45%"/>
         </imageobject>
         <imageobject role="html">
          <imagedata fileref="libvirt_vmm_vnet_ipv4.png" width="45%"/>
         </imageobject>
        </mediaobject>
       </figure>
      </step>
      <step>
       <para>
        Specify the networking mode.
        For the <guimenu>NAT</guimenu> and <guimenu>Routed</guimenu> types,
        you can specify to which device to forward network communications.
        While
        <guimenu>NAT</guimenu> (network address translation) remaps the virtual
        network address space and allows sharing a single IP address,
        <guimenu>Routed</guimenu> forwards packets from the virtual network to
        the &vmhost;'s physical network with no translation.
       </para>
      </step>
      <step>
       <para>
        If you need IPv4 networking, activate <guimenu>Enable IPv4</guimenu> and specify the IPv4 network address.
        If you need a DHCP server, activate <guimenu>Enable DHCPv4</guimenu> and specify the assignable IP address range.
       </para>
      </step>
      <step>
       <para>
        If you need IPv6 networking, activate <guimenu>Enable IPv6</guimenu> and specify the IPv6 network address.
        If you need a DHCP server, activate <guimenu>Enable DHCPv6</guimenu> and specify the assignable IP address range.
       </para>
      </step>
      <step>
       <para>
        If you want to specify a different domain name than the name of the virtual network,
        select <guimenu>Custom</guimenu> under <guimenu>DNS domain name</guimenu>
        and enter it here.
       </para>
      </step>
      <step>
       <para>
        Click <guimenu>Finish</guimenu> to create the new virtual network. On
        the &vmhost;, a new virtual network bridge
        <literal>virbr<replaceable>X</replaceable></literal> is available,
        which corresponds to the newly created virtual network. You can check
        with <command>bridge link</command>. &libvirt; automatically adds
        iptables rules to allow traffic to/from guests attached to the new
        <emphasis>virbr<replaceable>X</replaceable></emphasis> device.
       </para>
      </step>
     </procedure>
    </sect4>
    <sect4 xml:id="libvirt-networks-virtual-vmm-start">
     <title>Starting virtual networks</title>
     <para>
      To start a virtual network that is temporarily stopped, follow these
      steps:
     </para>
     <procedure>
      <step>
       <para>
        Start &vmm;. In the list of available connections, right-click the name
        of the connection for which you need to configure the virtual network,
        and then select <guimenu>Details</guimenu>.
       </para>
      </step>
      <step>
       <para>
        In the <guimenu>Connection Details</guimenu> window, click the
        <guimenu>Virtual Networks</guimenu> tab. You can see the list of all
        virtual networks available for the current connection.
       </para>
      </step>
      <step>
       <para>
        To start the virtual network, click <guimenu>Start</guimenu>.
       </para>
      </step>
     </procedure>
    </sect4>
    <sect4 xml:id="libvirt-networks-virtual-vmm-stop">
     <title>Stopping virtual networks</title>
     <para>
      To stop an active virtual network, follow these steps:
     </para>
     <procedure>
      <step>
       <para>
        Start &vmm;. In the list of available connections, right-click the name
        of the connection for which you need to configure the virtual network,
        and then select <guimenu>Details</guimenu>.
       </para>
      </step>
      <step>
       <para>
        In the <guimenu>Connection Details</guimenu> window, click the
        <guimenu>Virtual Networks</guimenu> tab. You can see the list of all
        virtual networks available for the current connection.
       </para>
      </step>
      <step>
       <para>
        Select the virtual network to be stopped, then click
        <guimenu>Stop</guimenu>.
       </para>
      </step>
     </procedure>
    </sect4>
    <sect4 xml:id="libvirt-networks-virtual-vmm-delete">
     <title>Deleting virtual networks</title>
     <para>
      To delete a virtual network from &vmhost;, follow these steps:
     </para>
     <procedure>
      <step>
       <para>
        Start &vmm;. In the list of available connections, right-click the name
        of the connection for which you need to configure the virtual network,
        and then select <guimenu>Details</guimenu>.
       </para>
      </step>
      <step>
       <para>
        In the <guimenu>Connection Details</guimenu> window, click the
        <guimenu>Virtual Networks</guimenu> tab. You can see the list of all
        virtual networks available for the current connection.
       </para>
      </step>
      <step>
       <para>
        Select the virtual network to be deleted, then click
        <guimenu>Delete</guimenu>.
       </para>
      </step>
     </procedure>
    </sect4>
    <sect4 xml:id="libvirt-networks-virtual-vmm-nsswitch">
<!-- fate#316628 -->
     <title>Obtaining IP addresses with <command>nsswitch</command> for NAT networks (in KVM)</title>
     <itemizedlist>
      <listitem>
       <para>
        On &vmhost;, install libvirt-nss, which provides NSS support for
        libvirt:
       </para>
<screen>&prompt.sudo;zypper in libvirt-nss</screen>
      </listitem>
      <listitem>
       <para>
        Add <literal>libvirt</literal> to
        <filename>/etc/nsswitch.conf</filename>:
       </para>
<screen>...
hosts:  files libvirt mdns_minimal [NOTFOUND=return] dns
...</screen>
      </listitem>
      <listitem>
       <para>
        If NSCD is running, restart it:
       </para>
<screen>&prompt.sudo;systemctl restart nscd</screen>
      </listitem>
     </itemizedlist>
     <para>
      Now you can reach the guest system by name from the host.
     </para>
     <para>
      The NSS module has limited functionality. It reads
      <filename>/var/lib/libvirt/dnsmasq/*.status</filename> files to find the
      host name and corresponding IP addresses in a JSON record describing each
      lease provided by <command>dnsmasq</command>. Host name translation can
      only be done on those &vmhost;s using a libvirt-managed bridged network
      backed by <command>dnsmasq</command>.
     </para>
    </sect4>
   </sect3>
   <sect3 xml:id="libvirt-networks-virtual-virsh">
    <title>Managing virtual networks with <command>virsh</command></title>
    <para>
     You can manage &libvirt;-provided virtual networks with the
     <command>virsh</command> command line tool. To view all network related
     <command>virsh</command> commands, run
    </para>
<screen>&prompt.sudo;virsh help network
Networking (help keyword 'network'):
 net-autostart                  autostart a network
        net-create                     create a network from an XML file
        net-define                     define (but don't start) a network from an XML file
        net-destroy                    destroy (stop) a network
        net-dumpxml                    network information in XML
        net-edit                       edit XML configuration for a network
        net-event                      Network Events
        net-info                       network information
        net-list                       list networks
        net-name                       convert a network UUID to network name
        net-start                      start a (previously defined) inactive network
        net-undefine                   undefine an inactive network
        net-update                     update parts of an existing network's configuration
 net-uuid                       convert a network name to network UUID</screen>
    <para>
     To view brief help information for a specific <command>virsh</command>
     command, run <command>virsh help
     <replaceable>VIRSH_COMMAND</replaceable></command>:
    </para>
<screen>&prompt.sudo;virsh help net-create
  NAME
    net-create - create a network from an XML file

  SYNOPSIS
    net-create &lt;file>

  DESCRIPTION
    Create a network.

  OPTIONS
    [--file] &lt;string>  file containing an XML network description</screen>
    <sect4 xml:id="libvirt-networks-virtual-virsh-create">
     <title>Creating a network</title>
<!-- 2016-02-25 tbazant
     https://wiki.libvirt.org/page/VirtualNetworking#Creating_a_virtual_network
     https://libvirt.org/formatnetwork.html
     https://libvirt.org/sources/virshcmdref/html/sect-net-create.html
     https://libvirt.org/sources/virshcmdref/html/
     -->
     <para>
      To create a new <emphasis>running</emphasis> virtual network, run
     </para>
<screen>&prompt.sudo;virsh net-create <replaceable>VNET_DEFINITION.xml</replaceable></screen>
     <para>
      The <replaceable>VNET_DEFINITION.xml</replaceable> XML file includes the
      definition of the virtual network that &libvirt; accepts.
     </para>
     <para>
      To define a new virtual network without activating it, run
     </para>
<screen>&prompt.sudo;virsh net-define <replaceable>VNET_DEFINITION.xml</replaceable></screen>
     <para>
      The following examples illustrate definitions of different types of
      virtual networks.
     </para>
     <example xml:id="ex-libvirt-net-nat">
      <title>NAT-based network</title>
      <para>
       The following configuration allows &vmguest;s outgoing connectivity if
       it is available on the &vmhost;. In the absence of &vmhost; networking, it
       allows guests to talk directly to each other.
      </para>
<screen>
&lt;network&gt;
&lt;name&gt;vnet_nated&lt;/name&gt;<co xml:id="vnet-xml-name"/>
&lt;bridge name="virbr1"/&gt;<co xml:id="vnet-xml-bridge"/>
 &lt;forward mode="nat"/&gt;<co xml:id="vnet-xml-forward"/>
 &lt;ip address="192.168.122.1" netmask="255.255.255.0"&gt;<co xml:id="vnet-xml-ip"/>
  &lt;dhcp&gt;
   &lt;range start="192.168.122.2" end="192.168.122.254"/&gt;<co xml:id="vnet-xml-dhcp"/>
   &lt;host mac="52:54:00:c7:92:da" name="host1.testing.com" \
    ip="192.168.1.101"/&gt;<co xml:id="vnet-xml-dhcp-host"/>
   &lt;host mac="52:54:00:c7:92:db" name="host2.testing.com" \
    ip="192.168.1.102"/&gt;
   &lt;host mac="52:54:00:c7:92:dc" name="host3.testing.com" \
    ip="192.168.1.103"/&gt;
  &lt;/dhcp&gt;
 &lt;/ip&gt;
&lt;/network&gt;
</screen>
      <calloutlist>
       <callout arearefs="vnet-xml-name">
        <para>
         The name of the new virtual network.
        </para>
       </callout>
       <callout arearefs="vnet-xml-bridge">
        <para>
         The name of the bridge device used to construct the virtual network.
         When defining a new network with a &lt;forward&gt; mode of <literal>"nat"</literal> or
         <literal>"route"</literal> (or an isolated network with no &lt;forward&gt; element),
         &libvirt; will automatically generate a unique name for the bridge
         device if none is given.
        </para>
       </callout>
       <callout arearefs="vnet-xml-forward">
        <para>
         Inclusion of the &lt;forward&gt; element indicates that the virtual
         network will be connected to the physical LAN. The
         <literal>mode</literal> attribute specifies the forwarding method. The
         most common modes are <literal>"nat"</literal> (Network Address Translation, the default),
         <literal>"route"</literal> (direct forwarding to the physical network, no address
         translation), and <literal>"bridge"</literal> (network bridge configured outside of
         &libvirt;). If the &lt;forward&gt; element is not specified, the
         virtual network will be isolated from other networks. For a complete
         list of forwarding modes, see
         <link xlink:href="https://libvirt.org/formatnetwork.html#elementsConnect"/>.
        </para>
       </callout>
       <callout arearefs="vnet-xml-ip">
        <para>
         The IP address and netmask for the network bridge.
        </para>
       </callout>
       <callout arearefs="vnet-xml-dhcp">
        <para>
         Enable DHCP server for the virtual network, offering IP addresses
         ranging from the specified <literal>start</literal> and
         <literal>end</literal> attributes.
        </para>
       </callout>
       <callout arearefs="vnet-xml-dhcp-host">
        <para>
         The optional &lt;host&gt; elements specify hosts that will be given
         names and predefined IP addresses by the built-in DHCP server. Any
         IPv4 host element must specify the following: the MAC address of the
         host to be assigned a given name, the IP to be assigned to that host,
         and the name to be given to that host by the DHCP server. An IPv6 host
         element differs slightly from that for IPv4: there is no
         <literal>mac</literal> attribute since a MAC address has no defined
         meaning in IPv6. Instead, the <literal>name</literal> attribute is
         used to identify the host to be assigned the IPv6 address. For DHCPv6,
         the <literal>name</literal> is the plain name of the client host sent
         by the client to the server. Note that this method of assigning a
         specific IP address can also be used instead of the
         <literal>mac</literal> attribute for IPv4.
        </para>
       </callout>
      </calloutlist>
     </example>
     <example>
      <title>Routed network</title>
      <para>
       The following configuration routes traffic from the virtual network to
       the LAN without applying any NAT. The IP address range must be
       preconfigured in the routing tables of the router on the &vmhost;
       network.
      </para>
<screen>
&lt;network&gt;
 &lt;name&gt;vnet_routed&lt;/name&gt;
 &lt;bridge name="virbr1"/&gt;
 &lt;forward mode="route" dev="eth1"/&gt;<co xml:id="vnet-xml-route"/>
 &lt;ip address="192.168.122.1" netmask="255.255.255.0"&gt;
  &lt;dhcp&gt;
   &lt;range start="192.168.122.2" end="192.168.122.254"/&gt;
  &lt;/dhcp&gt;
 &lt;/ip&gt;
&lt;/network&gt;
</screen>
      <calloutlist>
       <callout arearefs="vnet-xml-route">
        <para>
         The guest traffic may only go out via the
         <systemitem>eth1</systemitem> network device on the &vmhost;.
        </para>
       </callout>
      </calloutlist>
     </example>
     <example>
      <title>Isolated network</title>
      <para>
       This configuration provides a completely isolated private network. The
       guests can talk to each other, and to &vmhost;, but cannot reach any
       other machines on the LAN, as the &lt;forward&gt; element is missing in
       the XML description.
      </para>
<screen>&lt;network&gt;
 &lt;name&gt;vnet_isolated&lt;/name&gt;
 &lt;bridge name="virbr3"/&gt;
 &lt;ip address="192.168.152.1" netmask="255.255.255.0"&gt;
  &lt;dhcp&gt;
   &lt;range start="192.168.152.2" end="192.168.152.254"/&gt;
  &lt;/dhcp&gt;
 &lt;/ip&gt;
 &lt;/network&gt;
</screen>
     </example>
     <example>
      <title>Using an existing bridge on &vmhost;</title>
      <para>
       This configuration shows how to use an existing &vmhost;'s network
       bridge <literal>br0</literal>. &vmguest;s are directly connected to the
       physical network. Their IP addresses will all be on the subnet of the
       physical network, and there will be no restrictions on incoming or
       outgoing connections.
      </para>
<screen>&lt;network&gt;
        &lt;name&gt;host-bridge&lt;/name&gt;
        &lt;forward mode="bridge"/&gt;
        &lt;bridge name="br0"/&gt;
&lt;/network&gt;
</screen>
     </example>
    </sect4>
    <sect4 xml:id="libvirt-networks-virtual-virsh-list">
     <title>Listing networks</title>
     <para>
      To list all virtual networks available to &libvirt;, run:
     </para>
<screen>&prompt.sudo;virsh net-list --all

 Name                 State      Autostart     Persistent
----------------------------------------------------------
 crowbar              active     yes           yes
 vnet_nated           active     yes           yes
 vnet_routed          active     yes           yes
 vnet_isolated        inactive   yes           yes</screen>
<!-- fate#316628: Tool to obtain IP address allocated (DHCP)
      for bridged network in KVM -->
     <para>
      To list available domains, run:
     </para>
<screen>&prompt.sudo;virsh list
 Id    Name                           State
----------------------------------------------------
 1     nated_sles12sp3                running
 ...</screen>
     <para>
      To get a list of interfaces of a running domain, run <option>domifaddr
      <replaceable>DOMAIN</replaceable></option>, or optionally specify the
      interface to limit the output to this interface. By default, it
      additionally outputs their IP and MAC addresses:
     </para>
<screen>&prompt.sudo;virsh domifaddr nated_sles12sp3 --interface vnet0 --source lease
 Name       MAC address          Protocol     Address
-------------------------------------------------------------------------------
 vnet0      52:54:00:9e:0d:2b    ipv6         fd00:dead:beef:55::140/64
 -          -                    ipv4         192.168.100.168/24</screen>
     <para>
      To print brief information of all virtual interfaces associated with the
      specified domain, run:
     </para>
<screen>&prompt.sudo;virsh domiflist nated_sles12sp3
Interface  Type       Source       Model       MAC
---------------------------------------------------------
vnet0      network    vnet_nated   virtio      52:54:00:9e:0d:2b</screen>
    </sect4>
    <sect4 xml:id="libvirt-networks-virtual-virsh-info">
     <title>Getting details about a network</title>
     <para>
      To get detailed information about a network, run:
     </para>
<screen>&prompt.sudo;virsh net-info vnet_routed
Name:           vnet_routed
UUID:           756b48ff-d0c6-4c0a-804c-86c4c832a498
Active:         yes
Persistent:     yes
Autostart:      yes
Bridge:         virbr5</screen>
    </sect4>
    <sect4 xml:id="libvirt-networks-virtual-virsh-start">
     <title>Starting a network</title>
     <para>
      To start an inactive network that was already defined, find its name (or
      unique identifier, UUID) with:
     </para>
<screen>&prompt.sudo;virsh net-list --inactive
 Name                 State      Autostart     Persistent
----------------------------------------------------------
 vnet_isolated        inactive   yes           yes</screen>
     <para>
      Then run:
     </para>
<screen>&prompt.sudo;virsh net-start vnet_isolated
Network vnet_isolated started</screen>
    </sect4>
    <sect4 xml:id="libvirt-networks-virtual-virsh-stop">
     <title>Stopping a network</title>
     <para>
      To stop an active network, find its name (or unique identifier, UUID)
      with:
     </para>
<screen>&prompt.sudo;virsh net-list --inactive
 Name                 State      Autostart     Persistent
----------------------------------------------------------
 vnet_isolated        active     yes           yes</screen>
     <para>
      Then run:
     </para>
<screen>&prompt.sudo;virsh net-destroy vnet_isolated
Network vnet_isolated destroyed</screen>
    </sect4>
    <sect4 xml:id="libvirt-networks-virtual-virsh-undefine">
     <title>Removing a network</title>
     <para>
      To remove the definition of an inactive network from &vmhost;
      permanently, run:
     </para>
<screen>&prompt.sudo;virsh net-undefine vnet_isolated
Network vnet_isolated has been undefined</screen>
    </sect4>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="libvirt-host-storage">
  <title>Configuring a storage pool</title>

  <para>
   When managing a &vmguest; on the &vmhost; itself, you can access the
   complete file system of the &vmhost; to attach or create virtual hard disks
   or to attach existing images to the &vmguest;. However, this is not possible
   when managing &vmguest;s from a remote host. For this reason, &libvirt;
   supports so called <quote>Storage Pools</quote>, which can be accessed from
   remote machines.
  </para>

  <tip>
   <title>CD/DVD ISO images</title>
   <para>
    To be able to access CD/DVD ISO images on the &vmhost; from remote clients, they
    also need to be placed in a storage pool.
   </para>
  </tip>

  <para>
   &libvirt; knows two different types of storage: volumes and pools.
  </para>

  <variablelist>
   <varlistentry>
    <term>Storage volume</term>
    <listitem>
     <para>
      A storage volume is a storage device that can be assigned to a
      guest&mdash;a virtual disk or a CD/DVD/floppy image. Physically, it can
      be a block device&mdash;for example, a partition or a logical
      volume&mdash;or a file on the &vmhost;.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Storage pool</term>
    <listitem>
     <para>
      A storage pool is a storage resource on the &vmhost; that can be used for
      storing volumes, similar to network storage for a desktop machine.
      Physically it can be one of the following types:
     </para>
     <variablelist>
      <varlistentry>
       <term>File system directory (<guimenu>dir</guimenu>)</term>
       <listitem>
        <para>
         A directory for hosting image files. The files can be either one of
         the supported disk formats (raw or qcow2), or ISO images.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Physical disk device (<guimenu>disk</guimenu>)</term>
       <listitem>
        <para>
         Use a complete physical disk as storage. A partition is created for
         each volume that is added to the pool.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Pre-formatted block device (<guimenu>fs</guimenu>)</term>
       <listitem>
        <para>
         Specify a partition to be used in the same way as a file system
         directory pool (a directory for hosting image files). The only
         difference to using a file system directory is that &libvirt; takes
         care of mounting the device.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>iSCSI target (iscsi)</term>
       <listitem>
        <para>
         Set up a pool on an iSCSI target. You need to have been logged in to
         the volume once before to use it with &libvirt;. Use the &yast;
         <guimenu>iSCSI Initiator</guimenu> to detect and log in to a
         volume<phrase os="sles">, see <xref linkend="book-storage"/> for
         details</phrase>. Volume creation on iSCSI pools is not supported;
         instead, each existing Logical Unit Number (LUN) represents a volume.
         Each volume/LUN also needs a valid (empty) partition table or disk
         label before you can use it. If missing, use <command>fdisk</command>
         to add it:
        </para>
<screen>&prompt.sudo;fdisk -cu /dev/disk/by-path/ip-&wsIip;:3260-iscsi-iqn.2010-10.com.example:[...]-lun-2
Device contains neither a valid DOS partition table, nor Sun, SGI
or OSF disklabel
Building a new DOS disklabel with disk identifier 0xc15cdc4e.
Changes will remain in memory only, until you decide to write them.
After that, of course, the previous content won't be recoverable.

Warning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)

Command (m for help): w
The partition table has been altered!

Calling ioctl() to re-read partition table.
Syncing disks.</screen>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>LVM volume group (logical)</term>
       <listitem>
        <para>
         Use an LVM volume group as a pool. You can either use a predefined
         volume group, or create a group by specifying the devices to use.
         Storage volumes are created as partitions on the volume.
        </para>
        <warning>
         <title>Deleting the LVM-based pool</title>
         <para>
          When the LVM-based pool is deleted in the Storage Manager, the volume
          group is deleted as well. This results in a non-recoverable loss of
          all data stored on the pool!
         </para>
        </warning>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Multipath devices (<guimenu>mpath</guimenu>)</term>
       <listitem>
        <para>
         At the moment, multipathing support is limited to assigning existing
         devices to the guests. Volume creation or configuring multipathing
         from within &libvirt; is not supported.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Network exported directory (<guimenu>netfs</guimenu>)</term>
       <listitem>
        <para>
         Specify a network directory to be used in the same way as a file
         system directory pool (a directory for hosting image files). The only
         difference to using a file system directory is that &libvirt; takes
         care of mounting the directory. The supported protocol is NFS.
        </para>
       </listitem>
      </varlistentry>
<!-- <varlistentry>
      <term>Rados block device (<guimenu>rbd</guimenu>)</term>
      <listitem>
       <para>
        ...
       </para>
      </listitem>
     </varlistentry> -->
<!-- <varlistentry>
      <term>Sheepdog distributed storage system (<guimenu>sheepdog</guimenu>)</term>
      <listitem>
       <para>
        ...
       </para>
      </listitem>
     </varlistentry> -->
      <varlistentry>
       <term>SCSI host adapter (<guimenu>scsi</guimenu>)</term>
       <listitem>
        <para>
         Use an SCSI host adapter in almost the same way as an iSCSI target. We
         recommend to use a device name from
         <filename>/dev/disk/by-*</filename> rather than
         <filename>/dev/sd<replaceable>X</replaceable></filename>. The latter
         can change (for example, when adding or removing hard disks). Volume
         creation on iSCSI pools is not supported. Instead, each existing LUN
         (Logical Unit Number) represents a volume.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>
  </variablelist>

  <warning>
   <title>Security considerations</title>
   <para>
    To avoid data loss or data corruption, do not attempt to use resources such
    as LVM volume groups, iSCSI targets, etc., that are also used to build
    storage pools on the &vmhost;. There is no need to connect to these
    resources from the &vmhost; or to mount them on the
    &vmhost;&mdash;&libvirt; takes care of this.
   </para>
   <para>
    Do not mount partitions on the &vmhost; by label. Under certain
    circumstances it is possible that a partition is labeled from within a
    &vmguest; with a name already existing on the &vmhost;.
   </para>
  </warning>

  <sect2 xml:id="sec-libvirt-storage-virsh">
   <title>Managing storage with <command>virsh</command></title>
   <para>
    Managing storage from the command line is also possible by using
    <command>virsh</command>. However, creating storage pools is currently not
    supported by &suse;. Therefore, this section is restricted to documenting
    functions such as starting, stopping, and deleting pools, and volume management.
   </para>
   <para>
    A list of all <command>virsh</command> subcommands for managing pools and
    volumes is available by running <command>virsh help pool</command> and
    <command>virsh help volume</command>, respectively.
   </para>
   <sect3 xml:id="sec-libvirt-storage-virsh-list-pools">
    <title>Listing pools and volumes</title>
    <para>
     List all pools currently active by executing the following command. To
     also list inactive pools, add the option <option>--all</option>:
    </para>
<screen>&prompt.user;virsh pool-list --details</screen>
    <para>
     Details about a specific pool can be obtained with the
     <literal>pool-info</literal> subcommand:
    </para>
<screen>&prompt.user;virsh pool-info <replaceable>POOL</replaceable></screen>
    <para>
     By default, volumes can only be listed per pool. To list all volumes from a
     pool, enter the following command.
    </para>
<screen>&prompt.user;virsh vol-list --details <replaceable>POOL</replaceable></screen>
    <para>
     At the moment <command>virsh</command> offers no tools to show whether a
     volume is used by a guest or not. The following procedure describes a way
     to list volumes from all pools that are currently used by a &vmguest;.
    </para>
    <procedure xml:id="pro-libvirt-storage-virsh-list-vols">
     <title>Listing all storage volumes currently used on a &vmhost;</title>
     <step>
      <para>
       Create an XSLT style sheet by saving the following content to a file,
       for example, ~/libvirt/guest_storage_list.xsl:
      </para>
<screen>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:output method="text"/&gt;
  &lt;xsl:template match="text()"/&gt;
  &lt;xsl:strip-space elements="*"/&gt;
  &lt;xsl:template match="disk"&gt;
    &lt;xsl:text&gt;  &lt;/xsl:text&gt;
    &lt;xsl:value-of select="(source/@file|source/@dev|source/@dir)[1]"/&gt;
    &lt;xsl:text&gt;&amp;#10;&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</screen>
     </step>
     <step>
      <para>
       Run the following commands in a shell. It is assumed that the guest's
       XML definitions are all stored in the default location
       (<filename>/etc/libvirt/qemu</filename>). <command>xsltproc</command> is
       provided by the package
       <systemitem class="resource">libxslt</systemitem>.
      </para>
<screen>SSHEET="$HOME/libvirt/guest_storage_list.xsl"
cd /etc/libvirt/qemu
for FILE in *.xml; do
  basename $FILE .xml
  xsltproc $SSHEET $FILE
done</screen>
     </step>
    </procedure>
   </sect3>
   <sect3 xml:id="sec-libvirt-storage-virsh-start-pools">
    <title>Starting, stopping, and deleting pools</title>
    <para>
     Use the <command>virsh</command> pool subcommands to start, stop, or delete
     a pool. Replace <replaceable>POOL</replaceable> with the pool's name or
     its UUID in the following examples:
    </para>
    <variablelist>
     <varlistentry>
      <term>Stopping a pool</term>
      <listitem>
<screen>&prompt.user;virsh pool-destroy <replaceable>POOL</replaceable></screen>
       <note>
        <title>A pool's state does not affect attached volumes</title>
        <para>
         Volumes from a pool attached to &vmguest;s are always available,
         regardless of the pool's state (<guimenu>Active</guimenu> (stopped) or
         <guimenu>Inactive</guimenu> (started)). The state of the pool solely
         affects the ability to attach volumes to a &vmguest; via remote
         management.
        </para>
       </note>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Deleting a pool</term>
      <listitem>
<screen>&prompt.user;virsh pool-delete <replaceable>POOL</replaceable></screen>
       <warning>
        <title>Deleting storage pools</title>
        <para>
         See <xref linkend="deleting-storage-pools"/>
        </para>
       </warning>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Starting a pool</term>
      <listitem>
<screen>&prompt.user;virsh pool-start <replaceable>POOL</replaceable></screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Enable autostarting a pool</term>
      <listitem>
<screen>&prompt.user;virsh pool-autostart <replaceable>POOL</replaceable></screen>
       <para>
        Only pools that are marked to autostart will automatically be started
        if the &vmhost; reboots.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Disable autostarting a pool</term>
      <listitem>
<screen>&prompt.user;virsh pool-autostart <replaceable>POOL</replaceable> --disable</screen>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3 xml:id="sec-libvirt-storage-virsh-add-volumes">
    <title>Adding volumes to a storage pool</title>
    <para>
     <command>virsh</command> offers two ways to add volumes to storage pools:
     either from an XML definition with <literal>vol-create</literal> and
     <literal>vol-create-from</literal> or via command line arguments with
     <literal>vol-create-as</literal>. The first two methods are currently not
     supported by &suse;, therefore this section focuses on the subcommand
     <literal>vol-create-as</literal>.
    </para>
    <para>
     To add a volume to an existing pool, enter the following command:
    </para>
<screen>&prompt.user;virsh vol-create-as <replaceable>POOL</replaceable><co xml:id="co-vol-create-as-pool"/><replaceable>NAME</replaceable><co xml:id="co-vol-create-as-name"/> 12G --format<co xml:id="co-vol-create-as-capacity"/><replaceable>raw|qcow2</replaceable><co xml:id="co-vol-create-as-format"/> --allocation 4G<co xml:id="co-vol-create-as-alloc"/></screen>
    <calloutlist>
     <callout arearefs="co-vol-create-as-pool">
      <para>
       Name of the pool to which the volume should be added
      </para>
     </callout>
     <callout arearefs="co-vol-create-as-name">
      <para>
       Name of the volume
      </para>
     </callout>
     <callout arearefs="co-vol-create-as-capacity">
      <para>
       Size of the image, in this example 12 gigabytes. Use the suffixes k, M,
       G, T for kilobyte, megabyte, gigabyte, and terabyte, respectively.
      </para>
     </callout>
     <callout arearefs="co-vol-create-as-format">
      <para>
       Format of the volume. &suse; currently supports <literal>raw</literal>
       and <literal>qcow2</literal>.
      </para>
     </callout>
     <callout arearefs="co-vol-create-as-alloc">
      <para>
       Optional parameter. By default, <command>virsh</command> creates a sparse
       image file that grows on demand. Specify the amount of space that should
       be allocated with this parameter (4 gigabytes in this example). Use the
       suffixes k, M, G, T for kilobyte, megabyte, gigabyte, and terabyte,
       respectively.
      </para>
      <para>
       When not specifying this parameter, a sparse image file with no
       allocation will be generated. To create a non-sparse volume, specify the
       whole image size with this parameter (would be <literal>12G</literal> in
       this example).
      </para>
     </callout>
    </calloutlist>
    <sect4 xml:id="sec-libvirt-storage-virsh-add-volumes-clone">
     <title>Cloning existing volumes</title>
     <para>
      Another way to add volumes to a pool is to clone an existing volume. The
      new instance is always created in the same pool as the original.
     </para>
<screen>&prompt.user;virsh vol-clone <replaceable>NAME_EXISTING_VOLUME</replaceable><co xml:id="co-vol-clone-existing"/><replaceable>NAME_NEW_VOLUME</replaceable><co xml:id="co-vol-clone-new"/> --pool <replaceable>POOL</replaceable><co xml:id="co-vol-clone-pool"/></screen>
     <calloutlist>
      <callout arearefs="co-vol-clone-existing">
       <para>
        Name of the existing volume that should be cloned
       </para>
      </callout>
      <callout arearefs="co-vol-clone-new">
       <para>
        Name of the new volume
       </para>
      </callout>
      <callout arearefs="co-vol-clone-pool">
       <para>
        Optional parameter. &libvirt; tries to locate the existing volume
        automatically. If that fails, specify this parameter.
       </para>
      </callout>
     </calloutlist>
    </sect4>
   </sect3>
   <sect3 xml:id="sec-libvirt-storage-virsh-del-volumes">
    <title>Deleting volumes from a storage pool</title>
    <para>
     To permanently delete a volume from a pool, use the subcommand
     <literal>vol-delete</literal>:
    </para>
<screen>&prompt.user;virsh vol-delete <replaceable>NAME</replaceable> --pool <replaceable>POOL</replaceable></screen>
    <para>
     <option>--pool</option> is optional. &libvirt; tries to locate the volume
     automatically. If that fails, specify this parameter.
    </para>
    <warning>
     <title>No checks upon volume deletion</title>
     <para>
      A volume will be deleted in any case, regardless of whether it is
      currently used in an active or inactive &vmguest;. There is no way to
      recover a deleted volume.
     </para>
     <para>
      Whether a volume is used by a &vmguest; can only be detected by using by
      the method described in
      <xref linkend="pro-libvirt-storage-virsh-list-vols"/>.
     </para>
    </warning>
   </sect3>
   <sect3 xml:id="libvirt-storage-virsh-attach-volumes">
    <title>Attaching volumes to a &vmguest;</title>
    <para>
     After you create a volume as described in
     <xref
     linkend="sec-libvirt-storage-virsh-add-volumes"/>, you can
     attach it to a virtual machine and use it as a hard disk:
    </para>
<screen>&prompt.user;virsh attach-disk <replaceable>DOMAIN</replaceable> <replaceable>SOURCE_IMAGE_FILE</replaceable> <replaceable>TARGET_DISK_DEVICE</replaceable></screen>
    <para>
     For example:
    </para>
<screen>&prompt.user;virsh attach-disk sles12sp3 /virt/images/example_disk.qcow2 sda2</screen>
    <para>
     To check if the new disk is attached, inspect the result of the
     <command>virsh dumpxml</command> command:
    </para>
<screen>&prompt.root;virsh dumpxml sles12sp3
[...]
&lt;disk type='file' device='disk'>
 &lt;driver name='qemu' type='raw'/>
 &lt;source file='/virt/images/example_disk.qcow2'/>
 &lt;backingStore/>
 &lt;target dev='sda2' bus='scsi'/>
 &lt;alias name='scsi0-0-0'/>
 &lt;address type='drive' controller='0' bus='0' target='0' unit='0'/>
&lt;/disk>
[...]</screen>
    <sect4>
     <title>Hotplug or persistent change</title>
     <para>
      You can attach disks to both active and inactive domains. The attachment
      is controlled by the <option>--live</option> and
      <option>--config</option> options:
     </para>
     <variablelist>
      <varlistentry>
       <term><option>--live</option></term>
       <listitem>
        <para>
         Hotplugs the disk to an active domain. The attachment is not saved in
         the domain configuration. Using <option>--live</option> on an inactive
         domain is an error.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><option>--config</option></term>
       <listitem>
        <para>
         Changes the domain configuration persistently. The attached disk is
         then available after the next domain start.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><option>--live</option><option>--config</option></term>
       <listitem>
        <para>
         Hotplugs the disk and adds it to the persistent domain configuration.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
     <tip>
      <title><command>virsh attach-device</command></title>
      <para>
       <command>virsh attach-device</command> is the more generic form of
       <command>virsh attach-disk</command>. You can use it to attach other
       types of devices to a domain.
      </para>
     </tip>
    </sect4>
   </sect3>
   <sect3 xml:id="libvirt-storage-virsh-detach-volumes">
    <title>Detaching volumes from a &vmguest;</title>
    <para>
     To detach a disk from a domain, use <command>virsh detach-disk</command>:
    </para>
<screen>&prompt.root;virsh detach-disk <replaceable>DOMAIN</replaceable> <replaceable>TARGET_DISK_DEVICE</replaceable></screen>
    <para>
     For example:
    </para>
<screen>&prompt.root;virsh detach-disk sles12sp3 sda2</screen>
    <para>
     You can control the attachment with the <option>--live</option> and
     <option>--config</option> options as described in
     <xref
     linkend="libvirt-storage-virsh-attach-volumes"/>.
    </para>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-libvirt-storage-vmm">
   <title>Managing storage with &vmm;</title>
   <para>
    The &vmm; provides a graphical interface&mdash;the Storage Manager&mdash;to
    manage storage volumes and pools. To access it, either right-click a
    connection and choose <guimenu>Details</guimenu>, or highlight a connection
    and choose <menuchoice> <guimenu>Edit</guimenu> <guimenu>Connection
    Details</guimenu> </menuchoice>. Select the <guimenu>Storage</guimenu> tab.
   </para>
   <informalfigure>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="virt_virt-manager_storage.png" width="60%"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="virt_virt-manager_storage.png" width="60%"/>
     </imageobject>
    </mediaobject>
   </informalfigure>
   <sect3 xml:id="sec-libvirt-storage-vmm-addpool">
    <title>Adding a storage pool</title>
    <para>
     To add a storage pool, proceed as follows:
    </para>
    <procedure>
     <step>
      <para>
       Click <guimenu>Add</guimenu> in the bottom left corner. The dialog
       <guimenu>Add a New Storage Pool</guimenu> appears.
      </para>
     </step>
     <step>
      <para>
       Provide a <guimenu>Name</guimenu> for the pool (consisting of
       only alphanumeric characters and <literal>_</literal>, <literal>-</literal> or <literal>.</literal>) and select a
       <guimenu>Type</guimenu>.
      </para>
      <informalfigure>
       <mediaobject>
        <imageobject role="fo">
         <imagedata fileref="virt_virt-manager_storage_add.png" width="60%"/>
        </imageobject>
        <imageobject role="html">
         <imagedata fileref="virt_virt-manager_storage_add.png" width="60%"/>
        </imageobject>
       </mediaobject>
      </informalfigure>
     </step>
     <step>
      <para>
       Specify the required details below.
       They depend on the type of pool you are creating.
      </para>
      <important>
       <para>
        ZFS pools are not supported.
       </para>
      </important>
      <variablelist>
       <varlistentry>
        <term><emphasis role="bold">Type</emphasis> <guimenu>dir</guimenu></term>
        <listitem>
         <itemizedlist mark="bullet" spacing="normal">
          <listitem>
           <para>
            <guimenu>Target Path</guimenu>: Specify an existing directory.
           </para>
          </listitem>
         </itemizedlist>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis role="bold">Type</emphasis> <guimenu>disk</guimenu></term>
        <listitem>
         <itemizedlist mark="bullet" spacing="normal">
          <listitem>
           <para>
            <guimenu>Format</guimenu>: Format of the device's partition table.
            Using <guimenu>auto</guimenu> should usually work. If not, get the
            required format by running the command <command>parted</command>
            <option>-l</option> on the &vmhost;.
           </para>
          </listitem>
          <listitem>
           <para>
            <guimenu>Source Path</guimenu>: Path to the device. It is
            recommended to use a device name from
            <filename>/dev/disk/by-*</filename> rather than the simple
            <filename>/dev/sd<replaceable>X</replaceable></filename>, since the
            latter can change (for example, when adding or removing hard
            disks). You need to specify the path that resembles the whole disk,
            not a partition on the disk (if existing).
           </para>
          </listitem>
         </itemizedlist>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis role="bold">Type</emphasis> <guimenu>fs</guimenu></term>
        <listitem>
         <itemizedlist mark="bullet" spacing="normal">
          <listitem>
           <para>
            <guimenu>Target Path</guimenu>: Mount point on the &vmhost; file
            system.
           </para>
          </listitem>
          <listitem>
           <para>
            <guimenu>Format: </guimenu> File system format of the device. The
            default value <literal>auto</literal> should work.
           </para>
          </listitem>
          <listitem>
           <para>
            <guimenu>Source Path</guimenu>: Path to the device file. It is
            recommended to use a device name from
            <filename>/dev/disk/by-*</filename> rather than
            <filename>/dev/sd<replaceable>X</replaceable></filename>, because
            the latter can change (for example, when adding or removing hard
            disks).
           </para>
          </listitem>
         </itemizedlist>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis role="bold">Type</emphasis> <guimenu>iscsi</guimenu></term>
        <listitem>
         <para>
          Get the necessary data by running the following command on the
          &vmhost;:
         </para>
<screen>&prompt.sudo;iscsiadm --mode node</screen>
         <para>
          It will return a list of iSCSI volumes with the following format. The
          elements in bold text are required:
         </para>
<screen><emphasis role="bold">IP_ADDRESS</emphasis>:PORT,TPGT <emphasis role="bold">TARGET_NAME_(IQN)</emphasis></screen>
         <itemizedlist mark="bullet" spacing="normal">
          <listitem>
           <para>
            <guimenu>Target Path</guimenu>: The directory containing the device
            file. Use <literal>/dev/disk/by-path</literal> (default) or
            <literal>/dev/disk/by-id</literal>.
           </para>
          </listitem>
          <listitem>
           <para>
            <guimenu>Host Name</guimenu>: Host name or IP address of the iSCSI
            server.
           </para>
          </listitem>
          <listitem>
           <para>
            <guimenu>Source IQN</guimenu>: The iSCSI target name (iSCSI Qualified Name).
           </para>
          </listitem>
          <listitem>
           <para>
            <guimenu>Initiator IQN</guimenu>: The iSCSI initiator name.
           </para>
          </listitem>
         </itemizedlist>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis role="bold">Type</emphasis> <guimenu>logical</guimenu></term>
        <listitem>
         <itemizedlist mark="bullet" spacing="normal">
          <listitem>
           <para>
            <guimenu>Volgroup Name</guimenu>: Specify the device path of an existing volume group.
           </para>
          </listitem>
         </itemizedlist>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis role="bold">Type</emphasis> <guimenu>mpath</guimenu></term>
        <listitem>
         <itemizedlist mark="bullet" spacing="normal">
          <listitem>
           <para>
            <guimenu>Target Path</guimenu>: Support for multipathing is
            currently limited to making all multipath devices available.
            Therefore, specify an arbitrary string here that will then be
            ignored. The path is required, otherwise the XML parser will fail.
           </para>
          </listitem>
         </itemizedlist>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis role="bold">Type</emphasis> <guimenu>netfs</guimenu></term>
        <listitem>
         <itemizedlist mark="bullet" spacing="normal">
          <listitem>
           <para>
            <guimenu>Target Path</guimenu>: Mount point on the &vmhost; file
            system.
           </para>
          </listitem>
          <listitem>
           <para>
            <guimenu>Host Name</guimenu>: IP address or host name of the server
            exporting the network file system.
           </para>
          </listitem>
          <listitem>
           <para>
            <guimenu>Source Path</guimenu>: Directory on the server that is
            being exported.
           </para>
          </listitem>
         </itemizedlist>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis role="bold">Type</emphasis> <guimenu>rbd</guimenu></term>
        <listitem>
         <itemizedlist>
          <listitem>
           <para>
            <guimenu>Host Name</guimenu>: Host name of the server with an exported RADOS block device.
           </para>
          </listitem>
          <listitem>
           <para>
            <guimenu>Source Name</guimenu>: Name of the RADOS block device on the server.
           </para>
          </listitem>
         </itemizedlist>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis role="bold">Type</emphasis> <guimenu>scsi</guimenu></term>
        <listitem>
         <itemizedlist mark="bullet" spacing="normal">
          <listitem>
           <para>
            <guimenu>Target Path</guimenu>: The directory containing the device
            file. Use <literal>/dev/disk/by-path</literal> (default) or
            <literal>/dev/disk/by-id</literal>.
           </para>
          </listitem>
          <listitem>
           <para>
            <guimenu>Source Path</guimenu>: Name of the SCSI adapter.
           </para>
          </listitem>
         </itemizedlist>
        </listitem>
       </varlistentry>
      </variablelist>
      <note>
       <title>File browsing</title>
       <para>
        Using the file browser by clicking <guimenu>Browse</guimenu> is not
        possible when operating remotely.
       </para>
      </note>
     </step>
     <step>
      <para>
       Click <guimenu>Finish</guimenu> to add the storage pool.
      </para>
     </step>
    </procedure>
   </sect3>
   <sect3 xml:id="sec-libvirt-storage-vmm-manage">
    <title>Managing storage pools</title>
    <para>
     &vmm;'s Storage Manager lets you create or delete volumes in a pool. You
     may also temporarily deactivate or permanently delete existing storage
     pools. Changing the basic configuration of a pool is currently not
     supported by &suse;.
    </para>
    <sect4 xml:id="sec-libvirt-storage-vmm-manage-pool">
     <title>Starting, stopping, and deleting pools</title>
     <para>
      The purpose of storage pools is to provide block devices located on the
      &vmhost; that can be added to a &vmguest; when managing it from remote.
      To make a pool temporarily inaccessible from remote, click
      <guimenu>Stop</guimenu> in the bottom left corner of the Storage Manager.
      Stopped pools are marked with <guimenu>State: Inactive</guimenu> and are
      grayed out in the list pane. By default, a newly created pool will be
      automatically started <guimenu>On Boot</guimenu> of the &vmhost;.
     </para>
     <para>
      To start an inactive pool and make it available from remote again, click
      <guimenu>Start</guimenu> in the bottom left corner of the Storage
      Manager.
     </para>
     <note>
      <title>A pool's state does not affect attached volumes</title>
      <para>
       Volumes from a pool attached to &vmguest;s are always available,
       regardless of the pool's state (<guimenu>Active</guimenu> (stopped) or
       <guimenu>Inactive</guimenu> (started)). The state of the pool solely
       affects the ability to attach volumes to a &vmguest; via remote
       management.
      </para>
     </note>
     <para>
      To permanently make a pool inaccessible, click <guimenu>Delete</guimenu>
      in the bottom left corner of the Storage Manager. You can only delete
      inactive pools. Deleting a pool does not physically erase its contents on
      &vmhost;&mdash;it only deletes the pool configuration. However, you need
      to be extra careful when deleting pools, especially when deleting LVM
      volume group-based tools:
     </para>
     <warning xml:id="deleting-storage-pools">
      <title>Deleting storage pools</title>
      <para>
       Deleting storage pools based on <emphasis>local</emphasis> file system
       directories, local partitions or disks has no effect on the availability
       of volumes from these pools currently attached to &vmguest;s.
      </para>
      <para>
       Volumes located in pools of type iSCSI, SCSI, LVM group or Network
       Exported Directory will become inaccessible from the &vmguest; if the
       pool is deleted. Although the volumes themselves will not be deleted,
       the &vmhost; will no longer have access to the resources.
      </para>
      <para>
       Volumes on iSCSI/SCSI targets or Network Exported Directory will become
       accessible again when creating an adequate new pool or when
       mounting/accessing these resources directly from the host system.
      </para>
      <para>
       When deleting an LVM group-based storage pool, the LVM group definition
       will be erased and the LVM group will no longer exist on the host
       system. The configuration is not recoverable and all volumes from this
       pool are lost.
      </para>
     </warning>
    </sect4>
    <sect4 xml:id="sec-libvirt-storage-vmm-manage-volume-add">
     <title>Adding volumes to a storage pool</title>
     <para>
      &vmm; lets you create volumes in all storage pools, except in pools of
      types Multipath, iSCSI, or SCSI. A volume in these pools is equivalent to
      a LUN and cannot be changed from within &libvirt;.
     </para>
     <procedure>
      <step>
       <para>
        A new volume can either be created using the Storage Manager or while
        adding a new storage device to a &vmguest;. In either case, select a
        storage pool from the left panel, then click <guimenu>Create new
        volume</guimenu>.
       </para>
      </step>
      <step>
       <para>
        Specify a <guimenu>Name</guimenu> for the image and choose an image
        format.
       </para>
       <para>
        &suse; currently only supports <literal>raw</literal> or
        <literal>qcow2</literal> images. The latter option is not available on
        LVM group-based pools.
       </para>
       <para>
        Next to <guimenu>Max Capacity</guimenu>, specify the maximum size that
        the disk image is allowed to reach. Unless you are working with a
        <literal>qcow2</literal> image, you can also set an amount for
        <guimenu>Allocation</guimenu> that should be allocated initially. If
        the two values differ, a sparse image file will be created, which grows
        on demand.
       </para>
       <para>
        For <literal>qcow2</literal> images, you can use a <guimenu>Backing
        Store</guimenu> (also called <quote>backing file</quote>), which
        constitutes a base image. The newly created <literal>qcow2</literal>
        image will then only record the changes that are made to the base
        image.
       </para>
      </step>
      <step>
       <para>
        Start the volume creation by clicking <guimenu>Finish</guimenu>.
       </para>
      </step>
     </procedure>
    </sect4>
    <sect4 xml:id="sec-libvirt-storage-vmm-manage-volume-delete">
     <title>Deleting volumes from a storage pool</title>
     <para>
      Deleting a volume can only be done from the Storage Manager, by selecting
      a volume and clicking <guimenu>Delete Volume</guimenu>. Confirm with
      <guimenu>Yes</guimenu>.
     </para>
     <warning>
      <title>Volumes can be deleted even while in use</title>
      <para>
       Volumes can be deleted even if they are currently used in an active or
       inactive &vmguest;. There is no way to recover a deleted volume.
      </para>
      <para>
       Whether a volume is used by a &vmguest; is indicated in the
       <guimenu>Used By</guimenu> column in the Storage Manager.
      </para>
     </warning>
    </sect4>
   </sect3>
  </sect2>
 </sect1>
</chapter>
