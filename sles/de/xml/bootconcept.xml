<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="bootconcept.xml" version="5.0" xml:id="cha.boot">
 <title>Booten eines Linux-Systems</title>
 <info>
      <abstract>
        <para>
    Das Booten eines Linux-Systems umfasst verschiedene Komponenten und Tasks. Die Hardware selbst wird vom BIOS oder dem UEFI initialisiert, das den Kernel mithilfe eines Bootloaders startet. Anschließend wird der Bootvorgang vollständig vom Betriebssystem gesteuert und über <systemitem class="daemon">systemd</systemitem> abgewickelt. <systemitem class="daemon">systemd</systemitem> bietet eine Reihe von <quote>Zielen</quote>, mit denen Konfigurationen für den normalen Gebrauch, für Wartungsarbeiten oder für Notfälle gebootet werden.
   </para>
      </abstract>
      <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
        <dm:bugtracker/>
        <dm:translation>Ja</dm:translation>
      </dm:docmanager>
    </info>
    <sect1 xml:id="sec.boot.proc">
  <title>Der Linux-Bootvorgang</title>

  <para>
   Der Linux-Bootvorgang besteht aus mehreren Phasen, von denen jede einer anderen Komponente entspricht. In der folgenden Liste werden der Bootvorgang und die daran beteiligten Komponenten kurz zusammengefasst:
  </para>

  <orderedlist spacing="normal">
   <listitem>
    <formalpara>
     <title>BIOS/UEFI</title>
     <para>
      Nach dem Einschalten des Computers initialisiert das BIOS oder das UEFI den Bildschirm und die Tastatur und testet den Hauptspeicher. Bis zu dieser Phase greift der Computer nicht auf Massenspeichergeräte zu. Anschließend werden Informationen zum aktuellen Datum, zur aktuellen Uhrzeit und zu den wichtigsten Peripheriegeräten aus den CMOS-Werten geladen. Wenn die erste Festplatte und deren Geometrie erkannt wurden, geht die Systemkontrolle vom BIOS an den Bootloader über. Wenn das BIOS Netzwerk-Booting unterstützt, ist es auch möglich, einen Boot-Server zu konfigurieren, der den Bootloader bereitstellt. Auf x86_64-Systemen ist PXE-Boot erforderlich. Andere Architekturen verwenden meist das BOOTP-Protokoll, um den Bootloader abzurufen.
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>Bootloader</title>
     <para>
      Der erste physische 512 Byte große Datensektor der ersten Festplatte wird in den Arbeitsspeicher geladen und der <emphasis>Bootloader</emphasis>, der sich am Anfang dieses Sektors befindet, übernimmt die Steuerung. Die vom Bootloader ausgegebenen Befehle bestimmen den verbleibenden Teil des Bootvorgangs. Aus diesem Grund werden die ersten 512 Byte auf der ersten Festplatte als <emphasis>Master Boot Record</emphasis> (MBR) bezeichnet. Der Bootloader übergibt die Steuerung anschließend an das eigentliche Betriebssystem, in diesem Fall an den Linux-Kernel. Weitere Informationen zu GRUB 2, dem Linux-Bootloader, finden Sie unter <xref linkend="cha.grub2"/>. Bei einem Netzwerk-Boot fungiert das BIOS als Bootloader. Es erhält das Boot-Image vom Boot-Server und startet das System. Dieser Vorgang ist vollständig unabhängig von den lokalen Festplatten.
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>Kernel und <systemitem>initramfs</systemitem></title>
     <para>
      Um die Systemsteuerung zu übergeben, lädt der Bootloader sowohl den Kernel als auch ein initiales RAM-basiertes Dateisystem (das <systemitem>initramfs</systemitem>) in den Arbeitsspeicher. Die Inhalte der Datei <systemitem>initramfs</systemitem> können direkt vom Kernel verwendet werden. <systemitem>initramfs</systemitem> enthält eine kleine ausführbare Datei namens <systemitem>init</systemitem>, die das Einhängen des Root-Dateisystems übernimmt. Spezielle Hardware-Treiber für den Zugriff auf den Massenspeicher müssen in <systemitem>initramfs</systemitem> vorhanden sein. Weitere Informationen zu <systemitem>initramfs </systemitem>finden Sie unter <xref linkend="sec.boot.initrd"/>. Wenn das System über keine lokale Festplatte verfügt, muss <systemitem>initramfs</systemitem> das Root-Dateisystem für den Kernel bereitstellen. Dies kann mithilfe eines Netzwerkblockgeräts, wie iSCSI oder SAN, bewerkstelligt werden, es kann aber auch NFS als Root-Gerät eingesetzt werden.
     </para>
    </formalpara>
    <note>
     <title>Die <systemitem>init</systemitem>-Vorgänge</title>
     <para>
      Derzeit gibt es zwei unterschiedliche Programme mit dem Namen <quote>init</quote>:
     </para>
     <orderedlist spacing="normal">
      <listitem>
       <para>
        der <systemitem>initramfs</systemitem>-Vorgang, mit dem das Root-Dateisystem eingehängt wird
       </para>
      </listitem>
      <listitem>
       <para>
        der Betriebssystemvorgang, mit dem das System eingerichtet wird
       </para>
      </listitem>
     </orderedlist>
     <para>
      Die beiden Vorgänge werden in diesem Kapitel daher als <quote><systemitem>init</systemitem> unter <systemitem>initramfs</systemitem></quote> bzw. <quote><systemitem class="daemon">systemd</systemitem></quote> bezeichnet.
     </para>
    </note>
   </listitem>
   <listitem>
    <formalpara>
     <title><systemitem>init</systemitem> unter <systemitem>initramfs</systemitem></title>
     <para>
      Dieses Programm führt alle erforderlichen Aktionen aus, mit denen das eigentliche Root-Dateisystem eingehängt wird. Es bietet Kernel-Funktionen für das benötigte Dateisystem sowie Gerätetreiber für Massenspeicher-Controller mit <systemitem class="service">udev</systemitem>. Nachdem das Root-Dateisystem gefunden wurde, wird es auf Fehler geprüft und eingehängt. Wenn dieser Vorgang erfolgreich ist, wird das <systemitem>initramfs</systemitem> bereinigt, und der <systemitem class="daemon">systemd</systemitem>-Daemon wird für das Root-Dateisystem ausgeführt. Weitere Informationen zu <systemitem>init</systemitem> unter <systemitem>initramfs</systemitem> finden Sie unter <xref linkend="sec.boot.linuxrc"/>. Weitere Informationen zu <systemitem class="service">udev</systemitem> finden Sie in <xref linkend="cha.udev"/>.
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title><systemitem class="daemon">systemd</systemitem></title>
     <para>
      <systemitem class="daemon">systemd</systemitem> wickelt das eigentliche Booten des Systems ab; hierzu werden Dienste gestartet und Dateisysteme eingehängt. <systemitem class="daemon">systemd</systemitem> wird in <xref linkend="cha.systemd"/> beschrieben.
     </para>
    </formalpara>
   </listitem>
  </orderedlist>
 </sect1>
 <sect1 xml:id="sec.boot.initrd">
  <title><systemitem>initramfs</systemitem></title>

  <para>
   <systemitem>initramfs</systemitem> ist ein kleines cpio-Archiv, das der Kernel auf einen RAM-Datenträger laden kann. Es stellt eine minimale Linux-Umgebung bereit, die das Ausführen von Programmen ermöglicht, bevor das eigentliche Root-Dateisystem eingehängt wird. Diese minimale Linux-Umgebung wird durch eine BIOS- oder UEFI-Routine in den Arbeitsspeicher geladen, wobei lediglich ausreichend Arbeitsspeicher zur Verfügung stehen muss; ansonsten gelten keine besonderen Anforderungen. Das <systemitem>initramfs</systemitem>-Archiv must stets eine ausführbare Datei mit der Bezeichnung <systemitem>init</systemitem> umfassen, die den <systemitem class="daemon">systemd</systemitem>-Daemon auf dem Root-Dateisystem ausführt, so dass der Bootvorgang fortgesetzt werden kann.
  </para>

  <para>
   Bevor das Root-Dateisystem eingehängt und das Betriebssystem gestartet werden kann, ist es für den Kernel erforderlich, dass die entsprechenden Treiber auf das Gerät zugreifen, auf dem sich das Root-Dateisystem befindet. Diese Treiber können spezielle Treiber für bestimmte Arten von Festplatten oder sogar Netzwerktreiber für den Zugriff auf ein Netzwerk-Dateisystem umfassen. Die erforderlichen Module für das Root-Dateisystem können mithilfe von <systemitem>init</systemitem> oder <systemitem>initramfs</systemitem> geladen werden. Nachdem die Module geladen wurden, stellt <systemitem class="service">udev</systemitem> das <systemitem>initramfs</systemitem> mit den erforderlichen Geräten bereit. Später im Boot-Vorgang, nach dem Ändern des Root-Dateisystems, müssen die Geräte regeneriert werden. Hierzu wird die <systemitem class="daemon">systemd</systemitem>-Einheit <filename>udev.service</filename> mit dem Kommando <command>udevtrigger</command> verwendet.
  </para>

  <para>
   Wenn in einem installierten System Hardwarekomponenten (z. B. Festplatten) ausgetauscht werden müssen und diese Hardware zur Boot-Zeit andere Treiber im Kernel erfordert, müssen Sie die Datei <systemitem>initramfs</systemitem> aktualisieren. Dies erfolgt durch Aufruf von <command>dracut </command><option>-f</option> (durch <option>-f</option> wird die bestehende initramfs-Datei überschrieben). Zum Hinzufügen eines Treibers für die neue Hardware müssen Sie der Datei <filename>/etc/dracut.conf.d/01-dist.conf</filename> folgende Zeile hinzufügen.
  </para>

<screen>force_drivers+="<replaceable>driver1</replaceable>"</screen>

  <para>
   Ersetzen Sie dabei <replaceable>driver1</replaceable> durch den Modulnamen des Treibers. Sie können auch mehrere Treiber hinzufügen. In diesem Fall geben Sie eine durch Leerzeichen getrennte Liste der Modulnamen ein (<literal><replaceable>driver1</replaceable> <replaceable>driver2</replaceable></literal>).
  </para>

  <important>
   <title>Aktualisieren von <systemitem>initramfs</systemitem> oder <systemitem>init</systemitem></title>
   <para>
    Der Bootloader lädt <systemitem>initramfs</systemitem> oder <systemitem>init</systemitem> auf dieselbe Weise wie den Kernel. Es ist nicht erforderlich, GRUB 2 nach der Aktualisierung von <systemitem>initramfs</systemitem> oder <systemitem>init</systemitem> neu zu installieren, da GRUB 2 beim Booten das Verzeichnis nach der richtigen Datei durchsucht.
   </para>
  </important>

  <tip>
   <title>Ändern der Kernel-Variablen</title>
   <para>
    Wenn Sie die Werte bestimmter Kernel-Variablen über die <command>sysctl</command>-Benutzeroberfläche ändern und dabei die zugehörigen Dateien ändern (<filename>/etc/sysctl.conf</filename> oder <filename>/etc/sysctl.d/*.conf</filename>), geht die Änderung beim nächsten Neubooten des Systems verloren. Die Änderungen werden selbst dann nicht in der initramfs-Datei gespeichert, wenn Sie die Werte zur Laufzeit mit <command>sysctl --system</command> laden. Sie müssen die Datei mit <command>dracut </command> <option>-f</option> aktualisieren. (Durch <option>-f</option> wird die bestehende initramfs-Datei überschrieben.)
   </para>
  </tip>
 </sect1>
 <sect1 xml:id="sec.boot.linuxrc">
  <title>init unter <systemitem>initramfs</systemitem></title>

  <para>
   Der Hauptzweck von <systemitem>init</systemitem> unter <systemitem>initramfs</systemitem> ist es, das Einhängen des eigentlichen Root-Dateisystems sowie die Vorbereitung des Zugriffs darauf. Je nach aktueller Systemkonfiguration ist <systemitem>init</systemitem> unter <systemitem>initramfs</systemitem> für die folgenden Tasks verantwortlich.
  </para>

  <variablelist>
   <varlistentry>
    <term>Laden der Kernelmodule</term>
    <listitem>
     <para>
      Je nach Hardware-Konfiguration sind für den Zugriff auf die Hardware-Komponenten des Computers (vor allem auf die Festplatte) spezielle Treiber erforderlich. Für den Zugriff auf das eigentliche Root-Dateisystem muss der Kernel die entsprechenden Dateisystemtreiber laden.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Bereitstellen von speziellen Blockdateien</term>
    <listitem>
     <para>
      Der Kernel generiert Geräteereignisse für alle geladenen Module. <systemitem class="service">udev</systemitem> verarbeitet diese Ereignisse und generiert die erforderlichen blockspezifischen Dateien auf einem RAM-Dateisystem im Verzeichnis <filename>/dev</filename>. Ohne diese speziellen Dateien wäre ein Zugriff auf das Dateisystem und andere Geräte nicht möglich.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Verwalten von RAID- und LVM-Setups</term>
    <listitem>
     <para>
      Wenn Ihr System so konfiguriert ist, dass das Root-Dateisystem sich unter RAID oder LVM befindet, richtet <systemitem>init</systemitem> unter <systemitem>initramfs</systemitem> LVM oder RAID so ein, dass der Zugriff auf das Root-Dateisystem zu einem späteren Zeitpunkt erfolgt. Informationen über RAID und LVM finden Sie in <xref linkend="cha.advdisk"/>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry xml:id="ve.net">
    <term>Verwalten von Netzwerkkonfigurationen</term>
    <listitem>
     <para>
      Wenn Ihr System für die Verwendung eines netzwerkeingehängten Root-Dateisystems (über NFS eingehängt) konfiguriert ist, muss <systemitem>init</systemitem> unter <systemitem>initramfs</systemitem> sicherstellen, dass die entsprechenden Netzwerktreiber geladen und für den Zugriff auf das Root-Dateisystem eingerichtet werden.
     </para>
     <para>
      Wenn sich das Dateisystem auf einem Netzwerkblockgerät wie iSCSI oder SAN befindet, wird die Verbindung zum Speicherserver ebenfalls vom <systemitem>init</systemitem> unter <systemitem>initramfs</systemitem> eingerichtet.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Wenn <systemitem>init</systemitem> unter <systemitem>initramfs</systemitem> im Rahmen des Installationsvorgangs während des anfänglichen Boot-Vorgangs aufgerufen wird, unterscheiden sich seine Tasks von den oben beschriebenen:
  </para>

  <variablelist>
   <varlistentry>
    <term>Suchen des Installationsmediums</term>
    <listitem>
     <para>
      Beim Starten des Installationsvorgangs lädt der Rechner einen Installations-Kernel und eine besondere <systemitem>Einheit</systemitem> mit dem YaST-Installationsprogramm. Das YaST-Installationsprogramm wird in einem RAM-Dateisystem ausgeführt und benötigt Daten über den Speicherort des Installationsmediums, um auf dieses zugreifen und das Betriebssystem installieren zu können.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>
      Initiieren der Hardware-Erkennung und Laden der entsprechenden Kernelmodule
     </term>
    <listitem>
     <para>
      Wie unter <xref linkend="sec.boot.initrd"/> beschrieben, startet der Boot-Vorgang mit einem Mindestsatz an Treibern, die für die meisten Hardwarekonfigurationen verwendet werden können. <systemitem>init</systemitem> startet einen anfänglichen Hardware-Scan-Vorgang, bei dem die für die Hardwarekonfiguration geeigneten Treiber ermittelt werden. Diese Treiber werden zur Erstellung der zum Booten des Systems benötigten, benutzerdefinierten <systemitem>initramfs</systemitem>-Datei verwendet. Falls die Module nicht für "boot", sondern für "coldplug" benötigt werden, können sie mit <systemitem class="daemon">systemd</systemitem> geladen werden. Weitere Informationen finden Sie unter <xref linkend="sec.boot.systemd.advanced.kernel_modules"/>.

     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Laden des Installationssystems</term>
    <listitem>
     <para>
      Sobald die Hardware ordnungsgemäß erkannt wurde, werden die entsprechenden Treiber geladen. Das <systemitem class="service">udev</systemitem>-Programm erstellt die speziellen Gerätedateien, und <systemitem>init</systemitem> startet das Installationssystem mit dem YaST-Installationsprogramm.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Starten von YaST</term>
    <listitem>
     <para>
      <systemitem>init</systemitem> startet schließlich YaST, das wiederum die Paketinstallation und die Systemkonfiguration startet.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
</chapter>
