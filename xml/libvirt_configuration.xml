<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<!-- Converted by suse-upgrade version 1.1 -->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="cha.libvirt.config">
 <title>Configuring Virtual Machines</title>
 <info>
  <abstract>
   <para>
    &vmm;'s <guimenu>Details</guimenu> view offers in-depth information
    about the &vmguest;'s complete configuration and hardware equipment.
    Using this view, you can also change the guest configuration or add and
    modify virtual hardware. To access this view, open the guest's console
    in &vmm; and either choose <menuchoice> <guimenu>View</guimenu>
    <guimenu>Details</guimenu> </menuchoice> from the menu, or click the
    bulb icon in the toolbar.
   </para>
  </abstract>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker></dm:bugtracker>
  </dm:docmanager>
 </info>
 <para/>
 <figure>
  <title><guimenu>Details</guimenu> View of a &vmguest;</title>
  <mediaobject>
   <imageobject role="fo">
    <imagedata fileref="libvirt_vmm_details.png" width="75%" format="PNG"/>
   </imageobject>
   <imageobject role="html">
    <imagedata fileref="libvirt_vmm_details.png" width="75%" format="PNG"/>
   </imageobject>
  </mediaobject>
 </figure>
 <para>
  The left panel of the window lists &vmguest; overview and already
  installed hardware. After clicking an item in the list, you can access its
  detailed settings in the details view. You can change the hardware
  parameters to match your needs, then click <guimenu>Apply</guimenu> to
  confirm them. Some changes take effect immediately, while other need
  reboot of the machine&mdash;and <systemitem>virt-manager</systemitem>
  warns you about that fact.
 </para>
 <para>
  To remove installed hardware form &vmguest;, click it in the left panel
  and then click <guimenu>Remove</guimenu> in the bottom right of the
  window.
 </para>
 <para>
  To add new hardware, click <guimenu>Add Hardware</guimenu> below the left
  panel, then select the type of the hardware you want to add in the
  <guimenu>Add New Virtual Hardware</guimenu> window. Modify its parameters
  and confirm with <guimenu>Finish</guimenu>.
 </para>
 <para>
  The following sections describe configuration options for the specific
  hardware type <emphasis>being added</emphasis>. They do not focus on
  modifying an existing piece of hardware as the options are identical.
 </para>
 <sect1 xml:id="sec.libvirt.config.machine_setup">
  <title>Machine Setup</title>

  <para>
   This section describes hardware components and options that are vital to
   a &vmguest; and you cannot remove them: the processor and memory. It also
   shows how to view the overview and performance information, and boot
   options as well.
  </para>

  <sect2>
   <title>Overview</title>
   <para>
    <guimenu>Overview</guimenu> shows basic details about &vmguest; and the
    hypervisor.
   </para>
   <figure>
    <title>Overview details</title>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="libvirt_vmm_overview.png" width="70%" format="PNG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="libvirt_vmm_overview.png" width="70%" format="PNG"/>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    <guimenu>Name</guimenu>, <guimenu>Title</guimenu>, and
    <guimenu>Description</guimenu> are editable and help you identify
    &vmguest; in the <guimenu>Virtual Machine Manager</guimenu> list of
    machines.
   </para>
   <figure>
    <title>&vmguest; Title and Description</title>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="libvirt_vmm_desc.png" width="40%" format="PNG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="libvirt_vmm_desc.png" width="40%" format="PNG"/>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    <guimenu>UUID</guimenu> shows the universally unique identifier of the
    virtual machine, while <guimenu>Status</guimenu> shows its current
    status&mdash;<guimenu>Running</guimenu>, <guimenu>Paused</guimenu>, or
    <guimenu>Shutoff</guimenu>.
   </para>
   <para>
    The <guimenu>Hypervisor Details</guimenu> section shows the hypervisor
    type, CPU architecture, used emulator, and chipset type. None of the
    hypervisor parameters can be changed.
   </para>
  </sect2>

  <sect2>
   <title>Performance</title>
   <para>
    <guimenu>Performance</guimenu> shows regularly updated charts of CPU and
    memory usage, and disk and network I/O.
   </para>
   <figure>
    <title>Performance</title>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="libvirt_vmm_performance.png" width="70%" format="PNG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="libvirt_vmm_performance.png" width="70%" format="PNG"/>
     </imageobject>
    </mediaobject>
   </figure>
   <tip>
    <title>Enabling Disabled Charts</title>
    <para>
     Not all the charts in the <guimenu>Performance</guimenu> view are
     enabled by default. To enable disable selected charts, go to
     <menuchoice><guimenu>File</guimenu><guimenu>View
     Manager</guimenu><guimenu>Polling</guimenu></menuchoice>, and check the
     charts that you want to see regularly updated. You can also specify the
     time interval (in seconds) of the update.
    </para>
    <figure>
     <title>Statistics Charts</title>
     <mediaobject>
      <imageobject role="fo">
       <imagedata fileref="libvirt_vmm_polling_charts.png" width="40%" format="PNG"/>
      </imageobject>
      <imageobject role="html">
       <imagedata fileref="libvirt_vmm_polling_charts.png" width="40%" format="PNG"/>
      </imageobject>
     </mediaobject>
    </figure>
   </tip>
  </sect2>

  <sect2>
   <title>Processor</title>
   <para>
    <guimenu>Processor</guimenu> includes detailed information about
    &vmguest; processor configuration.
   </para>
   <figure>
    <title>Processor View</title>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="libvirt_vmm_processor.png" width="70%" format="PNG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="libvirt_vmm_processor.png" width="70%" format="PNG"/>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    In the <guimenu>CPUs</guimenu> section, you can configure several
    parameters related to the number of allocated CPUs.
   </para>
   <variablelist>
    <varlistentry>
     <term><guimenu>Logical host CPUs</guimenu>
     </term>
     <listitem>
      <para>
       The real number of CPUs installed on &vmhost;.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><guimenu>Current allocation</guimenu>
     </term>
     <listitem>
      <para>
       The number of currently allocated CPUs. You can hotplug more CPUs by
       increasing this value up to the <guimenu>Maximum allocation</guimenu>
       value.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><guimenu>Maximum allocation</guimenu>
     </term>
     <listitem>
      <para>
       Maximum number of allocable CPUs for the current session. Any change
       to this value will take effect after next &vmguest; reboot.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    The <guimenu>Configuration</guimenu> section lets you configure the CPU
    model, topology, and pinning.
   </para>
   <para>
    When activated, the <guimenu>Copy host CPU configuration</guimenu>
    option uses the host CPU model for &vmguest;. Otherwise you need to
    specify the CPU model from the drop-down list.
   </para>
   <para>
    After you activate <guimenu>Manually set CPU topology</guimenu>, you can
    specify a custom number of sockets, cores and threads for the CPU.
   </para>
   <para>
    You can also specify <guimenu>Default pinning</guimenu> (see
    <xref linkend="gloss.vt.cpu.pinning"/>) for the CPU, or get the relevant
    pinning information from the host by clicking <guimenu>Generate from
    host NUMA configuration</guimenu>.
   </para>
  </sect2>

  <sect2>
   <title>Memory</title>
   <para>
    <guimenu>Memory</guimenu> contains information about the memory that is
    available to &vmguest;.
   </para>
   <figure>
    <title>Memory View</title>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="libvirt_vmm_memory.png" width="70%" format="PNG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="libvirt_vmm_memory.png" width="70%" format="PNG"/>
     </imageobject>
    </mediaobject>
   </figure>
   <variablelist>
    <varlistentry>
     <term><guimenu>Total host memory</guimenu>
     </term>
     <listitem>
      <para>
       Total amount of memory installed on &vmhost;.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><guimenu>Current allocation</guimenu>
     </term>
     <listitem>
      <para>
       The amount of memory currently available to &vmguest;. You can
       hotplug more memory by increasing this value up to the value of
       <guimenu>Maximum allocation</guimenu>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><guimenu>Maximum allocation</guimenu>
     </term>
     <listitem>
      <para>
       The maximum value to which you can hotplug the currently available
       memory. Any change to this value will take effect after next
       &vmguest; reboot.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2>
   <title>Boot Options</title>
   <para>
    <guimenu>Boot Options</guimenu> introduces options affecting the
    &vmguest; boot process.
   </para>
   <figure>
    <title>Boot Options</title>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="libvirt_vmm_boot.png" width="70%" format="PNG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="libvirt_vmm_boot.png" width="70%" format="PNG"/>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    In the <guimenu>Autostart</guimenu> section, you can specify whether the
    virtual machine should automatically start during &vmhost; boot phase.
   </para>
   <para>
    In the <guimenu>Boot device order</guimenu>, activate the devices that
    will be used for booting &vmguest;. You can change their order with the
    up an down arrows on the right side of the list. If you want to choose
    from a list of bootable devices on &vmguest; startup, activate
    <guimenu>Enable boot menu</guimenu>.
   </para>
   <para>
    To boot a different kernel than the one on the boot device, activate
    <guimenu>Enable direct kernel boot</guimenu> and specify paths to
    alternative kernel and initrd placed on the &vmhost; file system. You
    can also specify kernel arguments that will be passed to the loaded
    kernel.
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.libvirt.config.storage">
  <title>Storage</title>

  <para>
   This section gives you detailed description of configuration options for
   storage devices. It includes both hard disks and removable media, such as
   USB or CDROM drives.
  </para>

  <procedure>
   <title>Adding a New Storage Device</title>
   <step>
    <para>
     Click <guimenu>Add Hardware</guimenu> below the left panel, then select
     <guimenu>Storage</guimenu> from the <guimenu>Add New Virtual
     Hardware</guimenu> window.
    </para>
    <figure>
     <title>Add New Virtual Hardware</title>
     <mediaobject>
      <imageobject role="fo">
       <imagedata fileref="libvirt_vmm_storage1.png" width="70%" format="PNG"/>
      </imageobject>
      <imageobject role="html">
       <imagedata fileref="libvirt_vmm_storage1.png" width="70%" format="PNG"/>
      </imageobject>
     </mediaobject>
    </figure>
   </step>
   <step>
    <para>
     If you prefer that &vmm; creates a disk image for you, activate
     <guimenu>Create a disk image on the computer's hard drive</guimenu> and
     specify its size in Gigabytes. If you want &vmm; to allocate the entire
     disk space no, activate the relevant option. Note that
     <literal>qcow2</literal> and <literal>qed</literal> formats do not
     support full allocation.
    </para>
    <para>
     If you want to have more control over the disk image creation, activate
     <guimenu>Select managed or other existing storage</guimenu> and click
     <guimenu>Browse</guimenu> to manage storage pools and images.
     <guimenu>Choose Storage</guimenu> window opens, which has almost
     identical functionality as the <guimenu>Storage</guimenu> card
     described in <xref linkend="sec.libvirt.storage.vmm"/>.
    </para>
   </step>
   <step>
    <para>
     After you manage to create and specify the disk image file, specify the
     <guimenu>Device type</guimenu>. It can be either <guimenu>Disk
     device</guimenu>, <guimenu>CDROM device</guimenu>, <guimenu>Floppy
     device</guimenu>, or <guimenu>LUN Passthrough</guimenu>. The latter is
     required if you want to use an existing SCSI storage directly without
     adding it into a storage pool.
    </para>
   </step>
   <step>
    <para>
     Select the <guimenu>Bus type</guimenu> for your device. The list of
     available options depends on the device type you selected in the
     previous step. Note that the <guimenu>Virtio-</guimenu> based types use
     paravirtualized drivers.
    </para>
   </step>
   <step>
    <para>
     In the <guimenu>Advanced options</guimenu> section, select the
     preferred <guimenu>Cache mode</guimenu> and <guimenu>Storage
     format</guimenu>. For more information on cache modes, see
     <xref linkend="cha.cachemodes"/>.
    </para>
    <tip>
     <title>Supported Storage Formats</title>
     <para>
      Only the <literal>raw</literal>, <literal>qcow2</literal>, and
      <literal>qed</literal> storage formats are supported by &suse;.
     </para>
    </tip>
   </step>
   <step>
    <para>
     Confirm your settings with <guimenu>Finish</guimenu>. A new storage
     device appears in the left panel.
    </para>
   </step>
  </procedure>
 </sect1>
 <sect1 xml:id="sec.libvirt.config.networking">
  <title>Networking</title>

  <para></para>
 </sect1>
 <sect1 xml:id="sec.libvirt.config.input_devices">
  <title>Input Devices</title>

  <para></para>
 </sect1>
 <sect1 xml:id="sec.libvirt.config.video">
  <title>Display and Video</title>

  <para></para>
 </sect1>
 <sect1 xml:id="sec.libvirt.config.controllers">
  <title>Controllers</title>

  <para></para>
 </sect1>
 <sect1 xml:id="sec.libvirt.config.ioio">
  <title>I/O Devices</title>

  <para></para>
 </sect1>
 <sect1 xml:id="sec.libvirt.config.misc">
  <title>Miscellaneouss</title>

  <para></para>
 </sect1>
 <sect1 xml:id="sec.libvirt.config.tablet">
  <title>Enabling Seamless and Synchronized Cursor Movement</title>

  <para>
   When you click within a &vmguest;'s console with the mouse, the cursor is
   captured by the console window and cannot be used outside the console
   unless it is explicitly released (by pressing <keycombo>
   <keycap function="alt"/> <keycap function="control"/> </keycombo> ). To
   prevent the console from grabbing the key and to enable seamless cursor
   movement between host and guest instead, add a tablet to the &vmguest;.
  </para>

  <para>
   Adding a tablet has the additional advantage of synchronizing the cursor
   movement between &vmhost; and &vmguest; when using a graphical
   environment on the guest. With no tablet configured on the guest, you
   will often see two cursor symbols with one dragging behind the other.
  </para>

  <procedure>
   <step>
    <para>
     Double-click a &vmguest; entry in the &vmm; to open its console and
     switch to the <guimenu>Details</guimenu> view with <menuchoice>
     <guimenu>View</guimenu> <guimenu>Details</guimenu> </menuchoice>.
    </para>
   </step>
   <step>
    <para>
     Click <guimenu>Add Hardware</guimenu> and choose
     <guimenu>Input</guimenu> and then <guimenu>EvTouch USB Graphics
     Tablet</guimenu> in the pop-up window. Proceed with
     <guimenu>Finish</guimenu>.
    </para>
   </step>
   <step>
    <para>
     If you try to add the tablet while the guest is still running, you will
     be asked whether to enable the tablet after the next reboot. Confirm
     with <guimenu>Yes</guimenu>.
    </para>
   </step>
   <step>
    <para>
     When you (re)start the &vmguest;, the tablet is available in the
     &vmguest;.
    </para>
   </step>
  </procedure>
 </sect1>
 <sect1 xml:id="sec.libvirt.config.cdrom" condition="kvm4x86">
  <title>Adding a CD/DVD-ROM Device with &vmm;</title>

  <para>
   &kvm; supports CD or DVD-ROMs in &vmguest; either by directly accessing a
   physical drive on the &vmhost; or by accessing ISO images. To create an
   ISO image from an existing CD or DVD, use <command>dd</command>:
  </para>

<screen>dd if=/dev/<replaceable>cd_dvd_device</replaceable> of=my_distro.iso bs=2048</screen>

  <para>
   To add a CD/DVD-ROM device to your &vmguest;, proceed as follows:
  </para>

  <procedure>
   <step>
    <para>
     Double-click a &vmguest; entry in the &vmm; to open its console and
     switch to the <guimenu>Details</guimenu> view with <menuchoice>
     <guimenu>View</guimenu> <guimenu>Details</guimenu> </menuchoice>.
    </para>
   </step>
   <step>
    <para>
     Click <guimenu>Add Hardware</guimenu> and choose
     <guimenu>Storage</guimenu> in the pop-up window. Proceed with
     <guimenu>Forward</guimenu>.
    </para>
   </step>
   <step>
    <para>
     Change the <guimenu>Device Type</guimenu> to <guimenu>IDE
     CDROM</guimenu>.
    </para>
   </step>
   <step>
    <para>
     Select <guimenu>Select Managed or Other Existing Storage</guimenu>.
    </para>
    <substeps performance="required">
     <step>
      <para>
       To assign the device to a physical medium, enter the path to the
       &vmhost;'s CD/DVD-ROM device (for example,
       <filename>/dev/cdrom</filename>) next to the
       <guimenu>Browse</guimenu> button. Alternatively you may use the
       <guimenu>Browse</guimenu> button to open a file browser and then
       click <guimenu>Browse Local</guimenu> to select the device. Assigning
       the device to a physical medium is only possible when the &vmm; was
       started on the &vmhost;.
      </para>
     </step>
     <step>
      <para>
       To assign the device to an existing image, click
       <guimenu>Browse</guimenu> to choose an image from a storage pool. If
       the &vmm; was started on the &vmhost;, you may alternatively choose
       an image from another location on the file system by clicking
       <guimenu>Browse Local</guimenu>. Select an image and close the file
       browser with <guimenu>Choose Volume</guimenu>.
      </para>
     </step>
    </substeps>
   </step>
   <step>
    <para>
     Proceed with <guimenu>Forward</guimenu> to review the settings. Apply
     them with <guimenu>Finish</guimenu>, <guimenu>Yes</guimenu>, and
     <guimenu>Apply</guimenu>.
    </para>
   </step>
   <step>
    <para>
     Reboot the &vmguest; to make the new device
     available.<phrase condition="kvm4x86"> For further information also see
     <xref linkend="sec.libvirt.config.cdrom.media_change"/>.</phrase>
    </para>
   </step>
  </procedure>
 </sect1>
 <sect1 xml:id="sec.libvirt.config.floppy" condition="kvm4x86">
  <title>Adding a Floppy Device with &vmm;</title>

  <para>
   Currently &kvm; only supports the use of floppy disk images&mdash;using a
   physical floppy drive is not supported. Create a floppy disk image from
   an existing floppy using <command>dd</command>:
  </para>

<screen>dd if=/dev/fd0 of=/var/lib/libvirt/images/floppy.img</screen>

  <para>
   To create an empty floppy disk image use one of the following commands:
  </para>

  <variablelist>
   <varlistentry>
    <term>Raw Image</term>
    <listitem>
<screen>dd if=/dev/zero of=/var/lib/libvirt/images/floppy.img bs=512 count=2880</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>FAT Formatted Image</term>
    <listitem>
<screen>mkfs.msdos -C /var/lib/libvirt/images/floppy.img 1440</screen>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   To add a floppy device to your &vmguest;, proceed as follows:
  </para>

  <procedure>
   <step>
    <para>
     Double-click a &vmguest; entry in the &vmm; to open its console and
     switch to the <guimenu>Details</guimenu> view with <menuchoice>
     <guimenu>View</guimenu> <guimenu>Details</guimenu> </menuchoice>.
    </para>
   </step>
   <step>
    <para>
     Click <guimenu>Add Hardware</guimenu> and choose
     <guimenu>Storage</guimenu> in the pop-up window. Proceed with
     <guimenu>Forward</guimenu>.
    </para>
   </step>
   <step>
    <para>
     Change the <guimenu>Device Type</guimenu> to <guimenu>Floppy
     Disk</guimenu>.
    </para>
   </step>
   <step>
    <para>
     Choose <guimenu>Select Managed or Other Existing Storage</guimenu> and
     click <guimenu>Browse</guimenu> to choose an existing image from a
     storage pool. If &vmm; was started on the &vmhost;, you may
     alternatively choose an image from another location on the file system
     by clicking <guimenu>Browse Local</guimenu>. Select an image and close
     the file browser with <guimenu>Choose Volume</guimenu>.
    </para>
   </step>
   <step>
    <para>
     Proceed with <guimenu>Forward</guimenu> to review the settings. Apply
     them with <guimenu>Finish</guimenu>, <guimenu>Yes</guimenu>, and
     <guimenu>Apply</guimenu>.
    </para>
   </step>
   <step>
    <para>
     Reboot the &vmguest; to make the new device
     available.<phrase condition="kvm4x86"> For further information also see
     <xref linkend="sec.libvirt.config.cdrom.media_change"/>.</phrase>
    </para>
   </step>
  </procedure>
 </sect1>
 <sect1 xml:id="sec.libvirt.config.cdrom.media_change" condition="kvm4x86">
  <title>Ejecting and Changing Floppy or CD/DVD-ROM Media with &vmm;</title>

  <para>
   Regardless of whether you are using the &vmhost;'s physical CD/DVD-ROM
   device or an ISO/floppy image, before you can change the media or image
   of an existing device in the &vmguest;, you first need to
   <literal>disconnect</literal> the media from the guest.
  </para>

  <procedure>
   <step>
    <para>
     Double-click a &vmguest; entry in the &vmm; to open its console and
     switch to the <guimenu>Details</guimenu> view with <menuchoice>
     <guimenu>View</guimenu> <guimenu>Details</guimenu> </menuchoice>.
    </para>
   </step>
   <step>
    <para>
     Choose the Floppy or CD/DVD-ROM device and <quote>eject</quote> the
     media by clicking <guimenu>Disconnect</guimenu>.
    </para>
   </step>
   <step>
    <para>
     To <quote>insert</quote> a new media, click <guimenu>Connect</guimenu>.
    </para>
    <substeps performance="required">
     <step>
      <para>
       If using the &vmhost;'s physical CD/DVD-ROM device, first change the
       media in the device (this may require unmounting it on the &vmhost;
       before it can be ejected). Then choose <guimenu>CD-ROM or
       DVD</guimenu> and select the device from the drop-down box.
      </para>
     </step>
     <step>
      <para>
       If using an ISO image, choose <guimenu>ISO image Location</guimenu>
       and select an image by clicking <guimenu>Browse</guimenu>. When
       connecting from a remote host, you may only choose images from
       existing storage pools.
      </para>
     </step>
    </substeps>
   </step>
   <step>
    <para>
     Click <guimenu>OK</guimenu> to finish. The new media can now be
     accessed in the &vmguest;.
    </para>
   </step>
  </procedure>
 </sect1>
 <sect1 xml:id="sec.libvirt.config.mahcinetype.virsh">
  <title>Change the Machine Type with <command>virsh</command></title>

  <para>
   By default, when installing with <command>virt-install</command> or
   <command>vm-install</command> tools, the machine type for &vmguest; is
   <emphasis>pc-i440fx</emphasis>. The machine type is stored in the
   &vmguest;'s xml configuration file in
   <filename>/etc/libvirt/qemu/</filename> in the tag
   <tag>type</tag>
   :
  </para>

<screen>&lt;type arch='x86_64' machine='pc-i440fx-2.3'&gt;hvm&lt;/type&gt;</screen>

  <para>
   Let's change this value to the new supported q35 machine type. q35 is an
   Intel* chipset. It includes <xref linkend="gloss.vt.acronym.pcie"/>. q35
   supports up to 12 USB ports, and has
   <xref linkend="gloss.vt.acronym.sata"/> and
   <xref linkend="gloss.vt.acronym.iommu"/> support. IRQ routing has also
   been improved.
  </para>

  <procedure>
   <step>
    <para>
     Check that your &vmguest; is inactive:
    </para>
<screen>virsh list --inactive
 Id    Name                           State
 ----------------------------------------------------
 -     sles11                         shut off</screen>
   </step>
   <step>
    <para>
     Edit the configuration for this &vmguest;:
    </para>
<screen>virsh edit sles11</screen>
   </step>
   <step>
    <para>
     Change the value of the
     <tag class="attribute">machine</tag>
     attribute:
    </para>
<screen>&lt;type arch='x86_64' machine='pc-q35-2.0'&gt;hvm&lt;/type&gt;</screen>
   </step>
   <step>
    <para>
     Now you can restart the &vmguest;.
    </para>
<screen>virsh start sles11</screen>
   </step>
   <step>
    <para>
     Now check that the machine type has changed. Log in to the &vmguest; as
     root and run the following command:
    </para>
<screen>&prompt.root;dmidecode | grep Product
Product Name: Standard PC (Q35 + ICH9, 2009)</screen>
   </step>
  </procedure>

  <tip>
   <title>Machine Type Update Recommendations</title>
   <para>
    Whenever the &qemu; version on the host system is upgraded (for example
    when upgrading the &vmhost; to a new service pack), it is also
    recommended to upgrade the machine type of the &vmguest;s to the latest
    available version (check with the command <command>qemu-system-x86_64 -M
    help</command> on the &vmhost;).
   </para>
   <para>
    The default machine type <literal>pc-i440fx</literal>, for example, is
    regularly updated. If your &vmguest; still runs with a machine type of
    <literal>pc-i440fx-1.<replaceable>x</replaceable></literal>, an update
    to <literal>pc-i440fx-2.<replaceable>x</replaceable></literal> is
    strongly recommended. This allows to take advantage of the most recent
    updates and corrections in the machine definitions, with an eye towards
    better future-looking compatibility.
   </para>
  </tip>
 </sect1>
 <sect1 xml:id="sec.libvirt.config.pci">
  <title>Adding a PCI Device to a &vmguest;</title>

  <para>
   You can directly assign host-PCI devices to guests (PCI pass-through).
   When the PCI device is assigned to one &vmguest;, it cannot be used on
   the host or by another &vmguest; unless re-assigned. A prerequisite for
   this feature is a &vmhost; configuration as described in
   <xref
   linkend="ann.vt.io.require"/>.
  </para>

  <note>
   <title>VFIO vs. &kvm; &pciback;</title>
   <para>
    &productname; currently supports two ways of assigning PCI devices to
    &vmguest;s: either via VFIO or via the legacy &kvm; &pciback;. Using
    VFIO is strongly recommended, since it is more stable and secure.
    Support for the legacy &kvm; &pciback; will be removed from future
    &productname; releases. See <xref linkend="sec.vt.io"/> for more
    details.
   </para>
   <para>
    VFIO support is built into libvirt and will automatically be used if the
    <literal>vfio_pci</literal> driver is loaded (see
    <xref
    linkend="ann.vt.io.require"/> for setup instructions). In case
    <literal>vfio_pci</literal> is not loaded, libvirt will automatically
    fall back to &kvm; &pciback;.
   </para>
  </note>

  <sect2 xml:id="sec.libvirt.config.pci.vmm">
   <title>Adding a PCI Device with &vmm;</title>
   <para>
    The following procedure describes how to add a PCI device to a &vmguest;
    using &vmm;:
   </para>
   <procedure>
    <step>
     <para>
      Double-click a &vmguest; entry in the &vmm; to open its console and
      switch to the <guimenu>Details</guimenu> view with <menuchoice>
      <guimenu>View</guimenu> <guimenu>Details</guimenu> </menuchoice>.
     </para>
    </step>
    <step>
     <para>
      Click <guimenu>Add Hardware</guimenu> and choose the <guimenu>PCI Host
      Device</guimenu> category in the left pane. A list of available PCI
      devices appears in the right part of the window.
     </para>
     <figure>
      <title>Adding a PCI Device</title>
      <mediaobject>
       <imageobject role="fo">
        <imagedata fileref="virt_add_pcidevice.png" width="75%" format="png"/>
       </imageobject>
       <imageobject role="html">
        <imagedata fileref="virt_add_pcidevice.png" width="75%" format="png"/>
       </imageobject>
      </mediaobject>
     </figure>
    </step>
    <step>
     <para>
      From the list of available PCI devices, choose the one you want to
      pass to the guest. Confirm with <guimenu>Finish</guimenu>.
     </para>
    </step>
   </procedure>
   <tip>
    <title>Assigning a PCI Device Requires a &vmguest; Shutdown</title>
    <para>
     Although it is possible to assign a PCI device to a running &vmguest;
     as described above, the device will not become available until you shut
     down the &vmguest; and reboot it afterwards.
    </para>
   </tip>
  </sect2>

  <sect2 xml:id="sec.libvirt.config.pci.virsh">
   <title>Adding a PCI Device with <command>virsh</command></title>
   <para>
    To assign a PCI device to &vmguest; with <command>virsh</command>,
    follow these steps:
   </para>
   <procedure>
    <step>
     <para>
      Identify the host PCI device to assign to the guest. In the following
      example we are assigning a DEC network card to the guest:
     </para>
<screen>&prompt.user;sudo lspci -nn
[...]
03:07.0 Ethernet controller [0200]: Digital Equipment Corporation DECchip \
21140 [FasterNet] [1011:0009] (rev 22)
[...]</screen>
     <para>
      Note down the device ID (<literal>03:07.0</literal> in this case).
     </para>
    </step>
    <step>
     <para>
      Gather detailed information about the device using <command>virsh
      nodedev-dumpxml <replaceable>ID</replaceable></command>. To get the
      <replaceable>ID</replaceable>, you need to replace colon and period in
      the device ID (<literal>03:07.0</literal>) with underscore and prefix
      the result with <quote>pci_0000_</quote>
      (<literal>pci_0000_03_07_0</literal>).
     </para>
<screen>&prompt.user;virsh nodedev-dumpxml pci_0000_03_07_0
&lt;device&gt;
  &lt;name&gt;pci_0000_03_07_0&lt;/name&gt;
  &lt;path&gt;/sys/devices/pci0000:00/0000:00:14.4/0000:03:07.0&lt;/path&gt;
  &lt;parent&gt;pci_0000_00_14_4&lt;/parent&gt;
  &lt;driver&gt;
    &lt;name&gt;tulip&lt;/name&gt;
  &lt;/driver&gt;
  &lt;capability type='pci'&gt;
    <emphasis role="bold">&lt;domain&gt;0&lt;/domain&gt;
    &lt;bus&gt;3&lt;/bus&gt;
    &lt;slot&gt;7&lt;/slot&gt;
    &lt;function&gt;0&lt;/function&gt;</emphasis>
    &lt;product id='0x0009'&gt;DECchip 21140 [FasterNet]&lt;/product&gt;
    &lt;vendor id='0x1011'&gt;Digital Equipment Corporation&lt;/vendor&gt;
    &lt;numa node='0'/&gt;
  &lt;/capability&gt;
&lt;/device&gt;</screen>
     <para>
      Note down the values for domain, bus, and function.
     </para>
    </step>
    <step>
     <para>
      Detach the device from the host system prior to attaching it to
      &vmguest;.
     </para>
<screen>&prompt.user;virsh nodedev-detach pci_0000_03_07_0
  Device pci_0000_03_07_0 detached</screen>
     <tip>
      <title>Multi-Function PCI Devices</title>
      <para>
       When using a multi-function PCI device that does not support FLR
       (function level reset) or PM (power management) reset, you need to
       detach all its functions from the &vmhost;. The whole device must be
       reset for security reasons. <systemitem>libvirt</systemitem> will
       refuse to assign the device if one of its functions is still in use
       by the &vmhost; or another &vmguest;.
      </para>
     </tip>
    </step>
    <step>
     <para>
      Convert the domain, bus, slot, and function value from decimal to
      hexadecimal, and prepend <literal>0x</literal> to tell the system that
      the value is hexadecimal. In our example, domain = 0, bus = 3, slot =
      7, and function = 0. Their hexadecimal values are:
     </para>
<screen>&prompt.user;printf %x 0
0
&prompt.user;printf %x 3
3
&prompt.user;printf %x 7
7</screen>
     <para>
      This results in domain = 0x0000, bus = 0x03, slot = 0x07 and function
      = 0x00.
     </para>
    </step>
    <step>
     <para>
      Run <command>virsh edit</command> on your domain, and add the
      following device entry in the <literal>&lt;devices&gt;</literal>
      section using the values from the previous step:
     </para>
<screen>&lt;hostdev mode='subsystem' type='pci' managed='yes'&gt;
  &lt;source&gt;
    &lt;address domain='0x0000' bus='0x03' slot='0x07' function='0x00'/&gt;
  &lt;/source&gt;
&lt;/hostdev&gt;</screen>
     <tip xml:id="tip.libvirt.config.pci.virsh.managed">
      <title><literal>managed</literal> vs. <literal>unmanaged</literal></title>
      <para>
       <systemitem>libvirt</systemitem> recognizes two modes for handling
       PCI devices: they can be either <literal>managed</literal> or
       <literal>unmanaged</literal>. In the managed case,
       <systemitem>libvirt</systemitem> will handle all the details of
       unbinding the device from the existing driver if needed, resetting
       the device, binding it to <systemitem>vfio-pci</systemitem> before
       starting the domain, etc. When the domain is terminated or the device
       is removed from the domain, <systemitem>libvirt</systemitem> will
       unbind from <systemitem>vfio-pci</systemitem> and rebind to the
       original driver in the case of a managed device. If the device is
       unmanaged, the user must take care to ensure all of these management
       aspects of the device are done before assigning it to a domain, and
       after the device is no longer used by the domain.
      </para>
      <para>
       In the example above, the <literal>managed='yes'</literal> option
       means that the device is managed. To switch the device mode to
       unmanaged, set <literal>managed='no'</literal> in the listing above.
       If you do so, you need to take care of the related driver with the
       <command>virsh nodedev-detach</command> and <command>virsh
       nodedev-reattach</command> commands. That means you need to run
       <command>virsh nodedev-detach pci_0000_03_07_0</command> prior to
       starting the &vmguest; to detach the device from the host. In case
       the &vmguest; is not running, you can make the device available for
       the host by running <command>virsh nodedev-reattach
       pci_0000_03_07_0</command>.
      </para>
     </tip>
    </step>
    <step>
     <para>
      Shut down the &vmguest; and restart it to make the assigned PCI device
      available.
     </para>
     <tip>
      <title>&selnx;</title>
      <para>
       If you are running &selnx; on your &vmhost;, you need to disable it
       prior to starting the &vmguest; with
      </para>
<screen>setsebool -P virt_use_sysfs 1</screen>
     </tip>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.libvirt.config.io">
  <title>Adding SR-IOV Devices</title>

  <para>
   Single Root I/O Virtualization (<xref linkend="vt.io.sriov"/>) capable
   <xref linkend="gloss.vt.acronym.pcie"/> devices can replicate their
   resources, so they appear to be multiple devices. Each of these
   "pseudo-devices" can be assigned to a &vmguest;.
  </para>

  <para>
   <xref linkend="vt.io.sriov"/> is an industry specification that was
   created by the Peripheral Component Interconnect Special Interest Group
   (PCI-SIG) consortium. It introduces physical functions (PF) and virtual
   functions (VF). PFs are full <xref linkend="gloss.vt.acronym.pcie"/>
   functions used to manage and configure the device. PFs also can move
   data. VFs lack the configuration and management part&mdash;they only can
   move data and a reduced set of configuration functions. Since VFs do not
   have all <xref
   linkend="gloss.vt.acronym.pcie"/> functions, the host
   operating system or the <xref linkend="gloss.vt.hypervisor"/> must
   support <xref
   linkend="vt.io.sriov"/> to be able to access and
   initialize VFs. The theoretical maximum for VFs is 256 per device
   (consequently the maximum for a dual-port Ethernet card would be 512). In
   practice this maximum is much lower, since each VF consumes resources.
  </para>

  <sect2 xml:id="sec.libvirt.config.io.requirements">
   <title>Requirements</title>
   <para>
    The following requirements must be met to be able to use
    <xref linkend="vt.io.sriov"/>:
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>
      An <xref linkend="vt.io.sriov"/>-capable network card (as of
      &productname; &productnumber;, only network cards support
      <xref linkend="vt.io.sriov"/>)
     </para>
    </listitem>
    <listitem>
     <para>
      An &x86-64; host supporting hardware virtualization (AMD-V or Intel
      VT-x), see <xref linkend="sec.kvm.requires.hardware"/> for more
      information
     </para>
    </listitem>
    <listitem>
     <para>
      A chipset that supports device assignment (AMD-Vi or Intel
      <xref linkend="gloss.vt.acronym.vtd"/>)
     </para>
    </listitem>
    <listitem>
     <para>
      libvirt-0.9.10 or better
     </para>
    </listitem>
    <listitem>
     <para>
      <xref linkend="vt.io.sriov"/> drivers must be loaded and configured on
      the host system
     </para>
    </listitem>
    <listitem>
     <para>
      A host configuration that meets the requirements listed at
      <xref
      linkend="ann.vt.io.require"/>
     </para>
    </listitem>
    <listitem>
     <para>
      A list of the PCI addresses of the VF(s) that will be assigned to
      &vmguest;s
     </para>
    </listitem>
   </itemizedlist>
   <tip>
    <title>Checking if a Device is SR-IOV-Capable</title>
    <para>
     The information whether a device is SR-IOV-capable can be obtained from
     its PCI descriptor by running <command>lspci</command>. A device that
     supports <xref linkend="vt.io.sriov"/> reports a capability similar to
     the following:
    </para>
<screen>Capabilities: [160 v1] Single Root I/O Virtualization (<xref linkend="vt.io.sriov"/>)</screen>
   </tip>
   <note>
    <title>Adding an SR-IOV Device at &vmguest; Creation</title>
    <para>
     In case you want to add an SR-IOV device to a &vmguest; when initially
     setting it up, the &vmhost; already needs to be configured as described
     in <xref linkend="sec.libvirt.config.io.config"/>.
    </para>
   </note>
  </sect2>

  <sect2 xml:id="sec.libvirt.config.io.config">
   <title>Loading and Configuring the SR-IOV Host Drivers</title>
   <para>
    To be able to access and initialize VFs, an SR-IOV-capable driver needs
    to be loaded on the host system.
<!-- See <xref linkend="???"/> for a
    list of supported cards and theit corresponding drivers. -->
   </para>
   <procedure>
    <step>
     <para>
      Before loading the driver, make sure the card is properly detected by
      running <command>lspci</command>. The following example shows the
      <command>lspci</command> output for the dual-port Intel 82576NS
      network card:
     </para>
<screen>&prompt.user;sudo /sbin/lspci | grep 82576
01:00.0 Ethernet controller: Intel Corporation 82576NS Gigabit Network Connection (rev 01)
01:00.1 Ethernet controller: Intel Corporation 82576NS Gigabit Network Connection (rev 01)
04:00.0 Ethernet controller: Intel Corporation 82576NS Gigabit Network Connection (rev 01)
04:00.1 Ethernet controller: Intel Corporation 82576NS Gigabit Network Connection (rev 01)</screen>
     <para>
      In case the card is not detected, it is likely that the hardware
      virtualization support in the BIOS/EFI has not been enabled.
     </para>
    </step>
    <step>
     <para>
      Check whether the <xref linkend="vt.io.sriov"/> driver is already
      loaded by running <command>lsmod</command>. In the following example a
      check for the igb driver (for the Intel 82576NS network card) returns
      a result. That means the driver is already loaded. If the command
      returns nothing, the driver is not loaded.
     </para>
<screen>&prompt.user;sudo /sbin/lsmod | egrep "^igb "
igb                   185649Â  0</screen>
    </step>
    <step>
     <para>
      Skip this step if the driver is already loaded.
     </para>
     <para>
      If the <xref linkend="vt.io.sriov"/> driver is not yet loaded, the
      non-<xref linkend="vt.io.sriov"/> driver needs to be removed first,
      before loading the new driver. Use <command>rmmod</command> to unload
      a driver. The following example unloads the
      non-<xref linkend="vt.io.sriov"/> driver for the Intel 82576NS network
      card:
     </para>
<screen>sudo /sbin/rmmod igbvf</screen>
     <para>
      Load the <xref linkend="vt.io.sriov"/> driver subsequently using the
      <command>modprobe</command> command:
     </para>
<screen>sudo /sbin/modprobe igb</screen>
    </step>
    <step>
     <para>
      Configure the driver by adding the number of VFs you want to make
      available and, if necessary, by blacklisting the non-SR-IOV driver:
     </para>
<screen>sudo echo -e "options igb max_vfs=8\nblacklist igbvf" &gt;&gt; /etc/modprobe.d/50-igb/</screen>
     <para>
      Make sure to replace the example values <literal>igb</literal>,
      <literal>igbvf</literal> and <literal>50-igb</literal> by values
      appropriate for your driver.
     </para>
    </step>
    <step>
     <para>
      Now make sure the driver is loaded on boot by creating the file
      <filename>/etc/modules-load.d/igb.conf</filename> with the following
      content:
     </para>
<screen># Load the igb driver at boot
igb</screen>
     <para>
      Make sure to replace the example value <literal>igb</literal> by a
      string appropriate for your driver.
     </para>
    </step>
    <step>
     <para>
      Reboot the machine and check if the SR-IOV driver is loaded by
      re-running the <command>lspci</command> command from the first step of
      this procedure. If the SR-IOV driver was loaded successfully you
      should see additional lines for the VFs:
     </para>
<screen>01:00.0 Ethernet controller: Intel Corporation 82576NS Gigabit Network Connection (rev 01)
01:00.1 Ethernet controller: Intel Corporation 82576NS Gigabit Network Connection (rev 01)
01:10.0 Ethernet controller: Intel Corporation 82576 Virtual Function (rev 01)
01:10.1 Ethernet controller: Intel Corporation 82576 Virtual Function (rev 01)
01:10.2 Ethernet controller: Intel Corporation 82576 Virtual Function (rev 01)
[...]
04:00.0 Ethernet controller: Intel Corporation 82576NS Gigabit Network Connection (rev 01)
04:00.1 Ethernet controller: Intel Corporation 82576NS Gigabit Network Connection (rev 01)
04:10.0 Ethernet controller: Intel Corporation 82576 Virtual Function (rev 01)
04:10.1 Ethernet controller: Intel Corporation 82576 Virtual Function (rev 01)
04:10.2 Ethernet controller: Intel Corporation 82576 Virtual Function (rev 01)
[...]</screen>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="sec.libvirt.config.io.attach">
   <title>Adding a VF Network Device to an Existing &vmguest;</title>
   <para>
    When the <xref linkend="vt.io.sriov"/> hardware is properly set up on
    the &vmhost;, you can add VFs to &vmguest;s. To do so, you need to
    collect some data first.
   </para>
   <procedure>
    <para>
     Note: The following procedure is using example data. Make sure to
     replace it by appropriate data from your setup.
    </para>
    <step>
     <para>
      Use the <command>virsh nodedev-list</command> command to get the PCI
      address of the VF you want to assign and its corresponding PF.
      Numerical values from the <command>lspci</command> output shown in
      <xref linkend="sec.libvirt.config.io.config"/> (for example
      <literal>01:00.0</literal> or <literal>04:00.1</literal>) are
      transformed by adding the prefix "pci_0000_" and by replacing colons
      and dots with underscores. So a PCI ID listed as "04:00.0" by
      <command>lspci</command> is listed as "pci_0000_04_00_0" by virsh. The
      following example lists the PCI IDs for the second port of the Intel
      82576NS network card:
     </para>
<screen>&prompt.user;sudo virsh nodedev-list | grep 0000_04_
pci_0000_04_00_0
pci_0000_04_00_1
pci_0000_04_10_0
pci_0000_04_10_1
pci_0000_04_10_2
pci_0000_04_10_3
pci_0000_04_10_4
pci_0000_04_10_5
pci_0000_04_10_6
pci_0000_04_10_7
pci_0000_04_11_0
pci_0000_04_11_1
pci_0000_04_11_2
pci_0000_04_11_3
pci_0000_04_11_4
pci_0000_04_11_5</screen>
     <para>
      The first two entries represent the PFs, whereas the other entries
      represent the VFs.
     </para>
    </step>
    <step>
     <para>
      Get more data that will be needed by running the command
      <command>virsh nodedev-dumpxml</command> on the PCI ID of the VF you
      want to add:
     </para>
<screen>&prompt.user;sudo virsh nodedev-dumpxml pci_0000_04_10_0
&lt;device&gt;
  &lt;name&gt;pci_0000_04_10_0&lt;/name&gt;
  &lt;parent&gt;pci_0000_00_02_0&lt;/parent&gt;
  &lt;capability type='pci'&gt;
    &lt;domain&gt;0&lt;/domain&gt;
    &lt;bus&gt;4&lt;/bus&gt;
    &lt;slot&gt;16&lt;/slot&gt;
    &lt;function&gt;0&lt;/function&gt;
    &lt;product id='0x10ca'&gt;82576 Virtual Function&lt;/product&gt;
    &lt;vendor id='0x8086'&gt;Intel Corporation&lt;/vendor&gt;
    &lt;capability type='phys_function'&gt;
      &lt;address domain='0x0000' bus='0x04' slot='0x00' function='0x0'/&gt;
    &lt;/capability&gt;
  &lt;/capability&gt;
&lt;/device&gt;</screen>
     <para>
      The following data is needed for the next step:
     </para>
     <itemizedlist mark="bullet" spacing="normal">
      <listitem>
       <para>
        &lt;domain&gt;0&lt;/domain&gt;
       </para>
      </listitem>
      <listitem>
       <para>
        &lt;bus&gt;4&lt;/bus&gt;
       </para>
      </listitem>
      <listitem>
       <para>
        &lt;slot&gt;16&lt;/slot&gt;
       </para>
      </listitem>
      <listitem>
       <para>
        &lt;function&gt;0&lt;/function&gt;
       </para>
      </listitem>
     </itemizedlist>
    </step>
    <step>
     <para>
      Create a temporary XML file (for example
      <filename>/tmp/vf-interface.xml</filename> containing the data
      necessary to add a VF network device to an existing &vmguest;. The
      minimal content of the file needs to look like the following:
     </para>
<screen>&lt;interface type='hostdev'&gt;<co xml:id="sriov.iface"/>
 &lt;source&gt;
  &lt;address type='pci' domain='0' bus='11' slot='16' function='0'2/&gt;<co xml:id="sriov.data"/>
 &lt;/source&gt;
&lt;/interface&gt;</screen>
     <calloutlist>
      <callout arearefs="sriov.iface">
       <para>
        VFs do not get a fixed MAC address; it changes every time the host
        reboots. When adding network devices the <quote>traditional</quote>
        way with &lt;hostdev&gt;, it would require to reconfigure the
        &vmguest;'s network device after each reboot of the host, because of
        the MAC address change. To avoid this kind of problem, libvirt
        introduced the <quote>interface type='hostdev'</quote> directive,
        which sets up network-specific data <emphasis>before</emphasis>
        assigning the device.
       </para>
      </callout>
      <callout arearefs="sriov.data">
       <para>
        Specify the data you acquired in the previous step here.
       </para>
      </callout>
     </calloutlist>
    </step>
    <step>
     <para>
      In case a device is already attached to the host, it cannot be
      attached to a guest. To make it available for guests, detach it from
      the host first:
     </para>
<screen>virsh nodedev-detach pci_0000_04_10_0</screen>
    </step>
    <step>
     <para>
      Last, add the VF interface to an existing &vmguest;:
     </para>
<screen>virsh attach-device <replaceable>GUEST</replaceable> /tmp/vf-interface.xml --<replaceable>OPTION</replaceable></screen>
     <para>
      <replaceable>GUEST</replaceable> needs to be replaced by the domain
      name, id or uuid of the &vmguest; and
      --<replaceable>OPTION</replaceable> can be one of the following:
     </para>
     <variablelist>
      <varlistentry>
       <term><option>--persistent</option>
       </term>
       <listitem>
        <para>
         This option will always add the device to the domain's persistent
         XML. In addition, if the domain is running, it will be hotplugged.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><option>--config</option>
       </term>
       <listitem>
        <para>
         This option will only affect the persistent XML, even if the domain
         is running. The device will only show up in the guest on next boot.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><option>--live</option>
       </term>
       <listitem>
        <para>
         This option will only affect a running domain. If the domain is
         inactive, the operation will fail. The device is not persisted in
         the XML and will not be available in the guest on next boot.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>--current</term>
       <listitem>
        <para>
         This option affects the current state of the domain. If the domain
         is inactive, the device is added to the persistent XML and will be
         available on next boot. If the domain is active, the device is
         hotplugged but not added to the persistent XML.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
     <para>
      To detach a VF interface, use the <command>virsh
      detach-device</command> command, which also takes the options listed
      above.
     </para>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="libvirt.config.io.pool">
   <title>Dynamic Allocation of VFs from a Pool</title>
   <para>
    If you define the PCI address of a VF into a guest's configuration
    statically as described in
    <xref linkend="sec.libvirt.config.io.attach"/>, it is hard to migrate
    such guest to another host. The host must have identical hardware in the
    same location on the PCI bus, or the guest configuration must be
    modified prior to each start.
   </para>
   <para>
    Another approach is to create a &libvirt; network with a device pool
    that contains all the VFs of an <xref linkend="vt.io.sriov"/> device.
    The guest then references this network, and each time it is started, a
    single VF is dynamically allocated to it. When the guest is stopped, the
    VF is returned to the pool, available for another guest.
   </para>
   <sect3 xml:id="libvirt.config.io.pool.host">
    <title>Defining Network with Pool of VFs on &vmhost;</title>
    <para>
     The following example of network definition creates a pool of all VFs
     for the <xref linkend="vt.io.sriov"/> device with its physical function
     (PF) at the network interface eth0 on the host:
    </para>
<screen>&lt;network&gt;
  &lt;name&gt;passthrough&lt;/name&gt;
    &lt;forward mode='hostdev' managed='yes'&gt;
      &lt;pf dev='eth0'/&gt;
    &lt;/forward&gt;
  &lt;/network&gt;</screen>
    <para>
     To use this network on the host, save the above code to a file, for
     example <filename>/tmp/passthrough.xml</filename>, and execute the
     following commands. Remember to replace eth0 with the real network
     interface name of your <xref linkend="vt.io.sriov"/> device's PF:
    </para>
<screen>virsh net-define /tmp/passthrough.xml
virsh net-autostart passthrough
virsh net-start passthrough</screen>
   </sect3>
   <sect3 xml:id="libvirt.config.io.pool.guest">
    <title>Configuring &vmguest; to Use VF from the Pool</title>
    <para>
     The following example of guest device interface definition uses a VF of
     the <xref linkend="vt.io.sriov"/> device from the pool created in
     <xref linkend="libvirt.config.io.pool.host"/>. &libvirt; automatically
     derives the list of all VFs associated with that PF the first time the
     guest is started.
    </para>
<screen>&lt;interface type='network'&gt;
  &lt;source network='passthrough'&gt;
&lt;/interface&gt;</screen>
    <para>
     To verify the list of associated VFs, run <command>virsh net-dumpxml
     passthrough</command> on the host after the first guest that uses the
     network with the pool of VFs starts.
    </para>
<screen>&lt;network connections='1'&gt;
  &lt;name&gt;passthrough&lt;/name&gt;
  &lt;uuid&gt;a6a26429-d483-d4ed-3465-4436ac786437&lt;/uuid&gt;
  &lt;forward mode='hostdev' managed='yes'&gt;
    &lt;pf dev='eth0'/&gt;
    &lt;address type='pci' domain='0x0000' bus='0x02' slot='0x10' function='0x1'/&gt;
    &lt;address type='pci' domain='0x0000' bus='0x02' slot='0x10' function='0x3'/&gt;
    &lt;address type='pci' domain='0x0000' bus='0x02' slot='0x10' function='0x5'/&gt;
    &lt;address type='pci' domain='0x0000' bus='0x02' slot='0x10' function='0x7'/&gt;
    &lt;address type='pci' domain='0x0000' bus='0x02' slot='0x11' function='0x1'/&gt;
    &lt;address type='pci' domain='0x0000' bus='0x02' slot='0x11' function='0x3'/&gt;
    &lt;address type='pci' domain='0x0000' bus='0x02' slot='0x11' function='0x5'/&gt;
  &lt;/forward&gt;
  &lt;/network&gt;</screen>
   </sect3>
  </sect2>
 </sect1>
</chapter>
