<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="adm_shell.xml" version="5.0" xml:id="cha-adm-shell">

 <title>Bash e scripts Bash</title>
 <info>
  <abstract>
   <para>
    Atualmente, muitas pessoas usam computadores com uma GUI (Graphical User Interface – Interface Gráfica do Usuário), como o GNOME. As GUIs oferecem muitos recursos, mas elas são limitadas para executar tarefas automatizadas. Os shells são um bom complemento às GUIs, e este capítulo apresenta uma visão geral de alguns aspectos deles; neste caso, o shell Bash.
   </para>
  </abstract>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>

 <sect1 xml:id="sec-adm-whatistheshell">
  <title>O que é <quote>o shell</quote>?</title>



  <para>
   Normalmente, <emphasis>o</emphasis> shell do Linux é o Bash (Bourne again Shell). Quando este capítulo menciona <quote>o shell</quote>, ele se refere ao Bash. Há mais shells disponíveis (ash, csh, ksh, zsh, etc.), cada um deles empregando recursos e características diferentes. Se você precisar de mais informações sobre outros shells, pesquise por <emphasis>shell</emphasis> no YaST.
  </para>

  <sect2 xml:id="sec-adm-configfiles">
   <title>Arquivos de configuração do Bash</title>
   <para>
    Um shell pode ser acionado como:
   </para>
   <orderedlist spacing="normal">
    <listitem>
     <formalpara>
      <title>Shell de login interativo</title>
      <para>
       Esse tipo é usado para efetuar login em uma máquina, chamando o Bash com a opção <option>--login</option>, ou para efetuar login em uma máquina remota com SSH.
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Shell interativo <quote>comum</quote></title>
      <para>
       Normalmente, este é o caso ao iniciar o xterm, o konsole, o gnome-terminal ou as ferramentas semelhantes de interface de linha de comando (CLI, Command Line Interface).
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Shell não interativo</title>
      <para>
       Ele é invocado para chamar um script de shell na linha de comando.
      </para>
     </formalpara>
    </listitem>
   </orderedlist>
   <para>
    Dependendo do tipo de shell usado, outros arquivos de configuração serão lidos. As tabelas seguintes mostram os arquivos de configuração de shell de login e sem login.
   </para>
   <table xml:id="tab-adm-shell-config-loginshells">
    <title>Arquivos de configuração do Bash para shells de login</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>
        <para>
         Arquivo
        </para>
       </entry>
       <entry>
        <para>
         Descrição
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         <filename>/etc/profile</filename>
        </para>
       </entry>
       <entry>
        <para>
         Não modifique esse arquivo, senão as suas modificações poderão ser destruídas durante a próxima atualização!
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>/etc/profile.local</filename>
        </para>
       </entry>
       <entry>
        <para>
         Use esse arquivos se for estender <filename>/etc/profile</filename>
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>/etc/profile.d/</filename>
        </para>
       </entry>
       <entry>
        <para>
         Contém arquivos de configuração de programas específicos para todo o sistema
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>~/.profile</filename>
        </para>
       </entry>
       <entry>
        <para>
         Insira aqui a configuração específica de usuário para os shells de login
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Observe que o shell de login também extrai os arquivos de configuração listados na <xref linkend="tab-adm-shell-configs-nonloginshells"/>.
   </para>
   <table xml:id="tab-adm-shell-configs-nonloginshells">
    <title>Arquivos de configuração do Bash para shells sem login</title>
    <tgroup cols="2">
     <tbody>
      <row>
       <entry>
        <para>
         <filename>/etc/bash.bashrc</filename>
        </para>
       </entry>
       <entry>
        <para>
         Não modifique esse arquivo, senão as suas modificações poderão ser destruídas durante a próxima atualização!
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>/etc/bash.bashrc.local</filename>
        </para>
       </entry>
       <entry>
        <para>
         Use esse arquivo para inserir suas modificações apenas do Bash em todo o sistema
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>~/.bashrc</filename>
        </para>
       </entry>
       <entry>
        <para>
         Insira aqui a configuração específica de usuário
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Além desses, o Bash usa mais outros arquivos:
   </para>
   <table>
    <title>Arquivos especiais do Bash</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>
        <para>
         Arquivo
        </para>
       </entry>
       <entry>
        <para>
         Descrição
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         <filename>~/.bash_history</filename>
        </para>
       </entry>
       <entry>
        <para>
         Contém uma lista de todos os comandos que você digitou
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>~/.bash_logout</filename>
        </para>
       </entry>
       <entry>
        <para>
         Executado durante o logout
        </para>
       </entry>
       </row>
       <row>
       <entry>
        <para>
         <filename>~/.alias</filename>
        </para>
       </entry>
       <entry>
        <para>
         Áliases definidos pelo usuário dos comandos usados com frequência. Consulte <command>man 1 alias</command> para obter mais detalhes sobre como definir álias.
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <bridgehead>Shells sem login</bridgehead>
   <para>
    Há shells especiais que impedem que os usuários efetuem login no sistema: <systemitem>/bin/false</systemitem> e <systemitem>/sbin/nologin</systemitem>. Os dois apresentam uma falha silenciosa quando o usuário tenta efetuar login no sistema. Isso foi planejado como uma medida de segurança para os usuários do sistema, embora os sistemas operacionais Linux modernos tenham ferramentas mais eficazes para controlar o acesso ao sistema, como PAM e AppArmor.
   </para>
   <para>
    O padrão do <phrase role="productname"><phrase os="sled">SUSE Linux Enterprise Desktop</phrase></phrase> é atribuir <systemitem>/bin/bash</systemitem> a usuários humanos, e <systemitem>/bin/false</systemitem> ou <systemitem>/sbin/nologin</systemitem> a usuários de sistema. O usuário <systemitem class="username">nobody</systemitem> tem o <systemitem>/bin/bash</systemitem> por razões de histórico, já que se trata de um usuário com privilégios mínimos que costumava ser o padrão para usuários de sistema. No entanto, o pouco de segurança obtida com o uso de <systemitem class="username">nobody</systemitem> se perde quando vários usuários de sistema o utilizam. Talvez seja possível mudá-lo para <systemitem>/sbin/nologin</systemitem>. A forma mais rápida de fazer esse teste é mudá-lo e verificar se ele corrompe quaisquer serviços ou aplicativos.
   </para>
   <para>
    Use o seguinte comando para listar os shells que são atribuídos a todos os usuários, tanto de sistema quanto humanos, em <filename>/etc/passwd</filename>. A saída varia de acordo com os serviços e os usuários no sistema:
   </para>
<screen><prompt>&gt; </prompt>sort -t: -k 7 /etc/passwd | awk -F: '{print $1"\t" $7}' | column -t
tux               /bin/bash
nobody            /bin/bash
root              /bin/bash
avahi             /bin/false
chrony            /bin/false
dhcpd             /bin/false
dnsmasq           /bin/false
ftpsecure         /bin/false
lightdm           /bin/false
mysql             /bin/false
postfix           /bin/false
rtkit             /bin/false
sshd              /bin/false
tftp              /bin/false
unbound           /bin/false
bin               /sbin/nologin
daemon            /sbin/nologin
ftp               /sbin/nologin
lp                /sbin/nologin
mail              /sbin/nologin
man               /sbin/nologin
nscd              /sbin/nologin
polkitd           /sbin/nologin
pulse             /sbin/nologin
qemu              /sbin/nologin
radvd             /sbin/nologin
rpc               /sbin/nologin
statd             /sbin/nologin
svn               /sbin/nologin
systemd-coredump  /sbin/nologin
systemd-network   /sbin/nologin
systemd-timesync  /sbin/nologin
usbmux            /sbin/nologin
vnc               /sbin/nologin
wwwrun            /sbin/nologin
messagebus        /usr/bin/false
scard             /usr/sbin/nologin</screen>
  </sect2>

  <xi:include href="fs_structure_i.xml"/>
 </sect1>
 <sect1 xml:id="sec-adm-shellscripts">
  <title>Gravando scripts shell</title>

  <para>
   Os scripts shell são um modo conveniente para executar uma ampla gama de tarefas: coleta de dados, pesquisa por uma palavra ou frase em um texto e muitas outras coisas úteis. O exemplo seguinte mostra um pequeno script shell que imprime um texto:
  </para>

  <example>
   <title>Um script shell que imprime um texto</title>
<screen>#!/bin/sh <co xml:id="co-adm-shell-shebang"/>
# Output the following line: <co xml:id="co-adm-shell-comment"/>
echo "Hello World" <co xml:id="co-adm-shell-echo"/></screen>
   <calloutlist>
    <callout arearefs="co-adm-shell-shebang">
     <para>
      A primeira linha começa com os caracteres <emphasis>Shebang</emphasis> (<literal>#!</literal>) que indica que este arquivo é um script. O interpretador especificado após o <emphasis>Shebang</emphasis> executa o script. Neste caso, o interpretador especificado é <command>/bin/sh</command>.
     </para>
    </callout>
    <callout arearefs="co-adm-shell-comment">
     <para>
      A segunda linha é um comentário que começa com o sinal de hash. É recomendável comentar linhas difíceis. Com o comentário apropriado, você pode se lembrar da finalidade e da função da linha. Além disso, outros leitores poderão entender seu script. O comentário é considerado uma boa prática na comunidade de desenvolvimento.
     </para>
    </callout>
    <callout arearefs="co-adm-shell-echo">
     <para>
      A terceira linha usa o comando interno <command>echo</command> para imprimir o texto correspondente.
     </para>
    </callout>
   </calloutlist>
  </example>

  <para>
   Antes que você possa executar esse script, há alguns pré-requisitos:
  </para>

  <orderedlist spacing="normal">
   <listitem>
    <para>
     Todo script deve conter uma linha Shebang (como no exemplo acima). Se a linha estiver ausente, você precisará chamar o interpretador manualmente.
    </para>
   </listitem>
   <listitem>
    <para>
     Grave o script no lugar desejado. Contudo, convém gravá-lo em um diretório onde o shell possa encontrá-lo. O caminho de pesquisa em um shell é determinado pela variável de ambiente <envar>PATH</envar>. Um usuário normal geralmente não tem acesso de gravação em <filename>/usr/bin</filename>. Por essa razão, recomenda-se gravar seus scripts no diretório <filename>~/bin/</filename> dos usuários. O exemplo acima leva o nome <filename>hello.sh</filename>.
    </para>
   </listitem>
   <listitem>
    <para>
     O script requer permissões de executável. Defina as permissões com o seguinte comando:
    </para>
<screen><prompt>&gt; </prompt>chmod +x ~/bin/hello.sh</screen>
   </listitem>
  </orderedlist>

  <para>
   Se você atendeu a todos os pré-requisitos acima, poderá executar o script das seguintes maneiras:
  </para>

  <orderedlist spacing="normal">
   <listitem>
    <formalpara>
     <title>Como caminho absoluto</title>
     <para>
      O script pode ser executado em um caminho absoluto. No nosso caso, ele é <command>~/bin/hello.sh</command>.
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>Em todos os lugares</title>
     <para>
      Se a variável de ambiente <envar>PATH</envar> incluir o diretório no qual o script está localizado, você poderá executar o script usando o comando <command>hello.sh</command>.
     </para>
    </formalpara>
   </listitem>
  </orderedlist>
 </sect1>
 <sect1 xml:id="sec-adm-shell-redirect">
  <title>Redirecionando eventos de comando</title>

  <para>
   Cada comando pode usar três canais, seja para entrada ou para saída:
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <formalpara>
     <title>Saída padrão</title>
     <para>
      Esse é o canal de saída padrão. Sempre que um comando imprime algo, ele usa o canal de saída padrão.
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>Entrada padrão</title>
     <para>
      Se um comando precisar da entrada dos usuários ou de outros comandos, ele usará esse canal.
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>Erro padrão</title>
     <para>
      Os comandos usam esse canal para gerar relatórios de erros.
     </para>
    </formalpara>
   </listitem>
  </itemizedlist>

  <para>
   Para redirecionar os canais, as possibilidades são as seguintes:
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>Comando &gt; Arquivo</literal>
    </term>
    <listitem>
     <para>
      Grava a saída do comando em um arquivo, apagando um arquivo existente. Por exemplo, o comando <command>ls</command> grava sua saída no arquivo <filename>listing.txt</filename>:
     </para>
<screen><prompt>&gt; </prompt>ls &gt; listing.txt</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>Comando &gt;&gt; Arquivo</literal>
    </term>
    <listitem>
     <para>
      Anexa a saída do comando a um arquivo. Por exemplo, o comando <command>ls</command> anexa sua saída ao arquivo <filename>listing.txt</filename>:
     </para>
<screen><prompt>&gt; </prompt>ls &gt;&gt; listing.txt</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>Comando &lt; Arquivo</literal>
    </term>
    <listitem>
     <para>
      Lê o arquivo como entrada do comando em questão. Por exemplo, o comando <command>read</command> extrai o conteúdo do arquivo para a variável:
     </para>
<screen><prompt>&gt; </prompt>read a &lt; foo</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>Comando1 | Comando2</literal>
    </term>
    <listitem>
     <para>
      Redireciona a saída do comando à esquerda como entrada para o comando à direita. Por exemplo, o comando <command>cat</command> gera a saída do conteúdo do arquivo <filename>/proc/cpuinfo</filename>. Essa saída é usada por <command>grep</command> para filtrar apenas as linhas que contêm <literal>cpu</literal>:
     </para>
<screen><prompt>&gt; </prompt>cat /proc/cpuinfo | grep cpu</screen>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Cada canal possui um <emphasis>descritor de arquivo</emphasis>: 0 (zero) para entrada padrão, 1 para saída padrão e 2 para erro padrão. É permitido inserir esse descritor de arquivo antes de um caractere <literal>&lt;</literal> ou <literal>&gt;</literal>. Por exemplo, a linha a seguir procura por um arquivo que começa com <filename>foo</filename>, mas suprime seus erros redirecionando-o para <filename>/dev/null</filename>:
  </para>

<screen><prompt>&gt; </prompt>find / -name "foo*" 2&gt;/dev/null</screen>
 </sect1>
 <sect1 xml:id="sec-adm-alias">
  <title>Usando álias</title>

  <para>
   Um álias é uma definição de atalho de um ou mais comandos. A sintaxe de um álias é a seguinte:
  </para>

<screen>alias <replaceable>NAME</replaceable>=<replaceable>DEFINITION</replaceable></screen>

  <para>
   Por exemplo, a linha a seguir define um álias <command>lt</command> que gera uma listagem extensa (opção <option>-l</option>), classifica-a por horário de modificação (<option>-t</option>) e imprime-a em ordem inversa de classificação (<option>&#x2011;r</option>):
  </para>

<screen><prompt>&gt; </prompt>alias lt='ls -ltr'</screen>

  <para>
   Para ver todas as definições de álias, use <command>alias</command> Remova o seu álias com <command>unalias</command> e o nome de álias correspondente.
  </para>
 </sect1>
 <sect1 xml:id="sec-adm-variables">
  <title>Usando variáveis no Bash</title>

  <para>
   Uma variável de shell pode ser global ou local. Variáveis globais, ou de ambiente, podem ser acessadas em todos os shells. As variáveis locais, ao contrário, são visíveis apenas no shell atual.
  </para>

  <para>
   Para ver todas as variáveis de ambiente, use o comando <command>printenv</command>. Se for preciso saber o valor de uma variável, insira o nome da variável como argumento:
  </para>

<screen><prompt>&gt; </prompt>printenv PATH</screen>

  <para>
   Uma variável, seja ela global ou local, também pode ser visualizada com <command>echo</command>:
  </para>

<screen><prompt>&gt; </prompt>echo $PATH</screen>

  <para>
   Para definir uma variável local, use um nome de variável, seguido pelo sinal de igual, seguido pelo valor:
  </para>

<screen><prompt>&gt; </prompt>PROJECT="SLED"</screen>

  <para>
   Não insira espaços antes e depois do sinal de igual, senão você obterá um erro. Para definir uma variável de ambiente, use <command>export</command>:
  </para>

<screen><prompt>&gt; </prompt>export NAME="tux"</screen>

  <para>
   Para remover uma variável, use <command>unset</command>:
  </para>

<screen><prompt>&gt; </prompt>unset NAME</screen>

  <para>
   A tabela a seguir contém algumas variáveis de ambiente comuns que podem ser usadas nos seus scripts shell:
  </para>

  <table xml:id="tab-adm-envars">
   <title>Variáveis de ambiente úteis</title>
   <tgroup cols="2">
    <tbody>
     <row>
      <entry>
       <para>
        <envar>HOME</envar>
       </para>
      </entry>
      <entry>
       <para>
        diretório pessoal do usuário atual
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>HOST</envar>
       </para>
      </entry>
      <entry>
       <para>
        nome do host atual
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>LANG</envar>
       </para>
      </entry>
      <entry>
       <para>
        quando uma ferramenta é localizada, ela usa o idioma dessa variável de ambiente. Também é possível definir o idioma inglês como <literal>C</literal>
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>PATH</envar>
       </para>
      </entry>
      <entry>
       <para>
        caminho de pesquisa do shell, uma lista de diretórios separados por dois-pontos
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>PS1</envar>
       </para>
      </entry>
      <entry>
       <para>
        especifica o prompt normal impresso antes de cada comando
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>PS2</envar>
       </para>
      </entry>
      <entry>
       <para>
        especifica o prompt secundário impresso quando você executa um comando em várias linhas
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>PWD</envar>
       </para>
      </entry>
      <entry>
       <para>
        diretório de trabalho atual
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>USUÁRIO</envar>
       </para>
      </entry>
      <entry>
       <para>
        usuário atual
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <sect2 xml:id="sec-adm-variables-argument">
   <title>Usando variáveis de argumento</title>

   <para>
    Por exemplo, se você tiver o script <command>foo.sh</command>, poderá executá-lo desta maneira:
   </para>
<screen><prompt>&gt; </prompt>foo.sh "Tux Penguin" 2000 </screen>
   <para>
    Para acessar todos os argumentos que são passados ao seu script, você precisa de parâmetros de posição. Isto é, <envar>$1</envar> para o primeiro argumento, <envar>$2</envar> para o segundo e assim sucessivamente. É possível usar até nove parâmetros. Para obter o nome do script, use <envar>$0</envar>.
   </para>
   <para>
    O script <command>foo.sh</command> a seguir imprime todos os argumentos de 1 a 4:
   </para>
<screen>#!/bin/sh
echo \"$1\" \"$2\" \"$3\" \"$4\"</screen>
   <para>
    Se você executar esse script com os argumentos acima, obterá:
   </para>
<screen>"Tux Penguin" "2000" "" ""</screen>

  </sect2>

  <sect2 xml:id="sec-adm-shell-varsubst">
   <title>Usando substituição de variável</title>
   <para>
    As substituições de variáveis aplicam um padrão ao conteúdo de uma variável, seja da esquerda ou da esquerda. A lista a seguir contém as formas de sintaxe possíveis:
   </para>
   <variablelist>
    <varlistentry>
     <term><literal>${VAR#padrão}</literal>
     </term>
     <listitem>
      <para>
       remove a correspondência mais curta possível da esquerda:
      </para>
<screen><prompt>&gt; </prompt>file=/home/tux/book/book.tar.bz2
<prompt>&gt; </prompt>echo ${file#*/}
home/tux/book/book.tar.bz2</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>${VAR##padrão}</literal>
     </term>
     <listitem>
      <para>
       remove a correspondência mais longa possível da esquerda:
      </para>
<screen><prompt>&gt; </prompt>file=/home/tux/book/book.tar.bz2
<prompt>&gt; </prompt>echo ${file##*/}
book.tar.bz2</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>${VAR%padrão}</literal>
     </term>
     <listitem>
      <para>
       remove a correspondência mais curta possível da direita:
      </para>
<screen><prompt>&gt; </prompt>file=/home/tux/book/book.tar.bz2
<prompt>&gt; </prompt>echo ${file%.*}
/home/tux/book/book.tar</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>${VAR%%padrão}</literal>
     </term>
     <listitem>
      <para>
       remove a correspondência mais longa possível da direita:
      </para>
<screen><prompt>&gt; </prompt>file=/home/tux/book/book.tar.bz2
<prompt>&gt; </prompt>echo ${file%%.*}
/home/tux/book/book</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>${VAR/padrão_1/padrão_2}</literal>
     </term>
     <listitem>
      <para>
       substitui o conteúdo de <replaceable>VAR</replaceable> do <replaceable>PADRÃO_1</replaceable> pelo do <replaceable>PADRÃO_2</replaceable>:
      </para>
<screen><prompt>&gt; </prompt>file=/home/tux/book/book.tar.bz2
<prompt>&gt; </prompt>echo ${file/tux/wilber}
/home/wilber/book/book.tar.bz2</screen>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>
 </sect1>
 <sect1 xml:id="sec-adm-shell-grouping">
  <title>Agrupando e combinando comandos</title>

  <para>
   Os shells permitem concatenar e agrupar comandos para uma execução condicional. Cada comando retorna um código de saída que determina o sucesso ou a falha de sua operação. Se o código for 0 (zero), significa que o comando obteve sucesso. Todos os outros códigos significam erro específico do comando.
  </para>

  <para>
   A lista a seguir mostra como os comandos podem ser agrupados:
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>Comando1 ; Comando2</literal>
    </term>
    <listitem>
     <para>
      executa os comandos em sequência. O código de saída não é verificado. A linha a seguir exibe o conteúdo do arquivo com <command>cat</command> e depois imprime suas propriedades com <command>ls</command>, independentemente dos códigos de erro:
     </para>
<screen><prompt>&gt; </prompt>cat filelist.txt ; ls -l filelist.txt</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>Comando1 &amp;&amp; Comando2</literal>
    </term>
    <listitem>
     <para>
      executa o comando à direita quando o comando à esquerda for bem-sucedido (E lógico). A linha a seguir exibe o conteúdo do arquivo e imprime suas propriedades apenas quando o comando anterior obtiver sucesso (compare com a entrada anterior nesta lista):
     </para>
<screen><prompt>&gt; </prompt>cat filelist.txt &amp;&amp; ls -l filelist.txt</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>Comando1 || Comando2</literal>
    </term>
    <listitem>
     <para>
      executa o comando à direita quando o comando da esquerda falhar (OU lógico). A linha a seguir cria um diretório em <filename>/home/wilber/bar</filename> apenas quando a criação do diretório em <filename>/home/tux/foo</filename> falhar:
     </para>
<screen><prompt>&gt; </prompt>mkdir /home/tux/foo || mkdir /home/wilber/bar</screen>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>nome_da_função(){ ... }</literal>
    </term>
    <listitem>
     <para>
      cria uma função shell. Você pode usar os parâmetros de posição para acessar seus argumentos. A linha a seguir define a função <literal>hello</literal> para imprimir uma mensagem curta:
     </para>
<screen><prompt>&gt; </prompt>hello() { echo "Hello $1"; }</screen>
     <para>
      Você pode chamar essa função assim:
     </para>
<screen><prompt>&gt; </prompt>hello Tux</screen>
     <para>
      que imprimirá:
     </para>
<screen>Hello Tux</screen>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 xml:id="sec-adm-shell-commonconstructs">
  <title>Trabalhando com construções de fluxo comuns</title>

  <para>
   Para controlar o fluxo do seu script, um shell possui as construções <command>while</command>, <command>if</command>, <command>for</command> e <command>case</command>.
  </para>



  <sect2 xml:id="sec-adm-shell-if">
   <title>Comando de controle if</title>
   <para>
    O comando <command>if</command> é usado para verificar expressões. Por exemplo, o código a seguir testa se o usuário atual é Tux:
   </para>
<screen>if test $USER = "tux"; then
  echo "Hello Tux."
else
  echo "You are not Tux."
fi</screen>
   <para>
    A expressão de teste pode ser tão complexa ou simples quanto possível. a expressão a seguir verifica se o arquivo <filename>foo.txt</filename> existe:
   </para>
<screen>if test -e /tmp/foo.txt ; then
  echo "Found foo.txt"
fi</screen>
   <para>
    A expressão de teste também pode ser abreviada entre colchetes:
   </para>
<screen>if [ -e /tmp/foo.txt ] ; then
  echo "Found foo.txt"
fi</screen>
   <para>
    Outras expressões úteis estão disponíveis em <link xlink:href="https://bash.cyberciti.biz/guide/If..else..fi"/>.
   </para>
  </sect2>

  <sect2 xml:id="sec-adm-shell-for">
   <title>Criando loops com o comando <command>for</command></title>
   <para>
    O loop <command>for</command> permite executar comandos para uma lista de entradas. Por exemplo, o código a seguir imprime algumas informações sobre arquivos PNG no diretório atual:
   </para>
<screen>for i in *.png; do
 ls -l $i
done</screen>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-adm-shell-moreinfo">
  <title>Mais informações</title>

  <para>
   Informações importantes sobre o Bash são fornecidas nas páginas de manual <command>man bash</command>. Mais informações sobre este tópico estão disponíveis na lista a seguir:
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     <link xlink:href="http://tldp.org/LDP/Bash-Beginners-Guide/html/index.html"/> — Bash Guide for Beginners (Guia do Bash para Iniciantes)
    </para>
   </listitem>
   <listitem>
    <para>
     <link xlink:href="http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html"/> — BASH Programming - Introduction HOW-TO (COMO FAZER Programação de Bash: Introdução)
    </para>
   </listitem>
   <listitem>
    <para>
     <link xlink:href="http://tldp.org/LDP/abs/html/index.html"/> — Advanced Bash-Scripting Guide (Guia Avançado de Criação de Scripts Bash)
    </para>
   </listitem>
   <listitem>
    <para>
     <link xlink:href="http://www.grymoire.com/Unix/Sh.html"/> — Sh - the Bourne Shell (Sh: o Bourne Shell)
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
</chapter>
