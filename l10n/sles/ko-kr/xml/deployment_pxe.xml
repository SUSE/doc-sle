<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="deployment_pxe.xml" version="5.0" role="General" xml:id="cha-deployment-prep-pxe">
 <title>네트워크 부팅 환경 준비</title>
 <info>
  <abstract>
   <para>
    이 장에서는 PXE로 부팅하는 데 필요한 인프라를 제공하는 DHCP 및 TFTP 서버를 구성하는 방법에 대해 설명합니다.
   </para>
  </abstract>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>

 <para>
  <phrase role="productname"><phrase os="sles">SUSE® Linux Enterprise Server</phrase></phrase>는 PXE(프리부팅 실행 환경)를 통해 설치할 수 있습니다. 클라이언트 하드웨어는 PXE를 통한 부팅을 지원해야 합니다. 네트워크는 필요한 데이터를 클라이언트에 제공하는 DHCP 서버 및 TFTP 서버를 제공해야 합니다. 이 장에서는 필요한 서버 설정에 대해 안내합니다.
 </para>
 <para>
  PXE는 커널 및 initrd만 부팅합니다. 설치 환경 또는 라이브 시스템으로 부팅하는 데 사용할 수 있습니다. 설치 소스를 설정하려면 <xref linkend="cha-deployment-instserver"/> 항목을 참조하십시오.
 </para>
 <para>
  이 절에서는 복잡한 부팅 시나리오에 필요한 구성 작업에 대해 다룹니다. 여기에는 DHCP, PXE 부팅, TFTP 및 WOL(Wake On Lan)에 즉시 적용 가능한 구성 예가 포함됩니다.
 </para>
 <para>
  이 예에서는 DHCP, TFTP 및 NFS 서버가 <literal>192.168.1.1</literal>이라는 IP로 동일한 시스템에 상주한다고 가정합니다. 모든 서비스는 문제 없이 다양한 시스템에 상주할 수 있습니다. 필요한 경우 IP 주소를 변경하십시오.
 </para>

 <sect1 xml:id="sec-deployment-dhcp-server">
  <title>DHCP 서버 설정</title>
  <para>
   DHCP 서버는 네트워크 클라이언트에 동적(<xref linkend="sec-deployment-dhcp-dynamic"/>) 및 고정 IP 주소를 할당(<xref linkend="sec-deployment-dhcp-static"/>)합니다. 그리고 서버, 경로 및 도메인을 통지합니다. TFTP 서버의 경우, DHCP는 커널 및 initrd 파일도 제공합니다. 로드해야 할 파일은 대상 시스템의 아키텍처 및 레거시 BIOS 또는 UEFI 부팅 중 무엇을 사용할지에 따라 다릅니다. 클라이언트는 DHCP 요청에서 아키텍처 유형을 전송합니다. 이 정보를 기반으로 DHCP 서버는 클라이언트가 부팅에 다운로드해야 할 파일을 결정합니다.
  </para>
  <warning>
   <title>PXE 및 AutoYaST 설치 실패</title>
   <para>
    SUSE Linux Enterprise 15.0부터, PXE 부팅 및 AutoYaST 설치가 실패하는 특수한 조건이 있습니다. 자세한 내용 및 해결 방법은 <xref linkend="sec-deployment-dhcp-rfc4361"/>에서 제공됩니다.
   </para>
  </warning>

  <sect2 xml:id="sec-deployment-dhcp-dynamic">
   <title>동적 주소 할당</title>
   <para>
    다음 예는 클라이언트에 IP 주소를 동적으로 할당하고 서버, 경로, 도메인 및 부팅 파일을 통지하는 DHCP 서버의 설정 방법을 보여줍니다.
   </para>
   <procedure xml:id="pro-deployment-dhcp-server">
    <step>
     <para>
      DHCP 서버를 호스팅하는 시스템에 <systemitem class="username">root</systemitem>로 로그인합니다.
     </para>
    </step>
    <step>
     <para>
      <command>systemctl enable dhcpd</command>를 실행하여 DHCP 서버를 활성화합니다.
     </para>
    </step>
    <step>
     <para>
      <filename>/etc/dhcpd.conf</filename>에 있는 DHCP 서버 구성 파일의 서브넷 구성에 다음 행을 추가합니다.
     </para>
<screen># The following lines are optional
option domain-name "my.lab";
option domain-name-servers 192.168.1.1;
option routers 192.168.1.1;
option ntp-servers 192.168.1.1;
ddns-update-style none;
default-lease-time 3600;

# The following lines are required
option arch code 93 = unsigned integer 16; # RFC4578
subnet 192.168.1.0 netmask 255.255.255.0 {
 next-server 192.168.1.1;
 range 192.168.1.100 192.168.1.199;
 default-lease-time 3600;
 max-lease-time 3600;
 if option arch = 00:07 or option arch = 00:09 {
   filename "/EFI/x86/grub.efi";
 }
 else if option arch = 00:0b {
   filename "/EFI/aarch64/bootaa64.efi";
 }
 else  {
   filename "/BIOS/x86/pxelinux.0";
 }
}</screen>
     <para>
      구성 예에서는 IP가 <literal>192.168.1.1</literal>인 서버에 DHCP, DNS 및 게이트웨이가 있는 <literal>192.168.1.0/24</literal> 서브넷을 사용합니다. 모든 IP 주소가 네트워크 레이아웃에 따라 변경되었는지 확인하십시오. <filename></filename>에서 사용할 수 있는 옵션에 대한 자세한 내용은 <systemitem>dhcpd.conf</systemitem>dhcpd.conf 매뉴얼 페이지를 참조하십시오.
     </para>
    </step>
    <step>
     <para>
      <command>systemctl restart dhcpd</command>를 실행하여 DHCP 서버를 다시 시작합니다.
     </para>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="sec-deployment-dhcp-static">
   <title>고정 IP 주소 할당</title>
   <para>
    DHCP 서버는 네트워크 클라이언트에 고정 IP 주소 및 호스트 이름도 할당할 수 있습니다. 한 가지 사용 사례는 고정 주소를 서버에 할당하는 것입니다. 다른 사용 사례는 고정 IP 주소가 할당된 네트워크에 참여할 수 있는 클라이언트를 제한하고 동적 주소 풀을 제공하지 않는 것입니다.
  </para>
  <para>
    다음 예에 따라 위의 DHCP 구성을 수정하십시오.
   </para>
<screen>group {
 host test {
   hardware ethernet <replaceable>MAC_ADDRESS</replaceable>;
   fixed-address <replaceable>IP_ADDRESS</replaceable>;
   }
}
</screen>
   <para>
    호스트 설명은 호스트 이름을 설치 대상에 할당합니다. 특정 호스트에 호스트 이름과 IP 주소를 바인딩하려면 클라이언트의 하드웨어(MAC) 주소를 지정해야 합니다. 이 예에서 사용되는 모든 변수를 사용 중인 환경의 실제 값으로 바꾼 후 변경 사항을 저장하고 DHCP 서버를 다시 시작합니다.
   </para>
  </sect2>

  <sect2 xml:id="sec-deployment-dhcp-rfc4361">
   <title>PXE 및 AutoYaST 설치 실패</title>
   <para>
    SUSE Linux Enterprise 15.0 및 ISC DHCP 4.3.x부터는 PXE 부팅 및 AutoYaST 설치가 실패하는 특수한 환경이 있습니다. DHCP 서버에 사용할 수 있는 동적 IP 주소 풀이 없지만 클라이언트당 미리 정의된 고정 주소만 허용되고 클라이언트가 RFC 4361 클라이언트 식별자를 전송하는 경우에는 PXE/AutoYaST 설치가 작동하지 않습니다 (특정 네트워크 클라이언트에 할당된 주소만 허용하고 동적 주소 풀을 제공하지 않으면 무작위 시스템이 네트워크에 참여할 수 없음).
   </para>
   <para>
    새 시스템이 PXE에서 시작되면 DHCP 서버로 요청을 전송하고 하드웨어 유형에서 구성된 클라이언트 식별자 및 네트워크 인터페이스의 MAC 주소를 사용하여 자체 시스템을 식별할 수 있습니다. 이는 RFC 2132 <literal>클라이언트 Id</literal>입니다. 그러면 DHCP 서버가 할당된 IP 주소를 제공합니다. 그리고 설치 커널이 로드되고 다른 DHCP 요청을 전송하지만, 이 <literal>클라이언트 ID</literal>는 다르며 RFC 4361 형식으로 전송됩니다. DHCP 서버는 이를 동일한 클라이언트로 인식하고 사용할 수 있는 동적 IP 주소를 검색하지만 사용할 수 없어 설치가 중단됩니다.
   </para>
   <para>
    해결 방법은 클라이언트가 RFC 2132 클라이언트 ID를 전송하도록 구성하는 것입니다. 설치 중에 RFC 2132 <literal>클라이언트 ID</literal>를 전송하려면, <literal>linuxrc</literal>를 사용하여 다음 <literal>ifcfg</literal> 명령을 전달합니다.
   </para>
<screen>ifcfg=eth0=dhcp,DHCLIENT_CLIENT_ID=<replaceable>01:03:52:54:00:02:c2:67</replaceable>,
DHCLIENT6_CLIENT_ID=<replaceable>00:03:52:54:00:02:c2:67</replaceable></screen>
   <para>
    이더넷에서 기존에 사용하던 RFC 2132 DHCPv4 <literal>클라이언트 ID</literal>는 하드웨어 유형(이더넷의 경우 <literal>01</literal>)으로 구성되고 다음에 하드웨어 주소(MAC 주소)가 옵니다. 그러한 예는 다음과 같습니다.
   </para>
<screen>01:52:54:00:02:c2:67</screen>
   <para>
    RFC 4361 DHCPv4 <literal>클라이언트 ID</literal>는 네트워크 인터페이스가 두 개 이상인 시스템을 식별하여 문제를 해결합니다. 새로운 DHCPv4 <literal>클라이언트 ID</literal>는 DHCPv6 <literal>클라이언트 ID</literal>와 형식이 동일합니다. 그리고 하드웨어 유형이 아닌 <literal>0xff</literal> 접두어로 시작하여 DHCPv6 IAID(시스템에서 인터페이스를 설명하는 인터페이스-주소 연결 ID) 및 시스템을 고유하게 식별하는 DHCPv6 고유 식별자(DUID)가 순서대로 뒤에 추가됩니다.
   </para>
   <para>
    위와 같은 하드웨어 유형 기반 및 하드웨어 주소 기반 DUID를 사용하는 새로운 RFC 4361 DHCPv4 <literal>클라이언트 ID</literal>는 다음과 같습니다.
   </para>
   <itemizedlist>
    <listitem>
     <para>
      MAC 주소의 마지막 바이트를 IAID로 사용: <literal>ff:00:02:c2:67:00:01:xx:xx:xx:xx:52:54:00:02:c2:67</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      IAID가 단순히 증가하는 숫자인 경우: <literal>ff:00:00:00:01:00:01:xx:xx:xx:xx:52:54:00:02:c2:67</literal>
     </para>
    </listitem>
   </itemizedlist>
   <para>
    DUID-LLT(DUID-Link-Layer Timestamp)의 <replaceable>xx:xx:xx:xx</replaceable> 필드는 생성 시간 스탬프입니다. DUID-LL(DUID-Link-Layer)(<literal>00:03:00:01:$MAC</literal>)에는 시간 스탬프가 없습니다.
   </para>
   <para>
    <literal>linuxrc</literal> 사용과 관련한 자세한 내용은 <citetitle>AutoYaST 안내서</citetitle>를 참조하십시오. <literal>man 4 initrd</literal> 및 <literal>dhcp4 &quot;create-cid&quot;</literal>, <literal>dhcp6 &quot;default-duid&quot;</literal> in <literal>man 5 wicked-config</literal>, <literal>wicked duid --help</literal>, <literal>wicked iaid --help</literal> 옵션에 대한 문서도 참조하십시오.
   </para>
  </sect2>
 </sect1>

 <sect1 xml:id="sec-deployment-tftp-server">
  <title>TFTP 서버 설정</title>
  <para>
   다음 절차는 서버를 준비하여 UEFI 및 BIOS가 포함된 클라이언트 시스템을 TFTP로 엑스포트된 파일을 사용하여 원격으로 부팅하는 방법을 설명합니다.
  </para>
  <sect2 xml:id="sec-deployment-tftp-server-install">
   <title>TFTP 서버 설치</title>
   <para>
    TFTP 서버를 설치하려면 다음 절차를 사용하십시오.
   </para>

   <procedure>
    <step>
     <para>
      <systemitem>tftp</systemitem> 패키지를 설치합니다.
     </para>
     <screen><prompt>&gt; </prompt><command>sudo</command> <command>zypper in tftp</command></screen>
    </step>
    <step>
     <para>
      <systemitem class="daemon">tftpd</systemitem>/etc/sysconfig/tftp<filename>에서 </filename> 구성을 검토하고 필요에 따라 옵션을 추가하거나 변경합니다. 자세한 내용은 <command>man 8 tftpd</command>를 참조하십시오. TFTP 데몬은 구성을 변경하지 않고 작동합니다. 파일의 기본 루트 디렉토리는 <filename>/srv/tftpboot</filename>입니다.
     </para>
    </step>
    <step>
     <para>
      <systemitem class="daemon">tftpd</systemitem>가 부팅 시간에 시작되는지 확인하고 다시 시작하여 새 구성을 읽습니다.
     </para>
     <screen><prompt>&gt; </prompt><command>sudo</command> <command>systemctl enable tftp.socket</command>
<prompt>&gt; </prompt><command>sudo</command> <command>systemctl restart tftp.socket</command></screen>
    </step>
   </procedure>
  </sect2>
  <sect2 xml:id="sec-deployment-tftp-server-grub-package">
   <title>부팅용 파일 설치</title>
   <para>
    <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase>는 BIOS의 PXE 또는 UEFI 시스템을 통해 부팅에 필요한 파일을 제공합니다. 지원되는 하드웨어 아키텍처는 다음과 같습니다.
   </para>

   <itemizedlist>
    <listitem>
     <para>
      AMD64/Intel 64
     </para>
    </listitem>
    <listitem>
     <para>
      AArch64
     </para>
    </listitem>
    <listitem>
     <para>
      POWER
     </para>
    </listitem>
    <listitem>
     <para>
      IBM Z
     </para>
    </listitem>
   </itemizedlist>

   <para>
    특정 하드웨어 아키텍처에서 부팅하기 위해 필요한 파일은 RPM 패키지에 포함되어 있습니다. TFTP 서버를 실행하는 시스템에 이 패키지를 설치합니다.
   </para>
   <screen><prompt>&gt; </prompt><command>sudo</command> <command>zypper in tftpboot-installation-SLE-<replaceable>OS_VERSION</replaceable>-<replaceable>ARCHITECTURE</replaceable></command></screen>
   <para>
    <replaceable>OS_VERSION</replaceable>을 <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 설치 버전 번호(예: <replaceable>SLE-15-SP3-x86_64</replaceable>)로 바꿉니다. 그리고 <replaceable>ARCHITECTURE</replaceable>를 시스템의 아키텍처(예: <literal>x86_64</literal>)로 바꿉니다. 따라서 결과로 생성되는 텍스트는 다음과 같습니다. <package>tftpboot-installation-SLE-15-SP3-x86_64</package> <command>zypper se tftpboot</command>를 사용하여 사용 가능한 모든 버전과 아키텍처를 검색합니다.
   </para>
   <para>
    파일은 <filename>/srv/tftpboot/SLE-<replaceable>OS_VERSION</replaceable>-<replaceable>ARCHITECTURE</replaceable></filename>에 설치됩니다. <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase>의 다른 버전 및 아키텍처에 대한 파일을 <filename>/srv/tftpboot</filename> 디렉토리에 복사할 수도 있습니다.
   </para>
   <tip>
    <title>다른 아키텍처 제공</title>
    <para>
     클라이언트 및 서버 하드웨어 아키텍처는 다를 수 있습니다. 예를 들어, AMD64/Intel 64 TFTP 서버를 실행하고 <package>tftpboot-installation-SLE-15-SP3-aarch64</package> 패키지를 설치하여 AArch64 클라이언트 시스템의 부팅 환경을 제공할 수 있습니다.
    </para>
   </tip>
   <note>
    <title>기존 <filename>/srv/tftpboot/</filename> 디렉토리</title>
    <para>
     <filename>/srv/tftpboot/</filename> 디렉토리가 시스템에 이미 있는 경우 모든 파일이 <filename>/usr/share/tftpboot-installation/</filename>에 설치됩니다. 이전 SLES 릴리스에서 PXE 서버를 업그레이드하는 경우 이에 해당합니다.
    </para>
    <para>
     이 문제를 해결하려면 <filename>/usr/share/tftpboot-installation/</filename>에서 <filename>/srv/tftpboot/</filename>로 파일을 직접 복사하십시오. 또는 <filename>/srv/tftpboot/</filename>를 제거하고 <package>tftpboot-installation-SLE-<replaceable>OS_VERSION</replaceable>-<replaceable>ARCHITECTURE</replaceable></package> 패키지를 다시 설치합니다.
    </para>
   </note>
  </sect2>
  <sect2 xml:id="sec-deployment-tftp-server-pxelinux">
   <title>PXELINUX 구성</title>
   <para>
    편집기에서 <filename>/srv/tftpboot/SLE-<replaceable>OS_VERSION</replaceable>-<replaceable>ARCHITECTURE</replaceable>/net/pxelinux.cfg/default</filename> 파일을 엽니다. <xref linkend="cha-deployment-instserver"/>에 설명된 대로 설정에 따라 <literal>install</literal> 파라미터의 경로를 바꿉니다 . 또한 <replaceable>TFTP_SERVER</replaceable>도 TFTP 서버의 IP 주소로 바꿉니다. PXELINUX 구성 옵션의 개요는 <xref linkend="sec-deployment-prep-boot-pxeopts"/> 항목을 참조하십시오.
   </para>
<screen>default linux

# install
label linux
  ipappend 2
  kernel boot/<replaceable>ARCHITECTURE</replaceable>/loader/linux
  append initrd=boot/<replaceable>ARCHITECTURE</replaceable>/loader/initrd instsys=tftp://<replaceable>TFTP_SERVER</replaceable>/SLE-<replaceable>OS_VERSION</replaceable>-<replaceable>ARCHITECTURE</replaceable>/boot/<replaceable>ARCHITECTURE</replaceable>/root install=<replaceable>PROTOCOL</replaceable>://<replaceable>SERVER_IP</replaceable>:/<replaceable>PATH</replaceable>

display  message
implicit 1
prompt  1
timeout  50</screen>
   <para>
    <literal>append</literal> 줄에서 사용되는 부팅 파라미터에 대한 자세한 내용은 <xref linkend="sec-boot-parameters-list"/> 항목을 참조하십시오.
   </para>
   <para>
    필요한 경우 <filename>/srv/tftpboot/SLE-<replaceable>OS_VERSION</replaceable>-<replaceable>ARCHITECTURE</replaceable>/net/pxelinux.cfg/message</filename>를 편집하여 [부팅] 메뉴에 메시지를 표시합니다.
   </para>
  </sect2>
  <sect2 xml:id="sec-deployment-tftp-server-efilinux-x86">
   <title>GRUB2를 사용하여 EFI의 PXE 부팅 준비</title>
   <para>
     일반적으로 GRUB2 구성 파일은 수정할 필요가 없습니다. 하지만 기본 설정은 설치 시스템용 네트워크 리소스를 포함하지 않습니다. 네트워크를 통해 전체 <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 설치를 수행하려면 <filename>/srv/tftpboot/SLE-<replaceable>OS_VERSION</replaceable>-<replaceable>ARCHITECTURE</replaceable>/EFI/BOOT/grub.cfg</filename> 파일의 <option>linuxefi</option> 명령문에 <option>install</option> 파라미터를 지정해야 합니다. <option>install</option> 파라미터에 대한 자세한 내용은 <xref linkend="sec-boot-parameters-list-install-source"/>를 참조하십시오.
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-deployment-prep-boot-pxeopts">
  <title>PXELINUX 구성 옵션</title>

  <para>
   여기에 나열된 옵션은 PXELINUX 구성 파일에 사용할 수 있는 모든 옵션의 하위 집합입니다.
  </para>

  <variablelist>
   <varlistentry>
    <term><option>APPEND <replaceable>OPTIONS</replaceable></option>
    </term>
    <listitem>
     <para>
      하나 이상의 옵션을 커널 명령 줄에 추가합니다. 이 옵션은 자동 부팅과 수동 부팅 모두에 추가됩니다. 옵션은 커널 명령의 맨 처음에 추가되고, 명시적으로 입력된 커널 옵션을 무효화하도록 일반적으로 허용됩니다.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><option>APPEND -</option>
    </term>
    <listitem>
     <para>
      아무 것도 추가하지 않습니다. <option>LABEL</option> 섹션에서 인수로 단일 하이픈이 있는 <option>APPEND</option>는 전역 <option>APPEND</option>를 무효화하는 데 사용할 수 있습니다.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><option>DEFAULT <replaceable>KERNEL_OPTIONS</replaceable>...</option>
    </term>
    <listitem>
     <para>
      기본 커널 명령줄을 설정합니다. PXELINUX가 자동으로 부팅되면 자동 옵션이 자동으로 추가되어 자동 부팅을 나타내는 것을 제외하고, DEFAULT 이후의 항목이 부팅 프롬프트 시 입력된 것처럼 작동합니다.
     </para>
     <para>
      구성 파일이 없거나 DEFAULT 항목이 구성 파일에 정의되지 않은 경우 기본값은 옵션이 없는 커널 이름 <quote>linux</quote>입니다.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>

    <term><option>IFAPPEND <replaceable>FLAG</replaceable></option>
    </term>
    <listitem>
     <para>
      <replaceable>FLAG</replaceable> 값에 따라 특정 옵션을 커널 명령줄에 추가합니다. <option>IFAPPEND</option> 옵션은 PXELINUX에서만 사용 가능합니다. <replaceable>FLAG</replaceable>에는 다음과 같은 값이 필요합니다(<xref linkend="tab-deployment-boot-pxeopts-ifappend"/> 참조).
     </para>
     <table xml:id="tab-deployment-boot-pxeopts-ifappend">
      <title><option>IFAPPEND</option>에서 생성 및 추가된 커널 명령 줄 옵션</title>
      <tgroup cols="2">
       <colspec colwidth="1*"/>
       <colspec colwidth="4*"/>
       <thead>
        <row>
         <entry valign="middle">
          <para>
           인수
          </para>
         </entry>
         <entry>
          <para>
           생성된 커널 명령 줄/설명
          </para>
         </entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>
          <para>
           <option>1</option>
          </para>
         </entry>
         <entry>
<screen>ip=<replaceable>CLIENT_IP</replaceable>:<replaceable>BOOT_SERVER_IP</replaceable>:<replaceable>GW_IP</replaceable>:<replaceable>NETMASK</replaceable></screen>
          <para>
           DHCP/BOOTP 또는 PXE 부팅 서버의 입력을 기반으로 자리 표시자가 바뀝니다.
          </para>
          <para>
           이 옵션은 부팅된 시스템에서 DHCP 클라이언트를 실행하기 위한 대체 옵션이 아닙니다. 정기적으로 갱신하지 않으면 PXE BIOS가 얻은 임대가 만료되므로 IP 주소를 DHCP 서버가 다시 사용할 수 있습니다.
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
           <option>2</option>
          </para>
         </entry>
         <entry>
<screen>BOOTIF=<replaceable>MAC_ADDRESS_OF_BOOT_INTERFACE</replaceable></screen>
          <para>
           DHCP 서버에서 응답을 받을 때까지 설치 서버가 LAN 인터페이스를 차례로 조사할 때 시간 제한을 피하려면 이 옵션이 유용합니다. 이 옵션을 사용하면 initrd 프로그램에서 시스템이 부팅되는 인터페이스를 결정할 수 있습니다. linuxrc에서 이 옵션을 읽고 이 네트워크 인터페이스를 사용합니다.
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
           <option>4</option>
          </para>
         </entry>
         <entry>
<screen>SYSUUID=<replaceable>SYSTEM_UUID</replaceable></screen>
          <para>
           소문자로 된 16진수의 UUID를 추가합니다. <filename>/usr/share/doc/packages/syslinux/pxelinux.txt</filename> 참조
          </para>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><option>LABEL <replaceable>LABEL</replaceable> KERNEL <replaceable>IMAGE</replaceable> APPEND <replaceable>OPTIONS</replaceable>...</option>
    </term>
    <listitem>
     <para>
      <replaceable>LABEL</replaceable>을 부팅할 커널로 입력하는 경우를 나타내며 PXELINUX는 대신 <replaceable>IMAGE</replaceable>를 부팅해야 하고 지정된 <option>APPEND</option> 옵션을 사용해야 합니다. 첫 번째 <option>LABEL</option> 명령 전에 파일의 전역 섹션에 지정된 항목을 바꿉니다. <replaceable>IMAGE</replaceable>의 기본값은 <replaceable>LABEL</replaceable>과 동일하고, <option>APPEND</option>가 지정되지 않은 경우 기본값은 전역 항목(있는 경우)입니다. 최대 128개의 <option>LABEL</option> 항목이 허용됩니다.
     </para>

     <para>
      PXELINUX는 다음 구문을 사용합니다.
     </para>
<screen>label <replaceable>MYLABEL</replaceable>
  kernel <replaceable>MYKERNEL</replaceable>
  append <replaceable>MYOPTIONS</replaceable></screen>
     <para>
      레이블은 파일 이름이었던 것처럼 바뀌고, 바뀐 후에는 고유해야 합니다. 예를 들어 <quote>v2.6.30</quote>과 <quote>v2.6.31</quote>의 두 레이블은 두 항목 모두 동일한 DOS 파일 이름으로 바뀌기 때문에 PXELINUX에서 구분할 수 없게 됩니다.
     </para>
     <para>
      커널이 Linux 커널일 필요는 없으며 부팅 섹터나 COMBOOT 파일일 수도 있습니다.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><option>LOCALBOOT <replaceable>TYPE</replaceable></option>
    </term>
    <listitem>
     <para>
      PXELINUX에서 <option>KERNEL</option> 옵션 대신 <option>LOCALBOOT 0</option>을 지정하는 것은 이 특수 레이블을 호출하는 것을 의미하며, 이로 인해 커널 부팅 대신 로컬 디스크 부팅이 실행될 수 있습니다.
     </para>
     <informaltable frame="topbot" rowsep="0">
      <tgroup cols="2">

       <thead>
        <row>
         <entry>
          <para>
           인수
          </para>
         </entry>
         <entry>
          <para>
           설명
          </para>
         </entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>
          <para>
           <literal>0</literal>
          </para>
         </entry>
         <entry>
          <para>
           일반 부팅을 수행합니다.
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
           <literal>4</literal>
          </para>
         </entry>
         <entry>
          <para>
           메모리에 있는 UNDI(Universal Network Driver Interface) 드라이버를 사용하여 로컬 부팅을 수행합니다.
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
           <literal>5</literal>
          </para>
         </entry>
         <entry>
          <para>
           메모리에 있는 UNDI 드라이버를 포함하여 전체 PXE 스택이 있는 로컬 부팅을 수행합니다.
          </para>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
     <para>
      모든 다른 값은 정의되지 않았습니다. UNDI 또는 PXE 스택의 정의를 모르는 경우 <literal>0</literal>을 지정하십시오.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><option>TIMEOUT <replaceable>TIME-OUT</replaceable></option>
    </term>
    <listitem>
     <para>
      부팅 프롬프트에서 자동으로 부팅될 때까지 기다려야 하는 시간을 1/10초 단위로 나타냅니다. 키보드의 아무 키나 누르면 시간 초과가 취소되고, 시작된 명령을 사용자가 완료할 것이라고 가정합니다. 제로(0) 시간 초과는 시간 초과를 완전히 비활성화합니다(이 항목도 기본값임). 허용 가능한 최대 시간 초과 값은 35996입니다(1시간 미만).
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><option>PROMPT<replaceable> flag_val</replaceable></option>
    </term>
    <listitem>
     <para>
      <option>flag_val</option>이 0인 경우 <keycap function="shift"/> 또는 <keycap function="alt"/> 키를 눌렀거나 <keycap>Caps Lock</keycap> 또는 <keycap>Scroll Lock</keycap> 키를 설정(기본값)한 경우에만 부팅 프롬프트를 표시합니다. <option>flag_val</option>이 1인 경우 항상 부팅 프롬프트를 표시합니다.
     </para>
<screen>F2  <replaceable>FILENAME</replaceable>
F1  <replaceable>FILENAME</replaceable>
..etc..
F9  <replaceable>FILENAME</replaceable>
F10 <replaceable>FILENAME</replaceable></screen>
     <para>
      부팅 프롬프트에서 기능 키를 눌렀을 때 화면에 나타난 파일을 표시합니다. 이 파일은 프리부팅 온라인 도움말(커널 명령줄 옵션에 해당)을 구현하는 데 사용할 수 있습니다. 이전 릴리스에서의 이전 버전과의 호환성의 경우 <keycap>F10</keycap>을 <literal>F0</literal>으로도 입력할 수 있습니다. 현재는 파일 이름을 <keycap>F11</keycap> 및 <keycap>F12</keycap>로 바인딩할 방법이 없습니다.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 xml:id="sec-deployment-prep-boot-pxeprep">
  <title>PXE 부팅을 위한 대상 시스템 준비</title>

  <para>
   BIOS 부팅 순서에 PXE 옵션을 포함시켜 PXE 부팅을 위한 시스템의 BIOS를 준비합니다.
  </para>

  <warning>
   <title>BIOS 부팅 순서</title>
   <para>
    PXE 옵션을 BIOS의 하드 디스크 부팅 파라미터 앞에 배치하지 마십시오. 그렇지 않으면 이 시스템은 부팅할 때마다 재설치를 시도합니다.
   </para>
  </warning>
 </sect1>

 <sect1 xml:id="sec-deployment-prep-boot-wol">
  <title>원격 절전 모드 해제를 위해 Wake-on-LAN 사용</title>
   <para>
       WOL(Wake-on-LAN)은 네트워크를 통해 절전 모드 해제 신호를 전송하여 컴퓨터의 절전 모드를 원격으로 해제하기 위한 이더넷 표준입니다. 이 신호를 <quote>매직 패킷</quote>이라고 합니다. 원격 절전 모드 해제를 활성화할 클라이언트 시스템과 절전 모드 해제 신호를 전송하는 데 사용할 각 시스템에 WOL을 설치하십시오. 매직 패킷은 UDP 포트 9를 통해 클라이언트 시스템에 있는 네트워크 인터페이스의 MAC 주소로 브로드캐스트됩니다.
   </para>
   <para>
       컴퓨터는 종료되었더라도 보통 완전히 꺼지지 않고 저전력 모드를 유지합니다. 네트워크 인터페이스는 WOL을 지원할 때 시스템의 전원이 꺼지면 매직 패킷 절전 모드 해제 신호를 수신 대기합니다. 매직 패킷을 수동으로 전송하거나 전송 시스템에서 cron 작업을 통해 절전 모드 해제 일정을 잡을 수 있습니다.
   </para>

  <sect2 xml:id="sec-deployment-prep-boot-wol-prereqs">
       <title>전제 조건</title>
   <para>
       WOL은 WOL을 지원하는 유선 및 무선 이더넷 카드와 함께 작동합니다.
   </para>
   <para>
       시스템 BIOS/UEFI에서 WOL을 활성화해야 할 수 있습니다.
   </para>
   <para>
       PXE 부팅에 대한 BIOS/UEFI 설정을 확인하여 우발적인 재설치 방지를 위해 비활성화 상태를 유지하십시오.
   </para>
   <para>
       방화벽을 조정하여 UDP 포트 9를 통한 트래픽을 허용하십시오.
   </para>
  </sect2>

  <sect2 xml:id="sec-deployment-prep-boot-wiredethernet">
       <title>유선 이더넷 지원 확인</title>
   <para>
       다음 명령을 실행하여 유선 이더넷 인터페이스가 WOL을 지원하는지 확인하십시오.
   </para>
   <screen><prompt>&gt; </prompt><command>sudo</command> ethtool eth0 | grep -i wake-on
Supports Wake-on: pumbg
Wake-on: g</screen>
   <para>
       예제 출력에는 eth0가 WOL을 지원하는 것으로 표시되어 있으며, 이것은 <literal>Supports Wake-on</literal> 줄의 <literal>g</literal> 플래그를 통해 알 수 있습니다. <literal>Wake-on: g</literal>는 WOL이 이미 활성화되어 있음을 나타냅니다. 따라서 이 인터페이스는 절전 모드 해제 신호를 수신할 준비가 되어 있습니다. WOL이 활성화되지 않은 경우 다음 명령으로 활성화하십시오.
   </para>
   <screen><prompt>&gt; </prompt><command>sudo</command> ethtool -s wol g</screen>
  </sect2>

   <sect2 xml:id="sec-deployment-prep-boot-wirelessethernet">
       <title>무선 인터페이스 지원 확인</title> 
   <para>
       Wi-Fi를 통한 절전 모드 해제 또는 WoWLAN을 실행하려면 WoWLAN을 지원하는 무선 네트워크 인터페이스가 필요합니다. 다음과 같이 <command>iw</command> 명령으로 테스트합니다. 이 명령은 <package>iw</package> 패키지에서 제공합니다.
   </para>
   <screen><prompt>&gt; </prompt><command>sudo</command> zypper in iw</screen>
   <para>
       다음과 같이 장치 이름을 찾으십시오.
   </para>
   <screen><prompt>&gt; </prompt><command>sudo</command> iw dev
phy#0
        Interface wlan2
                ifindex 3
                wdev 0x1
                addr 9c:ef:d5:fe:01:7c
                ssid accesspoint
                type managed
                channel 11 (2462 MHz), width: 20 MHz, center1: 2462 MHz
                txpower 20.00 dBm</screen>
   <para>
       이 예에서 WoWLAN 지원을 쿼리하는 데 사용할 장치 이름은 <literal>phy#0</literal>입니다. 이 예에서는 다음과 같이 지원하지 않는 것으로 표시되어 있습니다.
   </para>
       <screen><prompt>&gt; </prompt><command>sudo</command> iw phy#0 wowlan show
command failed: Operation not supported (-95)</screen>
   <para>
       이 예에서는 WoWLAN을 지원하는 인터페이스를 표시하고 있지만 WoWLAN이 비활성화되어 있습니다.
   </para>
   <screen><prompt>&gt; </prompt><command>sudo</command> iw phy#0 wowlan show
WoWLAN is disabled</screen>
   <para>
       다음과 같이 WoWLAN을 활성화하십시오.
   </para>
   <screen><prompt>&gt; </prompt><command>sudo</command> iw phy#0 wowlan enable magic-packet
WoWLAN is enabled:
* wake up on magic packet</screen>
</sect2>

<sect2 xml:id="sec-deployment-prep-boot-wol-install">
    <title>WOL 설치 및 테스트</title>
    <para>
        WOL을 사용하려면 클라이언트 및 전송 시스템에 <package>wol</package> 패키지를 설치합니다.
    </para>
<screen><prompt>&gt; </prompt><command>sudo</command> zypper in wol</screen>
    <para>          
        클라이언트 시스템에 <package>wol-udev-rules</package>를 설치합니다. 이 패키지는 시작할 때 WOL을 자동으로 활성화하는 udev 규칙을 설치합니다.
   </para>
   <para>
       다음과 같이 클라이언트 시스템에 있는 네트워크 인터페이스의 MAC 주소를 가져오십시오.
   </para>
   <screen><prompt>&gt; </prompt><command>sudo</command> ip addr show eth0|grep ether
link/ether 7c:ef:a5:fe:06:7c brd ff:ff:ff:ff:ff:ff</screen>
   <para>
       예제 출력에서 <literal>7c:ef:a5:fe:06:7c</literal>는 MAC 주소입니다.
   </para>
   <para>
       클라이언트 시스템을 종료하고 서브넷이 동일한 다른 컴퓨터에서 아래와 같이 클라이언트 시스템으로 절전 모드 해제 신호를 전송하십시오.
   </para>
   <screen><prompt>&gt; </prompt>wol <replaceable>7c:ef:a5:fe:06:7c</replaceable></screen>
   <para>
       대상 시스템과 두 번째 장치가 동일한 네트워크에 있지만 다른 서브넷에 있는 경우 다음과 같이 대상 시스템에 브로드캐스트 주소를 지정하십시오.
   </para>
   <screen><prompt>&gt; </prompt>wol -i <replaceable>192.168.0.63 7c:ef:a5:fe:06:7c</replaceable></screen>
   <para>
       WOL은 브로드캐스트 도메인에 의존하므로 전송 시스템은 다른 네트워크 세그먼트에 있을 수는 있지만 반드시 동일한 네트워크에 있어야 합니다.
   </para>
   <para>
       다른 네트워크에서 매직 패킷을 전송할 수 있습니다. 한 가지 방법은 라우터가 브로드캐스트 주소에 대한 포트 전달을 지원하는 경우 포트 전달을 사용하는 것입니다. 더 안전한 방법은 SSH를 통해 네트워크 내부의 호스트에 연결하여 거기에서 매직 패킷을 전송하는 것입니다.
   </para>
  </sect2>
 </sect1>
</chapter>
