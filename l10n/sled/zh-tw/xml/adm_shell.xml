<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="adm_shell.xml" version="5.0" xml:id="cha-adm-shell">

 <title>Bash 和 Bash 程序檔</title>
 <info>
  <abstract>
   <para>
    當今時代，許多人都在使用裝有 GNOME 之類圖形使用者介面 (GUI) 的電腦。儘管 GUI 可提供許多功能，但執行自動化任務時，這些功能會受到限制。外圍程序是 GUI 的有效補充，本章概述了外圍程序 (以 Bash 外圍程序為例) 的一些方面。
   </para>
  </abstract>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>

 <sect1 xml:id="sec-adm-whatistheshell">
  <title>什麼是<quote>外圍程序</quote>？</title>



  <para>
   一般而言，<emphasis></emphasis>Linux 外圍程序就是 Bash (Bourne again Shell)。本章中提及的<quote>外圍程序</quote>指的是 Bash。可用的外圍程序不止 Bash (還有 ash、csh、ksh、zsh 等等)，每個外圍程序都具有不同的功能和特性。如需有關其他外圍程序的詳細資訊，請在 YaST 中搜尋<emphasis>外圍程序</emphasis>。
  </para>

  <sect2 xml:id="sec-adm-configfiles">
   <title>Bash 組態檔案</title>
   <para>
    外圍程序可啟用為：
   </para>
   <orderedlist spacing="normal">
    <listitem>
     <formalpara>
      <title>互動式登入外圍程序</title>
      <para>
       使用 <option>--login</option> 選項啟用 Bash 以登入機器，或使用 SSH 登入遠端機器時會採用這種方式。
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title><quote>一般</quote>互動式外圍程序</title>
      <para>
       在啟動 xterm、konsole、gnome-terminal 或類似的指令行介面 (CLI) 工具時，通常會呼叫此外圍程序。
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>非互動式外圍程序</title>
      <para>
       當在指令行呼叫外圍程序程序檔時，就會呼叫此外圍程序。
      </para>
     </formalpara>
    </listitem>
   </orderedlist>
   <para>
    系統會讀取不同的組態檔案，視所使用的外圍程序類型而定。下面的表格顯示了登入與非登入外圍程序組態檔案。
   </para>
   <table xml:id="tab-adm-shell-config-loginshells">
    <title>登入外圍程序的 Bash 組態檔案</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>
        <para>
         檔案
        </para>
       </entry>
       <entry>
        <para>
         描述
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         <filename>/etc/profile</filename>
        </para>
       </entry>
       <entry>
        <para>
         請勿修改此檔案，否則當下次更新時，您的修改可能會被破壞！
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>/etc/profile.local</filename>
        </para>
       </entry>
       <entry>
        <para>
         擴充 <filename>/etc/profile</filename> 時使用此檔案
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>/etc/profile.d/</filename>
        </para>
       </entry>
       <entry>
        <para>
         包含特定程式的泛系統組態檔案
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>~/.profile</filename>
        </para>
       </entry>
       <entry>
        <para>
         在此處插入登入外圍程序的使用者特定組態
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    請注意，登入外圍程序還會獲取<xref linkend="tab-adm-shell-configs-nonloginshells"/>中所列的組態檔案。
   </para>
   <table xml:id="tab-adm-shell-configs-nonloginshells">
    <title>非登入外圍程序的 Bash 組態檔案</title>
    <tgroup cols="2">
     <tbody>
      <row>
       <entry>
        <para>
         <filename>/etc/bash.bashrc</filename>
        </para>
       </entry>
       <entry>
        <para>
         請勿修改此檔案，否則當下次更新時，您的修改可能會被破壞！
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>/etc/bash.bashrc.local</filename>
        </para>
       </entry>
       <entry>
        <para>
         使用此檔案只能插入 Bash 的泛系統修改
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>~/.bashrc</filename>
        </para>
       </entry>
       <entry>
        <para>
         在此處插入使用者特定的組態
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    此外，Bash 還使用其他檔案：
   </para>
   <table>
    <title>用於 Bash 的特殊檔案</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>
        <para>
         檔案
        </para>
       </entry>
       <entry>
        <para>
         描述
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         <filename>~/.bash_history</filename>
        </para>
       </entry>
       <entry>
        <para>
         包含您輸入的所有指令清單
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>~/.bash_logout</filename>
        </para>
       </entry>
       <entry>
        <para>
         登出時執行
        </para>
       </entry>
       </row>
       <row>
       <entry>
        <para>
         <filename>~/.alias</filename>
        </para>
       </entry>
       <entry>
        <para>
         使用者為常用指令定義的別名。如需定義別名的詳細資料，請參閱 <command>man 1 alias</command>。
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <bridgehead>非登入外圍程序</bridgehead>
   <para>
    下面兩個特殊外圍程序會阻擋使用者登入系統：<systemitem>/bin/false</systemitem> 和 <systemitem>/sbin/nologin</systemitem>。當使用者嘗試登入系統時，這兩個外圍程序都將失敗且不會顯示訊息。這是一種針對系統使用者而特意設計的安全措施，雖然新版 Linux 作業系統已提供更有效的工具 (例如 PAM 和 AppArmor) 來控制系統存取。
   </para>
   <para>
    <phrase role="productname"><phrase os="sled">SUSE Linux Enterprise Desktop</phrase></phrase> 上的預設行為是將 <systemitem>/bin/bash</systemitem> 指定給人類使用者，將 <systemitem>/bin/false</systemitem> 或 <systemitem>/sbin/nologin</systemitem> 指定給系統使用者。但由於歷史原因，<systemitem class="username">nobody</systemitem> 使用者擁有 <systemitem>/bin/bash</systemitem>，因為該使用者是預設用做系統使用者的最低特權使用者。但是，如果有多個系統使用者使用 <systemitem class="username">nobody</systemitem>，則將失去因使用 nobody 所獲得的任何安全性。應該可以將它變更為 <systemitem>/sbin/nologin</systemitem>；最快的測試方法是進行此變更，然後看看這樣是否中斷了任何服務或應用程式。
   </para>
   <para>
    使用以下指令列出 <filename>/etc/passwd</filename> 中已指定給所有使用者 (系統使用者和人類使用者) 的外圍程序。輸出視您系統上的服務和使用者而有所不同：
   </para>
<screen><prompt>&gt; </prompt>sort -t: -k 7 /etc/passwd | awk -F: '{print $1"\t" $7}' | column -t
tux               /bin/bash
nobody            /bin/bash
root              /bin/bash
avahi             /bin/false
chrony            /bin/false
dhcpd             /bin/false
dnsmasq           /bin/false
ftpsecure         /bin/false
lightdm           /bin/false
mysql             /bin/false
postfix           /bin/false
rtkit             /bin/false
sshd              /bin/false
tftp              /bin/false
unbound           /bin/false
bin               /sbin/nologin
daemon            /sbin/nologin
ftp               /sbin/nologin
lp                /sbin/nologin
mail              /sbin/nologin
man               /sbin/nologin
nscd              /sbin/nologin
polkitd           /sbin/nologin
pulse             /sbin/nologin
qemu              /sbin/nologin
radvd             /sbin/nologin
rpc               /sbin/nologin
statd             /sbin/nologin
svn               /sbin/nologin
systemd-coredump  /sbin/nologin
systemd-network   /sbin/nologin
systemd-timesync  /sbin/nologin
usbmux            /sbin/nologin
vnc               /sbin/nologin
wwwrun            /sbin/nologin
messagebus        /usr/bin/false
scard             /usr/sbin/nologin</screen>
  </sect2>

  <xi:include href="fs_structure_i.xml"/>
 </sect1>
 <sect1 xml:id="sec-adm-shellscripts">
  <title>撰寫外圍程序程序檔</title>

  <para>
   使用外圍程序程序檔可以方便地完成各種任務：收集資料、搜尋文字中的單字或片語，以及執行其他有用的操作。以下範例顯示了一個列印文字的小型外圍程序程序檔：
  </para>

  <example>
   <title>用於列印文字的外圍程序程序檔</title>
<screen>#!/bin/sh <co xml:id="co-adm-shell-shebang"/>
# Output the following line: <co xml:id="co-adm-shell-comment"/>
echo "Hello World" <co xml:id="co-adm-shell-echo"/></screen>
   <calloutlist>
    <callout arearefs="co-adm-shell-shebang">
     <para>
      第一行以 <emphasis>Shebang</emphasis> 字元 (<literal>#! </literal>) 開頭，指出此檔案為程序檔。在 <emphasis>Shebang</emphasis> 後面指定的解譯器將執行該程序檔。在本例中，指定的解譯器為 <command>/bin/sh</command>。
     </para>
    </callout>
    <callout arearefs="co-adm-shell-comment">
     <para>
      第二行為備註，以 # 開頭。我們建議對難以理解的行提供註解。提供適當的註解可以記住該行的用途和功能。另外，可協助其他閱讀者理解您的程序檔。在開發社群中，註解被視為一種良好的做法。
     </para>
    </callout>
    <callout arearefs="co-adm-shell-echo">
     <para>
      第三行使用內建指令 <command>echo</command> 列印相應的文字。
     </para>
    </callout>
   </calloutlist>
  </example>

  <para>
   在執行此程序檔之前，必須滿足幾項先決條件：
  </para>

  <orderedlist spacing="normal">
   <listitem>
    <para>
     每個程序檔都應包含 Shebang 行 (如上面的範例所示)。如果缺少該行，您需要手動呼叫直譯器。
    </para>
   </listitem>
   <listitem>
    <para>
     您可以將程序檔儲存於任何位置。但是，最好將其儲存於外圍程序可以找到的目錄中。外圍程序中的搜尋路徑由環境變數 <envar>PATH</envar> 決定。一般使用者通常沒有寫入 <filename>/usr/bin</filename> 的權限。因此，建議將程序檔儲存在使用者目錄 <filename>~/bin/</filename> 中。以上範例名為 <filename>hello.sh</filename>。
    </para>
   </listitem>
   <listitem>
    <para>
     程序檔需要執行權限。使用下列指令設定權限：
    </para>
<screen><prompt>&gt; </prompt>chmod +x ~/bin/hello.sh</screen>
   </listitem>
  </orderedlist>

  <para>
   如果滿足了上述所有先決條件，便可以按以下方式執行程序檔：
  </para>

  <orderedlist spacing="normal">
   <listitem>
    <formalpara>
     <title>做為絕對路徑</title>
     <para>
      執行程序檔時可以使用絕對路徑。在此例中為 <command>~/bin/hello.sh</command>。
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>任何位置</title>
     <para>
      如果 <envar>PATH</envar> 環境變數包含程序檔所在的目錄，您可以使用 <command>hello.sh</command> 來執行程序檔。
     </para>
    </formalpara>
   </listitem>
  </orderedlist>
 </sect1>
 <sect1 xml:id="sec-adm-shell-redirect">
  <title>重新導向指令事件</title>

  <para>
   每條指令可以使用三個通道用於輸入或輸出：
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <formalpara>
     <title>標準輸出</title>
     <para>
      這是預設的輸出通道。指令進行列印時會使用標準輸出通道。
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>標準輸入</title>
     <para>
      如果指令需要使用者或其他指令的輸入，將會使用此通道。
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>標準錯誤</title>
     <para>
      指令使用此通道報告錯誤。
     </para>
    </formalpara>
   </listitem>
  </itemizedlist>

  <para>
   要重新指向這些通道，可以使用以下幾種方式：
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>指令 &gt; 檔案</literal>
    </term>
    <listitem>
     <para>
      將指令輸出儲存為檔案，現有的檔案將會刪除。例如，<command>ls</command> 指令將輸出寫入到檔案 <filename>listing.txt</filename> 中：
     </para>
<screen><prompt>&gt; </prompt>ls &gt; listing.txt</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>指令 &gt;&gt; 檔案</literal>
    </term>
    <listitem>
     <para>
      將指令輸出附加至檔案。例如，<command>ls</command> 指令將輸出附加至檔案 <filename>listing.txt</filename> 中：
     </para>
<screen><prompt>&gt; </prompt>ls &gt;&gt; listing.txt</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>指令 &lt; 檔案</literal>
    </term>
    <listitem>
     <para>
      讀取檔案，將其做為指定指令的輸入。例如，<command>read</command> 指令會將檔案內容讀取至變數中：
     </para>
<screen><prompt>&gt; </prompt>read a &lt; foo</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>指令1 | 指令2</literal>
    </term>
    <listitem>
     <para>
      將左邊指令的輸出重新指向為右邊指令的輸入。例如，<command>cat</command> 指令會輸出 <filename>/proc/cpuinfo</filename> 檔案的內容。再由 <command>grep</command> 使用此輸出內容單獨過濾出包含 <literal>cpu</literal> 的行：
     </para>
<screen><prompt>&gt; </prompt>cat /proc/cpuinfo | grep cpu</screen>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   每個通道都有一個<emphasis>檔案描述子</emphasis>：0 (零) 代表標準輸入，1 代表標準輸出，2 代表標準錯誤。您可以將此檔案描述子插入到 <literal>&lt;</literal> 或 <literal>&gt;</literal> 字元的前面。例如，下行將搜尋以 <filename>foo</filename> 開始的檔案，但透過將檔案重新指向至 <filename>/dev/null</filename> 隱藏了錯誤：
  </para>

<screen><prompt>&gt; </prompt>find / -name "foo*" 2&gt;/dev/null</screen>
 </sect1>
 <sect1 xml:id="sec-adm-alias">
  <title>使用別名</title>

  <para>
   別名為一或多條指令的簡短定義。別名的語法為：
  </para>

<screen>alias <replaceable>NAME</replaceable>=<replaceable>DEFINITION</replaceable></screen>

  <para>
   例如，下行定義了一個別名 <command>lt</command>，它會輸出一份較長的清單 (選項 <option>-l</option>)，將其依修改時間排序 (<option>-t</option>)，並依排好序的倒序列印 (<option>-r</option>)：
  </para>

<screen><prompt>&gt; </prompt>alias lt='ls -ltr'</screen>

  <para>
   要檢視所有的別名定義，請使用 <command>alias</command>。若要移除別名，請使用 <command>unalias</command> 和對應的別名名稱。
  </para>
 </sect1>
 <sect1 xml:id="sec-adm-variables">
  <title>在 Bash 中使用變數</title>

  <para>
   外圍程序變數可以是全域變數或本地變數。您可以在所有外圍程序中存取全域變數或環境變數。與此相反，本地變數僅顯示於目前的外圍程序中。
  </para>

  <para>
   要檢視所有環境變數，請使用 <command>printenv</command> 指令。如需瞭解變數的值，則將變數名稱做為引數插入：
  </para>

<screen><prompt>&gt; </prompt>printenv PATH</screen>

  <para>
   無論是全域變數還是本地變數，都可以使用 <command>echo</command> 進行檢視：
  </para>

<screen><prompt>&gt; </prompt>echo $PATH</screen>

  <para>
   要設定本地變數，請使用變數名稱，後面跟上等號，再跟上值：
  </para>

<screen><prompt>&gt; </prompt>PROJECT="SLED"</screen>

  <para>
   請不要在等號兩邊插入空格，否則將會出錯。要設定環境變數，請使用 <command>export</command>：
  </para>

<screen><prompt>&gt; </prompt>export NAME="tux"</screen>

  <para>
   若要移除變數，請使用 <command>unset</command>：
  </para>

<screen><prompt>&gt; </prompt>unset NAME</screen>

  <para>
   下表包含了部分可在外圍程序程序檔中使用的常用環境變數：
  </para>

  <table xml:id="tab-adm-envars">
   <title>有用的環境變數</title>
   <tgroup cols="2">
    <tbody>
     <row>
      <entry>
       <para>
        <envar>HOME</envar>
       </para>
      </entry>
      <entry>
       <para>
        目前使用者的主目錄
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>HOST</envar>
       </para>
      </entry>
      <entry>
       <para>
        目前的主機名稱
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>LANG</envar>
       </para>
      </entry>
      <entry>
       <para>
        工具當地化以後，會使用此環境變數指定的語言。也可將英語設定為 <literal>C</literal>
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>PATH</envar>
       </para>
      </entry>
      <entry>
       <para>
        外圍程序的搜尋路徑，即以冒號分隔的目錄清單
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>PS1</envar>
       </para>
      </entry>
      <entry>
       <para>
        指定在每條指令前列印的一般提示
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>PS2</envar>
       </para>
      </entry>
      <entry>
       <para>
        指定執行多行指令時列印的輔助提示
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>PWD</envar>
       </para>
      </entry>
      <entry>
       <para>
        目前的工作目錄
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>USER</envar>
       </para>
      </entry>
      <entry>
       <para>
        目前的使用者
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <sect2 xml:id="sec-adm-variables-argument">
   <title>使用引數變數</title>

   <para>
    例如，如果您有程序檔 <command>foo.sh</command>，可以按以下格式執行該程序檔：
   </para>
<screen><prompt>&gt; </prompt>foo.sh "Tux Penguin" 2000 </screen>
   <para>
    若要存取傳送至程序檔的所有引數，需要使用位置參數。<envar>$1</envar> 代表第一個引數的位置參數，<envar>$2</envar> 代表第二個引數的位置參數，依此類推。最多可以使用九個參數。要獲取程序檔名稱，請使用 <envar>$0</envar>。
   </para>
   <para>
    下面的程序檔 <command>foo.sh</command> 可列印從 1 到 4 的所有引數：
   </para>
<screen>#!/bin/sh
echo \"$1\" \"$2\" \"$3\" \"$4\"</screen>
   <para>
    如果您使用以上引數執行此程序檔，所得結果為：
   </para>
<screen>"Tux Penguin" "2000" "" ""</screen>

  </sect2>

  <sect2 xml:id="sec-adm-shell-varsubst">
   <title>使用變數替代項</title>
   <para>
    變數替代項會從左側或右側將模式套用至變數內容。以下清單包含了可用的語法格式：
   </para>
   <variablelist>
    <varlistentry>
     <term><literal>${VAR#pattern}</literal>
     </term>
     <listitem>
      <para>
       從左側移除最短的相符項：
      </para>
<screen><prompt>&gt; </prompt>file=/home/tux/book/book.tar.bz2
<prompt>&gt; </prompt>echo ${file#*/}
home/tux/book/book.tar.bz2</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>${VAR##pattern}</literal>
     </term>
     <listitem>
      <para>
       從左側移除最長的相符項：
      </para>
<screen><prompt>&gt; </prompt>file=/home/tux/book/book.tar.bz2
<prompt>&gt; </prompt>echo ${file##*/}
book.tar.bz2</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>${VAR%pattern}</literal>
     </term>
     <listitem>
      <para>
       從右側移除最短的相符項：
      </para>
<screen><prompt>&gt; </prompt>file=/home/tux/book/book.tar.bz2
<prompt>&gt; </prompt>echo ${file%.*}
/home/tux/book/book.tar</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>${VAR%%pattern}</literal>
     </term>
     <listitem>
      <para>
       從右側移除最長的相符項：
      </para>
<screen><prompt>&gt; </prompt>file=/home/tux/book/book.tar.bz2
<prompt>&gt; </prompt>echo ${file%%.*}
/home/tux/book/book</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>${VAR/pattern_1/pattern_2}</literal>
     </term>
     <listitem>
      <para>
       以 <replaceable>PATTERN_2</replaceable> 取代 <replaceable>PATTERN_1</replaceable> 中 <replaceable>VAR</replaceable> 的內容：
      </para>
<screen><prompt>&gt; </prompt>file=/home/tux/book/book.tar.bz2
<prompt>&gt; </prompt>echo ${file/tux/wilber}
/home/wilber/book/book.tar.bz2</screen>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>
 </sect1>
 <sect1 xml:id="sec-adm-shell-grouping">
  <title>分組和組合指令</title>

  <para>
   外圍程序允許您組合及分組指令，以便按條件執行。每條指令都會傳回決定操作成功與否的離開碼。如果為 0 (零)，則說明指令成功，任何其他離開碼都代表特定於指令的錯誤。
  </para>

  <para>
   以下清單顯示了可對指令分組的方式：
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>指令1 ; 指令2</literal>
    </term>
    <listitem>
     <para>
      以順序執行指令。不檢查離開碼。下行透過 <command>cat</command> 顯示檔案內容，然後透過 <command>ls</command> 列印其檔案內容，而不管其離開碼為何：
     </para>
<screen><prompt>&gt; </prompt>cat filelist.txt ; ls -l filelist.txt</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>指令1 &amp;&amp; 指令2</literal>
    </term>
    <listitem>
     <para>
      如果左邊的指令成功，即會執行右邊的指令 (邏輯「與」)。下行顯示檔案內容，並且僅在前面的指令成功時才會列印其檔案內容 (將其與此清單中的上一個項目進行比較)：
     </para>
<screen><prompt>&gt; </prompt>cat filelist.txt &amp;&amp; ls -l filelist.txt</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>指令1 || 指令2</literal>
    </term>
    <listitem>
     <para>
      如果左邊的指令失敗，即會執行右邊的指令 (邏輯「或」)。下行將只會在於 <filename>/home/tux/foo</filename> 中建立目錄失敗時，才會在 <filename>/home/wilber/bar</filename> 中建立目錄：
     </para>
<screen><prompt>&gt; </prompt>mkdir /home/tux/foo || mkdir /home/wilber/bar</screen>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>funcname(){ ... }</literal>
    </term>
    <listitem>
     <para>
      建立外圍程序函數。可以使用位置參數存取其引數。下行定義了可列印較短訊息的函數 <literal>hello</literal>：
     </para>
<screen><prompt>&gt; </prompt>hello() { echo "Hello $1"; }</screen>
     <para>
      可以按以下格式呼叫此函數：
     </para>
<screen><prompt>&gt; </prompt>hello Tux</screen>
     <para>
      將會列印：
     </para>
<screen>Hello Tux</screen>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 xml:id="sec-adm-shell-commonconstructs">
  <title>使用通用流程建構元</title>

  <para>
   為了控制程序檔的流程，外圍程序包含 <command>while</command>、<command>if</command>、<command>for</command> 及 <command>case</command> 建構元。
  </para>



  <sect2 xml:id="sec-adm-shell-if">
   <title>if 控制指令</title>
   <para>
    <command>If</command> 指令用於檢查運算式。例如，以下程式碼將測試目前的使用者是否為 Tux：
   </para>
<screen>if test $USER = "tux"; then
  echo "Hello Tux."
else
  echo "You are not Tux."
fi</screen>
   <para>
    測試運算式可以很複雜，也可以很簡單。下面的運算式會檢查檔案 <filename>foo.txt</filename> 是否存在：
   </para>
<screen>if test -e /tmp/foo.txt ; then
  echo "Found foo.txt"
fi</screen>
   <para>
    測試運算式也可以縮寫到方括弧中：
   </para>
<screen>if [ -e /tmp/foo.txt ] ; then
  echo "Found foo.txt"
fi</screen>
   <para>
    如需更多有用的運算式，請參閱 <link xlink:href="https://bash.cyberciti.biz/guide/If..else..fi"/>。
   </para>
  </sect2>

  <sect2 xml:id="sec-adm-shell-for">
   <title>使用 <command>for</command> 指令建立迴路</title>
   <para>
    <command>for</command> 迴路可讓您對一組項目執行指令。例如，以下程式碼會列印目前目錄中關於 PNG 檔案的部分資訊：
   </para>
<screen>for i in *.png; do
 ls -l $i
done</screen>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-adm-shell-moreinfo">
  <title>更多資訊</title>

  <para>
   man 頁面 <command>man bash</command> 中提供了關於 Bash 的重要資訊。以下清單中提供了更多關於此主題的資訊：
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     <link xlink:href="http://tldp.org/LDP/Bash-Beginners-Guide/html/index.html"/> — Bash 初級使用者指南
    </para>
   </listitem>
   <listitem>
    <para>
     <link xlink:href="http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html"/> — BASH 程式設計 - 方法介紹
    </para>
   </listitem>
   <listitem>
    <para>
     <link xlink:href="http://tldp.org/LDP/abs/html/index.html"/> — Bash 程序檔進階指南
    </para>
   </listitem>
   <listitem>
    <para>
     <link xlink:href="http://www.grymoire.com/Unix/Sh.html"/> — Sh - Bourne 外圍程序
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
</chapter>
