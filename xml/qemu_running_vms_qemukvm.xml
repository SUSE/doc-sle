<?xml version="1.0"?>
<!DOCTYPE chapter PUBLIC "-//Novell//DTD NovDoc XML V1.0//EN" "novdocx.dtd"
[
  <!ENTITY % NOVDOC.DEACTIVATE.IDREF "INCLUDE">
  <!ENTITY % entities SYSTEM "entity-decl.ent">
  %entities;
]>
<chapter id="cha.qemu.running">
 <title>Running Virtual Machines with qemu-system-ARCH</title>
 <para>
  Once you have a virtual disk image ready (for more information on disk
  images, see <xref linkend="cha.qemu.guest_inst.qemu-img"/>), it is time to
  start the related virtual machine.
  <xref linkend="cha.qemu.guest_inst.qemu-kvm"/> introduced simple commands
  to install and run a &vmguest;. This chapter focuses on a more detailed
  explanation of <command>qemu-system-ARCH</command> usage, and shows
  solutions for more specific tasks. For a complete list of
  <command>qemu-system-ARCH</command>'s options, see its manual page
  (<command>man 1 qemu</command>).
 </para>
 <sect1 id="cha.qemu.running.basic">
  <title>Basic <command>qemu-system-ARCH</command> Invocation</title>

  <para>
   The <command>qemu-system-ARCH</command> command uses the following
   syntax:
  </para>

<screen>qemu-system-ARCH options<co id="co.qemu.running.basic.opts"/> disk_img<co id="co.qemu.running.basic.img"/></screen>

  <calloutlist>
   <callout arearefs="co.qemu.running.basic.opts">
    <para>
     <command>qemu-system-ARCH</command> understands a large number of
     options. Most of them define parameters of the emulated hardware, while
     others affect more general emulator behavior. If you do not supply any
     options, default values are used, and you need to supply the path to a
     disk image to be run.
    </para>
   </callout>
   <callout arearefs="co.qemu.running.basic.img">
    <para>
     Path to the disk image holding the guest system you want to virtualize.
     <command>qemu-system-ARCH</command> supports a large number of image
     formats. Use <command>qemu-img <option>--help</option></command> to
     list them. If you do not supply the path to a disk image as a separate
     argument, you have to use the <option>-drive file=</option> option.
    </para>
   </callout>
  </calloutlist>
 </sect1>
 <sect1 id="cha.qemu.running.gen_opts">
  <title>General <command>qemu-system-ARCH</command> Options</title>

  <para>
   This section introduces general <command>qemu-system-ARCH</command>
   options and options related to the basic emulated hardware, such as the
   virtual machine's processor, memory, model type, or time processing
   methods.
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>-name <replaceable>name_of_guest</replaceable></literal>
    </term>
    <listitem>
     <para>
      Specifies the name of the running guest system. The name is displayed
      in the window caption and also used for the VNC server.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>-boot <replaceable>options</replaceable></literal>
    </term>
    <listitem>
     <para>
      Specifies the order in which the defined drives will be booted. Drives
      are represented by letters, where 'a' and 'b' stands for the floppy
      drives 1 and 2, 'c' stands for the first hard disk, 'd' stands for the
      first CD-ROM drive, and 'n' to 'p' stand for Ether-boot network
      adapters.
     </para>
     <para>
      For example, <literal>qemu-system-ARCH [...] -boot order=ndc</literal>
      first tries to boot from network, then from the first CD-ROM drive,
      and finally from the first hard disk.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>-pidfile <replaceable>fname</replaceable></literal>
    </term>
    <listitem>
     <para>
      Stores the &qemu;'s process identification number (PID) in a file.
      This is useful if you run &qemu; from a script.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>-nodefaults</literal>
    </term>
    <listitem>
     <para>
      By default &qemu; creates basic virtual devices even if you do not
      specify them on the command line. This option turns this feature off,
      and you must specify every single device manually, including graphical
      and network cards, parallel or serial ports, or virtual consoles. Even
      &qemu; monitor is not attached by default.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>-daemonize</literal>
    </term>
    <listitem>
     <para>
      'Daemonizes' the &qemu; process after it is started. &qemu; will
      detach from the standard input and standard output after it is ready
      to receive connections on any of its devices.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <note>
   <title>Seabios Bios</title>
   <para>
    Seabios is the default Bios used. You can boot USB devices, any drive
    (CDROM, Floppy, or an hard drive disk). It has USB mouse and keyboard
    support and support multiple VGA cards. For more information about
    Seabios refer to
    <ulink
    url="http://en.wikipedia.org/wiki/SeaBIOS">Seabios
    Website</ulink>.
   </para>
  </note>

  <sect2 id="cha.qemu.running.gen_opts.basic">
   <title>Basic Virtual Hardware</title>
   <para></para>
   <sect3 id="sec.qemu.running.gen_opts.machine">
    <title>Machine Type</title>
    <para>
     You can specifies the type of the emulated machine. Run
     <command>qemu-system-ARCH -M help</command> to view a list of supported
     machine types.
    </para>
<screen>&prompt.user;qemu-system-x86_64 -M help
Supported machines are:
pc-0.13              Standard PC (i440FX + PIIX, 1996)
pc                   Standard PC (i440FX + PIIX, 1996) (alias of pc-i440fx-2.0)
pc-i440fx-2.0        Standard PC (i440FX + PIIX, 1996) (default)
pc-1.0               Standard PC (i440FX + PIIX, 1996)
pc-q35-1.7           Standard PC (Q35 + ICH9, 2009)
pc-1.1               Standard PC (i440FX + PIIX, 1996)
q35                  Standard PC (Q35 + ICH9, 2009) (alias of pc-q35-2.0)
pc-q35-2.0           Standard PC (Q35 + ICH9, 2009)
pc-i440fx-1.4        Standard PC (i440FX + PIIX, 1996)
pc-i440fx-1.5        Standard PC (i440FX + PIIX, 1996)
pc-0.14              Standard PC (i440FX + PIIX, 1996)
pc-0.15              Standard PC (i440FX + PIIX, 1996)
xenfv                Xen Fully-virtualized PC
pc-q35-1.4           Standard PC (Q35 + ICH9, 2009)
isapc                ISA-only PC
pc-0.10              Standard PC (i440FX + PIIX, 1996)
pc-1.2               Standard PC (i440FX + PIIX, 1996)
pc-0.11              Standard PC (i440FX + PIIX, 1996)
pc-i440fx-1.7        Standard PC (i440FX + PIIX, 1996)
pc-i440fx-1.6        Standard PC (i440FX + PIIX, 1996)
none                 empty machine
xenpv                Xen Para-virtualized PC
pc-q35-1.5           Standard PC (Q35 + ICH9, 2009)
pc-q35-1.6           Standard PC (Q35 + ICH9, 2009)
pc-0.12              Standard PC (i440FX + PIIX, 1996)
pc-1.3               Standard PC (i440FX + PIIX, 1996)</screen>
    <note>
     <title>ISA-PC</title>
     <para>
      <emphasis>isapc ISA-ony-PC</emphasis> is an unsupported machine type.
     </para>
    </note>
   </sect3>
   <sect3 id="cha.qemu.running.gen_opts.basic.cpu">
    <title>CPU Model</title>
    <para>
     To specify the type of the processor (CPU) model, run
     <command>qemu-system-ARCH -cpu
     <replaceable>MODEL</replaceable></command>. Use
     <command>qemu-system-ARCH -cpu help</command> to view a list of
     supported CPU models.
    </para>
<screen>&prompt.user;qemu-system-x86_64 -cpu help
x86           qemu64  QEMU Virtual CPU version 2.0.0                  
x86           phenom  AMD Phenom(tm) 9550 Quad-Core Processor         
x86         core2duo  Intel(R) Core(TM)2 Duo CPU     T7700  @ 2.40GHz 
x86            kvm64  Common KVM processor                            
x86           qemu32  QEMU Virtual CPU version 2.0.0                  
x86            kvm32  Common 32-bit KVM processor                     
x86          coreduo  Genuine Intel(R) CPU           T2600  @ 2.16GHz 
x86              486                                                  
x86          pentium                                                  
x86         pentium2                                                  
x86         pentium3                                                  
x86           athlon  QEMU Virtual CPU version 2.0.0                  
x86             n270  Intel(R) Atom(TM) CPU N270   @ 1.60GHz          
x86           Conroe  Intel Celeron_4x0 (Conroe/Merom Class Core 2)   
x86           Penryn  Intel Core 2 Duo P9xxx (Penryn Class Core 2)    
x86          Nehalem  Intel Core i7 9xx (Nehalem Class Core i7)       
x86         Westmere  Westmere E56xx/L56xx/X56xx (Nehalem-C)          
x86      SandyBridge  Intel Xeon E312xx (Sandy Bridge)                
x86          Haswell  Intel Core Processor (Haswell)                  
x86       Opteron_G1  AMD Opteron 240 (Gen 1 Class Opteron)           
x86       Opteron_G2  AMD Opteron 22xx (Gen 2 Class Opteron)          
x86       Opteron_G3  AMD Opteron 23xx (Gen 3 Class Opteron)          
x86       Opteron_G4  AMD Opteron 62xx class CPU                      
x86       Opteron_G5  AMD Opteron 63xx class CPU                      
x86             host  KVM processor with all supported host features (only
                      available in KVM mode)
Recognized CPUID flags:
  pbe ia64 tm ht ss sse2 sse fxsr mmx acpi ds clflush pn pse36 pat cmov mca
    pge mtrr sep apic cx8 mce pae msr tsc pse de vme fpu
  hypervisor rdrand f16c avx osxsave xsave aes tsc-deadline popcnt movbe
    x2apic sse4.2|sse4_2 sse4.1|sse4_1 dca pcid pdcm xtpr cx16 fma cid ssse3
    tm2 est smx vmx ds_cpl monitor dtes64 pclmulqdq|pclmuldq pni|sse3
  smap adx rdseed rtm invpcid erms bmi2 smep avx2 hle bmi1 fsgsbase
  3dnow 3dnowext lm|i64 rdtscp pdpe1gb fxsr_opt|ffxsr mmxext nx|xd syscall
  perfctr_nb perfctr_core topoext tbm nodeid_msr tce fma4 lwp wdt skinit xop
    ibs osvw 3dnowprefetch misalignsse sse4a abm cr8legacy extapic svm
    cmp_legacy lahf_lm
  pmm-en pmm phe-en phe ace2-en ace2 xcrypt-en xcrypt xstore-en xstore
  kvm_pv_unhalt kvm_pv_eoi kvm_steal_time kvm_asyncpf kvmclock kvm_mmu
    kvm_nopiodelay kvmclock
  pfthreshold pause_filter decodeassists flushbyasid vmcb_clean tsc_scale
    nrip_save svm_lock lbrv npt</screen>
    <para>
     CPU flags information can be found at
     <ulink
    url="http://en.wikipedia.org/wiki/CPUID">CPUID
     wikipedia</ulink>.
    </para>
   </sect3>
   <sect3 id="cha.qemu.running.gen_opts.basic.others">
    <title>Other Basics Options</title>
    <para>
     The following is a list of most commonly used options while launching
     <emphasis>qemu</emphasis> from command line. To see all options
     available please refer to <emphasis>qemu-doc</emphasis> manpage.
    </para>
    <variablelist>
     <varlistentry>
      <term><literal>-m <replaceable>megabytes</replaceable></literal>
      </term>
      <listitem>
       <para>
        Specifies how many megabytes are used for the virtual RAM size.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-balloon virtio</literal>
      </term>
      <listitem>
       <para>
        Specifies a paravirtualized device to dynamically change the amount
        of virtual RAM memory assigned to &vmguest;. The top limit is the
        amount of memory specified with <literal>-m</literal>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-smp <replaceable>number_of_cpus</replaceable></literal>
      </term>
      <listitem>
       <para>
        Specifies how many CPUs will be emulated. &qemu; supports up to 255
        CPUs on the PC platform (up to 64 with KVM acceleration used). This
        option also takes other CPU-related parameters, such as number of
        <emphasis>sockets</emphasis>, number of <emphasis>cores</emphasis>
        per socket, or number of <emphasis>threads</emphasis> per core.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     The following is an example of a working
     <command>qemu-system-ARCH</command> command line:
     <remark>taroth 2014-08-29: maybe update the following with a SLE 12 example?</remark>
    </para>
<screen>qemu-system-x86_64 -name "SLES 11 SP3" -M pc-i440fx-2.0 -m 512 -machine accel=kvm \
       -cpu kvm64 -smp 2 /images/sles.raw</screen>
    <figure>
     <title>&qemu; Window with SLES 11 SP3 as &vmguest;</title>
     <mediaobject>
      <imageobject role="fo">
       <imagedata fileref="qemu_win_sles.png" width="70%" format="PNG"/>
      </imageobject>
      <imageobject role="html">
       <imagedata fileref="qemu_win_sles.png" width="70%" format="PNG"/>
      </imageobject>
     </mediaobject>
    </figure>
    <variablelist>
     <varlistentry>
      <term><literal>-no-acpi</literal>
      </term>
      <listitem>
       <para>
        Disables <xref linkend="gloss.vt.acpi"/> support.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-S</literal>
      </term>
      <listitem>
       <para>
        &qemu; starts with CPU stopped. To start CPU, enter
        <literal>c</literal> in &qemu; monitor. For more information, see
        <xref
        linkend="cha.qemu.monitor"/>.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
  </sect2>

  <sect2 id="cha.qemu.running.gen_opts.storing_cong">
   <title>Storing and Reading Configuration of Virtual Devices</title>
   <variablelist>
    <varlistentry>
     <term><literal>-readconfig <replaceable>cfg_file</replaceable></literal>
     </term>
     <listitem>
      <para>
       Instead of entering the devices configuration options on the command
       line each time you want to run &vmguest;,
       <command>qemu-system-ARCH</command> can read it from a file that was
       either previously saved with <literal>-writeconfig</literal> or
       edited manually.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>-writeconfig <replaceable>cfg_file</replaceable></literal>
     </term>
     <listitem>
      <para>
       Dumps the current virtual machine's devices configuration to a text
       file. It can be consequently re-used with the
       <literal>-readconfig</literal> option.
       <remark>taroth 2014-08-29: maybe
       update the following with a SLE 12 example? We can but SLE11SP3 is
       still supported, so that's ok</remark>
      </para>
<screen>&prompt.user; qemu-system-ARCH -name "SLES 11 SP3" -M pc-i440fx-2.0 -m 512 -cpu kvm64 \
-smp 2 /images/sles.raw -writeconfig /images/sles.cfg
(exited)
&prompt.user; more /images/sles.cfg
# qemu config file

[drive]
  index = "0"
  media = "disk"
  file = "/images/sles_base.raw"</screen>
      <para>
       This way you can effectively manage the configuration of your virtual
       machines' devices in a well-arranged way.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="cha.qemu.running.gen_opts.rtc">
   <title>Guest Real-Time Clock</title>
   <variablelist>
    <varlistentry>
     <term><literal>-rtc <replaceable>options</replaceable></literal>
     </term>
     <listitem>
      <para>
       Specifies the way the RTC is handled inside a &vmguest;. By default,
       the clock of the guest is derived from that of the host system.
       Therefore, it is recommended that the host system clock is
       synchronized with an accurate external clock (for example, via NTP
       service).
      </para>
      <para>
       If you need to isolate the &vmguest; clock from the host one, specify
       <literal>clock=vm</literal> instead of the default
       <literal>clock=host</literal>.
      </para>
      <para>
       You can also specify a 'starting point' for &vmguest; clock with the
       <literal>base</literal> option:
      </para>
<screen>qemu-system-ARCH [...] -rtc clock=vm,base=2010-12-03T01:02:00</screen>
      <para>
       Instead of a timestamp, you can specify <literal>utc</literal> or
       <literal>localtime</literal>. The former instructs &vmguest; to start
       at the current UTC value (Coordinated Universal Time, see
       <ulink url="http://en.wikipedia.org/wiki/UTC"/>), while the latter
       applies the local time setting.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

<!--
  #!/bin/sh
  #set -x
  bridge=br0
  tap=$(/usr/bin/sudo /bin/tunctl -u $(/usr/bin/whoami) -b)

  /usr/bin/sudo /sbin/ip link set $tap up
  sleep 0.5s
  /usr/bin/sudo /sbin/brctl addif $bridge $tap

  /usr/bin/qemu-system-ARCH -m 512 \
  -boot order=cd,menu=on \
  -drive
  file=/local/kvm/sles11-SP1-vnc15.raw,if=virtio,cache=none,aio=native,boot=on \
  -net nic,model=virtio,macaddr=52:54:00:12:45:80 -net
  tap,ifname=$tap,script=no,downscript=no \
  -vga std \
  -usb -usbdevice tablet \
  -balloon virtio \
  -writeconfig /local/kvm/test.cfn \
  -vnc :15 -k de

  /usr/bin/sudo /sbin/brctl delif $bridge $tap
  /usr/bin/sudo /sbin/ip link set $tap down
  /usr/bin/sudo /bin/tunctl -d $tap
  -->
 </sect1>
 <sect1 id="cha.qemu.running.devices">
  <title>Using Devices in &qemu;</title>

  <para>
   &qemu; virtual machines emulate all devices needed to run a &vmguest;.
   &qemu; supports, for example, several types of network cards, block
   devices (hard and removable drives), <phrase condition="kvm4x86">USB
   devices, </phrase>character devices (serial and parallel
   ports)<phrase
   condition="kvm4x86">, or multimedia devices (graphic and
   sound cards)</phrase>. This section introduces options to configure
   various types of supported devices.
  </para>

  <tip>
   <para>
    If your device, such as <literal>-drive</literal>, needs a special
    driver and driver properties to be set, specify them with the
    <literal>-device</literal> option, and identify with
    <literal>drive=</literal> suboption. For example:
   </para>
<screen>qemu [...] -drive if=none,id=drive0,format=raw \
-device virtio-blk-pci,drive=drive0,scsi=off ...</screen>
   <para>
    To get help on available drivers and their properties, use
    <option>-device ?</option> and <option>-device
    <replaceable>driver</replaceable>,?</option>.
   </para>
  </tip>

  <sect2 id="cha.qemu.running.devices.block">
   <title>Block Devices</title>
   <para>
    Block devices are vital for virtual machines. In general, these are
    fixed or removable storage media usually referred to as 'drives'. One of
    the connected hard drives typically holds the guest operating system to
    be virtualized.
   </para>
   <para>
    <xref linkend="gloss.vt.vm"/> drives are defined with
    <literal>-drive</literal>. This option uses many suboptions, some of
    which are described in this section. For their complete list, see the
    manual page (<command>man 1 qemu</command>).
   </para>
   <variablelist>
    <title>Sub-options for the <literal>-drive</literal> Option</title>
    <varlistentry>
     <term><literal>file=image_fname</literal>
     </term>
     <listitem>
      <para>
       Specifies the path to the disk image that will be used with this
       drive. If not specified, an empty (removable) drive is assumed.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>if=drive_interface</literal>
     </term>
     <listitem>
      <para>
       Specifies the type of interface to which the drive is connected.
       Currently only <literal>floppy</literal>, <literal>scsi</literal>,
       <literal>ide</literal>, or <literal>virtio</literal> are supported by
       &suse;. <literal>virtio</literal> defines a paravirtualized disk
       driver. Default is <literal>ide</literal>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>index=index_of_connector</literal>
     </term>
     <listitem>
      <para>
       Specifies the index number of a connector on the disk interface (see
       the <literal>if</literal> option) where the drive is connected. If
       not specified, the index is automatically incremented.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>media=type</literal>
     </term>
     <listitem>
      <para>
       Specifies the type of media. Can be <literal>disk</literal> for
       hard disks, or <literal>cdrom</literal> for removable CD-ROM drives.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>format=img_fmt</literal>
     </term>
     <listitem>
      <para>
       Specifies the format of the connected disk image. If not specified,
       the format is autodetected. Currently, &suse; supports
       <literal>qcow2</literal>, <literal>qed</literal> and
       <literal>raw</literal> formats.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>cache=method</literal>
     </term>
     <listitem>
      <para>
       Specifies the caching method for the drive. Possible values are
       <literal>unsafe</literal>, <literal>writethrough</literal>,
       <literal>writeback</literal>, <literal>directsync</literal>, or
       <literal>none</literal>. For the <literal>qcow2</literal> image
       format, choose <literal>writeback</literal> if you care about
       performance. <literal>none</literal> disables the host page cache
       and, therefore, is the safest option. Default for image files is
       <literal>writeback</literal>. For more information, see
       <xref
        linkend="cha.qemu.cachemodes"/>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <tip>
    <para>
     To simplify defining of block devices, &qemu; understands several
     shortcuts which you may find handy when entering the
     <literal>qemu-system-ARCH</literal> command line.
    </para>
    <para>
     You can use
    </para>
<screen>qemu-system-ARCH -cdrom /images/cdrom.iso</screen>
    <para>
     instead of
    </para>
<screen>qemu-system-ARCH -drive file=/images/cdrom.iso,index=2,media=cdrom</screen>
    <para>
     and
    </para>
<screen>qemu-system-ARCH -hda /images/imagei1.raw -hdb /images/image2.raw -hdc \
/images/image3.raw -hdd /images/image4.raw</screen>
    <para>
     instead of
    </para>
<screen>qemu-system-ARCH -drive file=/images/image1.raw,index=0,media=disk \
-drive file=/images/image2.raw,index=1,media=disk \
-drive file=/images/image3.raw,index=2,media=disk \
-drive file=/images/image4.raw,index=3,media=disk</screen>
   </tip>
   <tip>
    <title>Using Host Drives Instead of Images</title>
    <para>
     As an alternative to using disk images (see
     <xref
     linkend="cha.qemu.guest_inst.qemu-img"/>) you can also use
     existing &vmhost; disks, connect them as drives, and access them from
     &vmguest;. Use the host disk device directly instead of disk image
     file names.
    </para>
    <para>
     To access the host CD-ROM drive, use
    </para>
<screen>qemu-system-ARCH [...] -drive file=/dev/cdrom,media=cdrom</screen>
    <para>
     To access the host hard disk, use
    </para>
<screen>qemu-system-ARCH [...] -drive file=/dev/hdb,media=disk</screen>
    <para>
     A host drive used by a &vmguest; must not be accessed concurrently by
     the &vmhost; or another &vmguest;.
    </para>
   </tip>
   <sect3 id="kvm.freedisk">
    <title>Freeing Unused Guest Disk Space</title>
    <para>
     A <xref linkend="gloss.vt.storage.sparse"/> is a type of disk image
     file that grows in size as the user adds data to it, taking up only as
     much disk space as is stored in it. For example, if you copy 1 GB of data
     inside the sparse disk image, its size grows by 1 GB. If you then
     delete for example 500 MB of the data, the image size does not by
     default decrease as expected.
    </para>
    <para>
     That is why the <option>discard=on</option> option is introduced on the
     &kvm; command line. It tells the hypervisor to automatically free the
     'holes' after deleting data from the sparse guest image. Note that this
     option is valid only for the <literal>if=scsi</literal> drive
     interface:
    </para>
<screen>qemu-system-ARCH [...] -drive file=/path/to/file.img,if=scsi,discard=on</screen>
    <warning>
     <para>
      <option>if=scsi</option> is not supported. This interface doesn't map
      to <emphasis>virtio-scsi</emphasis>, but rather to the <emphasis>lsi
      scsi adapter</emphasis>.
     </para>
    </warning>
   </sect3>
   <sect3 id="kvm.virtio_data_plane">
    <title>virtio-blk-data-plane</title>
    <para>
     The <emphasis>virtio-blk-data-plane</emphasis> is a new performance
     feature for KVM. It enables a high-performance code path for I/O
     requests coming from &vmguest;s. More specifically, this feature
     introduces dedicated threads (one per virtual block device) to process
     I/O requests going through the <emphasis>virtio-blk</emphasis> driver.
     It makes use of Linux AIO (asynchronous I/O interface) support in the
     &vmhost; Kernel directly&mdash;without the need to go through the QEMU
     block layer. Therefore it can sustain very high I/O rates on storage
     setups.
    </para>
    <para>
     The virtio-blk-data-plane feature can be enabled or disabled by the
     <option>x-data-plane=on|off</option> option on the
     <command>qemu</command> command line when starting the &vmguest;:
    </para>
<screen>qemu [...] -drive if=none,id=drive0,cache=none,aio=native,\
format=raw,file=filename -device virtio-blk-pci,drive=drive0,scsi=off,\
config-wce=off,x-data-plane=on [...]</screen>
    <para>
     As of now, the virtio-blk-data-plane has the following limitations:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       Only raw image format is supported.
      </para>
     </listitem>
     <listitem>
      <para>
       No support for live migration.
      </para>
     </listitem>
     <listitem>
      <para>
       Block jobs and hot unplug operations fail with -EBUSY.
      </para>
     </listitem>
     <listitem>
      <para>
       I/O throttling limits are ignored.
      </para>
     </listitem>
     <listitem>
      <para>
       Only Linux &vmhost;s are supported because of the Linux AIO usage,
       but non-Linux &vmguest;s are supported.
      </para>
     </listitem>
    </itemizedlist>
    <important>
     <para>
      The virtio-blk-data-plane feature is not yet supported in
      &productname;. It is released as a technical preview only.
     </para>
    </important>
   </sect3>
   <sect3 id="kvm.virtio_blk.use_bio">
    <title>Bio-Based I/O Path for virtio-blk</title>
    <para>
     For better performance of I/O-intensive applications, a new I/O path
     was introduced for the virtio-blk interface in kernel version 3.7. This
     bio-based block device driver skips the I/O scheduler, and thus
     shortens the I/O path in guest and has lower latency. It is especially
     useful for high-speed storage devices, such as SSD disks.
    </para>
    <para>
     The driver is disabled by default. To use it, do the following:
    </para>
    <procedure>
     <step>
      <para>
       Append <command>virtio_blk.use_bio=1</command> to the kernel command
       line on the guest. You can do so via
       <menuchoice><guimenu>&yast;</guimenu><guimenu>System</guimenu><guimenu>Boot
       Loader</guimenu></menuchoice>.
      </para>
      <para>
       You can do it also by editing <filename>/etc/default/grub</filename>,
       searching for the line that contains
       <emphasis>GRUB_CMDLINE_LINUX_DEFAULT=</emphasis>, and adding the kernel
       parameter at the end. Then run <command>grub2-mkconfig
       >/boot/grub2/grub.cfg</command> to update the grub2 boot menu.
      </para>
     </step>
     <step>
      <para>
       Reboot the guest with the new kernel command line active.
      </para>
     </step>
    </procedure>
    <tip>
     <title>Bio-Based Driver on Slow Devices</title>
     <para>
      The bio-based virtio-blk driver does not help on slow devices such as
      spin hard disks. The reason is that the benefit of scheduling is
      larger than what the shortened bio path offers. Do not use the
      bio-based driver on slow devices.
     </para>
    </tip>
   </sect3>
  </sect2>

  <sect2 id="cha.qemu.running.devices.graphic">
   <title>Graphic Devices and Display Options</title>
   <para>
    This section describes &qemu; options affecting the type of the emulated
    video card and the way &vmguest; graphical output is displayed.
   </para>
   <sect3 id="cha.qemu.running.devices.graphic.vga">
    <title>Defining Video Cards</title>
    <para>
     &qemu; uses <literal>-vga</literal> to define a video card used to
     display &vmguest; graphical output. The <literal>-vga</literal> option
     understands the following values:
    </para>
    <variablelist>
     <varlistentry>
      <term><literal>none</literal>
      </term>
      <listitem>
       <para>
        Disables video cards on &vmguest; (no video card is emulated). You
        can still access the running &vmguest; via the serial console.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>std</literal>
      </term>
      <listitem>
       <para>
        Emulates a standard VESA 2.0 VBE video card. Use it if you intend to
        use high display resolution on &vmguest;.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>cirrus</literal>
      </term>
      <listitem>
       <para>
        Emulates Cirrus Logic GD5446 video card. Good choice if you insist
        on high compatibility of the emulated video hardware. Most operating
        systems (even Windows 95) recognize this type of card.
       </para>
       <tip>
        <para>
         For best video performance with the <literal>cirrus</literal> type,
         use 16-bit color depth both on &vmguest; and &vmhost;.
        </para>
       </tip>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3 id="cha.qemu.running.devices.graphic.display">
    <title>Display Options</title>
    <para>
     The following options affect the way &vmguest; graphical output is
     displayed.
    </para>
    <variablelist>
     <varlistentry>
      <term><literal>-sdl</literal>
      </term>
      <listitem>
       <para>
        Enables SDL.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-spice option[,option[,...]]</literal>
      </term>
      <listitem>
       <para>
        Enables the spice remote desktop protocol.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-vnc display[,option[,option[,...]]]</literal>
      </term>
      <listitem>
       <para>
        Refer to <xref linkend="cha.qemu.running.vnc"/> for more
        information.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-nographic</literal>
      </term>
      <listitem>
       <para>
        Disables &qemu;'s graphical output. The emulated serial port is
        redirected to the console.
       </para>
       <para>
        After starting the virtual machine with
        <literal>-nographic</literal>, press
        <keycombo><keycap function="control"/><keycap>A</keycap></keycombo>
        <keycap>H</keycap> in the virtual console to view the list of other
        useful shortcuts, for example, to toggle between the console and the
        &qemu; monitor.
       </para>
<screen>&prompt.user; qemu-system-ARCH -hda /images/sles_base.raw -nographic

C-a h    print this help
C-a x    exit emulator
C-a s    save disk data back to file (if -snapshot)
C-a t    toggle console timestamps
C-a b    send break (magic sysrq)
C-a c    switch between console and monitor
C-a C-a  sends C-a
(pressed C-a c)

QEMU 2.0.0 monitor - type 'help' for more information
(qemu)</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-no-frame</literal>
      </term>
      <listitem>
       <para>
        Disables decorations for the &qemu; window. Convenient for dedicated
        desktop workspace.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-full-screen</literal>
      </term>
      <listitem>
       <para>
        Starts &qemu; graphical output in full screen mode.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-no-quit</literal>
      </term>
      <listitem>
       <para>
        Disables the 'close' button of &qemu; window and prevents it from
        being closed by force.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-alt-grab, -ctrl-grab</literal>
      </term>
      <listitem>
       <para>
        By default &qemu; window releases the 'captured' mouse after
        <keycombo><keycap>Ctrl</keycap><keycap>Alt</keycap></keycombo> is
        pressed. You can change the key combination to either
        <keycombo><keycap>Ctrl</keycap><keycap>Alt</keycap><keycap>Shift</keycap></keycombo>
        (<literal>-alt-grab</literal>), or <keycap>Right Ctrl</keycap>
        (<literal>-ctrl-grab</literal>).
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
  </sect2>

  <sect2 id="cha.qemu.running.devices.usb" condition="kvm4x86">
   <title>USB Devices</title>
   <para>
    There are two ways to create USB devices usable by the &vmguest; in
    &kvm;: you can either emulate new USB devices inside a &vmguest;, or
    assign an existing host USB device to a &vmguest;. To use USB devices in
    &qemu; you first need to enable the generic USB driver with the
    <option>-usb</option> option. Then you can specify individual devices
    with the <option>-usbdevice</option> option.
   </para>
   <sect3 id="kvm.usb.emulate">
    <title>Emulating USB Devices in &vmguest;</title>
    <para>
     &suse; currently supports the following types of USB devices:
     <literal>disk</literal>, <literal>host</literal>,
     <literal>serial</literal>, <literal>braille</literal>,
     <literal>net</literal><literal>mouse</literal> and
     <literal>tablet</literal>.
    </para>
    <variablelist>
     <title>Types of USB devices for the <literal>-usbdevice</literal> option</title>
     <varlistentry>
      <term><literal>disk</literal>
      </term>
      <listitem>
       <para>
        Emulates a mass storage device based on file. The optional
        <literal>format</literal> option is used rather than detecting the
        format.
       </para>
<screen>qemu-system-ARCH [...] -usbdevice
        disk:format=raw:/virt/usb_disk.raw</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>host</literal>
      </term>
      <listitem>
       <para>
        Pass through the host device (identified by bus.addr).
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>serial</literal>
      </term>
      <listitem>
       <para>
        Serial converter to a host character device.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>braille</literal>
      </term>
      <listitem>
       <para>
        Emulates a braille device using BrlAPI to display the braille
        output.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>net</literal>
      </term>
      <listitem>
       <para>
        Emulates a network adapter that supports CDC Ethernet and RNDIS
        protocols.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>mouse</literal>
      </term>
      <listitem>
       <para>
        Emulates a virtual USB mouse. This option overrides the default PS/2
        mouse emulation. The following example shows the hardware status of
        a mouse on &vmguest; started with <literal>qemu-system-ARCH [...]
        -usbdevice mouse</literal>:
       </para>
<screen>&prompt.user; sudo hwinfo --mouse
20: USB 00.0: 10503 USB Mouse
[Created at usb.122]
UDI: /org/freedesktop/Hal/devices/usb_device_627_1_1_if0
[...]
Hardware Class: mouse
Model: "Adomax QEMU USB Mouse"
Hotplug: USB
Vendor: usb 0x0627 "Adomax Technology Co., Ltd"
Device: usb 0x0001 "QEMU USB Mouse"
[...]</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>tablet</literal>
      </term>
      <listitem>
       <para>
        Emulates a pointer device that uses absolute coordinates (such as
        touchscreen). This option overrides the default PS/2 mouse
        emulation. The tablet device is useful if you are viewing &vmguest;
        via the VNC protocol. See <xref linkend="cha.qemu.running.vnc"/> for
        more information.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3 id="kvm.usb.passthru">
    <title>&usbback;</title>
    <para>
     To assign an existing host USB device to a &vmguest;, you need to find
     out its host bus and device ID.
    </para>
<screen>&exampleuser;@vmhost:~> lsusb
[...]
Bus 002 Device 005: ID 12d1:1406 Huawei Technologies Co., Ltd. E1750
[...]</screen>
    <para>
     In the above example, we want to assign a USB stick connected to the
     host's USB bus number 2 with device number 5. Now run the &vmguest;
     with the following additional options:
    </para>
<screen>qemu-system-ARCH [...] -usb -device usb-host,hostbus=2,hostaddr=5</screen>
    <para>
     After the guest is booted, check that the assigned USB device is
     present on it.
    </para>
<screen>&exampleuser;@vmguest:~> lsusb
[...]
Bus 001 Device 002: ID 12d1:1406 Huawei Technologies Co., Ltd. E1750
[...]</screen>
    <note>
     <para>
      The guest operating system must take care of mounting the assigned USB
      device so that it is accessible for the user.
     </para>
    </note>
   </sect3>
  </sect2>

  <sect2 id="kvm.pciback" condition="kvm4x86">
   <title>&pciback;</title>
   <para>
    &pciback; is a technique to give your &vmguest; exclusive access to a
    PCI device.
   </para>
   <note>
    <title>Prereqisites</title>
    <para>
     To make use of &pciback;, your motherboard chipset, BIOS, and CPU must
     have support for <xref linkend="gloss.vt.acronym.iommu"/> (AMD) or
     <xref
     linkend="gloss.vt.acronym.vtd"/> (Intel) virtualization
     technology. To make sure that your computer supports this feature, ask
     your supplier specifically to deliver a system that supports &pciback;.
    </para>
    <para>
     Assigning graphics cards is not supported by &suse;.
    </para>
   </note>
   <note>
    <title>Consider Using libvirt for Setting Up &pciback;</title>
    <para>
     There are some factors affecting successful &pciback; that are best
     handled programmatically. If you encounter problems, consider instead
     relying on libvirt to manage guests that use &pciback; devices. Refer
     to <xref linkend="sec.libvirt.config.pci.virsh"/> or
     <xref
     linkend="sec.libvirt.config.pci"/> for details.
    </para>
   </note>
   <procedure>
    <title>Configuring &pciback;</title>
    <step>
     <para>
      Check whether <xref linkend="gloss.vt.acronym.iommu"/> is actively
      enabled and recognized on the host. Run <command>sudo dmesg | grep -e
      DMAR -e IOMMU</command> on Intel machines, or <command>sudo dmesg |
      grep AMD-Vi</command> on AMD machines. If you get no output, edit your
      boot loader configuration and add <literal>intel_iommu=on</literal>
      (Intel machines) or <literal>iommu=pt iommu=1</literal> (AMD
      machines). Then reboot the host machine. Also make sure that
      <xref linkend="gloss.vt.acronym.iommu"/>
      (<xref
      linkend="gloss.vt.acronym.vtd"/>) has been enabled in the
      BIOS/firmware.
     </para>
    </step>
    <step>
     <para>
      Identify the host PCI device to assign to the guest.
     </para>
<screen>&exampleuser;@vmhost:~> sudo lspci -nn
[...] 00:1b.0 Audio device [0403]: Intel Corporation 82801H (ICH8 Family) \
HD Audio Controller [8086:284b] (rev 02) [...]</screen>
     <para>
      Note down the device (<literal>00:1b.0</literal>) and vendor
      (<literal>8086:284b</literal>) ID.
     </para>
    </step>
    <step>
     <para>
      Unbind the device from host Kernel driver and bind it to the PCI stub
      driver.
     </para>
<screen>&exampleuser;@vmhost:~> sudo modprobe pci_stub
&exampleuser;@vmhost:~> sudo echo "8086 284b" > /sys/bus/pci/drivers/pci-stub/new_id
&exampleuser;@vmhost:~> sudo echo "0000:00:1b.0" > /sys/bus/pci/devices/0000:00:1b.0/driver/unbind
&exampleuser;@vmhost:~> sudo echo "0000:00:1b.0" > /sys/bus/pci/drivers/pci-stub/bind</screen>
    </step>
    <step>
     <para>
      Now run the &vmguest; with the PCI device assigned.
     </para>
<screen>qemu-system-ARCH [...] -device pci-assign,host=00:1b.0</screen>
    </step>
   </procedure>
   <note>
    <para>
     If the PCI device shares IRQ with other devices, it cannot be assigned
     to a &vmguest;.
    </para>
   </note>
   <para>
    &kvm; also supports PCI device hotplugging to a &vmguest;. To achieve
    this, you need to switch to a &qemu; monitor (see
    <xref
     linkend="cha.qemu.monitor"/> for more information) and issue
    the following commands:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      hot-add:
     </para>
<screen>device_add pci-assign,host=00:1b.0,id=new_pci_device</screen>
    </listitem>
    <listitem>
     <para>
      hot-remove:
     </para>
<screen>device_del new_pci_device</screen>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 id="kvm.vfio">
   <title>VFIO: Secure Direct Access to Devices</title>
   <para>
    <xref linkend="vt.io.vfio"/> stands for <emphasis>Virtual Function
    I/O</emphasis> and is a new user-level driver framework for Linux. It is
    meant to replace the traditional PCI device assignment. The
    <xref linkend="vt.io.vfio"/> driver exposes direct device access to
    userspace in a secure memory (<xref linkend="gloss.vt.acronym.iommu"/>)
    protected environment.
   </para>
   <para>
    Compared to &kvm; PCI device assignment, <xref linkend="vt.io.vfio"/>
    interface has the following advantages:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Resource access is compatible with secure boot.
     </para>
    </listitem>
    <listitem>
     <para>
      Device is isolated and its memory access protected.
     </para>
    </listitem>
    <listitem>
     <para>
      Offers user space device driver with more flexible device ownership
      model.
     </para>
    </listitem>
    <listitem>
     <para>
      Is independent of &kvm; technology, and not bound to x86 architecture
      only.
     </para>
    </listitem>
   </itemizedlist>
   <sect3 id="kvm.vfio.groups">
    <title>IOMMU Groups</title>
    <para>
     The <xref linkend="gloss.vt.acronym.iommu"/> (input/output memory
     management unit that connects a direct memory access-capable I/O bus to
     the main memory) API supports the notion of groups. A group is a set of
     devices that can be isolated from all other devices in the system.
     Groups are therefore the unit of ownership used by
     <xref linkend="vt.io.vfio"/>.
    </para>
    <para>
     To find the <xref linkend="gloss.vt.acronym.iommu"/> group for your PCI
     device, you first need to identify it. Use <command>hwinfo</command> or
     <command>lspci</command> to find its bus ID. Suppose you want to find an
     <xref linkend="gloss.vt.acronym.iommu"/> group for the following
     device:
    </para>
<screen>01:10.0 Ethernet controller: Intel Corporation 82576 Virtual Function (rev 01)</screen>
    <para>
     Run the following to find the group:
    </para>
<screen># readlink /sys/bus/pci/devices/0000:01:10.0/iommu_group
../../../../kernel/iommu_groups/15</screen>
    <para>
     The <xref linkend="gloss.vt.acronym.iommu"/> group number is 15. Now
     you can check the devices belonging to the same
     <xref linkend="gloss.vt.acronym.iommu"/> group:
    </para>
<screen>ls -l /sys/bus/pci/devices/0000:01:10.0/iommu_group/devices/0000:01:10.0
[...] 0000:00:1e.0 -> ../../../../devices/pci0000:00/0000:00:1e.0
[...] 0000:01:10.0 -> ../../../../devices/pci0000:00/0000:00:1e.0/0000:01:10.0
[...] 0000:01:10.1 -> ../../../../devices/pci0000:00/0000:00:1e.0/0000:01:10.1</screen>
   </sect3>
   <sect3 id="kvm.vfio.assign">
    <title>Device Assignment</title>
    <para>
     To assign a device to <xref linkend="vt.io.vfio"/> driver, follow these
     steps:
    </para>
    <procedure>
     <step>
      <para>
       Unbind the device from the device driver:
      </para>
<screen># echo 0000:01:10.0 | sudo tee \
/sys/bus/pci/devices/0000:01:10.0/driver/unbind</screen>
     </step>
     <step>
      <para>
       Find the vendor and device ID of the PCI device you want to assign to
       <xref linkend="vt.io.vfio"/>:
      </para>
<screen># lspci -n -s 01:10.0
01:10.0 0200: 8086:10ca (rev 01)</screen>
     </step>
     <step>
      <para>
       Load the <literal>vfio-pci</literal> driver:
      </para>
<screen># modprobe vfio-pci</screen>
     </step>
     <step>
      <para>
       Now bind the device to the <literal>vfio-pci</literal> driver:
      </para>
<screen># echo 8086 10ca | sudo tee \
/sys/bus/pci/drivers/vfio-pci/new_id</screen>
     </step>
     <step>
      <para>
       After the assignment is done, check the vfio device belongs to
       <xref linkend="gloss.vt.acronym.iommu"/> group 15:
      </para>
<screen># ls /dev/vfio
15 vfio</screen>
     </step>
    </procedure>
   </sect3>
   <sect3 id="kvm.vfio.start">
    <title>Starting <command>qemu-system-ARCH</command> with <literal>vfio-pci</literal></title>
    <para>
     After you assigned the PCI device to the <literal>vfio-pci</literal>
     driver, you can include it in the <command>qemu-system-ARCH</command>
     command line:
    </para>
<screen># sudo qemu-system-ARCH [...] -device vfio-pci,host=01:10.0,id=net0</screen>
   </sect3>
   <sect3 id="kvm.vfio.more">
    <title>For More Information</title>
    <para>
     You can find more detailed information on the
     <xref linkend="vt.io.vfio"/> driver in the
     <filename>/usr/src/linux/Documentation/vfio.txt</filename> file
     (package <systemitem>kernel-source</systemitem> has to be installed).
    </para>
    <para>
     You can find a useful (but slightly outdated) presentation at
     <ulink
     url="http://www.linux-kvm.org/wiki/images/b/b4/2012-forum-VFIO.pdf"/>.
    </para>
   </sect3>
  </sect2>

  <sect2 id="cha.qemu.running.devices.char">
   <title>Character Devices</title>
   <para>
    Use <literal>-chardev</literal> to create a new character device. The
    option uses the following general syntax:
   </para>
<screen>qemu-system-ARCH [...] -chardev <replaceable>backend_type</replaceable>,id=<replaceable>id_string</replaceable></screen>
   <para>
    where <replaceable>backend_type</replaceable> can be one of
    <literal>null</literal>, <literal>socket</literal>,
    <literal>udp</literal>, <literal>msmouse</literal>,
    <literal>vc</literal>, <literal>file</literal>, <literal>pipe</literal>,
    <literal>console</literal>, <literal>serial</literal>,
    <literal>pty</literal>, <literal>stdio</literal>,
    <literal>braille</literal>, <literal>tty</literal>, or
    <literal>parport</literal>. All character devices must have a unique
    identification string up to 127 characters long. It is used to identify
    the device in other related directives. For the complete description of
    all back-end's suboptions, see the manual page (<command>man 1
    qemu</command>). A brief description of the available
    <literal>back-ends</literal> follows:
   </para>
   <variablelist>
    <varlistentry>
     <term><literal>null</literal>
     </term>
     <listitem>
      <para>
       Creates an empty device that outputs no data and drops any data it
       receives.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>stdio</literal>
     </term>
     <listitem>
      <para>
       Connects to &qemu;'s process standard input and standard output.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>socket</literal>
     </term>
     <listitem>
      <para>
       Creates a two-way stream socket. If <replaceable>path</replaceable>
       is specified, a Unix socket is created:
      </para>
<screen>qemu-system-ARCH [...] -chardev \
socket,id=unix_socket1,path=/tmp/unix_socket1,server</screen>
      <para>
       The <replaceable>server</replaceable> suboption specifies that the
       socket is a listening socket.
      </para>
      <para>
       If <replaceable>port</replaceable> is specified, a TCP socket is
       created:
      </para>
<screen>qemu-system-ARCH [...] -chardev \
socket,id=tcp_socket1,host=localhost,port=7777,server,nowait</screen>
      <para>
       The command creates a local listening (<literal>server</literal>) TCP
       socket on port 7777. &qemu; will not block waiting for a client to
       connect to the listening port (<literal>nowait</literal>).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>udp</literal>
     </term>
     <listitem>
      <para>
       Sends all network traffic from &vmguest; to a remote host over the
       UDP protocol.
      </para>
<screen>qemu-system-ARCH [...] -chardev udp,id=udp_fwd,host=&wsIVname;,port=7777</screen>
      <para>
       The command binds port 7777 on the remote host &wsIVname; and sends
       &vmguest; network traffic there.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>vc</literal>
     </term>
     <listitem>
      <para>
       Creates a new &qemu; text console. You can optionally specify the
       dimensions of the virtual console:
      </para>
<screen>qemu-system-ARCH [...] -chardev vc,id=vc1,width=640,height=480 -mon chardev=vc1</screen>
      <para>
       The command creates a new virtual console called
       <literal>vc1</literal> of the specified size, and connects the &qemu;
       monitor to it.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>file</literal>
     </term>
     <listitem>
      <para>
       Logs all traffic from &vmguest; to a file on &vmhost;. The
       <literal>path</literal> is required and will be created if it does
       not exist.
      </para>
<screen>qemu-system-ARCH [...] -chardev file,id=qemu_log1,path=/var/log/qemu/guest1.log</screen>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    By default &qemu; creates a set of character devices for serial and
    parallel ports, and a special console for &qemu; monitor. You can,
    however, create your own character devices and use them for the just
    mentioned purposes. The following options will help you:
   </para>
   <variablelist>
    <varlistentry>
     <term><literal>-serial <replaceable>char_dev</replaceable></literal>
     </term>
     <listitem>
      <para>
       Redirects the &vmguest;'s virtual serial port to a character device
       <replaceable>char_dev</replaceable> on &vmhost;. By default, it is a
       virtual console (<literal>vc</literal>) in graphical mode, and
       <literal>stdio</literal> in non-graphical mode. The
       <literal>-serial</literal> understands many suboptions. See the
       manual page <command>man 1 qemu</command> for a complete list of them.
      </para>
      <para>
       You can emulate up to 4 serial ports. Use <literal>-serial
       none</literal> to disable all serial ports.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>-parallel <replaceable>device</replaceable></literal>
     </term>
     <listitem>
      <para>
       Redirects the &vmguest;'s parallel port to a
       <replaceable>device</replaceable>. This option supports the same
       devices as <literal>-serial</literal>.
      </para>
      <tip>
       <para>
        With &sls; as a &vmhost;, you can directly use the hardware parallel
        port devices <filename>/dev/parportN</filename> where
        <literal>N</literal> is the number of the port.
       </para>
      </tip>
      <para>
       You can emulate up to 3 parallel ports. Use <literal>-parallel
       none</literal> to disable all parallel ports.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>-monitor <replaceable>char_dev</replaceable></literal>
     </term>
     <listitem>
      <para>
       Redirects the &qemu; monitor to a character device
       <replaceable>char_dev</replaceable> on &vmhost;. This option supports
       the same devices as <literal>-serial</literal>. By default, it is a
       virtual console (<literal>vc</literal>) in a graphical mode, and
       <literal>stdio</literal> in non-graphical mode.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    For a complete list of available character devices back-ends, see the
    man page (<command>man 1 qemu</command>).
   </para>
  </sect2>
 </sect1>
 <sect1 id="cha.qemu.running.networking">
  <title>Networking in &qemu;</title>

  <para>
   Use the <literal>-net</literal> option to define a network interface and
   a specific type of networking for your &vmguest;. Currently, &suse;
   supports the following options: <literal>none</literal>,
   <literal>nic</literal>, <literal>user</literal>,
   <literal>bridge</literal>, and <literal>tap</literal>. For a complete
   list of <literal>-net</literal> suboptions, see the manual page
   (<command>man 1 qemu</command>).
  </para>

  <variablelist>
   <title>Supported <literal>-net</literal> Suboptions</title>
   <varlistentry>
    <term><literal>bridge</literal>
    </term>
    <listitem>
     <para>
      Uses a specified network helper to configure the TAP interface and
      attach it to a specified bridge. For more information, see
      <xref
       linkend="cha.qemu.running.networking.bridge"/>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>nic</literal>
    </term>
    <listitem>
     <para>
      Creates a new Network Interface Card (NIC) and connects it to a
      specified Virtual Local Area Network (VLAN). For more information, see
      <xref linkend="cha.qemu.running.networking.nic"/>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>user</literal>
    </term>
    <listitem>
     <para>
      Specifies user-mode networking. For more information, see
      <xref
       linkend="cha.qemu.running.networking.usermode"/>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>tap</literal>
    </term>
    <listitem>
     <para>
      Specifies bridged or routed networking. For more information, see
      <xref
       linkend="cha.qemu.running.networking.bridge"/>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <sect2 id="cha.qemu.running.networking.nic">
   <title>Defining a Network Interface Card</title>
   <para>
    Use <literal>-net nic</literal> to add a new emulated network card:
   </para>
<screen>qemu-system-ARCH [...] -net nic,vlan=1<co id="co.qemu.running.networking.nic.vlan"/>,macaddr=&wsIVmac;<co id="co.qemu.running.networking.nic.mac"/>,\
model=virtio<co id="co.qemu.running.networking.nic.model"/>,name=ncard1<co
id="co.qemu.running.networking.nic.name"/> -net user</screen>
   <calloutlist>
    <callout arearefs="co.qemu.running.networking.nic.vlan">
     <para>
      Connects the network interface to VLAN number 1. You can specify your
      own number,&mdash;it is mainly useful for identification purpose. If you
      omit this suboption, &qemu; uses the default 0.
     </para>
    </callout>
    <callout arearefs="co.qemu.running.networking.nic.mac">
     <para>
      Specifies the Media Access Control (MAC) address for the network card.
      It is a unique identifier and you are advised to always specify it. If
      not, &qemu; supplies its own default MAC address and creates a
      possible MAC address conflict within the related VLAN.
     </para>
    </callout>
    <callout arearefs="co.qemu.running.networking.nic.model">
     <para>
      Specifies the model of the network card. Use <literal>-net
      nic,model=?</literal> to get the list of all network card models
      supported by &qemu; on your platform:
     </para>
     <para>
      Currently, &suse; supports the models <literal>rtl8139</literal>,
      <literal>e1000</literal> and <literal>virtio</literal>.
     </para>
    </callout>
   </calloutlist>
  </sect2>

  <sect2 id="cha.qemu.running.networking.usermode">
   <title>User-Mode Networking</title>
   <para>
    The <literal>-net user</literal> option instructs &qemu; to use 
    user-mode networking. This is the default if no networking mode is
    selected. Therefore, these command lines are equivalent:
   </para>
<screen>qemu-system-ARCH -hda /images/sles_base.raw</screen>
<screen>qemu-system-ARCH -hda /images/sles_base.raw -net nic -net user</screen>
   <para>
    This mode is useful if you want to allow the &vmguest; to access the
    external network resources, such as the Internet. By default, no incoming
    traffic is permitted and therefore, the &vmguest; is not visible to
    other machines on the network. No administrator privileges are required
    in this networking mode. The user-mode is also useful  for doing a
    'network-booting' on your &vmguest; from a local directory on &vmhost;.
   </para>
   <para>
    The &vmguest; allocates an IP address from a virtual DHCP server.
    &vmhost; (the DHCP server) is reachable at 10.0.2.2, while the IP
    address range for allocation starts from 10.0.2.15. You can use
    <command>ssh</command> to connect to &vmhost; at 10.0.2.2, and
    <command>scp</command> to copy files back and forth.
   </para>
   <sect3 id="cha.qemu.running.networking.usermode.examples">
    <title>Command Line Examples</title>
    <para>
     This section shows several examples on how to set up user-mode
     networking with &qemu;.
    </para>
    <example id="ex.qemu.net.usermode.resctrict">
     <title>Restricted User-mode Networking</title>
<screen>qemu-system-ARCH [...] -net user<co id="co.usermode.user"/>,vlan=1<co id="co.usermode.vlan"/>,name=user_net1<co id="co.usermode.name"/>,restrict=yes<co id="co.usermode.restrict"/></screen>
     <calloutlist>
      <callout arearefs="co.usermode.user">
       <para>
        Specifies user-mode networking.
       </para>
      </callout>
      <callout arearefs="co.usermode.vlan">
       <para>
        Connects to VLAN number 1. If omitted, defaults to 0.
       </para>
      </callout>
      <callout arearefs="co.usermode.name">
       <para>
        Specifies a human-readable name of the network stack. Useful when
        identifying it in the &qemu; monitor.
       </para>
      </callout>
      <callout arearefs="co.usermode.restrict">
       <para>
        Isolates &vmguest;. It will not be able to communicate with &vmhost;
        and no network packets will be routed to the external network.
       </para>
      </callout>
     </calloutlist>
    </example>
    <example id="ex.qemu.net.usermode.iprange">
     <title>User-mode Networking with Custom IP Range</title>
<screen>qemu-system-ARCH [...] -net user,net=10.2.0.0/8<co id="co.usermode.net"/>,host=10.2.0.6<co id="co.usermode.host"/>,dhcpstart=10.2.0.20<co id="co.usermode.dhcpstart"/>,\
hostname=tux_kvm_guest<co id="co.usermode.hostname"/></screen>
     <calloutlist>
      <callout arearefs="co.usermode.net">
       <para>
        Specifies the IP address of the network that &vmguest; sees and
        optionally the netmask. Default is 10.0.2.0/8.
       </para>
      </callout>
      <callout arearefs="co.usermode.host">
       <para>
        Specifies the &vmhost; IP address that &vmguest; sees. Default is
        10.0.2.2.
       </para>
      </callout>
      <callout arearefs="co.usermode.dhcpstart">
       <para>
        Specifies the first of the 16 IP addresses that the built-in DHCP
        server can assign to &vmguest;. Default is 10.0.2.15.
       </para>
      </callout>
      <callout arearefs="co.usermode.hostname">
       <para>
        Specifies the host name that the built-in DHCP server will assign to
        &vmguest;.
       </para>
      </callout>
     </calloutlist>
    </example>
    <example id="ex.qemu.net.usermode.netboot_tftp">
     <title>User-mode Networking with Network-boot and TFTP</title>
<screen>qemu-system-ARCH [...] -net user,tftp=/images/tftp_dir<co id="co.usermode.tftp"/>,bootfile=/images/boot/pxelinux.0<co id="co.usermode.bootfile"/></screen>
     <calloutlist>
      <callout arearefs="co.usermode.tftp">
       <para>
        Activates a built-in TFTP (a file transfer protocol with the
        functionality of a very basic FTP) server. The files in the
        specified directory will be visible to a &vmguest; as the root of a
        TFTP server.
       </para>
      </callout>
      <callout arearefs="co.usermode.bootfile">
       <para>
        Broadcasts the specified file as a BOOTP (a network protocol that
        offers an IP address and a network location of a boot image, often
        used in diskless workstations) file. When used together with
        <literal>tftp</literal>, the &vmguest; can boot from network from
        the local directory on the host.
       </para>
      </callout>
     </calloutlist>
    </example>
    <example id="ex.qemu.net.usermode.hostfwd">
     <title>User-mode Networking with Host Port Forwarding</title>
<screen>qemu-system-ARCH [...] -net user,hostfwd=tcp::2222-:22</screen>
     <para>
      Forwards incoming TCP connections to the port 2222 on the host to the
      port 22 (<systemitem class="service">SSH</systemitem>) on &vmguest;.
      If <systemitem class="daemon">sshd</systemitem> is running on
      &vmguest;, enter
     </para>
<screen>ssh qemu_host -p 2222</screen>
     <para>
      where <literal>qemu_host</literal> is the host name or IP address of
      the host system, to get a <systemitem class="daemon">SSH</systemitem>
      prompt from &vmguest;.
     </para>
    </example>
   </sect3>
  </sect2>

  <sect2 id="cha.qemu.running.networking.bridge">
   <title>Bridged Networking</title>
   <para>
    With the <literal>-net tap</literal> option, &qemu; creates a network
    bridge by connecting the host TAP network device to a specified VLAN of
    &vmguest;. Its network interface is then visible to the rest of the
    network. This method does not work by default and has to be explicitly
    specified.
   </para>
   <para>
    First, create a network bridge and add a &vmhost; physical network
    interface (usually <literal>eth0</literal>) to it:
   </para>
   <procedure>
    <step>
     <para>
      Start &yastcc; and select <menuchoice><guimenu>Network
      Devices</guimenu><guimenu>Network Settings</guimenu></menuchoice>.
     </para>
    </step>
    <step>
     <para>
      Click <guimenu>Add</guimenu> and select <guimenu>Bridge</guimenu> from
      the <guimenu>Device Type</guimenu> drop-down list in the
      <guimenu>Hardware Dialog</guimenu> window. Click
      <guimenu>Next</guimenu>.
     </para>
    </step>
    <step>
     <para>
      Choose whether you need a dynamically or statically assigned IP
      address, and fill the related network settings if applicable.
     </para>
    </step>
    <step>
     <para>
      In the <guimenu>Bridged Devices</guimenu> pane, select the Ethernet
      device to add to the bridge.
     </para>
     <figure>
      <title>Configuring Network Bridge with &yast;</title>
      <mediaobject>
       <imageobject role="fo">
        <imagedata fileref="qemu_yast_bridge_eth0.png" width="70%" format="PNG"/>
       </imageobject>
       <imageobject role="html">
        <imagedata fileref="qemu_yast_bridge_eth0.png" width="70%" format="PNG"/>
       </imageobject>
      </mediaobject>
     </figure>
     <para>
      Click <guimenu>Next</guimenu>. When asked about adapting an already
      configured device, click <guimenu>Continue</guimenu>.
     </para>
    </step>
    <step>
     <para>
      Click <guimenu>OK</guimenu> to apply the changes. Check if the bridge
      is created:
     </para>
<screen>&prompt.user; brctl show
bridge name bridge id          STP enabled  interfaces
br0         8000.001676d670e4  no           eth0</screen>
    </step>
   </procedure>
   <sect3>
    <title>Connecting to a Bridge Manually</title>
    <para>
     Use the following example script to connect &vmguest; to the newly
     created bridge interface <literal>br0</literal>. Several commands in
     the script are run via the <command>sudo</command> mechanism because
     they require &rootuser; privileges.
    </para>
    <note>
     <para>
      Make sure the <systemitem>tunctl</systemitem> and
      <systemitem>bridge-utils</systemitem> packages are installed on the
      &vmhost;. If not, install them with <command>zypper in tunctl
      bridge-utils</command>.
     </para>
    </note>
<screen>
#!/bin/bash
bridge=br0<co id="co.qemu.net.bridge.br"/>
tap=$(sudo tunctl -u $(whoami) -b)<co id="co.qemu.net.bridge.tap"/>
sudo ip link set $tap up<co id="co.qemu.net.bridge.up"/>
sleep 1s<co id="co.qemu.net.bridge.sleep"/>
sudo brctl addif $bridge $tap<co id="co.qemu.net.bridge.br3"/>
qemu-system-ARCH -m 512 -hda /images/sles_base.raw \
-net nic,vlan=0,model=virtio,macaddr=&wsIVmac; \
-net tap,vlan=0,ifname=$tap<co id="co.qemu.net.bridge.ifname"/>,script=no<co id="co.qemu.net.bridge.script"/>,downscript=no
sudo brctl delif $bridge $tap<co id="co.qemu.net.bridge.delif"/>
sudo ip link set $tap down<co id="co.qemu.net.bridge.linkdown"/>
sudo tunctl -d $tap<co id="co.qemu.net.bridge.deltap"/></screen>
    <calloutlist>
     <callout arearefs="co.qemu.net.bridge.br">
      <para>
       Name of the bridge device.
      </para>
     </callout>
     <callout arearefs="co.qemu.net.bridge.tap">
      <para>
       Prepare a new TAP device and assign it to the user who runs the
       script. TAP devices are virtual network devices often used for
       virtualization and emulation setups.
      </para>
     </callout>
     <callout arearefs="co.qemu.net.bridge.up">
      <para>
       Bring up the newly created TAP network interface.
      </para>
     </callout>
     <callout arearefs="co.qemu.net.bridge.sleep">
      <para>
       Make a 1-second pause to make sure the new TAP network interface is
       really up.
      </para>
     </callout>
     <callout arearefs="co.qemu.net.bridge.br3">
      <para>
       Add the new <literal>TAP</literal> device to the network bridge
       <literal>br0</literal>.
      </para>
     </callout>
     <callout arearefs="co.qemu.net.bridge.ifname">
      <para>
       The <literal>ifname=</literal> suboption specifies the name of the
       TAP network interface used for bridging.
      </para>
     </callout>
     <callout arearefs="co.qemu.net.bridge.script">
      <para>
       Before <command>qemu-system-ARCH</command> connects to a network
       bridge, it checks the <literal>script</literal> and
       <literal>downscript</literal> values. If it finds the specified
       scripts on the &vmhost; file system, it runs the
       <literal>script</literal> before it connects to the network bridge
       and <literal>downscript</literal> after it exits the network
       environment. You can use these scripts to first set up and bring up
       the bridged network devices, and then to deconfigure them. By
       default, <filename>/etc/qemu-ifup</filename> and
       <filename>/etc/qemu-ifdown</filename> are examined. If
       <literal>script=no</literal> and <literal>downscript=no</literal> are
       specified, the script execution is disabled and you have to take care of
       it manually.
      </para>
     </callout>
     <callout arearefs="co.qemu.net.bridge.delif">
      <para>
       Deletes the TAP interface from a network bridge
       <literal>br0</literal>.
      </para>
     </callout>
     <callout arearefs="co.qemu.net.bridge.linkdown">
      <para>
       Sets the state of the TAP device to 'down'.
      </para>
     </callout>
     <callout arearefs="co.qemu.net.bridge.deltap">
      <para>
       Deconfigures the TAP device.
      </para>
     </callout>
    </calloutlist>
   </sect3>
   <sect3 id="qemu.bridge.helper">
    <title>Connecting to a Bridge with qemu-bridge-helper</title>
    <para>
     Another way to connect &vmguest; to a network through a network bridge
     is by means of the <filename>qemu-bridge-helper</filename> helper
     program. It configures the TAP interface for you, and attaches it to
     the specified bridge. The default helper executable is
     <filename>/usr/lib64/qemu-bridge-helper</filename>. The helper
     executable is setuid root, which is only executable by the members of
     the virtualization group (<literal>kvm</literal>). Therefore the
     <command>qemu-system-ARCH</command> command itself does not have to be
     run under &rootuser; privileges.
    </para>
    <para>
     You can call the helper the following way:
    </para>
<screen>qemu-system-ARCH [...] -net nic,vlan=0,model=virtio -net bridge,vlan=0,br=br0</screen>
    <para>
     You can specify your own custom helper script that will take care of
     the TAP device (de)configuration, with the
     <option>helper=/path/to/your/helper</option> option:
    </para>
<screen>qemu-system-ARCH [...] -net bridge,vlan=0,br=br1,helper=/path/to/bridge-helper</screen>
    <tip>
     <para>
      To define access privileges to <literal>qemu-bridge-helper</literal>,
      inspect the <filename>/etc/qemu-system-ARCH/bridge.conf</filename>
      file. For example the following directive
     </para>
<screen>allow br0</screen>
     <para>
      allows the <command>qemu-system-ARCH</command> command to connect its
      &vmguest; to the network bridge <literal>br0</literal>.
     </para>
    </tip>
   </sect3>
  </sect2>

  <sect2 id="kvm.qemu.vnet">
   <title>Accelerated Networking with <systemitem>vhost-net</systemitem></title>
   <para>
    The <systemitem>vhost-net</systemitem> module is used to accelerate
    &kvm;'s paravirtualized network drivers. It provides better latency and
    greater throughput for network.
   </para>
   <para>
    To make use of the module, verify that the host's running Kernel has
    <literal>CONFIG_VHOST_NET</literal> turned on or enabled as a module:
   </para>
<screen>grep CONFIG_VHOST_NET /boot/config-`uname -r`</screen>
   <para>
    Also verify that the guest's running Kernel has
    <literal>CONFIG_PCI_MSI</literal> enabled:
   </para>
<screen>grep CONFIG_PCI_MSI /boot/config-`uname -r`</screen>
   <para>
    If both conditions are met, use the <literal>vhost-net</literal> driver
    by starting the guest with the following example command line:
   </para>
<screen>qemu-system-ARCH [...] -netdev tap,id=guest0,vhost=on,script=no
-net nic,model=virtio,netdev=guest0,macaddr=00:16:35:AF:94:4B</screen>
   <para>
    Note that <literal>guest0</literal> is an identification string of the
    vhost-driven device.
   </para>
  </sect2>

  <sect2 id="kvm.qemu.multiqueue">
   <title>Scaling Network Performance with Multiqueue virtio-net</title>
   <para>
    As the number of virtual CPUs increases in &vmguest;s, &qemu; offers a
    way of improving the network performance using
    <emphasis>multiqueue</emphasis>. Multiqueue virtio-net scales the
    network performance by allowing &vmguest; virtual CPUs to transfer
    packets in parallel. Multiqueue support is required on both &vmhost; and
    &vmguest; side.
   </para>
   <tip>
    <title>Performance Benefit</title>
    <para>
     The Multiqueue virtio-net solution is most beneficial in the following cases:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       Network traffic packets are large.
      </para>
     </listitem>
     <listitem>
      <para>
       &vmguest; has more connections active at the same time, mainly
       between the guest systems, or between the guest and the host, or
       between the guest and an external system.
      </para>
     </listitem>
     <listitem>
      <para>
       The number of active queues is equal to the number of virtual CPUs in
       the &vmguest;.
      </para>
     </listitem>
    </itemizedlist>
   </tip>
   <note>
    <para>
     While multiqueue virtio-net increases the total network throughput, it
     increases CPU consumption as it makes use of the virtual CPU's power.
    </para>
   </note>
   <procedure id="kvm.qemu.mq.enable">
    <title>How to Enable Multiqueue virtio-net</title>
    <para>
     The following procedure lists important steps to enable the multiqueue
     feature with <command>qemu-system-ARCH</command>. It assumes that a tap
     network device with multiqueue capability (supported since kernel
     version 3.8) is set up on the &vmhost;.
    </para>
    <step>
     <para>
      In <command>qemu-system-ARCH</command>, enable multiqueue for the tap
      device:
     </para>
<screen>-netdev tap,vhost=on,queues=<replaceable>N</replaceable></screen>
     <para>
      where <literal>N</literal> stands for the number of queue pairs.
     </para>
    </step>
    <step>
     <para>
      In <command>qemu-system-ARCH</command>, enable multiqueue and specify
      MSI-X (Message Signaled Interrupt) vectors for the virtio-net-pci
      device:
     </para>
<screen>-device virtio-net-pci,mq=on,vectors=<replaceable>2*N+2</replaceable></screen>
     <para>
      where the formula for the number of MSI-X vectors results from: N
      vectors for TX (transmit) queues, N for RX (receive) queues, one for
      configuration purposes, and one for possible VQ (vector quantization)
      control.
     </para>
    </step>
    <step>
     <para>
      In &vmguest;, enable multiqueue on the relevant network interface
      (<literal>eth0</literal> in this example):
     </para>
<screen>ethtool -L eth0 combined 2*N</screen>
    </step>
   </procedure>
   <para>
    The resulting <command>qemu-system-ARCH</command> command line will look
    similar to the following example:
   </para>
<screen>qemu-system-ARCH [...] -netdev tap,id=guest0,queues=4,vhost=on \
-device virtio-net-pci,netdev=guest0,mq=on,vectors=10</screen>
   <para>
    Note that the <literal>id</literal> of the network device
    (<literal>guest0</literal> ) needs to be identical for both options.
   </para>
   <para>
    Inside the running &vmguest;, specify the following command as &rootuser;:
   </para>
<screen>ethtool -L eth0 combined 8</screen>
   <para>
    Now the guest system networking makes use of the multiqueue support from
    the <command>qemu-system-ARCH</command> hypervisor.
   </para>
  </sect2>
 </sect1>
 <sect1 id="cha.qemu.running.vnc">
  <title>Viewing a &vmguest; with&nbsp;VNC</title>

  <para>
   By default &qemu; uses a GTK (a cross-platform toolkit library) window to
   display the graphical output of a &vmguest;.
   <remark condition="clarity">
    2014-08-06 - fs: feedback from brogers: We should explain the "display
    xxx" command line syntax to present the various display options before
    diving into the vnc details.
   </remark>
   With the <literal>-vnc</literal> option specified, you can make &qemu;
   listen on a specified VNC display and redirect its graphical output to
   the VNC session.
  </para>

  <tip>
   <para>
    When working with &qemu;'s virtual machine via VNC session, it is useful
    to work with the <literal>-usbdevice tablet</literal> option.
   </para>
   <para>
    Moreover, if you need to use another keyboard layout than the default
    <literal>en-us</literal>, specify it with the <literal>-k</literal>
    option.
   </para>
  </tip>

  <para>
   The first suboption of <literal>-vnc</literal> must be a
   <emphasis>display</emphasis> value. The <literal>-vnc</literal> option
   understands the following display specifications:
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>host:display</literal>
    </term>
    <listitem>
     <para>
      Only connections from <literal>host</literal> on the display number
      <literal>display</literal> will be accepted. The TCP port on which the
      VNC session is then running is normally a 5900 +
      <literal>display</literal> number. If you do not specify
      <literal>host</literal>, connections will be accepted from any host.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>unix:path</literal>
    </term>
    <listitem>
     <para>
      The VNC server listens for connections on Unix domain sockets. The
      <literal>path</literal> option specifies the location of the related
      Unix socket.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>none</literal>
    </term>
    <listitem>
     <para>
      The VNC server functionality is initialized, but the server itself is
      not started. You can start the VNC server later with the &qemu;
      monitor. For more information, see <xref linkend="cha.qemu.monitor"/>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Following the display value there may be one or more option flags
   separated by commas. Valid options are:
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>reverse</literal>
    </term>
    <listitem>
     <para>
      Connect to a listening VNC client via a <emphasis>reverse</emphasis>
      connection.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>websocket</literal>
    </term>
    <listitem>
     <para>
      Opens an additional TCP listening port dedicated to VNC Websocket
      connections. By definition the Websocket port is 5700+display.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>password</literal>
    </term>
    <listitem>
     <para>
      Require that password-based authentication is used for client
      connections.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>tls</literal>
    </term>
    <listitem>
     <para>
      Require that clients use TLS when communicating with the VNC server.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>x509=/path/to/certificate/dir</literal>
    </term>
    <listitem>
     <para>
      Valid if TLS is specified. Require that x509 credentials are used for
      negotiating the TLS session.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>x509verify=/path/to/certificate/dir</literal>
    </term>
    <listitem>
     <para>
      Valid if TLS is specified. Require that x509 credentials are used for
      negotiating the TLS session.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>sasl</literal>
    </term>
    <listitem>
     <para>
      Require that the client uses SASL to authenticate with the VNC server.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>acl</literal>
    </term>
    <listitem>
     <para>
      Turn on access control lists for checking of the x509 client
      certificate and SASL party.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>lossy</literal>
    </term>
    <listitem>
     <para>
      Enable lossy compression methods (gradient, JPEG, ...).
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>non-adaptive</literal>
    </term>
    <listitem>
     <para>
      Disable adaptive encodings. Adaptive encodings are enabled by default.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>share=[allow-exclusive|force-shared|ignore]</literal>
    </term>
    <listitem>
     <para>
      Set display sharing policy.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <note>
   <para>
    For more details about the display options, see the
    <emphasis>qemu-doc</emphasis> man page.
   </para>
  </note>

  <para>
   An example VNC usage:
  </para>

<screen>&prompt.user; qemu-system-ARCH [...] -vnc :5
(on the client:)
&prompt.user2;:~> vinagre &wsII;:5905 &amp;</screen>

  <figure>
   <title>&qemu; VNC Session</title>
   <mediaobject>
    <imageobject role="fo">
     <imagedata fileref="qemu_sles_vnc.png" width="70%" format="PNG"/>
    </imageobject>
    <imageobject role="html">
     <imagedata fileref="qemu_sles_vnc.png" width="70%" format="PNG"/>
    </imageobject>
   </mediaobject>
  </figure>

  <sect2 id="cha.qemu.running.vnc.secure">
   <title>Secure VNC Connections</title>
   <para>
    The default VNC server setup does not use any form of authentication. In
    the previous example, any user can connect and view the &qemu; VNC
    session from any host on the network.
   </para>
   <para>
    There are several levels of security that you can apply to your VNC
    client/server connection. You can either protect your connection with a
    password, use x509 certificates, use SASL authentication, or even
    combine some of these authentication methods in one &qemu; command.
   </para>
   <para>
    See <xref linkend="app.kvm.certificates"/> for more information about
    the x509 certificates generation. For more information about configuring
    x509 certificates on a &vmhost; and the client, see
    <xref
    linkend="sec.libvirt.connect.remote.tls"/> and
    <xref
    linkend="sec.libvirt.connect.remote.tls.client"/>.
   </para>
   <para>
    The Vinagre VNC viewer supports advanced authentication mechanisms.
    Therefore, it will be used to view the graphical output of &vmguest; in
    the following examples. For this example, let us assume that the server
    x509 certificates <filename>ca-cert.pem</filename>,
    <filename>server-cert.pem</filename>, and
    <filename>server-key.pem</filename> are located in the
    <filename>/etc/pki/qemu</filename> directory on the host, while the
    client's certificates are distributed in the following locations on the
    client:
   </para>
   <simplelist>
    <member><filename>/etc/pki/CA/cacert.pem</filename>
    </member>
    <member><filename>/etc/pki/libvirt-vnc/clientcert.pem</filename>
    </member>
    <member><filename>/etc/pki/libvirt-vnc/private/clientkey.pem</filename>
    </member>
   </simplelist>
   <example id="ex.running.vnc.secure.pwd">
    <title>Password Authentication</title>
<screen>qemu-system-ARCH [...] -vnc :5,password -monitor stdio</screen>
    <para>
     Starts the &vmguest; graphical output on VNC display number 5 (usually
     port 5905). The <literal>password</literal> suboption initializes a
     simple password-based authentication method. There is no password set
     by default and you have to set one with the <command>change vnc
     password</command> command in &qemu; monitor:
    </para>
<screen>QEMU 2.0.0 monitor - type 'help' for more information
(qemu) change vnc password
Password: ****
</screen>
    <para>
     You need the <literal>-monitor stdio</literal> option here, because you
     would not be able to manage the &qemu; monitor without redirecting its
     input/output.
    </para>
   </example>
   <figure>
    <title>Authentication Dialog in Vinagre</title>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="qemu_vnc_pwd.png" width="70%" format="PNG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="qemu_vnc_pwd.png" width="70%" format="PNG"/>
     </imageobject>
    </mediaobject>
   </figure>
   <example id="ex.running.vnc.secure.x509">
    <title>x509 Certificate Authentication</title>
    <para>
     The &qemu; VNC server can use TLS encryption for the session and x509
     certificates for authentication. The server asks the client for a
     certificate and validates it against the CA certificate. Use this
     authentication type if your company provides an internal certificate
     authority.
    </para>
<screen>qemu-system-ARCH [...] -vnc :5,tls,x509verify=/etc/pki/qemu</screen>
   </example>
   <example id="ex.running.vnc.secure.pwd_x509">
    <title>x509 Certificate and Password Authentication</title>
    <para>
     You can combine the password authentication with TLS encryption and
     x509 certificate authentication to create a two-layer authentication
     model for clients. Remember to set the password in the &qemu; monitor
     after you run the following command:
    </para>
<screen>qemu-system-ARCH [...] -vnc :5,password,tls,x509verify=/etc/pki/qemu -monitor stdio</screen>
   </example>
   <example id="ex.running.vnc.secure.sasl">
    <title>SASL Authentication</title>
    <para>
     Simple Authentication and Security Layer (SASL) is a framework for
     authentication and data security in Internet protocols. It integrates
     several authentication mechanisms, like PAM, Kerberos, LDAP and more.
     SASL keeps its own user database, so the connecting user accounts do
     not need to exist on &vmhost;.
    </para>
    <para>
     For security reasons, you are advised to combine SASL authentication
     with TLS encryption and x509 certificates:
    </para>
<screen>qemu-system-ARCH [...] -vnc :5,tls,x509,sasl -monitor stdio</screen>
   </example>
  </sect2>
 </sect1>
 <sect1 id="kvm.qemu.virtfs">
  <title>VirtFS: Sharing Folders between Host and Guests</title>

  <para>
   &vmguest;s usually run in a separate computing space&mdash;they are
   provided their own memory range, dedicated CPUs, and file system space.
   The ability to share parts of the &vmhost;'s file system makes the
   virtualization environment more flexible by simplifying mutual data
   exchange. Network file systems, such as CIFS and NFS, have been the
   traditional way of sharing folders. But as they are not specifically
   designed for virtualization purposes, they suffer from major performance
   and feature issues.
  </para>

  <para>
   &kvm; introduces a new optimized method called
   <emphasis>VirtFS</emphasis> (sometimes referred to as a <quote>file
   system pass-through</quote>). VirtFS uses a paravirtual file system
   driver, which avoids converting the guest application file system
   operations into block device operations, and then again into host file
   system operations.
  </para>

  <para>
   You typically use VirtFS for the following situations:
  </para>

  <itemizedlist>
   <listitem>
    <para>
     To access a shared folder from several guests, or to provide
     guest-to-guest file system access.
    </para>
   </listitem>
   <listitem>
    <para>
     To replace the virtual disk as the root file system to which the guest's
     ramdisk connects during the guest boot process.
    </para>
   </listitem>
   <listitem>
    <para>
     To provide storage services to different customers from a single host file
     system in a cloud environment.
    </para>
   </listitem>
  </itemizedlist>

  <sect2 id="kvm.qemu.virtfs.implement">
   <title>Implementation</title>
   <para>
    In &qemu;, the implementation of VirtFS is facilitated by defining two
    types of devices:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      <literal>virtio-9p-pci</literal> device which transports protocol
      messages and data between the host and the guest.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>fsdev</literal> device which defines the export file system
      properties, such as file system type and security model.
     </para>
    </listitem>
   </itemizedlist>
   <example id="ex.qemu.virtfs.host">
    <title>Exporting Host's File System with VirtFS</title>
<screen>qemu-system-ARCH [...] -fsdev local,id=exp1<co id="co.virtfs.host.id"/>,path=/tmp/<co id="co.virtfs.host.path"/>,security_model=mapped<co id="co.virtfs.host.sec_model"/>
-device virtio-9p-pci,fsdev=exp1<co
  id="co.virtfs.host.fsdev"/>,mount_tag=v_tmp<co id="co.virtfs.host.mnt_tag"/></screen>
    <calloutlist>
     <callout arearefs="co.virtfs.host.id">
      <para>
       Identification of the file system to be exported.
      </para>
     </callout>
     <callout arearefs="co.virtfs.host.path">
      <para>
       File system path on the host to be exported.
      </para>
     </callout>
     <callout arearefs="co.virtfs.host.sec_model">
      <para>
       Security model to be used&mdash;<literal>mapped</literal> keeps the
       guest file system modes and permissions isolated from the host, while
       <literal>none</literal> invokes a <quote>pass-through</quote>
       security model in which permission changes on the guest's files are
       reflected on the host as well.
      </para>
     </callout>
     <callout arearefs="co.virtfs.host.fsdev">
      <para>
       The exported file system ID defined before with <literal>-fsdev
       id=</literal> .
      </para>
     </callout>
     <callout arearefs="co.virtfs.host.mnt_tag">
      <para>
       Mount tag used later on the guest to mount the exported file system.
      </para>
     </callout>
    </calloutlist>
    <para>
     Such an exported file system can be mounted on the guest like this
    </para>
<screen>sudo mount -t 9p -o trans=virtio v_tmp /mnt</screen>
    <para>
     where <literal>v_tmp</literal> is the mount tag defined earlier with
     <literal>-device mount_tag=</literal> and <literal>/mnt</literal> is
     the mount point where you want to mount the exported file system.
    </para>
   </example>
  </sect2>
 </sect1>
 <sect1 id="kvm.qemu.ksm">
  <title>KSM: Sharing Memory Pages between Guests</title>

  <para>
   Kernel SamePage Merging (<xref linkend="gloss.vt.acronym.ksm"/>) is a
   Linux Kernel feature that merges identical memory pages from multiple
   running processes into one memory region. Because &kvm; guests run as
   processes under Linux, <xref linkend="gloss.vt.acronym.ksm"/> provides
   the memory overcommit feature to hypervisors for more efficient use of
   memory. Therefore, if you need to run multiple virtual machines on a host
   with limited memory, <xref linkend="gloss.vt.acronym.ksm"/> may be
   helpful to you.
  </para>

  <para>
   For more information on the meaning of the
   <filename>/sys/kernel/mm/ksm/*</filename> files, see
   <filename>/usr/src/linux/Documentation/vm/ksm.txt</filename> (package
   <systemitem>kernel-source</systemitem>).
  </para>

<!-- 
 aginies: 2014-08-29
 brogers remarks: 
 we shouldn't need to mention looking for whether such and such config option
 is enabled in the running kernel. We CONTROL the running kernel in this
 context 
  <para>
    To make use of <xref linkend="gloss.vt.acronym.ksm"/>, do the following.
  </para>
  <procedure>
   <step>
    <para>
     Verify that <xref linkend="gloss.vt.acronym.ksm"/> is enabled in your running Kernel:
    </para>
<screen>grep KSM /boot/config-`uname -r`
CONFIG_KSM=y</screen>
    <para>
     If <xref linkend="gloss.vt.acronym.ksm"/> is enabled in the running Kernel, you will see the following
     files under the <filename>/sys/kernel/mm/ksm</filename> directory:
    </para>

f.c.i.g bug with tag comment .... need to remove screen content....
 svn version r14426

   </step>
   <step>
    <para>
     Check if <xref linkend="gloss.vt.acronym.ksm"/> feature is turned on.
    </para>
<screen>cat /sys/kernel/mm/ksm/run</screen>
    <para>
     If the command returns <literal>0</literal>, turn <xref linkend="gloss.vt.acronym.ksm"/> on with
    </para>
<screen>sudo echo 1 > /sys/kernel/mm/ksm/run</screen>
   </step>
   <step>
    <para>
     Now run several &vmguest;s under &kvm; and inspect the content of files
     <filename>pages_sharing</filename> and
     <filename>pages_shared</filename>, for example:
    </para>
<screen>while [ 1 ]; do cat /sys/kernel/mm/ksm/pages_shared; sleep 1; done
13522
13523
13519
13518
13520
13520
13528</screen>
   </step>
  </procedure>
-->
 </sect1>
</chapter>
