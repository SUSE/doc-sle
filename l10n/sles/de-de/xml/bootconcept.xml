<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="bootconcept.xml" version="5.0" xml:id="cha-boot">
 <title>Einführung in den Bootvorgang</title>
 <info>
  <abstract>
   <para>
    Das Booten eines Linux-Systems umfasst verschiedene Komponenten und Tasks. Nach der Firmware- und Hardware-Initialisierung, die von der Computerarchitektur abhängt, wird der Kernel mithilfe des Bootloaders GRUB 2 gestartet. Anschließend wird der Bootvorgang vollständig vom Betriebssystem gesteuert und über <systemitem class="daemon">systemd</systemitem> abgewickelt. <systemitem class="daemon">systemd</systemitem> bietet eine Reihe von <quote>Zielen</quote>, mit denen Konfigurationen für den normalen Gebrauch, für Wartungsarbeiten oder für Notfälle gebootet werden.
   </para>
  </abstract>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>


 <sect1 xml:id="sec-boot-terminology">
  <title>Terminologie</title>
  <para>
   In diesem Kapitel werden Begriffe verwendet, die unter Umständen nicht eindeutig sind. Aus diesem Grund stellen wir im Folgenden einige Definitionen bereit:
  </para>
  <variablelist>
   <varlistentry>
    <term><systemitem>init</systemitem></term>
    <listitem>
     <para>
      Derzeit gibt es zwei unterschiedliche Prozesse mit dem Namen <quote>init</quote>:
     </para>
     <itemizedlist>
      <listitem>
       <para>
        den <systemitem>initramfs</systemitem>-Vorgang, mit dem das root-Dateisystem eingehängt wird
       </para>
      </listitem>
      <listitem>
       <para>
        den Betriebssystemprozess, mit dem alle anderen Prozesse gestartet werden und der über das echte root-Dateisystem ausgeführt wird
       </para>
      </listitem>
     </itemizedlist>
     <para>
      In beiden Fällen wird die jeweilige Aufgabe vom Programm <systemitem class="daemon">systemd</systemitem> ausgeführt. Zunächst wird sie aus dem <systemitem>initramfs</systemitem> ausgeführt, sodass das root-Dateisystem eingehängt wird. Wurde dieser Vorgang erfolgreich abgeschlossen, wird der Vorgang als ursprünglicher Prozess erneut ausgeführt, diesmal aus dem root-Dateisystem. Damit keine Verwirrung entsteht, welcher der beiden <systemitem class="daemon">systemd</systemitem>-Prozesse gemeint ist, bezeichnen wir den ersten als <emphasis>init auf initramfs</emphasis> und den zweiten als <emphasis>systemd</emphasis>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>
     <systemitem>initrd</systemitem>/<systemitem>initramfs</systemitem>
    </term>
    <listitem>
     <para>
      Eine <systemitem>initrd</systemitem> (ursprüngliche RAM-Festplatte) ist eine Imagedatei, die ein Image des root-Dateisystems enthält, das vom Kernel geladen und über <filename>/dev/ram</filename> als temporäres root-Dateisystem eingehängt wird. Für das Einhängen dieses Dateisystems ist ein Dateisystemtreiber erforderlich.
     </para>
     <para>
      Ab Kernel 2.6.13 wurde initrd durch <systemitem>initramfs</systemitem> (ursprüngliches RAM-Dateisystem) ersetzt, für das kein Dateisystemtreiber eingehängt werden muss. <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> verwendet ausschließlich ein <systemitem>initramfs</systemitem>. Da <systemitem>initramfs</systemitem> jedoch als <filename>/boot/initrd</filename> gespeichert ist, wird es auch häufig als <quote>initrd</quote> bezeichnet. In diesem Kapitel verwenden wir ausschließlich den Begriff <systemitem>initramfs</systemitem>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 xml:id="sec-boot-proc">
  <title>Der Linux-Bootvorgang</title>
  <para>
   Der Linux-Bootvorgang besteht aus mehreren Phasen, von denen jede einer anderen Komponente entspricht:
  </para>
  <orderedlist>
   <listitem>
    <para>
     <xref linkend="sec-boot-proc-initialization" xrefstyle="HeadingOnPage"/>
    </para>
   </listitem>
   <listitem>
    <para>
     <xref linkend="sec-boot-proc-kernel" xrefstyle="HeadingOnPage"/>
    </para>
   </listitem>
   <listitem>
    <para>
     <xref linkend="sec-boot-initramfs" xrefstyle="HeadingOnPage"/>
    </para>
   </listitem>
   <listitem>
    <para>
     <xref linkend="sec-boot-systemd" xrefstyle="HeadingOnPage"/>
    </para>
   </listitem>
  </orderedlist>

  <sect2 xml:id="sec-boot-proc-initialization">
   <title>Initialisierungs- und Bootloader-Phase</title>
   <para>
    Während der Initialisierungsphase wird die Computerhardware eingerichtet und die Geräte werden vorbereitet. Dieser Prozess verläuft, abhängig von der Hardwarearchitektur, bei jedem Gerät anders.
   </para>
   <para>
    <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> nutzt für alle Architekturen den Bootloader GRUB 2. Abhängig von Architektur und Firmware ist das Starten des Bootloaders GRUB 2 unter Umständen ein Prozess mit mehreren Schritten. Zweck des Bootloaders ist es, den Kernel und das ursprüngliche RAM-basierte Dateisystem (initramfs) zu laden. Weitere Informationen zu GRUB 2 finden Sie in <xref linkend="cha-grub2"/>.
   </para>
   <sect3 xml:id="sec-boot-proc-initialization-x86-aarch" arch="x86_64;aarch64">
    <title>Initialisierungs- und Bootloader-Phase auf AArch64 und AMD64/Intel 64</title>
    <para>
     Nach dem Einschalten des Computers initialisiert das BIOS oder das UEFI den Bildschirm und die Tastatur und testet den Hauptspeicher. Bis zu dieser Phase greift der Computer nicht auf Massenspeichergeräte zu. Anschließend werden Informationen zum aktuellen Datum, zur aktuellen Uhrzeit und zu den wichtigsten Peripheriegeräten aus den CMOS-Werten geladen. Wenn die Boot-Medien und deren Geometrie erkannt wurden, geht die Systemkontrolle vom BIOS/UEFI an den Bootloader über.
    </para>
    <para>
     Auf einem mit traditionellem BIOS ausgestatteten Computer kann nur Code des ersten physischen 512-Byte-Datensektors (Master-Boot-Datensatz, MBR) der Boot-Festplatte geladen werden. Nur die minimalistische Version von GRUB 2 passt in den MBR. Seine einzige Aufgabe besteht darin, ein Core-Image von GRUB 2 zu laden, das die Dateisystemtreiber aus der Lücke zwischen MBR und erster Partition (MBR-Partitionstabelle) oder der BIOS-Boot-Partition (GPT-Partitionstabelle) enthält. Dieses Image enthält Dateisystemtreiber und ist somit in der Lage, auf <filename>/boot</filename> im root-Dateisystem zuzugreifen. <filename>/boot</filename> enthält zusätzliche Module für den Core von GRUB 2 sowie den Kernel und das initramfs-Image. Wenn GRUB 2 Zugriff auf diese Partition hat, lädt es den Kernel und das initramfs-Image in den Speicher und übergibt die Steuerung an den Kernel.
    </para>
    <para>
     Wird ein BIOS-System aus einem verschlüsselten Dateisystem gebootet, das über eine verschlüsselte <filename>/boot</filename>-Partition verfügt, müssen Sie das Entschlüsselungspasswort zweimal eingeben. Zunächst benötigt es GRUB 2, um <filename>/boot</filename> zu entschlüsseln, die zweite Eingabe ermöglicht es <systemitem class="daemon">systemd</systemitem>, die verschlüsselten Volumes einzuhängen.
    </para>
    <para>
     Auf UEFI-Computern verläuft der Boot-Vorgang sehr viel einfacher als auf Computern mit herkömmlichem BIOS. Die Firmware kann eine FAT-formatierte Systempartition von Festplatten mit GPT-Partitionstabelle lesen. Diese EFI-Systempartition (im laufenden System eingehängt als<filename>/boot/efi</filename>) bietet ausreichend Platz für eine komplette GRUB 2-Anwendung, die unmittelbar von der Firmware geladen und ausgeführt wird.
    </para>
    <para>
     Wenn das BIOS/UEFI Netzwerk-Booting unterstützt, ist es auch möglich, einen Boot-Server zu konfigurieren, der den Bootloader bereitstellt. Das System kann dann über PXE gebootet werden. Das BIOS/UEFI dient als Bootloader. Es erhält das Boot-Image vom Boot-Server und startet das System. Dieser Vorgang ist vollständig unabhängig von den lokalen Festplatten.
    </para>
   </sect3>
   <sect3 xml:id="sec-boot-proc-initialization-zsystems" arch="zseries">
    <title>
     Initialisierungs- und Bootloader-Phase auf IBM Z
    </title>
    <para>
     Bei IBM Z muss der Boot-Vorgang durch einen Bootloader namens <command>zipl</command> (ursprüngliches z-Programmladen) initialisiert werden. Obwohl <command>zipl</command> das Lesen unterschiedlicher Dateisysteme unterstützt, unterstützt es nicht das SLE-Standarddateisystem (Btrfs) oder das Booten aus Snapshots. <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> nutzt somit einen zweistufigen Boot-Vorgang, der gewährleistet, dass Btrfs zum Boot-Zeitpunkt vollständig unterstützt wird:
    </para>
    <procedure>
     <step>
      <para>
       <command>zipl</command> bootet aus der Partition <filename>/boot/zipl</filename>, die mit dem Datensystem Ext2, Ext3, Ext4 oder XFS formatiert werden kann. Diese Partition enthält einen minimalistischen Kernel sowie ein initramfs, die in den Speicher geladen werden. Das initramfs enthält (unter anderem) einen Btrfs-Treiber und den Bootloader GRUB 2. Der Kernel wird mit dem Parameter <literal>initgrub</literal> gestartet, der ihm befiehlt, GRUB 2 zu starten.
      </para>
     </step>
     <step>
      <para>
       Der Kernel hängt das root-Dateisystem ein, sodass auf <filename>/boot</filename> zugegriffen werden kann. Jetzt wird GRUB 2 über initramfs gestartet. Die Anwendung liest ihre Konfiguration aus <filename>/boot/grub2/grub.cfg</filename> aus und lädt den letzten Kernel und das initramfs aus <filename>/boot</filename>. Der neue Kernel wird nun über Kexec geladen.
      </para>
     </step>
    </procedure>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-boot-proc-kernel">
   <title>Die Kernel-Phase</title>
   <para>
    Sobald der Bootloader die Systemsteuerung übergeben hat, läuft der Boot-Vorgang auf allen Architekturen gleich ab. Der Bootloader lädt sowohl den Kernel als auch ein ursprüngliches RAM-basiertes Dateisystem (<systemitem>initramfs</systemitem>) in den Speicher und der Kernel übernimmt die Steuerung.
   </para>
   <para>
    Nachdem der Kernel die Speicherverwaltung eingerichtet und CPU-Typ und -Eigenschaften erkannt hat, wird die Hardware initialisiert und das temporäre root-Dateisystem aus dem Speicher eingehängt, der mit <systemitem>initramfs</systemitem> geladen wurde.
   </para>

   <sect3 xml:id="sec-boot-initrd">
    <title>Die <systemitem>initramfs</systemitem>-Datei</title>
    <para>
     <systemitem>initramfs</systemitem> (ursprüngliches RAM-Dateisystem) ist ein kleines cpio-Archiv, das der Kernel auf einen RAM-Datenträger laden kann. Zu finden ist es unter <filename>/boot/initrd</filename>. Es lässt sich mit einem Tool namens <command>dracut</command> erstellen – weitere Hinweise finden Sie unter <command>man 8 dracut</command>.
    </para>
    <para>
     <systemitem>initramfs</systemitem> stellt eine minimale Linux-Umgebung bereit, die das Ausführen von Programmen ermöglicht, bevor das eigentliche root-Dateisystem eingehängt wird. Diese minimale Linux-Umgebung wird durch eine BIOS- oder UEFI-Routine in den Arbeitsspeicher geladen, wobei lediglich ausreichend Arbeitsspeicher zur Verfügung stehen muss; ansonsten gelten keine besonderen Anforderungen. Das <systemitem>initramfs</systemitem>-Archiv must stets eine ausführbare Datei mit der Bezeichnung <systemitem>init</systemitem> umfassen, die den <systemitem class="daemon">systemd</systemitem>-Daemon auf dem root-Dateisystem ausführt, so dass der Bootvorgang fortgesetzt werden kann.
    </para>
    <para>
     Bevor das root-Dateisystem eingehängt und das Betriebssystem gestartet werden kann, ist es für den Kernel erforderlich, dass die entsprechenden Treiber auf das Gerät zugreifen, auf dem sich das root-Dateisystem befindet. Diese Treiber können spezielle Treiber für bestimmte Arten von Festplatten oder sogar Netzwerktreiber für den Zugriff auf ein Netzwerk-Dateisystem umfassen. Die erforderlichen Module für das root-Dateisystem werden mithilfe von <systemitem>init</systemitem> oder <systemitem>initramfs</systemitem> geladen. Nachdem die Module geladen wurden, stellt <systemitem class="service">udev</systemitem> das <systemitem>initramfs</systemitem> mit den erforderlichen Geräten bereit. Später im Boot-Vorgang, nach dem Ändern des root-Dateisystems, müssen die Geräte regeneriert werden. Dies geschieht über die <systemitem class="daemon">systemd</systemitem>-Einheit <filename>systemd-udev-trigger.service</filename>.
    </para>

    <sect4 xml:id="sec-boot-initrd-regenerate">
     <title>Erneutes Generieren von initramfs</title>
     <para>
      Da <systemitem>initramfs</systemitem> Treiber enthält, muss es aktualisiert werden, sobald neue Versionen der darin gespeicherten Treiber verfügbar sind. Dies geschieht automatisch bei der Installation des Pakets, das die Treiberaktualisierung enthält. YaST oder zypper informieren Sie über diesen Umstand, indem Sie den Output des Befehls anzeigen, mit dem <systemitem>initramfs</systemitem> generiert wird. Es gibt jedoch einige Situationen, in denen Sie <systemitem>initramfs</systemitem> manuell neu erzeugen müssen:
     </para>
     <itemizedlist>
      <listitem>
       <para>
        
        <xref xrefstyle="select:title" linkend="var-initrd-regenerate-drivers"/>
       </para>
      </listitem>
      <listitem>
       <para>
        
        <xref xrefstyle="select:title" linkend="var-initrd-regenerate-raidroot"/>
       </para>
      </listitem>
      <listitem>
       <para>
        
        <xref xrefstyle="select:title" linkend="var-initrd-regenerate-lvmadd"/>
       </para>
      </listitem>
      <listitem>
       <para>
        
        <xref xrefstyle="select:title" linkend="var-initrd-regenerate-kernelvars"/>
       </para>
      </listitem>
     </itemizedlist>

     <variablelist>
      <varlistentry xml:id="var-initrd-regenerate-drivers">
       <term>Hinzufügen von Treibern aufgrund von Änderungen an der Hardware</term>
       <listitem>
        <para>
         Wenn Hardwarekomponenten (z. B. Festplatten) ausgetauscht werden müssen und diese Hardware zur Bootzeit andere Treiber im Kernel erfordert, müssen Sie die Datei <systemitem>initramfs</systemitem> aktualisieren.
        </para>
        <para>
         Öffnen oder erstellen Sie <filename>/etc/dracut.conf.d/10-<replaceable>DRIVER</replaceable>.conf</filename> und fügen Sie die folgende Zeile hinzu (achten Sie auf das führende Leerzeichen):
        </para>
        <screen>force_drivers+=" <replaceable>DRIVER1</replaceable> "</screen>
        <para>
         Ersetzen Sie dabei <replaceable>DRIVER1</replaceable> durch den Modulnamen des Treibers. Sie können auch mehrere Treiber hinzufügen. In diesem Fall geben Sie eine durch Leerzeichen getrennte Liste der Modulnamen ein:
        </para>
        <screen>force_drivers+=" <replaceable>DRIVER1</replaceable> <replaceable>DRIVER2</replaceable> "</screen>
        <para>
         Fahren Sie mit <xref linkend="pro-generate-initramfs"/> fort.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry xml:id="var-initrd-regenerate-raidroot">
       <term>Verschieben von Systemverzeichnissen auf RAID oder LVM</term>
       <listitem>
        <para>
         Wann immer Sie Auslagerungsdateien oder Systemverzeichnisse wie <filename>/usr</filename> in einem laufenden System auf RAID oder ein logisches Volume verschieben, müssen Sie ein <systemitem>initramfs</systemitem> erstellen, das Softwaretreiber für RAID oder LVM unterstützt.
        </para>
        <para>
         Hierzu müssen Sie die entsprechenden Einträge in <filename>/etc/fstab</filename> erstellen und die neuen Einträge (beispielsweise mit <command>mount -a</command> und/oder <command>swapon -a</command>) einhängen.
        </para>
        <para>
         Fahren Sie mit <xref linkend="pro-generate-initramfs"/> fort.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry xml:id="var-initrd-regenerate-lvmadd">
       <term>Hinzufügen von Festplatten zu einer LVM-Gruppe/einem Btrfs-RAID mit root-Dateisystem</term>
       <listitem>
        <para>
         Wann immer Sie eine Festplatte zu einer logischen Volumegruppe oder einem Btrfs-RAID, die oder das das root-Dateisystem enthält, hinzufügen (oder daraus entfernen), müssen Sie ein <systemitem>initramfs</systemitem> erstellen, das das größere Volume unterstützt. Befolgen Sie die Anweisungen unter <xref linkend="pro-generate-initramfs"/>.
        </para>
        <para>
         Fahren Sie mit <xref linkend="pro-generate-initramfs"/> fort.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry xml:id="var-initrd-regenerate-kernelvars">
       <term>Ändern der Kernel-Variablen</term>
       <listitem>
        <para>
         Wenn Sie die Werte von Kernel-Variablen über die <command>sysctl</command>-Benutzeroberfläche ändern und dabei die zugehörigen Dateien ändern (<filename>/etc/sysctl.conf</filename> oder <filename>/etc/sysctl.d/*.conf</filename>), geht die Änderung beim nächsten Neubooten des Systems verloren. Die Änderungen werden selbst dann nicht in der <systemitem>initramfs</systemitem>-Datei gespeichert, wenn Sie die Werte zur Laufzeit mit <command>sysctl --system</command> laden. Aktualisieren Sie es, in dem Sie wie in <xref linkend="pro-generate-initramfs"/> beschrieben vorgehen.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <procedure xml:id="pro-generate-initramfs">
      <title>Generieren eines initramfs</title>
       <para>
       Beachten Sie, dass alle Kommandos des folgenden Verfahrens als <systemitem class="username">root</systemitem>-Benutzer ausgeführt werden müssen.
      </para>
      <step>
      <para>
        Geben Sie Ihr Verzeichnis <filename>/boot</filename> ein:
      </para>
      <screen><prompt role="root"># </prompt>cd /boot</screen>
      </step>
      <step>
       <para>
        Erzeugen Sie eine neue <systemitem>initramfs</systemitem>-Datei mit <command>dracut</command> und ersetzen Sie dabei <replaceable>MY_INITRAMFS</replaceable> durch einen Dateinamen Ihrer Wahl:
       </para>
       <screen><prompt role="root"># </prompt>dracut <replaceable>MY_INITRAMFS</replaceable></screen>
       <para>
        Führen Sie alternativ <command>dracut -f</command>
        <replaceable>FILENAME</replaceable> aus und ersetzen Sie damit eine vorhandene init-Datei.
       </para>
      </step>
      <step>
       <para>
        (Überspringen Sie diesen Schritt, wenn Sie im vorangegangenen Schritt <command>dracut -f</command> ausgeführt haben.) Erstellen Sie einen symbolischen Link von der <systemitem>initramfs</systemitem>-Datei, die Sie im vorangegangenen Schritt erstellt haben, zu <systemitem>initrd</systemitem>:
       </para>
       <screen><prompt role="root"># </prompt> ln -sf <replaceable>MY_INITRAMFS</replaceable> <systemitem>initrd</systemitem> </screen>
      </step>
      <step arch="zseries">
       <para>
        Unter der Architektur IBM z müssen Sie zudem <command>grub2-install</command> ausführen.
       </para>
      </step>
     </procedure>
    </sect4>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-boot-initramfs">
   <title>Die Phase init auf initramfs</title>
   <para>
    Das temporäre root-Dateisystem, das vom Kernel aus <systemitem>initramfs</systemitem> eingehängt wird, enthält die ausführbare Datei <systemitem class="daemon">systemd</systemitem> (die wir im Folgenden als <systemitem>init</systemitem> auf <systemitem>initramfs</systemitem> bezeichnen, siehe auch <xref linkend="sec-boot-terminology"/>). Dieses Programm führt alle erforderlichen Aktionen aus, mit denen das eigentliche root-Dateisystem eingehängt wird. Es bietet Kernel-Funktionen für das benötigte Dateisystem sowie Gerätetreiber für Massenspeicher-Controller mit <systemitem class="service">udev</systemitem>.
   </para>

   <para>
    Der Hauptzweck von <systemitem>init</systemitem> unter <systemitem>initramfs</systemitem> ist es, das Einhängen des eigentlichen root-Dateisystems sowie die Vorbereitung des Zugriffs darauf. Je nach aktueller Systemkonfiguration ist <systemitem>init</systemitem> unter <systemitem>initramfs</systemitem> für die folgenden Tasks verantwortlich.
   </para>

   <variablelist>
    <varlistentry>
     <term>Laden der Kernelmodule</term>
     <listitem>
      <para>
       Je nach Hardware-Konfiguration sind für den Zugriff auf die Hardware-Komponenten des Computers (vor allem auf die Festplatte) spezielle Treiber erforderlich. Für den Zugriff auf das eigentliche root-Dateisystem muss der Kernel die entsprechenden Dateisystemtreiber laden.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Bereitstellen von speziellen Blockdateien</term>
     <listitem>
      <para>
       Der Kernel generiert, abhängig von den geladenen Modulen, Geräteereignisse. <systemitem class="service">udev</systemitem> verarbeitet diese Ereignisse und generiert die erforderlichen blockspezifischen Dateien auf einem RAM-Dateisystem im Verzeichnis <filename>/dev</filename>. Ohne diese speziellen Dateien wäre ein Zugriff auf das Dateisystem und andere Geräte nicht möglich.
      </para>
    </listitem>
    </varlistentry>
    <varlistentry>
     <term>Verwalten von RAID- und LVM-Setups</term>
     <listitem>
      <para>
       Wenn Ihr System so konfiguriert ist, dass das root-Dateisystem sich unter RAID oder LVM befindet, richtet <systemitem>init</systemitem> unter <systemitem>initramfs</systemitem> LVM oder RAID so ein, dass der Zugriff auf das root-Dateisystem zu einem späteren Zeitpunkt erfolgt. 
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Verwalten der Netzwerkkonfiguration</term>
     <listitem>
      <para>
       Wenn Ihr System für die Verwendung eines Netzwerk-eingehängten root-Dateisystems (über NFS eingehängt) konfiguriert ist, muss <systemitem>init</systemitem> sicherstellen, dass die entsprechenden Netzwerktreiber geladen und für den Zugriff auf das root-Dateisystem eingerichtet werden.
      </para>
      <para>
       Wenn sich das Dateisystem auf einem Netzwerkblockgerät wie iSCSI oder SAN befindet, wird die Verbindung zum Speicherserver ebenfalls von <systemitem>init</systemitem> unter <systemitem>initramfs</systemitem> eingerichtet. <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> unterstützt das Booten von einem sekundären iSCSI-Ziel, wenn das primäre Ziel nicht verfügbar ist. <phrase os="sles">Weitere Details zur Konfiguration des Boot-iSCSI-Ziels finden Sie im <xref linkend="sec-iscsi-initiator-yast"/></phrase>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   <note>
    <title>Umgang mit Einhängefehlern</title>
    <para>
     Wenn beim Einhängen des root-Dateisystems in der Bootumgebung ein Fehler auftritt, muss es überprüft und repariert werden, bevor das Booten fortgesetzt werden kann. Die Dateisystemprüfung wird für Ext3- und Ext4-Dateisysteme automatisch gestartet. Der Reparaturvorgang findet für XFS- und Btrfs-Dateisysteme nicht automatisch statt und dem Benutzer werden Informationen angezeigt, die die verfügbaren Optionen zur Reparatur des Dateisystems beschreiben. Wenn das Dateisystem erfolgreich repariert wurde, versucht das System nach dem Beenden der Bootumgebung erneut, das root-Dateisystem einzuhängen. Falls dieser Vorgang erfolgreich ist, wird der Bootvorgang wie gewohnt fortgesetzt.
    </para>
   </note>

   <sect3 xml:id="sec-boot-linuxrc-initramfs">
    <title>Die Phase init auf initramfs während des Installationsvorgangs</title>
    <para>
     Wenn <systemitem>init</systemitem> unter <systemitem>initramfs</systemitem> im Rahmen des Installationsvorgangs während des anfänglichen Boot-Vorgangs aufgerufen wird, unterscheiden sich seine Tasks von den oben beschriebenen. Beachten Sie, dass das Installationssystem auch <systemitem class="daemon">systemd</systemitem> aus <systemitem>initramfs</systemitem> nicht startet – diese Aufgaben werden von <command>linuxrc</command> übernommen.
    </para>

    <variablelist>
     <varlistentry>
      <term>Suchen des Installationsmediums</term>
      <listitem>
       <para>
        Beim Starten des Installationsvorgangs lädt der Rechner einen Installations-Kernel und eine besondere <systemitem>init</systemitem> mit dem YaST-Installationsprogramm. Das YaST-Installationsprogramm wird in einem RAM-Dateisystem ausgeführt und benötigt Daten über den Speicherort des Installationsmediums, um auf dieses zugreifen und das Betriebssystem installieren zu können.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       Initiieren der Hardware-Erkennung und Laden der entsprechenden Kernelmodule
      </term>
      <listitem>
       <para>
        Wie bereits in <xref linkend="sec-boot-initrd"/> erwähnt, beginnt der Boot-Vorgang mit einem Mindestsatz an Treibern, die für die meisten Hardware-Konfigurationen verwendet werden können. Bei Rechnern mit AArch64, POWER und AMD64/Intel 64 löst <command>linuxrc</command> zunächst eine Hardwareabfrage aus, durch die die Treiber ermittelt werden, die sich für Ihre Hardwarekonfiguration eignen. Unter IBM Z muss beispielsweise über linuxrc oder parmfile eine Liste der Treiber und deren Parameter bereitgestellt werden.
       </para>
       <para>
        Diese Treiber werden zur Erstellung der zum Booten des Systems benötigten, benutzerdefinierten <systemitem>initramfs</systemitem>-Datei verwendet. Falls die Module nicht für „boot“, sondern für „coldplug“ benötigt werden, können sie mit <systemitem class="daemon">systemd</systemitem> geladen werden. Weitere Informationen finden Sie unter <xref linkend="sec-boot-systemd-advanced-kernel-modules"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Laden des Installationssystems</term>
      <listitem>
       <para>
        Wenn die Hardware ordnungsgemäß erkannt wurde, werden die entsprechenden Treiber geladen. Das <systemitem class="service">udev</systemitem>-Programm erstellt die speziellen Gerätedateien und <command>linuxrc</command> startet das Installationssystem mit dem YaST-Installationsprogramm.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Starten von YaST</term>
      <listitem>
       <para>
        <command>linuxrc</command> startet schließlich YaST, das wiederum die Paketinstallation und die Systemkonfiguration startet.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
  </sect2>


  <sect2 xml:id="sec-boot-systemd">
   <title>Die systemd-Phase</title>
   <para>
    Nachdem das <quote>echte</quote> root-Dateisystem gefunden wurde, wird es auf Fehler geprüft und eingehängt. Wenn dieser Vorgang erfolgreich ist, wird das <systemitem>initramfs</systemitem> bereinigt, und der <systemitem class="daemon">systemd</systemitem>-Daemon wird für das root-Dateisystem ausgeführt. <systemitem class="daemon">systemd</systemitem> ist der System- und Servicemanager von Linux. Es handelt sich dabei um den übergeordneten Prozess, der als PID 1 gestartet wird und wie ein init-System agiert, das die Benutzerraumdienste startet und betreibt. Ausführliche Informationen finden Sie unter <xref linkend="cha-systemd"/>.
   </para>
  </sect2>
 </sect1>
</chapter>
