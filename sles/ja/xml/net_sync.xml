<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="net_sync.xml" version="5.0" xml:id="cha.net.sync">
 <title>ファイルの同期</title>
 <info>
      <abstract>
        <para>
    今日、多くの人々が複数のコンピュータを使用しています。自宅に1台、職場に1台またはそれ以上、外出時にラップトップ、タブレット、またはスマートフォンを携帯することも珍しくありません。これらすべてのコンピュータには、多くのファイルが必要です。すべてのコンピュータで最新バージョンのデータを使用できるように、どのコンピュータでも作業ができて、ファイルの変更ができればと考えるでしょう。
   </para>
      </abstract>
      <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
        <dm:bugtracker>
          </dm:bugtracker>
        <dm:translation>yes</dm:translation>
      </dm:docmanager>
    </info>
    <indexterm xml:id="idx.files_syncronizing" class="startofrange"> <primary>ファイル</primary> <secondary>同期</secondary> </indexterm>
 <sect1 xml:id="sec.net.sync.soft">
  <title>使用可能なデータ同期ソフトウェア</title>

  <para>
   データの同期は、高速ネットワークで固定接続されているコンピュータ間ではまったく問題なく実現できます。この場合、NFSなどのネットワークファイルシステムを使用し、ファイルをサーバに保存して、すべてのホストがネットワーク経由で同じデータにアクセスすればよいわけです。ところがこの方法は、ネットワーク接続が低速な場合、または固定でない場合には不可能です。ラップトップをもって外出しているとき、必要なファイルをローカルハードディスクにコピーする必要があります。しかし、そうすると今度は、変更したファイルを同期させる必要があります。1台のコンピュータでファイルを変更したときは、必ず他のすべてのコンピュータでファイルを更新しなければなりません。たまにコピーする程度なら、手動でscpまたはrsyncを使用してコピーすればよいでしょう。しかし、ファイルが多い場合、手順が複雑になるだけでなく、新しいファイルを古いファイルで上書きしてしまうといった間違いを防ぐために細心の注意が必要になります。
  </para>

  <warning>
   <title>データ損失の危険</title>
   <para>
    データを同期システムで管理する前に、使用するプログラムをよく理解し、機能をテストしておく必要があります。重要なファイルのバックアップは不可欠です。
   </para>
  </warning>

  <para>
   このように手動によるデータの同期は、時間がかかる上に間違いが起こりやすい作業ですが、この作業を自動化するためのさまざまな方法を採用したプログラムを使用することで手動による作業は行わずにすみます。ここでの説明は、このようなプログラムの仕組みと使用法について、一般的な理解を図ることを目的としています。実際に使用する場合は、プログラムのマニュアルを参照してください。
  </para>

  <para>
   
   ファイル同期は、クラウドコンピューティングソリューションでも実行できるようになりました。
  </para>

  <sect2 xml:id="sec.net.sync.soft.cvs">
   <title>CVS</title><indexterm> <primary>ファイル</primary> <secondary>同期化</secondary> <tertiary>CVS</tertiary> </indexterm> <indexterm> <primary>CVS</primary> </indexterm>
   <para>
    CVSは、多くの場合プログラムソースのバージョン管理に使用されるプログラムで、複数のコンピュータでファイルのコピーを保存する機能を持っています。したがって、データ同期にも適しています。CVSはサーバ上に一元的なリポジトリを設定し、ファイルおよびファイルの変更内容を保存します。ローカルに実行された変更はリポジトリにコミットされ、更新によって他のコンピュータに取得されます。両方の処理はユーザによって実行される必要があります。
   </para>
   <para>
    CVSは、複数のコンピュータで変更が行われた場合、非常に優れたエラー回復力を発揮します。変更内容がマージされ、同じ行が変更された場合は、競合がレポートされます。競合が生じても、データベースは一貫した状態のままです。競合はクライアントホストで解決するためにのみ表示されます。
   </para>
  </sect2>

  <sect2 xml:id="sec.net.sync.soft.rsync">
   <title>rsync</title><indexterm> <primary>rsync</primary> </indexterm> <indexterm> <primary>ファイル</primary> <secondary>同期化</secondary> <tertiary>rsync</tertiary> </indexterm>
   <para>
    バージョン管理は不要であっても、低速ネットワーク接続を使用して大きなディレクトリ構造を同期させる必要がある場合は、ツールrsyncの適切に開発されたメカニズムを使用して、ファイル内の変更箇所のみを送信できます。この処理では、テキストファイルのみでなくバイナリファイルも対象となります。ファイル間の差分を検出するために、rsyncはファイルをブロック単位で分割してチェックサムを計算します。
   </para>
   <para>
    変更内容の検出処理は高コストを伴います。rsyncの使用量に合わせて、同期対象となるシステムの規模を調整する必要があります。特に、RAMが重要です。
   </para>
  </sect2>




 </sect1>
 <sect1 xml:id="sec.net.sync.select">
  <title>プログラムを選択する場合の決定要因</title>

  <para>
   使用するプログラムを決定する際に重要な要因がいくつかあります。
  </para>

  <sect2 xml:id="sec.net.sync.select.client-server">
   <title>クライアント/サーバ対ピアツーピア</title>
   <para>
    一般に、データの配信には2種類のモデルが使用されます。1つは、すべてのクライアントが、そのファイルを一元的なサーバによって同期させるモデルです。サーバはすべてのクライアントから、少なくともいずれかの時点でアクセスできる必要があります。このモデルは、CVSが使用します。
   </para>
   <para>
    もう1つは、すべてのネットワークホストがそれぞれのデータをピアとして相互に同期させるモデルです。rsyncは、実際にクライアントモードで動作しますが、任意のクライアントがサーバとして動作できます。
   </para>
  </sect2>

  <sect2 xml:id="sec.net.sync.select.port">
   <title>移植性</title>
   <para>
    CVS、およびrsyncは、各種のUNIXおよびWindowsシステムなど、他の多くのオペレーティングシステムでも使用できます。
   </para>
  </sect2>

  <sect2 xml:id="sec.net.sync.select.auto">
   <title>インタラクティブと自動制御</title>
   <para>
    CVSでは、ユーザが手動によってデータの同期を開始します。これにより、データの同期を詳細に制御でき、競合の処理も容易です。ただし、同期の間隔が長すぎると、競合が起こりやすくなります。
   </para>
  </sect2>

  <sect2 xml:id="sec.net.sync.select.problems">
   <title>競合:問題と解決策</title>
   <para>
    複数のユーザが大きなプログラミングプロジェクトにかかわっている場合も、CVSでは、競合はまれにしか発生しません。これはドキュメントが個別の行単位でマージされるためです。競合が起こると、影響を受けるのは1台のクライアントだけです。CVSでは、通常、競合が容易に解決できます。
   </para>
   <para>
    rsyncには、競合処理の機能はありません。ユーザは、意図せずにファイルを上書きしないように注意し、考えられる競合はすべて手動で解決する必要があります。安全のために、RCSなどのバージョン管理システムを追加採用できます。
   </para>
  </sect2>

  <sect2 xml:id="sec.net.sync.select.files">
   <title>ファイルの選択と追加</title>
   <para>
    CVSでは、新しいディレクトリやファイルは、コマンド<command>cvs</command> <option>add</option>を使って明示的に追加する必要があります。これにより、同期の対象となるファイルについて、ユーザがより詳細に制御できます。しかし他方で、新しいファイルが見過ごされることが多く、特に<command>cvs</command> <option>update</option>の出力に表示される疑問符は、ファイルの数が多いためにたびたび無視されます。
   </para>
  </sect2>

  <sect2 xml:id="sec.net.sync.select.history">
   <title>履歴</title>
   <para>
    CVSは追加機能として、古いバージョンのファイルが再構成できます。変更を行うたびに簡単な編集コメントを挿入しておくと、内容とコメントからファイルの作成状況を後で簡単に追跡できます。これは論文やプログラムテキストを作成する際、貴重な支援となります。
   </para>
  </sect2>

  <sect2 xml:id="sec.net.sync.select.size">
   <title>データ量と必要なハードディスク容量</title>
   <para>
    同期の対象となるすべてのホストには、分散されたデータを処理できるだけの十分なハードディスクの空き容量が必要です。CVSでは、サーバ上のリポジトリデータベースに余分な容量が必要となります。ファイルの履歴もサーバに保存されるため、このための容量も別に必要です。テキスト形式のファイルが変更されたときには、変更された行だけを保存すれば足ります。バイナリファイルは、ファイルが変更されるたびに、ファイルのサイズと同じだけの容量が必要なため、テキストより必要な容量が多くなります。
   </para>
  </sect2>

  <sect2 xml:id="sec.net.sync.select.gui">
   <title>GUI</title>
   <para>
    CVSを使い慣れたユーザは、通常、コマンドラインでプログラムを制御します。しかし、cervisiaのようなLinux用のグラフィカルユーザインタフェースがあり、また他のオペレーティングシステム用にwincvsなども用意されています。開発ツールやEmacsなどのテキストエディタの多くが、CVSをサポートしています。競合の解決は、これらのフロントエンドの方が、はるかに容易です。
   </para>
  </sect2>

  <sect2 xml:id="sec.net.sync.select.use">
   <title>使いやすさ</title>
   <para>
    rsyncは、より使いやすく初心者向けです。CVSは、より操作が難しくなっています。ユーザはリポジトリとローカルデータの間のインタラクションを理解する必要があります。データを変更すると、最初にローカルでリポジトリとマージする必要があります。これはコマンド<command>cvs</command>または<option>update</option>で実行します。次にコマンド<command>cvs</command>または<option>commit</option>でデータをリポジトリに送信する必要があります。この手順をいったん理解すれば、初心者の方でもCVSを簡単に利用できるようになります。
   </para>
  </sect2>

  <sect2 xml:id="sec.net.sync.select.sec">
   <title>攻撃に備えるセキュリティ</title>
   <para>
    伝送中、データは妨害や改ざんから保護される必要があります。CVSやrsyncはいずれもSSH (セキュアシェル)経由で容易に使用できるため、この種の攻撃に対するセキュリティを備えています。CVSをrsh(リモートシェル)経由で実行するのは避けるべきです。また、安全でないネットワークで<emphasis>pserver</emphasis>メカニズムを使用してCVSにアクセスすることもお勧めできません。
   </para>
  </sect2>

  <sect2 xml:id="sec.net.sync.select.loss">
   <title>データ損失からの保護</title>
   <para>
    CVSは、プログラミングプロジェクト管理のため長期間にわたって開発者に使用されてきたため、きわめて安定しています。CVSでは開発履歴が保存されるため、誤ってファイルを削除するといったユーザの誤操作にも対応できます。
   </para>
   <table xml:id="tab.sync_overview">
    <title>ファイル同期化ツールの機能: -- = とても悪い、- = 悪い、または利用不可、o = 普通、+ = 良好、++ = とても良好、x = 利用可能</title>

    <tgroup cols="3">
     <thead>
      <row>
       <entry>
        <para/>
       </entry>
       <entry>
        <para>
         CVS
        </para>
       </entry>
       <entry>
        <para>
         rsync
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         クライアント/サーバ
        </para>
       </entry>
       <entry>
        <para>
         C-S
        </para>
       </entry>
       <entry>
        <para>
         C-S
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         移植性
        </para>
       </entry>
       <entry>
        <para>
         Lin、Un*x、Win
        </para>
       </entry>
       <entry>
        <para>
         Lin、Un*x、Win
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         対話処理
        </para>
       </entry>
       <entry>
        <para>
         x
        </para>
       </entry>
       <entry>
        <para>
         x
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         Speed
        </para>
       </entry>
       <entry>
        <para>
         o
        </para>
       </entry>
       <entry>
        <para>
         +
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         競合
        </para>
       </entry>
       <entry>
        <para>
         ++
        </para>
       </entry>
       <entry>
        <para>
         o
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         ファイル選択
        </para>
       </entry>
       <entry>
        <para>
         Sel./file, dir.
        </para>
       </entry>
       <entry>
        <para>
         ディレクトリ
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         履歴
        </para>
       </entry>
       <entry>
        <para>
         x
        </para>
       </entry>
       <entry>
        <para>
         -
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         ハードディスクスペース
        </para>
       </entry>
       <entry>
        <para>
         --
        </para>
       </entry>
       <entry>
        <para>
         o
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         GUI
        </para>
       </entry>
       <entry>
        <para>
         o
        </para>
       </entry>
       <entry>
        <para>
         -
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         難度
        </para>
       </entry>
       <entry>
        <para>
         o
        </para>
       </entry>
       <entry>
        <para>
         +
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         攻撃
        </para>
       </entry>
       <entry>
        <para>
         + (SSH)
        </para>
       </entry>
       <entry>
        <para>
         + (SSH)
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         データ損失
        </para>
       </entry>
       <entry>
        <para>
         ++
        </para>
       </entry>
       <entry>
        <para>
         +
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.net.sync.cvs">
  <title>CVSの概要</title><indexterm xml:id="idx.CVS" class="startofrange"> <primary>CVS</primary> </indexterm> <indexterm xml:id="idx.files_synchronizing_CVS" class="startofrange"> <primary>ファイル</primary> <secondary>同期化</secondary> <tertiary>CVS</tertiary> </indexterm>

  <para>
   CVSは、個々のファイルが頻繁に編集され、ASCIIテキストやプログラムソーステキストのようなファイル形式で保存される場合の同期に適しています。CVSを使用して他の形式、たとえばJPEGファイルのデータを同期させることは可能ですが、生成される数多くのファイルをCVSサーバに恒久的に保存するため、結果としてデータ量が膨大になります。このような場合、CVSの機能のほとんどが利用できません。CVSを使用したファイルの同期は、すべてのワークステーションが同じサーバにアクセスできる場合のみ可能です。
  </para>

  <sect2 xml:id="sec.net.sync.cvs.config">
   <title>CVSサーバの設定</title>
   <para>
    <emphasis>サーバ</emphasis>とは、すべてのファイルの最新バージョンを含め、有効なファイルが配置されるホストです。固定のワークステーションであれば、どれでもサーバとして使用できます。可能であれば、CVSリポジトリのデータを定期バックアップに含めます。
   </para>
   <para>
    CVSサーバを設定するとき、できればユーザアクセスをSSH経由で許可します。ユーザがサーバに<systemitem class="username">tux</systemitem>として認識され、CVSソフトウェアがサーバとクライアントにインストールされている場合、次の環境変数をクライアント側に設定する必要があります。
   </para>
<screen><?dbsuse-latex font-size="footnotesize" ?>


CVS_RSH=ssh CVSROOT=tux@server:/serverdir</screen>
   <para>
    コマンド<command>cvs</command><option>init</option>を使用して、クライアント側からCVSサーバを初期化します。これは一度だけ実行すれば、後は必要ありません。
   </para>
   <para>
    最後に、同期に名前を付ける必要があります。クライアント上で、CVSで管理するファイルのディレクトリ(空のディレクトリ)を選択するか作成します。ディレクトリには、同期用の名前を付けます。この例で、ディレクトリ名は<literal>synchome</literal>です。このディレクトリに移動し、次のコマンドを入力して、同期名を<literal>synchome</literal>と設定します。
   </para>
<screen>cvs import synchome tux wilber</screen>
   <para>
    CVSの多くはコメントが必要です。このため、CVSはエディタを起動します(環境変数<literal>$EDITOR</literal>で定義されたエディタか、エディタが定義されていない場合はvi)。事前に次の例のようなコマンドラインにコメントを入力しておけば、エディタ呼び出しが避けられます。
   </para>
<screen>cvs import -m 'this is a test' synchome tux wilber</screen>
  </sect2>

  <sect2 xml:id="sec.net.sync.cvs.using">
   <title>CVSの使用</title>
   <para>
    これで、すべてのホストが<command>cvs</command><option>co synchome</option>を使用して同期リポジトリからチェックアウトできます。これにより、クライアントに新しいサブディレクトリ<filename>synchome</filename>が作成されます。変更内容をサーバにコミットするには、ディレクトリ<filename>synchome</filename>(またはそのサブディレクトリ)に移動し、「<command>cvs</command> <option>commit</option>」と入力します。
   </para>
   <para>
    デフォルトでは、すべてのファイル(サブディレクトリを含め)がサーバにコミットされます。個別のファイルまたはディレクトリだけをコミットするには、<command>cvs</command><option>commit file1 directory1</option>のように指定します。新しいファイルとディレクトリは、サーバにコミットする前に、<command>cvs</command><option>add file1 directory1</option>のようなコマンドを使用してリポジトリに追加する必要があります。この後、<command>cvs</command><option>commit file1 directory1</option>を実行して、新しく追加したファイルとディレクトリをコミットします。
   </para>
   <para>
    他のワークステーションに移動する場合、同じワークステーションの以前のセッションで同期リポジトリからチェックアウトしていない場合は、ここでチェックアウトします。
   </para>
   <para>
    サーバとの同期は、<command>cvs</command> <option>update</option>を使用して起動します。<command>cvs</command> <option>update file1 directory1</option>を使用すると、ファイルやディレクトリを個別に更新できます。現行のファイルとサーバに格納されているバージョンとの違いを確認するには、コマンド<command>cvs</command> <option>diff</option>または<command>cvs</command> <option>diff file1 directory1</option>を使用します。更新によって変更されたファイルを確認する場合は、<command>cvs</command> <option>-nq update</option>を使用します。
   </para>
   <para>
    更新時に表示されるステータス記号の例を次に示します。
   </para>
   <variablelist>
    <varlistentry>
     <term>U</term>
     <listitem>
      <para>
       ローカルバージョンが更新されました。この更新はサーバが提供しているすべてのファイル、およびローカルにシステムに存在しないすべてのファイルに影響します。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>M</term>
     <listitem>
      <para>
       ローカルバージョンが変更されました。サーバ上で変更があれば、その差分がローカルコピーに取り込まれていることがあります。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>P</term>
     <listitem>
      <para>
       ローカルバージョンに対し、サーバ上のバージョンからパッチが適用されました。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>C</term>
     <listitem>
      <para>
       ローカルファイルが、リポジトリの現在のバージョンと競合しています。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>?</term>
     <listitem>
      <para>
       このファイルがCVSに存在しません。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    ステータス<literal>M</literal>は、ローカルで変更されたファイルを示します。ローカルコピーをサーバにコミットするか、ローカルファイルを削除して更新を再実行します。この場合、不足しているファイルは、サーバから取得されます。ローカルに変更したファイルをコミットしたが、そのファイルで同じ行に変更があり以前にコミットされている場合は、競合が<literal>C</literal>で示されて表示されることがあります。
   </para>
   <para>
    この場合、ファイル内の競合マーク(<quote><literal>&gt;&gt;</literal></quote>および<quote><literal>&lt;&lt;</literal></quote>)を確認し、2つのバージョンのどちらを採用するか決定します。これは厄介な作業のため、変更を破棄し、ローカルファイルを削除して「<command>cvs</command> <option>up</option>」と入力し、現在のバージョンをサーバから取得することもできます。
   </para><indexterm class="endofrange" startref="idx.CVS"/><indexterm class="endofrange" startref="idx.files_synchronizing_CVS"/>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.net.sync.rsync">
  <title>rsyncの概要</title><indexterm> <primary>rsync</primary> </indexterm>

  <para>
   rsyncは、大量のデータを定期的に送信する必要があるが、変更量はあまり多くない場合に便利です。たとえば、バックアップの作成時などが該当します。もう1つのアプリケーションはステージングサーバに関係します。この種のサーバには、DMZでWebサーバに定期的にミラー化されるWebサーバの完全なディレクトリツリーが格納されます。
  </para>

  <sect2 xml:id="sec.net.sync.rsync.usage">
   <title>設定と操作</title>
   <para>
    rsyncには2つの操作モードがあります。このプログラムを使用してデータをアーカイブまたはコピーできます。そのためには、ターゲットシステム上にSSHなどのリモートシェルがあれば十分です。ただし、rsyncをdaemonとして使用し、ネットワークにディレクトリを提供することもできます。
   </para>
   <para>
    rsync の基本操作モードの場合、特別な設定は不要です。rsync では、ディレクトリ全体を別のシステムに直接ミラー化できます。たとえば、次のコマンドでは、tuxのホームディレクトリのバックアップがバックアップサーバsun上に作成されます。
   </para>
<screen>rsync -baz -e ssh /home/tux/ tux@sun:backup</screen>
   <para>
    次のコマンドは、ディレクトリを復元する場合に使用します。
   </para>
<screen>rsync -az -e ssh tux@sun:backup /home/tux/</screen>
   <para>
    ここまでの操作は、scpのような通常のコピーツールの場合とほぼ同じです。
   </para>
   <para>
    rsyncのすべての機能を完全に使用可能にするには、<quote>rsync</quote>モードで操作する必要があります。そのためには、いずれかのシステムでrsyncdデーモンを起動します。設定はファイル<filename>/etc/rsyncd.conf</filename>内で行います。たとえば、rsyncでディレクトリ<filename>/srv/ftp</filename>を使用可能にするには、次の設定を使用します。
   </para>
<screen>gid = nobody
uid = nobody
read only = true
use chroot = no
transfer logging = true
log format = %h %o %f %l %b
log file = /var/log/rsyncd.log

[FTP]
        path = /srv/ftp
        comment = An Example</screen>
   <para>
    続いて、<command>systemctl start rsyncd</command>を実行してrsyncdを起動します。また、ブート処理中にrsyncdを自動的に起動する方法もあります。このようにセットアップするには、このサービスをYaSTの<guimenu>サービスマネージャ</guimenu>で有効にするか、またはコマンドを手動で入力します。
   </para>
<screen><prompt>root # </prompt> systemctl enable rsyncd</screen>
   <para>

    代わりに、syncdをxinetdによって起動することもできます。ただし、この方法はrsyncdの使用頻度が低いサーバの場合にのみ使用してください。
   </para>
   <para>
    この例では、すべての接続を示すログファイルも作成されます。このファイルは<filename>/var/log/rsyncd.log</filename>に格納されます。
   </para>
   <para>
    これで、クライアントシステムからの転送をテストできます。そのためには次のコマンドを使用します。
   </para>
<screen>rsync -avz sun::FTP</screen>
   <para>
    このコマンドを入力すると、サーバのディレクトリ<filename>/srv/ftp</filename>にあるファイルがすべてリストされます。このリクエストはログファイル<filename>/var/log/rsyncd.log</filename>にも記録されます。実際の転送を開始するには、ターゲットディレクトリを指定します。現在のディレクトリには<literal>.</literal>.を使用してください。たとえば、次のようにします。
   </para>
<screen>rsync -avz sun::FTP .</screen>
   <para>
    デフォルトでは、rsyncでの同期中にファイルは削除されません。ファイルを削除する必要がある場合は、オプション「<option>--delete</option>」を追加してください。新しい方のファイルが削除されないように、代わりにオプション<option>--update</option>を使用することもできます。競合が発生した場合は、手動で解決する必要があります。
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.net.sync.summary">
  <title>詳細情報</title>

  <variablelist>
   <varlistentry>
    <term>CVS</term>
    <listitem>
     <para>
      CVSの重要情報については、ホームページ「<link xlink:href="http://www.cvshome.org"/>」を参照してください。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>rsync</term>
    <listitem>
     <para>
      rsyncに関する重要な情報は、マニュアルページ<command>man</command><option>rsync</option>および<command>man</command><option>rsyncd.conf</option>を参照してください。rsyncの基本原則に関する技術情報については、<filename>/usr/share/doc/packages/rsync/tech_report.ps</filename>を参照してください。rsyncの最新ニュースについては、このプロジェクトのWebサイト<link xlink:href="http://rsync.samba.org/"/>を参照してください。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Subversion</term>
    <listitem>
     <para>
      サブバージョンは、SUSE Linux Enterprise SDKから入手できます。SDKは、SUSE Linux Enterprise用のモジュールで、SUSEカスタマーセンターからオンラインチャネル経由で入手できます。または、<link xlink:href="http://download.suse.com/"/>からダウンロードしてください。(「<literal>SUSE Linux Enterpriseソフトウェア開発キット</literal>」で検索してください。)詳細については、<xref linkend="cha.add-ons"/>を参照してください。
     </para>
    </listitem>
   </varlistentry>
  </variablelist><indexterm class="endofrange" startref="idx.files_syncronizing"/>
 </sect1>
</chapter>
