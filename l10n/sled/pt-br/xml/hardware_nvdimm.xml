<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="hardware_nvdimm.xml" version="5.0" xml:id="cha-nvdimm"> <title>Memória persistente</title>
 <info>
      <abstract>
        <para>
    Este capítulo contém informações adicionais sobre como usar o SUSE Linux Enterprise com memória principal não volátil, também conhecida como <emphasis>Memória Persistente</emphasis>, que consiste em um ou mais NVDIMMs.
   </para>
      </abstract>
      <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
        <dm:bugtracker/>
        <dm:translation>yes</dm:translation>
      </dm:docmanager>
    </info>
    <sect1 xml:id="sec-nvdimm-intro">
  <title>Introdução</title>

  <para>
   Memória persistente é um novo tipo de armazenamento no computador, que combina velocidades muito próximas às da RAM dinâmica (DRAM) ao endereçamento byte por byte da RAM, além da permanência dos SSDs (Solid-State Disks – Discos de Estado Sólido).
  </para>

  <para>
   No momento, a SUSE permite o uso de memória persistente com o SUSE Linux Enterprise Server em máquinas com as arquiteturas AMD64/Intel 64 e POWER.
  </para>
  
  <para>
   Como a RAM convencional, a memória persistente é instalada diretamente nos slots de memória da placa-mãe. Dessa forma, ela é fornecida no mesmo fator de formato físico da RAM – como DIMMs. Eles são conhecidos como NVDIMMs: módulos de memória dupla em linha não voláteis.
  </para>

  <para>
   No entanto, ao contrário da RAM, a memória persistente apresenta vários aspectos similares aos SSDs com base em flash. As duas são baseadas em formatos de circuito de memória de estado sólido, mas, apesar disso, ambas fornecem armazenamento não volátil: O conteúdo é mantido quando o sistema é desligado ou reiniciado. Para ambos os formatos de meio, a gravação de dados é mais lenta do que a leitura, e os dois suportam um número limitado de ciclos de regravação. Por fim, também como os SSDs, o acesso à memória persistente no nível do setor será possível se isso for mais adequado para um determinado aplicativo.
  </para>

  <para>
   Modelos diferentes usam formatos distintos de meio de armazenamento eletrônico, como Intel 3D XPoint, ou uma combinação de NAND Flash e DRAM. Há novos formatos de RAM não volátil também em desenvolvimento. Isso significa que fornecedores e modelos diferentes do NVDIMM oferecem características distintas de durabilidade e desempenho.
  </para>

  <para>
   Como as tecnologias de armazenamento envolvidas estão em um estágio inicial de desenvolvimento, o hardware de fornecedores diferentes pode impor limitações distintas. Dessa forma, as afirmações a seguir são uma generalização.
  </para>
  
  <para>
   A memória persistente é até dez vezes mais lenta do que a DRAM, mas cerca de mil vezes mais rápida do que o armazenamento flash. Ela pode ser regravada byte por byte, em vez de usar o processo da memória flash de “apagar e regravar” todo o setor. Por fim, enquanto os ciclos de regravação são limitados, a maioria dos formatos de memória persistente pode processar milhões de regravações, em comparação com os milhares de ciclos do armazenamento flash.
  </para>
  
  <para>
   Isso apresenta duas consequências importantes:
  </para>

  <itemizedlist>
   <listitem>
    <para>
     Com a tecnologia atual, não é possível executar um sistema apenas com memória persistente e, desse modo, atingir uma memória principal totalmente não volátil. Você deve usar uma mistura de RAM convencional e NVDIMMs. Os aplicativos e o sistema operacional serão executados na RAM convencional, com os NVDIMMs fornecendo o armazenamento suplementar muito rápido.
    </para>
   </listitem>
   <listitem>
    <para>
     As características de desempenho da memória persistente dos diversos fornecedores significam que talvez seja necessário para os programadores prestar atenção nas especificações de hardware dos NVDIMMs em um servidor específico, incluindo quantos NVDIMMs existem e em quais slots de memória eles se encaixam. Certamente, isso afetará o uso do hipervisor, a migração de software entre máquinas host diferentes, etc.
    </para>
   </listitem>
  </itemizedlist>

  <para>
   Esse novo subsistema de armazenamento está definido na versão 6 do padrão ACPI. No entanto, o <filename>libnvdimm</filename> suporta NVDIMMs anteriores ao padrão, e eles podem ser usados da mesma maneira.
  </para>
  
 </sect1>
 <sect1 xml:id="sec-nvdimm-terms">
  <title>Termos</title>

  <variablelist>
   <varlistentry>
    <term>Região</term>
    <listitem>
     <para>
      Uma <emphasis>região</emphasis> é um bloco da memória persistente que pode ser dividido em mais <emphasis>namespace</emphasis>s. Não é possível acessar a memória persistente de uma região sem primeiro alocá-la a um namespace.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Namespace</term>
    <listitem>
     <para>
      Uma única faixa continuamente endereçada de armazenamento não volátil, comparável a namespaces de SSD do NVM Express ou a LUNs (Logical Units – Unidades Lógicas) de SCSI. Os namespaces aparecem no diretório <filename>/dev/cdrom</filename> do servidor como dispositivos de blocos separados. Dependendo do método de acesso necessário, os namespaces podem unir o armazenamento de vários NVDIMMs em grandes volumes ou permitir que ele seja particionado em volumes menores.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Modo</term>
    <listitem>
     <para>
      Cada namespace também tem um <emphasis>modo</emphasis> que define os recursos NVDIMM que estão habilitados para esse namespace. Os namespaces irmão da mesma região pai sempre terão o mesmo tipo, mas poderão ser configurados para ter modos diferentes. Veja a seguir os modos de namespace:
     </para>
     <variablelist>
      <varlistentry>
       <term>devdax</term>
       <listitem>
        <para>
         Modo Dispositivo-DAX. Cria um arquivo de dispositivo de caractere único (<filename>/dev/dax<replaceable>X</replaceable>.<replaceable>S</replaceable>
         </filename>). <emphasis>Não</emphasis> requer a criação do sistema de arquivos.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>fsdax</term>
       <listitem>
        <para>
         Modo Sistema de arquivos-DAX. Padrão, se nenhum outro modo for especificado. Cria um dispositivo de blocos (<filename>/dev/pmem<replaceable>X</replaceable> [.<replaceable>Y</replaceable>]</filename>) que suporta o DAX para <literal>ext4</literal> ou <literal>XFS</literal>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>sector</term>
       <listitem>
        <para>
         Para sistemas de arquivos legados que não efetuam checksum de metadados. Adequado para pequenos volumes de boot. Compatível com outros sistemas operacionais.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>raw</term>
       <listitem>
        <para>
         Um disco de memória sem rótulo ou metadados. Não suporta a DAX. Compatível com outros sistemas operacionais.
        </para>
        <note>
         <para>
          O modo <literal>raw</literal> não é suportado pelo SUSE. Não é possível montar sistemas de arquivos em namespaces <literal>raw</literal>.
         </para>
        </note>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Tipo</term>
    <listitem>
     <para>
      Cada namespace e região tem um <emphasis>tipo</emphasis> que define o modo como a memória persistente associada a esse namespace ou região pode ser acessada. Um namespace sempre tem o mesmo tipo que sua região pai. Há dois tipos diferentes: Memória Persistente, que pode ser configurada de duas formas diferentes, e o Modo de Bloco descontinuado.
     </para>
     <variablelist>
      <varlistentry>
       <term>Memória persistente (PMEM)</term>
       <listitem>
        <para>
         O armazenamento PMEM oferece acesso no nível de bytes, assim como a RAM. Usando a PMEM, um único namespace pode incluir vários NVDIMMs intercalados, permitindo que todos sejam usados como um único dispositivo.
        </para>
        <para>
         Há duas maneiras de configurar um namespace PMEM.
        </para>
        <variablelist>
         <varlistentry>
          <term>PMEM com DAX</term>
          <listitem>
           <para>
            Um namespace PMEM configurado para Acesso Direto (DAX) significa que o acesso à memória ignora o cache de página do kernel e vai direto para o meio. O software pode ler ou gravar diretamente cada byte do namespace de maneira separada.
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>PMEM com tabela de conversão de blocos (BTT, Block Translation Table)</term>
          <listitem>
           <para>
            Um namespace PMEM configurado para operar no modo BTT é acessado de setor por setor, como uma unidade de disco convencional, em vez do modelo endereçável por byte mais semelhante ao da RAM. Um mecanismo de tabela de conversão de lotes acessa as unidades do tamanho do setor.
           </para>
           <para>
            A vantagem da BTT é a proteção de dados. O subsistema de armazenamento garante que cada setor seja completamente gravado no meio subjacente. Se um setor não puder ser completamente gravado (ou seja, se a operação de gravação falhar por algum motivo), todo o setor será revertido ao estado anterior. Portanto, um determinado setor não pode ser parcialmente gravado. 
           </para>
           <para>
            Além disso, acesso a namespaces BTT é armazenado em cache pelo kernel.
           </para>
           <para>
            A desvantagem é que não é possível usar o DAX para namespaces BTT.
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Modo de bloco (BLK)</term>
       <listitem>
        <para>
         O armazenamento do modo de bloco considera cada NVDIMM como um dispositivo separado. Seu uso foi descontinuado e não é mais suportado.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
     <para>
      Exceto pelos namespaces <literal>devdax</literal>, todos os outros tipos devem ser formatados com um sistema de arquivos, assim como em uma unidade convencional. O <phrase role="productname"><phrase os="sled">SUSE Linux Enterprise Desktop</phrase></phrase> suporta os sistemas de arquivos <literal>ext2</literal>, <literal>ext4</literal> e <literal>XFS</literal> para essa finalidade.
     </para>
   </listitem>
   </varlistentry>
   <varlistentry>
    <term>Acesso direto (DAX)</term>
    <listitem>
     <para>
      O DAX permite que a memória persistente seja mapeada diretamente para o espaço de endereço de um processo, por exemplo, usando a chamada do sistema <literal>mmap</literal>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Endereço físico DIMM (DPA)</term>
    <listitem>
     <para>
      Um endereço de memória como uma diferença na memória de um único DIMM; ou seja, começar do zero como o menor byte endereçável nesse DIMM.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Rótulo</term>
    <listitem>
     <para>
      Metadados armazenados no NVDIMM, como definições de namespace. É possível acessá-los usando DSMs.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Método específico do dispositivo (DSM)</term>
    <listitem>
     <para>
      Método ACPI para acessar o firmware em um NVDIMM.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 xml:id="sec-nvdimm-uses">
  <title>Casos de uso</title>

  <sect2 xml:id="sec-nvdimm-uses-pmem">
   <title>PMEM com DAX</title>
   <para>
    É importante observar que esse formato de acesso à memória <emphasis>não</emphasis> é transacional. Em caso de queda de energia ou outra falha no sistema, os dados podem não ser totalmente gravados no armazenamento. O armazenamento PMEM será adequado apenas se o aplicativo puder resolver a situação dos dados parcialmente gravados.
   </para>
   <sect3>
    <title>
     Aplicativos que se beneficiam de grandes quantidades de armazenamento endereçável por byte</title>
    <para>
     Se o servidor for hospedar um aplicativo que possa usar diretamente grandes quantidades de armazenamento rápido byte por byte, o programador poderá usar a chamada do sistema <literal>mmap</literal> para inserir blocos da memória persistente diretamente no espaço do endereço do aplicativo, sem usar nenhuma RAM do sistema adicional.
    </para>
   </sect3>
   <sect3>
    <title>Evitando o uso do cache de página do kernel</title>
    <para>
     Evite usar o cache de página do kernel se você deseja continuar usando a RAM para o cache de página. Em vez disso, passe-o para os seus aplicativos. Por exemplo, a memória não volátil pode se dedicar a armazenar imagens da VM (Virtual Machine – Máquina Virtual). Como elas não são armazenadas em cache, isso reduz o uso do cache no host, permitindo mais VMs por host.
    </para>
   </sect3>
  </sect2>

  <sect2>
   <title>PMEM com BTT</title>
   <para>
    Isso é útil quando você deseja usar a memória persistente em um conjunto de NVDIMMs como um pool do tipo disco de armazenamento muito rápido. Por exemplo, ao colocar o diário do sistema de arquivos na PMEM com BTT, você aumenta a confiabilidade da recuperação do sistema de arquivos após uma queda de energia ou outra interrupção repentina (consulte a <xref linkend="sec-nvdimm-setup-btt"/>).
   </para>
   <para>
    Para aplicativos, esses dispositivos apenas aparecem como SSDs muito rápidos e podem ser usados como qualquer outro dispositivo de armazenamento. Por exemplo, a LVM pode ser colocada em camadas sobre a memória persistente e funcionará normalmente.
   </para>
   <para>
    A vantagem do BTT é que a atomicidade de gravação do setor é garantida; portanto, até os aplicativos sofisticados que dependem da integridade dos dados continuarão funcionando. O relatório de erros da mídia funciona por meio dos canais de geração de relatórios de erros. 
   </para>
  </sect2>
 </sect1>

 <sect1 xml:id="sec-nvdimm-tools">
  <title>Ferramentas para gerenciamento de memória persistente</title>

  <para>
   Para gerenciar a memória persistente, é necessário instalar o pacote <literal>ndctl</literal>. Esse procedimento também instala o pacote <filename>libndctl</filename>, que fornece um conjunto de bibliotecas de espaço do usuário para configurar os NVDIMMs.
  </para>
  
  <para>
   Essas ferramentas funcionam por meio da biblioteca <filename>libnvdimm</filename>, que suporta três tipos de NVDIMM:
  </para>
  
  <itemizedlist>
   <listitem>
    <para>
     PMEM
    </para>
   </listitem>
   <listitem>
    <para>
     BLK
    </para>
   </listitem>
   <listitem>
    <para>
     PMEM e BLK simultâneos
    </para>
   </listitem>
  </itemizedlist>

  <para>
   O utilitário <command>ndctl</command> inclui um conjunto útil de páginas de <command>manual</command>, que pode ser acessado com o comando:
  </para>

<screen><prompt>tux &gt; </prompt><command>ndctl help <replaceable>subcommand</replaceable></command></screen>

  <para>
   Para ver uma lista de subcomandos disponíveis, use:
  </para>

<screen><prompt>tux &gt; </prompt><command>ndctl --list-cmds</command></screen>

  <para>
   Os subcomandos disponíveis incluem:
  </para>

  <variablelist>
   <varlistentry>
    <term>version</term>
    <listitem>
     <para>
      Exibe a versão atual das ferramentas de suporte do NVDIMM.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>enable-namespace</term>
    <listitem>
     <para>
      Torna o namespace especificado disponível para uso.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>disable-namespace</term>
    <listitem>
     <para>
      Impede que o namespace especificado seja usado.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>create-namespace</term>
    <listitem>
     <para>
      Cria um novo namespace com base nos dispositivos de armazenamento especificado.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>destroy-namespace</term>
    <listitem>
     <para>
      Remove o namespace especificado.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>enable-region</term>
    <listitem>
     <para>
      Torna a região especificada disponível para uso.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>disable-region</term>
    <listitem>
     <para>
      Impede que a região especificada seja usada.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>zero-labels</term>
    <listitem>
     <para>
      Apaga os metadados de um dispositivo.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>read-labels</term>
    <listitem>
     <para>
      Recupera os metadados do dispositivo especificado.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>list</term>
    <listitem>
     <para>
      Exibe os dispositivos disponíveis.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>help</term>
    <listitem>
     <para>
      Exibe as informações sobre como usar a ferramenta.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 xml:id="sec-nvdimm-setup">
  <title>Configurando a memória persistente</title>

  <sect2 xml:id="sec-nvdimm-setup-view">
   <title>Vendo o armazenamento NVDIMM disponível</title>
   <para>
    É possível usar o comando <command>ndctl</command> <literal> list</literal> para listar todos os NVDIMMs disponíveis em um sistema.
   </para>
   <para>
    No exemplo a seguir, o sistema tem três NVDIMMs, que estão em um único conjunto de canal triplo intercalado.
   </para>
<screen><prompt role="root">root # </prompt><command>ndctl list --dimms</command>

[
 {
  "dev":"nmem2",
  "id":"8089-00-0000-12325476"
 },
 {
  "dev":"nmem1",
  "id":"8089-00-0000-11325476"
 },
 {
  "dev":"nmem0",
  "id":"8089-00-0000-10325476"
 }
]</screen>
   <para>
    Com um parâmetro diferente, o <command>ndctl</command>
    <literal> list</literal> também listará as regiões disponíveis.
   </para>
   <note>
    <para>
     As regiões podem não aparecer em ordem numérica.
    </para>
   </note>
   <para>
    Apesar de haver apenas três NVDIMMs, eles aparacem como quatro regiões.
   </para>
<screen><prompt role="root">root # </prompt><command>ndctl list --regions</command>

[
 {
  "dev":"region1",
  "size":68182605824,
  "available_size":68182605824,
  "type":"blk"
 },
 {
  "dev":"region3",
  "size":202937204736,
  "available_size":202937204736,
  "type":"pmem",
  "iset_id":5903239628671731251
  },
  {
   "dev":"region0",
   "size":68182605824,
   "available_size":68182605824,
   "type":"blk"
  },
  {
   "dev":"region2",
   "size":68182605824,
   "available_size":68182605824,
   "type":"blk"
  }
]</screen>
   <para>
    O espaço está disponível em dois formatos diferentes: como três regiões separadas de 64 GB do tipo BLK ou como uma região combinada de 189 GB do tipo PMEM, que apresenta todo o espaço nos três NVDIMMs intercalados como um único volume.
   </para>
   <para>
    Observe que o valor exibido para <literal>available_size</literal> é igual ao de <literal>size</literal>. Isso significa que nada do espaço ainda foi alocado.
   </para>
  </sect2>

  <sect2 xml:id="sec-nvdimm-setup-dax">
   <title>Configurando o armazenamento como um único namespace PMEM com DAX</title>
   <para>
    Para o primeiro exemplo, configuraremos nossos três NVDIMMs em um único namespace PMEM com Acesso Direto (DAX).
   </para>
   <para>
    A primeira etapa é criar um novo namespace.
   </para>
<screen><prompt role="root">root # </prompt><command>ndctl create-namespace --type=<replaceable>pmem</replaceable> --mode=<replaceable>fsdax</replaceable> --map=<replaceable>memory</replaceable></command>
{
 "dev":"namespace3.0",
 "mode":"memory",
 "size":199764213760,
 "uuid":"dc8ebb84-c564-4248-9e8d-e18543c39b69",
 "blockdev":"pmem3"
}</screen>
   <para>
    Esse procedimento cria um dispositivo de blocos <filename>/dev/pmem3</filename>, que suporta DAX. O <literal>3</literal> no nome do dispositivo é herdado do número da região pai, neste caso, <filename>region3</filename>.
   </para>
   <para>
    A opção <option>--map=memory</option> separa parte do espaço do armazenamento PMEM nos NVDIMMs para que ele possa ser usado para alocar as estruturas de dados internas do kernel denominadas <literal>struct pages</literal>. Dessa forma, o novo namespace PMEM pode ser usado com recursos como <literal>O_DIRECT I/O</literal> e <literal>RDMA</literal>.
   </para>
   <para>
    A reserva de parte da memória persistente para estruturas de dados do kernel é o que causa uma redução na capacidade do namespace PMEM em relação à região PMEM pai.
   </para>
   <para>
    Na sequência, verificamos se o novo dispositivo de blocos está disponível para o sistema operacional:
   </para>
<screen><prompt role="root">root # </prompt><command>fdisk -l /dev/<replaceable>pmem3</replaceable></command>
Disk /dev/pmem3: 186 GiB, 199764213760 bytes, 390164480 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 4096 bytes
I/O size (minimum/optimal): 4096 bytes / 4096 bytes</screen>
   <para>
    Antes que possa ser usada, como qualquer outra unidade, ela deverá ser formatado. Neste exemplo, nós a formatamos com XFS:
   </para>
<screen><prompt role="root">root # </prompt><command>mkfs.xfs /dev/<replaceable>pmem3</replaceable></command>
meta-data=/dev/pmem3      isize=256    agcount=4, agsize=12192640 blks
         =                sectsz=4096  attr=2, projid32bit=1
         =                crc=0        finobt=0, sparse=0
data     =                bsize=4096   blocks=48770560, imaxpct=25
         =                sunit=0      swidth=0 blks
naming   =version 2       bsize=4096   ascii-ci=0 ftype=1
log      =internal log    bsize=4096   blocks=23813, version=2
         =                sectsz=4096  sunit=1 blks, lazy-count=1
realtime =none            extsz=4096   blocks=0, rtextents=0</screen>
   <para>
    Em seguida, podemos montar a nova unidade em um diretório:
   </para>
<screen><prompt role="root">root # </prompt><command>mount -o dax /dev/<replaceable>pmem3</replaceable> /mnt/<replaceable>pmem3</replaceable></command></screen>
   <para>
    Agora, podemos verificar que temos um dispositivo compatível com DAX:
   </para>
<screen><prompt role="root">root # </prompt><command>mount | grep dax</command>
/dev/pmem3 on /mnt/pmem3 type xfs (rw,relatime,attr2,dax,inode64,noquota)</screen>
   <para>
    O resultado é que agora contamos com um namespace PMEM formatado com o sistema de arquivos XFS e montado com DAX.
   </para>
   <para>
    Qualquer chamada <literal>mmap()</literal> para arquivos nesse de sistema de arquivos retornará endereços virtuais que são mapeados diretamente para a memória persistente em nossos NVDIMMs, ignorando completamente o cache de página.
   </para>
   <para>
    Qualquer chamada <literal>fsync</literal> ou <literal>msync</literal> nos arquivos nesse sistema de arquivos ainda garantirá que os dados modificados sejam totalmente gravados nos NVDIMMs. Essas chamadas descarregam as linhas de cache do processador associadas a qualquer página que tenha sido modificada no espaço do usuário por meio de mapeamentos <literal>mmap</literal>. 
   </para>
   <sect3 xml:id="sec-nvdimm-setup-deldax">
    <title>Removendo um namespace</title>
    <para>
     Antes de criar qualquer outro tipo de volume que use o mesmo armazenamento, devemos desmontar e, em seguida, remover esse volume PMEM.
    </para>
    <para>
     Em primeiro lugar, desmonte-o:
    </para>
<screen><prompt role="root">root # </prompt><command>umount /mnt/<replaceable>pmem3</replaceable></command></screen>
    <para>
     Em seguida, desabilite o namespace:
    </para>
<screen><prompt role="root">root # </prompt><command>ndctl disable-namespace <replaceable>namespace3.0</replaceable></command>
disabled 1 namespace</screen>
    <para>
     Por último, apague-o:
    </para>
<screen><prompt role="root">root # </prompt><command>ndctl destroy-namespace <replaceable>namespace3.0</replaceable></command>
destroyed 1 namespace</screen>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-nvdimm-setup-btt">
   <title>Criando um namespace PMEM com BTT</title>
   <para>
     A BTT oferece atomicidade de gravação de setores, o que faz dela uma boa opção quando você precisa de proteção de dados, por exemplo, para diários do Ext4 e XFS. Em caso de queda de energia, os diários estão protegidos e podem ser recuperados. Os exemplos a seguir mostram como criar um namespace PMEM com BTT no modo de setor e como colocar o diário do sistema de arquivos nesse namespace.
   </para>
<screen><prompt role="root">root # </prompt><command>ndctl create-namespace --type=pmem --mode=sector</command>
{
 "dev":"namespace3.0",
 "mode":"sector",
 "uuid":"51ab652d-7f20-44ea-b51d-5670454f8b9b",
 "sector_size":4096,
 "blockdev":"pmem3s"
}</screen>
   <para>
    Em seguida, verifique se o novo dispositivo está presente:
   </para>
<screen><prompt role="root">root # </prompt><command>fdisk -l /dev/<replaceable>pmem3s</replaceable></command>
Disk /dev/pmem3s: 188.8 GiB, 202738135040 bytes, 49496615 sectors
Units: sectors of 1 * 4096 = 4096 bytes
Sector size (logical/physical): 4096 bytes / 4096 bytes
I/O size (minimum/optimal): 4096 bytes / 4096 bytes</screen>
   <para>
    Como o namespace PMEM compatível com DAX que configuramos anteriormente, esse namespace PMEM compatível com BTT consome todo o armazenamento disponível nos NVDIMMs.
   </para>   
   <note>
    <para>
     O <literal>s</literal> à direita no nome do dispositivo (<filename>/dev/<replaceable>pmem3s</replaceable></filename>) indica o <literal>setor</literal> e pode ser usado para diferenciar facilmente os namespaces configurados para usar o BTT.
    </para>
   </note>
   <para>
    É possível formatar e montar o volume como no exemplo anterior.
   </para>
   <para>
    O namespace PMEM mostrado aqui não pode usar DAX. Em vez disso, ele usa o BTT para fornecer <emphasis>atomicidade de gravação do setor</emphasis>. Em cada gravação de setor efetuada por meio do driver de bloco PMEM, o BTT alocará um novo setor para receber os novos dados. O BTT atualizará atomicamente suas estruturas de mapeamento internas depois que os novos dados forem totalmente gravados para que os dados recém-gravados ainda fiquem disponíveis aos aplicativos. Se acabar a força a qualquer momento durante esse processo, a gravação será completamente perdida, e o aplicativo terá acesso a seus dados antigos, ainda intactos. Isso impede a condição conhecida como "setores interrompidos".
   </para>
   <para>
    Esse namespace PMEM habilitado para BTT pode ser formatado e usado com um sistema de arquivos exatamente como qualquer outro dispositivo de blocos padrão. Ele não pode ser usado com DAX. No entanto, os mapeamentos <literal>mmap</literal> para os arquivos nesse dispositivo de blocos usarão o cache de página.
   </para>
  </sect2>
  
  <sect2 xml:id="sec-nvdimm-fs-journal">
      <title>Colocando o diário do sistema de arquivos na PMEM/BTT</title>
   <para>
      Quando você coloca o diário do sistema de arquivos em um dispositivo separado, ele deve usar o mesmo tamanho de bloco que o sistema de arquivos. O tamanho mais provável é 4096, e você pode saber o tamanho do bloco com este comando:
  </para>
  <screen><prompt role="root">root # </prompt><command>blockdev --getbsz /dev/<replaceable>sda3</replaceable></command></screen>
  <para>
      O exemplo a seguir cria um novo diário do Ext4 em um dispositivo NVDIMM separado, cria o sistema de arquivos em um dispositivo SATA e, em seguida, anexa o novo sistema de arquivos ao diário:
 </para>
 <screen>
<prompt role="root">root # </prompt><command>mke2fs -b 4096 -O journal_dev /dev/<replaceable>pmem3s</replaceable></command>
<prompt role="root">root # </prompt><command>mkfs.ext4 -J device=/dev/<replaceable>pmem3s</replaceable> /dev/<replaceable>sda3</replaceable></command>
</screen>
  <para>
      O exemplo a seguir cria um novo sistema de arquivos XFS em uma unidade SATA e cria o diário em um dispositivo NVDIMM separado:
  </para>
<screen><prompt role="root">root # </prompt><command>mkfs.xfs -l logdev=/dev/<replaceable>pmem3s </replaceable> /dev/<replaceable>sda3</replaceable></command>  
</screen>
<para>
    Consulte <command>man 8 mkfs.ext4</command> e <command>man 8 mkfs.ext4</command> para obter informações detalhadas sobre as opções.
</para>
</sect2>
 </sect1>

 <sect1 xml:id="sec-nvdimm-moreinfo">
  <title>Mais informações</title>

  <para>
   Mais informações sobre este tópico estão disponíveis na lista a seguir:
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     <link xlink:href="https://nvdimm.wiki.kernel.org/">Memória persistente Wiki</link>
    </para>
    <para>
     Contém instruções sobre como configurar os sistemas NVDIMM, informações sobre testes e links para as especificações relacionadas à habilitação do NVDIMM. Este site é desenvolvido à medida que o suporte a NVDIMM no Linux é desenvolvido.
    </para>
   </listitem>
   <listitem>
    <para>
     <link xlink:href="http://pmem.io/">Programação de memória persistente</link>
    </para>
    <para>
     Informações sobre como configurar, usar e programar sistemas com memória não volátil no Linux e em outros sistemas operacionais. Aborda a Biblioteca NVM (NVML, NVM Library), que fornece APIs úteis para programação com memória persistente no espaço do usuário.
    </para>
   </listitem>
   <listitem>
    <para>
     <link xlink:href="https://www.kernel.org/doc/Documentation/nvdimm/nvdimm.txt"> LIBNVDIMM: Dispositivos não voláteis</link>
    </para>
    <para>
     Destinado a desenvolvedores de kernel, ele faz parte da pasta Documentação na árvore de kernel atual do Linux. Ele explica sobre os diferentes módulos do kernel envolvidos na preparação do NVDIMM, apresenta alguns detalhes técnicos da implementação do kernel e aborda a interface do <filename>sysfs</filename> com o kernel que é usada pela ferramenta <command>ndctl</command>.
    </para>
   </listitem>
   <listitem>
    <para>
     <link xlink:href="https://github.com/pmem/ndctl">GitHub: pmem/ndctl</link>
    </para>
    <para>
     Biblioteca de utilitários para gerenciar o subsistema <command>libnvdimm</command> no kernel do Linux. Inclui também as bibliotecas de espaço do usuário, além de testes de unidade e documentação.
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
</chapter>
