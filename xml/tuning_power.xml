<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//Novell//DTD NovDoc XML V1.0//EN" "novdocx.dtd"
[
  <!ENTITY % NOVDOC.DEACTIVATE.IDREF "INCLUDE">
  <!ENTITY % entities SYSTEM "entity-decl.ent">
  %entities;
]>
<chapter id="cha.tuning.power">
 <title>Power Management</title>

<!--
 power management on the server (not mobile computers)
 Info Provider: Thomas Renniger <trenn@suse.de>
-->
 <abstract>
  <para>
   Power management aims at reducing operating costs for energy and cooling
   systems while at the same time keeping the performance of a system at a
   level that matches the current requirements. Thus, power management is
   always a matter of balancing the actual performance needs and power
   saving options for a system. Power management can be implemented and used
   at different levels of the system. A set of specifications for power
   management functions of devices and the operating system interface to
   them has been defined in the Advanced Configuration and Power Interface
   (ACPI). As power savings in server environments can primarily be achieved
   on processor level, this chapter introduces some of the main concepts and
   highlights some tools for analyzing and influencing relevant parameters.
  </para>
 </abstract>
 <sect1 id="sec.tuning.power.cpu">
  <title>Power Management at CPU Level</title>

  <para>
   At CPU level, you can control power usage in various ways: for example,
   by using idling power states (C-states), changing CPU frequency
   (P-states), and throttling the CPU (T-states). The following sections
   give a short introduction to each approach and its significance for power
   savings. Detailed specifications can be found at
   <ulink url="http://www.acpi.info/spec.htm"
   />.
  </para>

  <sect2 id="sec.tuning.power.cpu.cstates">
   <title>C-States (Processor Operating States)</title>
   <para>
    Modern processors have several power saving modes called
    <literal>C-states</literal>. They reflect the capability of an idle
    processor to turn off unused components in order to save power. Whereas
    C-states have been available for laptops for some time, they are a
    rather recent trend in the server market (for example, with Intel*
    processors, C-modes are only available since
    <phrase role="productname">Nehalem</phrase>).
   </para>
   <para> When a processor runs in the <literal>C0</literal> state, it is
    executing instructions. A processor running in any other C-state is idle.
    The higher the C number, the deeper the CPU sleep mode: more components are
    shut down to save power. Deeper sleep states are very efficient concerning
    power consumption in an idle system. But the downside is that they introduce
    higher latency (the time the CPU needs to go back to <literal>C0</literal>).
    Depending on the workload (threads waking up, triggering some CPU utilization
    and then going back to sleep again for a short period of time) or hardware (for
    example, interrupt activity of a network device), disabling the deepest sleep states
    can significantly increase overall performance. For details on how
    to do so, refer to <xref
     linkend="sec.tuning.power.tools.cpupower.idle-info"/>.</para>
   <para>
    Some states also have submodes with different power saving latency
    levels. Which C-states and submodes are supported depends on the
    respective processor. However, <literal>C1</literal> is always
    available.
   </para>
   <para>
    <xref linkend="tab.tuning.power.cstates"/> gives an overview of the most
    common C-states.
   </para>
   <table id="tab.tuning.power.cstates">
    <title>C-States</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>
        <para>
         Mode
        </para>
       </entry>
       <entry>
        <para>
         Definition
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         C0
        </para>
       </entry>
       <entry>
        <para>
         Operational state. CPU fully turned on.
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         C1
        </para>
       </entry>
       <entry>
        <para>
         First idle state. Stops CPU main internal clocks via software. Bus
         interface unit and APIC are kept running at full speed.
<!--taroth 2010-04-28: upon request by trenn, do
          not mention C1E at  all-->
<!--Some processors
         also support an Enhanced C1 state (C1E or Enhanced Halt State) for
         lower power consumption. -->
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         C2
        </para>
       </entry>
       <entry>
        <para>
         Stops CPU main internal clocks via hardware. State where the
         processor maintains all software-visible states, but may take
         longer to wake up through interrupts.
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         C3
        </para>
       </entry>
       <entry>
        <para>
         Stops all CPU internal clocks. The processor does not need to keep
         its cache coherent, but maintains other states. Some processors
         have variations of the C3 state that differ in how long it takes to
         wake the processor through interrupts.
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>To avoid needless power consumption, it is recommended to test your
    workloads with deep sleep states enabled versus deep sleep states disabled. 
    A recent maintenance update for &productname; 11 SP3 provides an updated <systemitem
     class="resource">cpupower</systemitem> package with an additional
    <command>cpupower</command> subcommand. Use it to disable or enable 
    individual C-states, if necessary. For more information, refer to <xref
    linkend="sec.tuning.power.tools.cpupower.idle-info"/> or the
    <command>cpupower-idle-set(1)</command> man page.</para>
<!--taroth 2010-04-28: upon request by trenn, do not mention C1E at all-->
<!--<para>Whereas states C0 to C3 cut clock signals used inside the CPU, there are also
    C-states that work by reducing the CPU voltage (C4 to C6). <literal>Enhanced</literal> modes can
    do both at the same time. For example, C1E tries to provide more power savings than the
    traditional C1 state by also lowering the voltage and frequency. In fact, C1E has the ability to
    lower the voltage/frequency faster than any of the &cpufreq; governors discussed in <xref
    linkend="sec.tuning.power.cpufreq"/>. </para>-->
<!--taroth 2010-08-02: from pcmcia-apm.xml: add for next revision:
  <para>The current state is displayed in <filename>/proc/acpi/processor/*/power</filename>.</para>-->
  </sect2>

  <sect2 id="sec.tuning.power.cpu.pstates">
   <title>P-States (Processor Performance States)</title>
   <para>
    While a processor operates (in C0 state), it can be in one of several
    CPU performance states <literal>(P-states)</literal>. Whereas C-states
    are idle states (all but C0), <literal>P-states</literal> are
    operational states that relate to CPU frequency and voltage.
   </para>
   <para>
    The higher the P-state, the lower the frequency and voltage at which the
    processor runs. The number of P-states is processor-specific and the
    implementation differs across the various types. However,
    <literal>P0</literal> is always the highest-performance state. Higher
    P-state numbers represent slower processor speeds and lower power
    consumption. For example, a processor in P3 state runs more slowly and
    uses less power than a processor running at P1 state. To operate at any
    P-state, the processor must be in the C0 state where the processor is
    working and not idling. The CPU P-states are also defined in the
    Advanced Configuration and Power Interface (ACPI) specification, see
    <ulink url="http://www.acpi.info/spec.htm"/>.
   </para>
   <para>
    C-states and P-states can vary independently of one another.
   </para>
  </sect2>

  <sect2 id="sec.tuning.cpu.power.tstates">
   <title>T-States (Processor Throttling States)</title>
   <para>
    T-states refer to throttling the processor clock to lower frequencies in
    order to reduce thermal effects. This means that the CPU is forced to be
    idle a fixed percentage of its cycles per second. Throttling states
    range from <literal>T1</literal> (the CPU has no forced idle cycles) to
    <literal>T<replaceable>n</replaceable></literal>, with the percentage of
    idle cycles increasing the greater <replaceable>n</replaceable> is.
   </para>
   <para>
    Note that throttling does not reduce voltage and since the CPU is forced
    to idle part of the time, processes will take longer to finish and will
    consume more power instead of saving any power.
   </para>
   <para>
    T-states are only useful if reducing thermal effects is the primary
    goal. Since T-states can interfere with C-states (preventing the CPU
    from reaching higher C-states), they can even increase power consumption
    in a modern CPU capable of C-states.
   </para>
<!--taroth 2010-0802: from pcmcia-apm.xml, perhaps add for next revision:
   <para>The system interface is <filename>/proc/acpi/processor/*/throttling</filename>.</para>-->
  </sect2>

  <sect2 id="sec.tuning.cpu.power.turbo">
   <title>Turbo Features</title>
<!--taroth 2011-09-22: terminology: AMD: Turbo CORE, Intel: Turbo Boost-->
   <para>
    Since quite some time, CPU power consumption and performance tuning is
    not only about frequency scaling anymore. In modern processors, a
    combination of different means is used to achieve the optimum balance
    between performance and power savings: deep sleep states, traditional
    dynamic frequency scaling and hidden boost frequencies. The turbo
    features (Turbo CORE* or Turbo Boost*) of the latest AMD* or Intel*
    processors allow to dynamically increase (boost) the clock speed of
    active CPU cores while other cores are in deep sleep states. This
    increases the performance of active threads while still complying to
    Thermal Design Power (TDP) limits.
   </para>
   <para>
    However, the conditions under which a CPU core may use turbo frequencies
    are very architecture-specific. Learn how to evaluate the efficiency of
    those new features in
    <xref
     linkend="sec.tuning.power.tools.cpupower"/>.
   </para>
  </sect2>
 </sect1>
 <sect1 id="sec.tuning.power.cpufreq">
  <title>The Linux Kernel &cpufreq; Infrastructure</title>

<!--relates to P-States-->

  <para>
   Processor performance states (P-states) and processor operating states
   (C-states) are the capability of a processor to switch between different
   supported operating frequencies and voltages to modulate power
   consumption.
  </para>

  <para>
   In order to dynamically scale processor frequencies at runtime, you can
   use the &cpufreq; infrastructure to set a static or dynamic power policy
   for the system. Its main components are the &cpufreq; subsystem
   (providing a common interface to the various low-level technologies and
   high-level policies) , the in-kernel governors (policy governors that can
   change the CPU frequency based on different criteria) and CPU-specific
   drivers that implement the technology for the specific processor.
  </para>

  <para>
   The dynamic scaling of the clock speed helps to consume less power and
   generate less heat when not operating at full capacity.
  </para>

  <sect2 id="sec.tuning.power.cpufreq.governors">
   <title>In-Kernel Governors</title>
   <para>
    You can think of the in-kernel governors as a sort of pre-configured
    power schemes for the CPU. The &cpufreq; governors use P-states to
    change frequencies and lower power consumption. The dynamic governors
    can switch between CPU frequencies, based on CPU utilization to allow
    for power savings while not sacrificing performance. These governors
    also allow for some tuning so you can customize and change the frequency
    scaling behavior.
   </para>
   <para>
    The following governors are available with the &cpufreq; subsystem:
   </para>
   <variablelist>
    <varlistentry>
     <term>Performance Governor</term>
     <listitem>
      <para>
       The CPU frequency is statically set to the highest possible for
       maximum performance. Consequently, saving power is not the focus of
       this governor.
      </para>
      <para>
       Tuning options: The range of maximum frequencies available to the
       governor can be adjusted (for example, with the
       <command>cpupower</command> command line tool).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Powersave Governor</term>
     <listitem>
      <para>
       The CPU frequency is statically set to the lowest possible. This can
       have severe impact on the performance, as the system will never rise
       above this frequency no matter how busy the processors are.
      </para>
      <para>
       However, using this governor often does not lead to the expected
       power savings as the highest savings can usually be achieved at idle
       through entering C-states. Due to running processes at the lowest
       frequency with the powersave governor, processes will take longer to
       finish, thus prolonging the time for the system to enter any idle
       C-states.
      </para>
      <para>
       Tuning options: The range of minimum frequencies available to the
       governor can be adjusted (for example, with the
       <command>cpupower</command> command line tool).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>On-demand Governor</term>
     <listitem>
      <para>
       The kernel implementation of a dynamic CPU frequency policy: The
       governor monitors the processor utilization. As soon as it exceeds a
       certain threshold, the governor will set the frequency to the highest
       available. If the utilization is less than the threshold, the next
       lowest frequency is used. If the system continues to be
       underemployed, the frequency is again reduced until the lowest
       available frequency is set.
      </para>
      <para>
       For &sle;, the on-demand governor is the default governor and the one
       that has the best test coverage.
      </para>
      <para>
       Tuning options: The range of available frequencies, the rate at which
       the governor checks utilization, and the utilization threshold can be
       adjusted. Another parameter you might want to change for the
       on-demand governor is <literal>ignore_nice_load</literal>. For
       details, refer to
       <xref linkend="pro.tuning.power.t-states.ignore.nice"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Conservative Governor</term>
     <listitem>
      <para>
       Similar to the on-demand implementation, this governor also
       dynamically adjusts frequencies based on processor utilization,
       except that it allows for a more gradual increase in power. If
       processor utilization exceeds a certain threshold, the governor does
       not immediately switch to the highest available frequency (as the
       on-demand governor does), but only to next higher frequency
       available.
      </para>
      <para>
       Tuning options: The range of available frequencies, the rate at which
       the governor checks utilization, the utilization thresholds, and the
       frequency step rate can be adjusted.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
<!-- taroth 2010-04-16: userspace governor is no longer supported by us, according to
    trenn-->
  </sect2>

  <sect2 id="sec.tuning.power.cpufreq.files">
   <title>Related Files and Directories</title>
   <para>
    If the &cpufreq; subsystem in enabled on your system (which it is by
    default with &sls;), you can find the relevant files and directories
    under <filename>/sys/devices/system/cpu/</filename>. If you list the
    contents of this directory, you will find a
    <filename>cpu{0..x}</filename> subdirectory for each processor, and
    several other files and directories. A <filename>cpufreq</filename>
    subdirectory in each processor directory holds a number of files and
    directories that define the parameters for &cpufreq;. Some of them are
    writable (for &rootuser;), some of them are read-only. If your system
    currently uses the on-demand or conservative governor, you will see a
    separate subdirectory for those governors in
    <filename>cpufreq</filename>, containing the parameters for the
    governors.
   </para>
   <note>
    <title>Different Processor Settings</title>
    <para>
     The settings under the <filename>cpufreq</filename> directory can be
     different for each processor. If you want to use the same policies
     across all processors, you need to adjust the parameters for each
     processor. Instead of looking up or modifying the current settings
     manually (in <filename>/sys/devices/system/cpu*/cpufreq</filename>), we
     advise to use the tools provided by the
     <systemitem class="resource"
      >cpupower</systemitem> package
     <phrase os="sles;sled"> or by the older
     <systemitem class="resource">cpufrequtils</systemitem> package</phrase>
     for that.
    </para>
   </note>
  </sect2>
 </sect1>
 <sect1 id="sec.tuning.power.tools">
  <title>Viewing, Monitoring and Tuning Power-related Settings</title>

  <para>
   The following command line tools are available for that purpose:
  </para>

  <variablelist>
   <varlistentry>
    <term><xref linkend="sec.tuning.power.tools.cpufrequtils" xrefstyle="select:title"/>
    </term>
    <listitem>
     <para>
      With the tools of the
      <systemitem class="resource"
       >cpufrequtils</systemitem> package
      you can view and modify settings of the kernel-related &cpufreq;
      subsystem. The <command>cpufreq*</command> commands are useful for
      modifying settings related to P-states, especially frequency scaling
      and &cpufreq; governors.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><xref linkend="sec.tuning.power.tools.cpupower" xrefstyle="select:title"/>
    </term>
    <listitem>
     <para>
      The new <command>cpupower</command> tool was designed to give an
      overview of <emphasis>all</emphasis> CPU power-related parameters that
      are supported on a given machine, including turbo (or boost) states.
      Use the tool set to view and modify settings of the kernel-related
      &cpufreq; and cpuidle systems as well as other settings not related to
      frequency scaling or idle states. The integrated monitoring framework
      can access both Kernel-related parameters and hardware statistics and
      is thus ideally suited for performance benchmarks. It also helps you
      to identify the dependencies between turbo and idle states.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><xref linkend="sec.tuning.power.tools.powertop" xrefstyle="select:title"/>
    </term>
    <listitem>
     <para>
      &powertop; combines various sources of information (analysis of
      programs, device drivers, kernel options, amounts and sources of
      interrupts waking up processors from sleep states) and shows them in
      one screen. The tool helps you to identify the reasons for unnecessary
      high power consumption (for example, processes that are mainly
      responsible for waking up a processor from its idle state) and to
      optimize your system settings to avoid these.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <sect2 id="sec.tuning.power.tools.cpufrequtils">
   <title>Using the <systemitem class="resource">cpufrequtils</systemitem> Tools</title>
   <note>
    <title><command>cpupower</command> and <command>cpufrequtils</command></title>
    <para>
     All functions of <command>cpufrequtils</command> are also covered by
     <command>cpupower</command>&mdash;a new set of tools that is more
     powerful and provides additional features. As
     <command>cpupower</command> will replace
     <command>cpufrequtils</command> sooner or later, we advise to switch to
     <command>cpupower</command> soon and to adjust your scripts
     accordingly.
    </para>
   </note>
   <para>
    After you have installed the
    <systemitem class="resource"
     >cpufrequtils</systemitem> package,
    you can make use of the <command>cpufreq-info</command> and
    <command>cpufreq-set</command> command line tools.
   </para>
   <sect3 id="sec.tuning.power.tools.cpufreq-info">
    <title>Viewing Current Settings with <command>cpufreq-info</command></title>
    <para>
     The <command>cpufreq-info</command> command helps you to retrieve
     &cpufreq; kernel information. Run without any options, it collects the
     information available for your system:
    </para>
    <example>
     <title>Example Output of <command>cpufreq-info</command></title>
<screen><?dbsuse-fo font-size="0.63em"?>cpufrequtils 004: cpufreq-info (C) Dominik Brodowski 2004-2006
Report errors and bugs to http://bugs.opensuse.org, please.
analyzing CPU 0:
  driver: acpi-cpufreq
  CPUs which need to switch frequency at the same time: 0
  hardware limits: 2.80 GHz - 3.40 GHz
  available frequency steps: 3.40 GHz, 2.80 GHz
  available cpufreq governors: conservative, userspace, powersave, ondemand, performance
  current policy: frequency should be within 2.80 GHz and 3.40 GHz.
                  The governor "performance" may decide which speed to use
                  within this range.
  current CPU frequency is 3.40 GHz.
analyzing CPU 1:
 driver: acpi-cpufreq
 CPUs which need to switch frequency at the same time: 1
 hardware limits: 2.80 GHz - 3.40 GHz
 available frequency steps: 3.40 GHz, 2.80 GHz
 available cpufreq governors: conservative, userspace, powersave, ondemand, performance
 current policy: frequency should be within 2.80 GHz and 3.40 GHz.
                 The governor "performance" may decide which speed to use
                 within this range.
current CPU frequency is 3.40 GHz.
    </screen>
    </example>
    <para>
     Using the appropriate options, you can view the current CPU frequency,
     the minimum and maximum CPU frequency allowed, show the currently used
     &cpufreq; policy, the available &cpufreq; governors, or determine the
     &cpufreq; kernel driver used. For more details and the available
     options, refer to the <command>cpufreq-info</command> man page or run
     <command>cpufreq-info <option>--help</option></command>.
    </para>
   </sect3>
   <sect3 id="sec.tuning.power.tools.cpufreq-set">
    <title>Modifying Current Settings with <command>cpufreq-set</command></title>
    <para>
     To modify &cpufreq; settings, use the <command>cpufreq-set</command>
     command as &rootuser;. It allows you set values for the minimum or
     maximum CPU frequency the governor may select or to create a new
     governor. With the <option>-c</option> option, you can also specify for
     which of the processors the settings should be modified. That makes it
     easy to use a consistent policy across all processors without adjusting
     the settings for each processor individually. For more details and the
     available options, refer to the <command>cpufreq-set</command> man page
     or run <command>cpufreq-set <option>--help</option></command>.
    </para>
   </sect3>
  </sect2>

  <sect2 id="sec.tuning.power.tools.cpupower">
   <title>Using the <systemitem class="resource">cpupower</systemitem> Tools</title>
   <para>
    After installing the
    <systemitem class="resource"
     >cpupower</systemitem> package, view
    the available <command>cpupower</command> subcommands with
    <command>cpupower&nbsp;--help</command>. Access the general man page
    with <command>man&nbsp;cpupower</command>, and the man pages of the
    subcommands with
    <command>man&nbsp;cpupower-<replaceable>subcommand</replaceable></command>.
   </para>
   <para>
    The subcommands <command>frequency-info</command> and
    <command>frequency-set</command> are mostly equivalent to
    <command>cpufreq-info</command> and <command>cpufreq-set</command>,
    respectively. However, they provide extended output and there are small
    differences in syntax and behavior:
   </para>
   <itemizedlist>
    <title>Syntax Differences Between <command>cpufreq*</command> and <command>cpupower</command></title>
    <listitem>
     <para>
      To specify the number of the CPU to which the command is applied, both
      commands have the <option>-c</option> option. Due to the
      command-subcommand structure, the placement of the <option>-c</option>
      option is different for <command>cpupower</command>:
     </para>
     <para>
      <command>cpupower -c 4 frequency-info</command> (versus
      <command>cpufreq-info -c 4</command>)
     </para>
     <para>
      <command>cpupower</command> lets you also specify a list of CPUs with
      <option>-c</option>. For example, the following command would affect
      the CPUs <literal>1</literal> , <literal>2</literal>,
      <literal>3</literal>, and <literal>5</literal>:
     </para>
     <para>
      <command>cpupower -c 1-3,5 frequency-set</command>
     </para>
    </listitem>
    <listitem>
     <para>
      If <command>cpufreq*</command> and <command>cpupower</command> are
      used without the <option>-c</option> option, the behavior differs:
     </para>
     <para>
      <command>cpufreq-set</command> automatically applies the command to
      CPU <literal>0</literal>, whereas
      <command>cpupower&nbsp;frequency-set</command> applies the command to
      all CPUs in this case. Typically, <command>cpupower *info</command>
      subcommands access only CPU <literal>0</literal>, whereas
      <command>cpufreq-info</command> accesses all CPUs, if not specified
      otherwise.
     </para>
    </listitem>
   </itemizedlist>
   <sect3 id="sec.tuning.power.tools.cpupower.freq-info">
    <title>Viewing Current Settings with <command>cpupower</command></title>
    <para>
     Similar to <command>cpufreq-info</command>,
     <command>cpupower&nbsp;frequency-info</command> also shows the
     statistics of the cpufreq driver used in the Kernel. Additionally, it
     shows if turbo (boost) states are supported and enabled in the BIOS.
     Run without any options, it shows an output similar to the following:
    </para>
    <example>
     <title>Example Output of <command>cpupower frequency-info</command></title>
<screen><?dbsuse-fo font-size="0.63em"?>analyzing CPU 0:
  driver: acpi-cpufreq
  CPUs which run at the same hardware frequency: 0 1 2 3
  CPUs which need to have their frequency coordinated by software: 0
  maximum transition latency: 10.0 us.
  hardware limits: 2.00 GHz - 2.83 GHz
  available frequency steps: 2.83 GHz, 2.34 GHz, 2.00 GHz
  available cpufreq governors: conservative, userspace, powersave, ondemand, performance
  current policy: frequency should be within 2.00 GHz and 2.83 GHz.
                  The governor "ondemand" may decide which speed to use
                  within this range.
  current CPU frequency is 2.00 GHz (asserted by call to hardware).
  boost state support:
    Supported: yes
    Active: yes
    </screen>
    </example>
    <para>
     To get the current values for all CPUs, use
     <command>cpupower&nbsp;-c&nbsp;all&nbsp;frequency-info</command>.
    </para>
   </sect3>
   <sect3 id="sec.tuning.power.tools.cpupower.idle-info">
    <title>Viewing and Modifying Kernel Idle Statistics with <command>cpupower</command></title>
    <para>
     The <command>idle-info</command> subcommand shows the statistics of the
     cpuidle driver used in the Kernel. It works on all architectures that
     use the cpuidle Kernel framework.
    </para>
<!-- taroth 2011-08-16: this is the output from my desktop machine, maybe
     ask trenn for output by a server machine-->
    <example>
     <title>Example Output of <command>cpupower idle-info</command></title>
<screen>CPUidle driver: acpi_idle
CPUidle governor: menu

Analyzing CPU 0:
Number of idle states: 3
Available idle states: C1 C2
C1:
Flags/Description: ACPI FFH INTEL MWAIT 0x0
Latency: 1
Usage: 3156464
Duration: 233680359
C2:
Flags/Description: ACPI FFH INTEL MWAIT 0x10
Latency: 1
Usage: 273007117
Duration: 103148860538</screen>
    </example>
    <para>After finding out which processor idle states are supported with
     <command>cpupower idle-info</command>, individual states can be disabled
     using the <command>cpupower idle-set</command> command. Typically one wants
     to disable the deepest sleep state, for example:</para>
    <screen>cpupower idle-set -d 4</screen>
    <para>But before making this change permanent by adding the corresponding
     command to a current <filename>/etc/init.d/*</filename> <remark>taroth 2014-03-10: FIXME -
      SYSTEMD</remark>service file, check for
     performance or power impact. 
     </para>
   </sect3>
   <sect3 id="sec.tuning.power.tools.cpupower.monitor">
    <title>Monitoring Kernel and Hardware Statistics with <command>cpupower</command></title>
    <para>
     The most powerful enhancement is the <command>monitor</command>
     subcommand. Use it to report processor topology, and monitor frequency
     and idle power state statistics over a certain period of time. The
     default interval is <literal>1</literal> second, but it can be changed
     with the <option>-i</option>. Independent processor sleep states and
     frequency counters are implemented in the tool&mdash;some retrieved
     from kernel statistics, others reading out hardware registers. The
     available monitors depend on the underlying hardware and the system.
     List them with <command>cpupower&nbsp;monitor&nbsp;-l</command>. For a
     description of the individual monitors, refer to the cpupower-monitor
     man page.
    </para>
    <para>
     The <command>monitor</command> subcommand allows you to execute
     performance benchmarks and to compare Kernel statistics with hardware
     statistics for specific workloads.
    </para>
    <example id="ex.cpupower.monitor">
     <title>Example <command>cpupower monitor</command> Output</title>
<screen>|Mperf               || Idle_Stats
 <co id="co.cpupower.mon.mperf"/>&nbsp;                     <co id="co.cpupower.mon.idle"/>&nbsp;
CPU | C0   | Cx   | Freq || POLL | C1   | C2   | C3
   0|  3.71| 96.29|  2833||  0.00|  0.00|  0.02| 96.32
   1| 100.0| -0.00|  2833||  0.00|  0.00|  0.00|  0.00
   2|  9.06| 90.94|  1983||  0.00|  7.69|  6.98| 76.45
   3|  7.43| 92.57|  2039||  0.00|  2.60| 12.62| 77.52
     </screen>
     <calloutlist>
      <callout arearefs="co.cpupower.mon.mperf">
       <para>
        Mperf shows the average frequency of a CPU, including boost
        frequencies, over a period of time. Additionally, it shows the
        percentage of time the CPU has been active (<literal>C0</literal>)
        or in any sleep state (<literal>Cx</literal>). The default sampling
        rate is <literal>1</literal> second and the values are read directly
        from the hardware registers. As the turbo states are managed by the
        BIOS, it is impossible to get the frequency values at a given
        instant. On modern processors with turbo features the Mperf monitor
        is the only way to find out about the frequency a certain CPU has
        been running in.
       </para>
      </callout>
      <callout arearefs="co.cpupower.mon.idle">
       <para>
        Idle_Stats shows the statistics of the cpuidle kernel subsystem. The
        kernel updates these values every time an idle state is entered or
        left. Therefore there can be some inaccuracy when cores are in an
        idle state for some time when the measure starts or ends.
       </para>
      </callout>
     </calloutlist>
     <para>
      Apart from the (general) monitors in the example above, other
      architecture-specific monitors are available. For detailed
      information, refer to the <command>cpupower-monitor</command> man
      page.
     </para>
    </example>
    <para>
     By comparing the values of the individual monitors, you can find
     correlations and dependencies and evaluate how well the power saving
     mechanism works for a certain workload. In
     <xref linkend="ex.cpupower.monitor" xrefstyle="select:label"/> you can
     see that CPU <literal>0</literal> is idle (the value of
     <literal>Cx</literal> is near to 100%), but runs at a very high
     frequency. Additionally, the CPUs <literal>0</literal> and
     <literal>1</literal> have the same frequency values which means that
     there is a dependency between them.
    </para>
   </sect3>
   <sect3 id="sec.tuning.power.tools.cpupower.freq-set">
    <title>Modifying Current Settings with <command>cpupower</command></title>
    <para>
     Similar to <command>cpufreq-set</command>, you can use
     <command>cpupower&nbsp;frequency-set</command> command as &rootuser;
     to modify current settings. It allows you to set values for the minimum
     or maximum CPU frequency the governor may select or to create a new
     governor. With the <option>-c</option> option, you can also specify for
     which of the processors the settings should be modified. That makes it
     easy to use a consistent policy across all processors without adjusting
     the settings for each processor individually. For more details and the
     available options, refer to the
     <command>cpupower-freqency-set</command> man page or run
     <command>cpupower&nbsp;frequency-set <option>--help</option></command>.
    </para>
   </sect3>
  </sect2>

  <sect2 id="sec.tuning.power.tools.powertop">
   <title>Monitoring Power Consumption with &powertop;</title>
   <para>
    Another useful tool for monitoring system power consumption is
    &powertop;. It helps you to identify the reasons for unnecessary high
    power consumption (for example, processes that are mainly responsible
    for waking up a processor from its idle state) and to optimize your
    system settings to avoid these. It supports both Intel and AMD
    processors. The <systemitem
    class="resource">powertop</systemitem>
    package is available from the &sle; SDK. For information on how to
    access the SDK, refer to <xref linkend="preface.tuning"/>.
   </para>
   <para>
    &powertop; combines various sources of information (analysis of
    programs, device drivers, kernel options, amounts and sources of
    interrupts waking up processors from sleep states) and shows them in one
    screen. <xref linkend="ex.tuning.power.powertop"/> shows which
    information categories are available:
   </para>
   <example id="ex.tuning.power.powertop">
    <title>Example &powertop; Output</title>
<screen>Cn               Avg  residency       P-states   (frequencies)
<co id="co.powertop.cstates"/>&nbsp;                <co id="co.powertop.avg"/>&nbsp;     <co id="co.powertop.residency"/>&nbsp;             <co id="co.powertop.pstates"/>&nbsp;           <co id="co.powertop.freq"/>
C0 (cpu running)        (11.6%)       2.00 Ghz       0.1%
polling         0.0ms   ( 0.0%)       2.00 Ghz       0.0%
C1              4.4ms   (57.3%)       1.87 Ghz       0.0%
C2             10.0ms   (31.1%)       1064 Mhz      99.9%


Wakeups-from-idle per second : 11.2     interval: 5.0s <co id="co.powertop.wakeups"/>
no ACPI power usage estimate available <co id="co.powertop.power"/>
<?dbsuse-fo font-size="0.7em"?>
Top causes for wakeups: <co id="co.powertop.culprits"/>
96.2% (826.0)       &lt;interrupt&gt; : extra timer interrupt
 0.9% (  8.0)     &lt;kernel core&gt; : usb_hcd_poll_rh_status (rh_timer_func)
 0.3% (  2.4)       &lt;interrupt&gt; : megasas
 0.2% (  2.0)     &lt;kernel core&gt; : clocksource_watchdog (clocksource_watchdog)
 0.2% (  1.6)       &lt;interrupt&gt; : eth1-TxRx-0
 0.1% (  1.0)       &lt;interrupt&gt; : eth1-TxRx-4

[...]

Suggestion: <co id="co.powertop.suggestions"/> Enable SATA ALPM link power management via:
echo min_power > /sys/class/scsi_host/host0/link_power_management_policy
or press the S key.</screen>
    <calloutlist>
     <callout arearefs="co.powertop.cstates">
      <para>
       The column shows the C-states. When working, the CPU is in state
       <literal>0</literal>, when resting it is in some state greater than
       <literal>0</literal>, depending on which C-states are available and
       how deep the CPU is sleeping.
      </para>
     </callout>
     <callout arearefs="co.powertop.avg">
      <para>
       The column shows average time in milliseconds spent in the particular
       C-state.
      </para>
     </callout>
     <callout arearefs="co.powertop.residency">
      <para>
       The column shows the percentages of time spent in various C-states.
       For considerable power savings during idle, the CPU should be in
       deeper C-states most of the time. In addition, the longer the average
       time spent in these C-states, the more power is saved.
      </para>
     </callout>
     <callout arearefs="co.powertop.pstates">
      <para>
       The column shows the frequencies the processor and kernel driver
       support on your system.
      </para>
     </callout>
     <callout arearefs="co.powertop.freq">
      <para>
       The column shows the amount of time the CPU cores stayed in different
       frequencies during the measuring period.
      </para>
     </callout>
     <callout arearefs="co.powertop.wakeups">
      <para>
       Shows how often the CPU is awoken per second (number of interrupts).
       The lower the number the better. The <literal>interval</literal>
       value is the &powertop; refresh interval which can be controlled with
       the <option>-t</option> option. The default time to gather data is 5
       seconds.
      </para>
     </callout>
     <callout arearefs="co.powertop.power">
      <para>
       When running &powertop; on a laptop, this line displays the ACPI
       information on how much power is currently being used and the
       estimated time until discharge of the battery. On servers, this
       information is not available.
      </para>
     </callout>
     <callout arearefs="co.powertop.culprits">
      <para>
       Shows what is causing the system to be more active than needed.
       &powertop; displays the top items causing your CPU to awake during
       the sampling period.
      </para>
     </callout>
     <callout arearefs="co.powertop.suggestions">
      <para>
       Suggestions on how to improve power usage for this machine.
      </para>
     </callout>
    </calloutlist>
   </example>
   <para>
    For more information, refer to the &powertop; project page at
    <ulink
    url="http://www.lesswatts.org/projects/powertop/"/>. It also
    provides tips and tricks and an informative FAQ section.
   </para>
  </sect2>
 </sect1>
 <sect1 id="sec.tuning.power.options">
  <title>Special Tuning Options</title>

  <para>
   The following sections highlight some of the most relevant settings that
   you might want to touch.
  </para>

  <sect2 id="sec.tuning.power.options.p-states">
   <title>Tuning Options for P-States</title>
   <para>
    The &cpufreq; subsystem offers several tuning options for P-states: You
    can switch between the different governors, influence minimum or maximum
    CPU frequency to be used or change individual governor parameters.
   </para>
   <para>
    To switch to another governor at runtime, use
    <command>cpupower&nbsp;frequency-set</command>
    <phrase os="sles;sled">(or <command>cpufreq-set</command>)</phrase> with
    the <option>-g</option> option. For example, running the following
    command (as &rootuser;) will activate the on-demand governor:
   </para>
<screen>cpupower frequency-set -g ondemand</screen>
   <para>
    If you want the change in governor to persist also after a reboot or
    shutdown, use the pm-profiler as described in
    <xref
     linkend="sec.tuning.power.pm-profiler"/>.
   </para>
   <para>
    To set values for the minimum or maximum CPU frequency the governor may
    select, use the <option>-d</option> or <option>-u</option> option,
    respectively.
   </para>
   <para>
    Apart from the governor settings that can be influenced with
    <command>cpupower</command> or <command>cpufreq*</command>, you can also
    tune further governor parameters manually, for example,
    <xref
     linkend="pro.tuning.power.t-states.ignore.nice" xrefstyle="select:title"/>.
   </para>
   <procedure id="pro.tuning.power.t-states.ignore.nice">
    <title>Ignoring Nice Values in Processor Utilization</title>
    <para>
     One parameter you might want to change for the on-demand or
     conservative governor is <literal>ignore_nice_load</literal>.
    </para>
    <para>
     Each process has a niceness value associated with it. This value is
     used by the kernel to determine which processes require more processor
     time than others. The higher the nice value, the lower the priority of
     the process. Or: the <quote>nicer</quote> a process, the less CPU it
     will try to take from other processes.
    </para>
    <para>
     If the <literal>ignore_nice_load</literal> parameter for the on-demand
     or conservative governor is set to <literal>1</literal>, any processes
     with a <literal>nice</literal> value will not be counted toward the
     overall processor utilization. When <literal>ignore_nice_load</literal>
     is set to <literal>0</literal> (default value), all processes are
     counted toward the utilization. Adjusting this parameter can be useful
     if you are running something that requires a lot of processor capacity
     but you do not care about the runtime.
    </para>
    <step>
     <para>
      Change to the subdirectory of the governor whose settings you want to
      modify, for example:
     </para>
<screen>cd /sys/devices/system/cpu/cpu0/cpufreq/conservative/</screen>
    </step>
    <step>
     <para>
      Show the current value of <filename>ignore_nice_load</filename> with:
     </para>
<screen>cat ignore_nice_load</screen>
    </step>
    <step>
     <para>
      To set the value to <literal>1</literal>, execute:
     </para>
<screen>echo 1 > ignore_nice_load</screen>
    </step>
   </procedure>
   <tip>
    <title>Using the Same Value for All Cores</title>
    <para>
     When setting the <literal>ignore_nice_load</literal> value for
     <literal>cpu0</literal>, the same value is automatically used for all
     cores. In this case, you do not need to repeat the steps above for each
     of the processors where you want to modify this governor parameter.
    </para>
   </tip>
   <para>
    Another parameter that significantly impacts the performance loss caused
    by dynamic frequency scaling is the sampling rate (rate at which the
    governor checks the current CPU load and adjusts the processor's
    frequency accordingly). Its default value depends on a BIOS value and it
    should be as low as possible. However, in modern systems, an appropriate
    sampling rate is set by default and does not need manual intervention.
   </para>
  </sect2>

  <sect2 id="sec.tuning.power.options-c.states">
   <title>Tuning Options for C-states</title>
   <para>
    By default, &productname; uses C-states appropriately. The only
    parameter you might want to touch for optimization is the
    <literal>sched_mc_power_savings</literal> scheduler. Instead of
    distributing a work load across all cores with the effect that all cores
    are used only at a minimum level, the kernel can try to schedule
    processes on as few cores as possible so that the others can go idle.
    This helps to save power as it allows some processors to be idle for a
    longer time so they can reach a higher C-state. However, the actual
    savings depend on a number of factors, for example how many processors
    are available and which C-states are supported by them (especially
    deeper ones such as <literal>C3</literal> to <literal>C6</literal>).
   </para>
   <para>
    If <literal>sched_mc_power_savings</literal> is set to
    <literal>0</literal> (default value), no special scheduling is done. If
    it is set to <literal>1</literal>, the scheduler tries to consolidate
    the work onto the fewest number of processors possible in the case that
    all processors are a little busy.
<!--taroth 2010-04-28: according to trenn, a value of 2 is also
    supported, but not documented anywhere, therefore not mentioning for now-->
    To modify this parameter, proceed as follows:
   </para>
   <procedure id="pro.tuning.power.c-states.ignore.scheduler">
    <title>Scheduling Processes on Cores</title>
    <step>
     <para>
      Become &rootuser; on a command line.
     </para>
    </step>
    <step>
     <para>
      To view the current value of
      <filename>sched_mc_power_savings</filename>, use the following
      command:
     </para>
<screen>cpupower info -m</screen>
    </step>
    <step>
     <para>
      To set <literal>sched_mc_power_savings</literal> to
      <literal>1</literal>, execute:
     </para>
<screen>cpupower set -m 1</screen>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 id="sec.tuning.power.pm-profiler">
  <title>Creating and Using Power Management Profiles</title>

  <para>
   &productname; includes pm-profiler, intended for server use. It is a
   script infrastructure to enable or disable certain power management
   functions via configuration files. It allows you to define different
   profiles, each having a specific configuration file for defining
   different settings. A configuration template for new profiles can be
   found at
   <filename>/usr/share/doc/packages/pm-profiler/config.template</filename>.
   The template contains a number of parameters you can use for your
   profile, including comments on usage and links to further documentation.
   The individual profiles are stored in
   <filename>/etc/pm-profiler/</filename>. The profile that will be
   activated on system start, is defined in
   <filename>/etc/pm-profiler.conf</filename>.
  </para>

  <procedure id="pro.tuning.power.pm-profile">
   <title>Creating and Switching Power Profiles</title>
   <para>
    To create a new profile, proceed as follows:
   </para>
   <step>
    <para>
     Create a directory in <filename>/etc/pm-profiler/</filename>,
     containing the profile name, for example:
    </para>
<screen> mkdir /etc/pm-profiler/testprofile</screen>
   </step>
   <step>
    <para>
     To create the configuration file for the new profile, copy the profile
     template to the newly created directory:
    </para>
<screen>cp /usr/share/doc/packages/pm-profiler/config.template \
     /etc/pm-profiler/testprofile/config</screen>
   </step>
   <step>
    <para>
     Edit the settings in
     <filename>/etc/pm-profiler/testprofile/config</filename> and save the
     file. You can also remove variables that you do not need&mdash;they
     will be handled like empty variables, the settings will not be touched
     at all.
    </para>
   </step>
   <step>
    <para>
     Edit <filename>/etc/pm-profiler.conf</filename>. The
     <systemitem>PM_PROFILER_PROFILE</systemitem> variable defines which
     profile will be activated on system start. If it has no value, the
     default system or kernel settings will be used. To set the newly
     created profile:
    </para>
<screen>PM_PROFILER_PROFILE="<replaceable>testprofile</replaceable>"
    </screen>
    <para>
     The profile name you enter here must match the name you used in the
     path to the profile configuration file
     (<filename>/etc/pm-profiler/testprofile/config</filename>), not
     necessarily the <literal>NAME</literal> you used for the profile in the
     <filename>/etc/pm-profiler/testprofile/config</filename>.
    </para>
   </step>
   <step>
    <para>
     To activate the profile, run
    </para>
<screen>sudo systemctl start pm-profiler</screen>
    <para>
     or
    </para>
<screen>/usr/lib/pm-profiler/enable-profile testprofile </screen>
   </step>
  </procedure>

  <para>
   Though you have to manually create or modify a profile by editing the
   respective profile configuration file, you can use &yast; to switch
   between different profiles. Start &yast; and select <menuchoice>
   <guimenu>System</guimenu> <guimenu>Power Management</guimenu>
   </menuchoice> to open the <guimenu>Power Management Settings</guimenu>.
   Alternatively, become &rootuser; and execute <command>yast2
   power-management</command> on a command line. The drop-down list shows
   the available profiles. <literal>Default</literal> means that the system
   default settings will be kept. Select the profile to use and click
   <guimenu>Finish</guimenu>.
  </para>
 </sect1>
 <sect1 id="sec.tuning.power.trouble">
  <title>Troubleshooting</title>

  <variablelist>
   <varlistentry>
    <term>BIOS options enabled?</term>
    <listitem>
     <para>
      In order to make use of C-states or P-states, check your BIOS options:
     </para>
     <itemizedlist>
      <listitem>
       <para>
        To use C-states, make sure to enable <literal>CPU C State</literal>
        or similar options to benefit from power savings at idle.
       </para>
      </listitem>
      <listitem>
       <para>
        To use P-states and the &cpufreq; governors, make sure to enable
        <literal>Processor Performance States</literal> options or similar.
       </para>
      </listitem>
     </itemizedlist>
     <para>
      In case of a CPU upgrade, make sure to upgrade your BIOS, too. The
      BIOS needs to know the new CPU and its valid frequencies steps in
      order to pass this information on to the operating system.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>&cpufreq; subsystem enabled?</term>
    <listitem>
     <para>
      In &productname;, the &cpufreq; subsystem is enabled by default. To
      find out if the subsystem is currently enabled, check for the
      following path in your system:
      <filename>/sys/devices/system/cpu/cpufreq</filename> (or
      <filename>/sys/devices/system/cpu/cpu*/cpufreq</filename> for machines
      with multiple cores). If the <filename>cpufreq</filename> subdirectory
      exists, the subsystem is enabled.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Log file information?</term>
    <listitem>
     <para>
      Check syslog (usually <filename>/var/log/messages</filename>) for any
      output regrading the &cpufreq; subsystem. Only severe errors are
      reported there.
     </para>
     <para>
      If you suspect problems with the &cpufreq; subsystem on your machine,
      you can also enable additional debug output. To do so, either use
      <command>cpufreq.debug=7</command> as boot parameter or execute the
      following command as &rootuser;:
     </para>
<screen>echo 7 > /sys/module/cpufreq/parameters/debug</screen>
     <para>
      This will cause &cpufreq; to log more information to
      <command>dmesg</command> on state transitions, which is useful for
      diagnosis. But as this additional output of kernel messages can be
      rather comprehensive, use it only if you are fairly sure that a
      problem exists.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 id="sec.tuning.power.more">
  <title>For More Information</title>

  <itemizedlist>
   <listitem>
    <para>
     A threepart, comprehensive article about tuning components with regards
     to power efficiency is available at the following URLs:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <citetitle>Reduce Linux power consumption, Part 1: The CPUfreq
       subsystem</citetitle>, available at
       <ulink
        url="http://www.ibm.com/developerworks/linux/library/l-cpufreq-1/?ca=dgr-lnxw03ReduceLXPWR-P1dth-LX&amp;S_TACT=105AGX59&amp;S_CMP=grlnxw03"
       />
      </para>
     </listitem>
     <listitem>
      <para>
       <citetitle>Reduce Linux power consumption, Part 2: General and
       governor-specific settings</citetitle>, available at
       <ulink
        url="http://www.ibm.com/developerworks/linux/library/l-cpufreq-2/?ca=dgr-lnxw03ReduceLXPWR-P1dth-LX&amp;S_TACT=105AGX59&amp;S_CMP=grlnxw03"
       />
      </para>
     </listitem>
     <listitem>
      <para>
       <citetitle>Reduce Linux power consumption, Part 3: Tuning
       results</citetitle>, available at
       <ulink
        url="http://www.ibm.com/developerworks/linux/library/l-cpufreq-3/?ca=dgr-lnxw03ReduceLXPWR-P1dth-LX&amp;S_TACT=105AGX59&amp;S_CMP=grlnxw03"
       />
      </para>
     </listitem>
    </itemizedlist>
   </listitem>
   <listitem>
    <para>
     The LessWatts.org project deals with how to save power, reduce costs
     and increase efficiency on Linux systems. Find the project home page at
     <ulink
      url="http://www.lesswatts.org/"/>. The project page also
     holds an informative FAQs section at
     <ulink url="http://www.lesswatts.org/documentation/faq/index.php"/> and
     provides useful tips and tricks. For tips dealing with the CPU level,
     refer to <ulink
      url="http://www.lesswatts.org/tips/cpu.php"/>.
     For more information about &powertop;, refer to
     <ulink url="http://www.lesswatts.org/projects/powertop/"/>.
    </para>
   </listitem>
   <listitem>
    <para>
     Platforms with a Baseboard Management Controller (BMC) may have
     additional power management configuration options accessible via the
     service processor. These configurations are vendor specific and
     therefore not subject of this guide. For more information, refer to the
     manuals provided by your vendor. For example, <citetitle>HP ProLiant
     Server Power Management on SUSE Linux Enterprise Server
     11&mdash;Integration Note </citetitle> provides detailed information
     how the HP platform specific power management features interact with
     the Linux Kernel. The paper is available from
     <ulink
      url="http://h18004.www1.hp.com/products/servers/technology/whitepapers/os-techwp.html"
     />.
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
</chapter>
<!--taroth 2011-08-11: new tool: cpupower (for osuse: replacing cpufrequtils, for SLE 11: both can
 be installed parallel), the following is copied from a mail by trenn-->
<!-- Why is there need for another tool?
 **********************************************

 CPU power consumption vs performance tuning is not about
 CPU frequency switching anymore for quite some time.
 Deep sleep states, traditional dynamic frequency scaling and
 hidden turbo/boost frequencies are tight close together and
 depend on each other. The first two exist on different architectures
 like PPC, Itanium and ARM the latter only on X86.
 On X86 the APU (CPU+GPU) will only run most efficiently if CPU
 and GPU has proper power management in place.

 Users and Developers want to have *one* tool to get an overview what their
 system supports and to monitor and debug CPU power management in detail.

 The tool should compile and work on as much architectures as
 possible.

 What is this tool doing?
 ***************************

 It provides all features cpufrequtils does.
 It got enhanced with cpuidle and turbo/boost mode (on X86) statistics.
 On AMD the exact amount of supported boost states and their frequencies
 are shown. On Intel only turbo/boost support is shown.

 It got enhanced with a generic HW monitor tool (cpupower monitor).

 The generic HW monitor tool is the most powerful enhancement.
 It is a framework to monitor kernel or HW power statistics.
 It's easy to extend with additional, architecture or processor model
 specific counters.
 It's based on turbostat which got merged into the kernel recently:
 tools/power/x86/turbostat

 In fact turbostat functionality is integrated as three separate monitors
 implementing the cpupower monitor API:
 - Nehalem
 - SandyBridge
 - Mperf
 While Nehalem and SandyBridge HW sleep counters are Intel specific, the
 mperf functionality is now available on other HW than Intel, supporting
 the
 needed registers (Functionality includes: average frequency including
 turbo/boost frequency, C0 vs Cx idle count).

 Additionally there is a monitor to collect kernel idle statistics and
 display them (separate or together) in the same format. This works on all
 architectures using the cpuidle kernel framework including different ARM
 architectures and there were patches for powerpc (not in the mainline
 kernel yet).
 This allows to compare kernel and HW statistics on specific workloads and
 figure out how the HW performs compared to OS behavior.

 Additionally there is an AMD Liano (fam 12h) and Ontario (fam 14h) family
 specific monitor. This one shows different Package Core (!PC0, PC1, PC7)
 sleep state statistics directly read out from HW, similar to Nehalem
 and SandyBridge coutners.
 The registers are accessed via PCI and therefore can still be read out
 while cores have been offlined.
 The Liano/Ontario monitor has one special counter: NBP1 (North Bridge P1).
 This one always returns 0 or 1, depending on whether the North Bridge P1
 power state got entered at least once during measure time.
 Being able to enter NBP1 state also depends on graphics power management.
 Therefore this counter can be used to verify whether the graphics' driver
 power management is working as expected. (E.g. this counter proves that
 radeon KMS graphics drivers are missing functionality and NBP1 will only
 be entered when using the fglrx driver).


 Some examples
 ******************

 On a somewhat older Intel machine where turbostat complaints about:
 /archteam/trenn/packages/turbostat/turbostat
 No invariant TSC

 You still get mperf statistics (here core 1 is 100% used):
 /archteam/trenn/git/latest_cpupowerutils/cpufrequtils/cpupower monitor
 |Mperf               || Idle_Stats
 CPU | C0   | Cx   | Freq || POLL | C1   | C2   | C3
 0|  3.71| 96.29|  2833||  0.00|  0.00|  0.02| 96.32
 1| 100.0| -0.00|  2833||  0.00|  0.00|  0.00|  0.00
 2|  9.06| 90.94|  1983||  0.00|  7.69|  6.98| 76.45
 3|  7.43| 92.57|  2039||  0.00|  2.60| 12.62| 77.52

 Hm, mperf (C0 vs Cx) implementation also depends on a correct working
 TSC, but shows sane values on this machine. But it can be implemented
 in another way using gettimeofday and not tsc as well.

 For above machine, listing available monitors/counters via:
 "cpupower monitor -l" shows:

 Monitor "Mperf" (3 states) - Might overflow after 922000000 s
 C0      [T] -> Processor Core not idle
 Cx      [T] -> Processor Core in an idle state
 Freq    [T] -> Average Frequency (including boost) in MHz
 Monitor "Idle_Stats" (3 states) - Might overflow after 4294967295 s
 POLL    [T] -> CPUIDLE CORE POLL IDLE
 C1      [T] -> ACPI FFH INTEL MWAIT 0x0
 C2      [T] -> ACPI FFH INTEL MWAIT 0x10
 C3      [T] -> ACPI FFH INTEL MWAIT 0x30

 On a Tylersburg/Nehalem you get an additional one:
 Monitor "Nehalem" (4 states) - Might overflow after 922000000 s
 C3      [C] -> Processor Core C3
 C6      [C] -> Processor Core C6
 PC3     [P] -> Processor Package C3
 PC6     [P] -> Processor Package C6

 On a SandyBridge you have yet another monitor:
 Monitor "SandyBridge" (3 states) - Might overflow after 922000000 s
 C7      [C] -> Processor Core C7
 PC2     [P] -> Processor Package C2
 PC7     [P] -> Processor Package C7

 If output is too much or you only want to compare specific stats,
 use:
 ./cpupower monitor -m "SandyBridge,Mperf"
 and only SandyBridge and Mperf counters are shown in the order you
 pass them.

 On an AMD (at least latest fam10h with mperf/boost support) one
 would of course not get the Nehalem or SandyBridge, but
 still the Mperf counters.

 Additionlly on Ontario (fam 14h) or Liano (fam 12h) you get some
 AMD specific sleep state residency HW counters:

 Monitor "Ontario" (4 states) - Might overflow after 343 s
 !PC0    [P] -> Package in sleep state (PC1 or deeper)
 PC1     [P] -> Processor Package C1
 PC6     [P] -> Processor Package C6
 NBP1    [P] -> North Bridge P1 boolean counter (returns 0 or 1)


 Kernel Idle_Stats counter is the only one also working without root
 privileges and is architecture independent (should provide info on quite
 some ARM models and possibly soon on powerpc as well if cpuidle support
 is implemented in the kernel there):

 ./cpupower monitor
 Available monitor Mperf needs root access
 |Idle_Stats
 CPU | POLL | C1   | C2   | C3
 0|  0.00|  0.00|  3.20| 89.86
 1|  0.00|  0.00|  2.27| 82.62
 2|  0.00|  0.00| 23.44| 68.78
 3|  0.00| 15.38|  9.34| 65.31

 If you want to monitor specific workload the turbostat feature to
 measure specific commands is available as well:

 ./cpupower monitor cp xorg-x11-driver-video-7.6-163.1.x86_64.rpm /tmp/
 cp took 0.23406 seconds and exited with status 0
 |Ontario                    || Mperf              || Idle_Stats
 CPU | !PC0 | PC1  | PC6  | NBP1 || C0   | Cx   | Freq || POLL | C1   | C2
 0| 72.38|  1.47| 19.39|     0|| 21.16| 78.84|   800||  0.00| 90.59|
 0.00
 1| 72.38|  1.47| 19.39|     0||  2.91| 97.09|  1184||  0.00| 97.42|
 0.00

 This output reveals quite some kernel bugs:
 - C2 is not entered -> dma_latency set too high by ath9k -> fixed already
 -> But microcode still insures deep sleep states are
 entered. Using C2 should be more efficient, though.
 That can get proofed with some more measures...

 - NorthBridge P1 not entered -> Kernel radeon driver missing some PM.
 -> fglrx would show 1 here.
 - Frequency of the wrong core is switched up?
 -> Just realized that, might be related to:
 http://comments.gmane.org/gmane.linux.kernel.cpufreq/6977
 Hm, it's not always reproducable, anyway the tool works...-->
