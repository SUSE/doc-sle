<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "generic-entities.ent">
    %entities;
]>

<chapter xmlns="http://docbook.org/ns/docbook"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         version="5.0"
         xml:lang="en"
         xml:id="cha-ssh">

 <title>Securing network operations with OpenSSH</title>
 <info>
  <abstract>
   <para>
    OpenSSH is the SSH (secure shell) implementation that ships with &sls;,
    for securing network operations such as remote administration, file
    transfers, and tunneling insecure protocols. SSH encrypts all traffic,
    including authentication, to protect against eavesdropping and
    connection hijacking. This chapter covers basic operations, plus host
    key rotation and certificate authentication, which are especially useful
    for managing larger SSH deployments.
   </para>
  </abstract>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker>
   </dm:bugtracker>
  </dm:docmanager>
 </info>

 <sect1 xml:id="sec-ssh-overview">
  <title>OpenSSH overview</title>
  <para>
   SSH is a protocol that provides end-to-end protection for
   communications between the computers on your network, or between
   computers on your network and systems outside your network. SSH is
   a client-server protocol. Any host running the
   <systemitem class="daemon">sshd</systemitem>
   daemon can accept connections from any other host. Every host running
   <systemitem class="daemon">sshd</systemitem> can have their own custom
   custom configurations, such as limiting who can have access, and which
   authentication protocols are allowed.
  </para>
  <para>
   The <package>openssh</package> package installs the server, client,
   file transfer commands, and helper utilities.
  </para>
  <para>
   OpenSSH supports several different types of authentication:
  </para>
  <variablelist>
   <varlistentry>
    <term>Password authentication</term>
    <listitem>
     <para>
      Uses your system login and password; you must have a user
      account on the machine you are connecting to. This is the simplest
      and most flexible authentication because you can open an SSH session
      from anywhere, on any machine. It is also the least secure, because it
      is vulnerable to password-cracking and keystroke logging.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Public key authentication</term>
    <listitem>
     <para>
      Authenticates with your personal SSH keys, rather than your
      system login. This is less flexible than password authentication,
      because you can open SSH sessions only from a machine that holds
      your private identity key. It is much stronger because it is not
      vulnerable to password cracking or keystroke logging; an attacker must
      possess your private key and know its passphrase.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
     <term>Passphrase-less public key authentication</term>
     <listitem>
      <para>
       Public key authentication, paired with private identity keys that do
       not have passphrases. This is useful for automated services, like
       scripts and cron jobs. You must protect private keys, because anyone
       who gains access to them can easily masquerade as the key owner.
      </para>
      <para>
       A useful alternative is to use <command>ssh-agent</command> and
       related utilities for managing passphrase-protected keys. These
       hold passphrases in memory, and apply them as needed.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Certificate authentication</term>
     <listitem>
      <para>
       OpenSSH supports certification authentication, for easier key
       management and large-scale SSH deployments.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

 <para>
  &productname; installs the OpenSSH package by default, providing the
  following commands:
 </para>

 <variablelist>
  <varlistentry>
   <term><command>ssh</command></term>
   <listitem>
    <para>
     The client command for initiating an SSH connection to a remote host.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><command>scp</command></term>
   <listitem>
    <para>
     Secure file copy from or to a remote host.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><command>sftp</command></term>
   <listitem>
    <para>
     Secure file transfer between a client and an SFTP server.
     <!--the SFTP protocol (SSH FTP), a protocol made from scratch
     and that has nothing to do with FTPS or FTPES (FTP over SSL / TLS).-->
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><command>ssh-add</command></term>
   <listitem>
    <para>
     Add private key identities to the authentication agent,
     <command>ssh-agent</command>.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><command>ssh-agent</command></term>
   <listitem>
    <para>
     Manages a user's private identity keys and their passphrases, for
     public key authentication. <command>ssh-agent</command> holds the
     passphrases in memory and applies them as needed, so that users do not
     have to type their passphrases to authenticate.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><command>ssh-copy-id</command></term>
   <listitem>
    <para>
     Securely transfer a public key to a remote host, to set up
     public key authentication.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><command>ssh-keyscan</command></term>
   <listitem>
    <para>
     Collect the public SSH host keys of a number of hosts, for
     populating <filename>known_hosts</filename> files.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</sect1>

<sect1 xml:id="sec-ssh-server-config">
 <title>Server hardening</title>
 <para>
  OpenSSH ships with a usable default server configuration, but there are
  additional steps you can take to secure your server.
 </para>
 <para>
  The default server configuration file, <filename>/etc/ssh/sshd_config</filename>,
  contains the default configuration, and all the defaults are commented
  out. Override any default item by entering your own configuration item,
  uncommented, like the following example that sets a different listening
  port, and specifies the listening IPv4 address:
 </para>
 <screen>
#Port 22
Port <replaceable>2022</replaceable>

#ListenAddress 0.0.0.0
ListenAddress <replaceable>192.168.10.100</replaceable></screen>
 <para>
  The following settings for <filename>/etc/ssh/sshd_config</filename>
  strengthen access controls:
 </para>
 <screen># Check if the file modes and ownership of the userâ€™s files and
# home directory are correct before allowing them to login
StrictModes yes

# If your machine has more than one IP address, define which address or
# addresses it listens on
ListenAddress <replaceable>192.168.10.100</replaceable>

# Allow only members of the listed groups to log in
AllowGroups <replaceable>ldapadmins backupadmins</replaceable>

# Or, deny certain groups. If you use both, DenyGroups is read first
DenyGroups <replaceable>users</replaceable>

# Allow or deny certain users. If you use both, DenyUsers is read first
AllowUsers <replaceable>user1 user2 user3</replaceable>
DenyUsers <replaceable>user4</replaceable>

# Allow root logins only with public key authentication
PermitRootLogin prohibit-password

# Disable password authentication and allow only public key authentication
# for all users
PasswordAuthentication no</screen>

 <para>
  After changing <filename>/etc/ssh/sshd_config</filename>, run the syntax
  checker:
 </para>
 <screen>&prompt.sudo;<command>sshd -t</command></screen>
 <para>
  The syntax checker only checks for correct syntax, and does not find
  configuration errors. When you are finished, reload the configuration:
 </para>
 <screen>&prompt.sudo;<command>systemctl reload sshd.server</command></screen>
 <para>
  Check the server's key directories for correct permissions.
 </para>
 <para>
  <filename>/etc/ssh</filename> should be mode 0755/drwxr-xr-x, owned by
  root:root.
 </para>
 <para>
  Private keys should be 0600/-rw-------, owned by root:root.
 </para>
 <para>
  Private keys should be 0644/-rw-r--r--, owned by root:root.
 </para>
</sect1>

<sect1 xml:id="sec-ssh-programm">
  <title>Password authentication</title>
  <para>
   With <command>ssh</command> you may log in to remote
   systems and work interactively. To log in to the host
   <literal>&exampleserver;</literal> as user &exampleuser; enter one of
   the following commands:
  </para>

<screen>&prompt.user;<command>ssh &exampleuser_plain;@&exampleserver;</command>
&prompt.user;<command>ssh -l &exampleuser_plain; &exampleserver;</command></screen>

  <para>
   Type <literal>exit</literal> and press Enter to close an SSH session.
  </para>

  <para>
   If the user name is the same on both machines, you can omit it, and then
   using <command>ssh &exampleserver;</command> is sufficient. The remote
   host prompts for the remote user's password. After a successful
   authentication, you can work on the remote command line or use
   interactive applications, such as &yast; in text mode.
  </para>

  <para>
   You may also run  non-interactive commands on remote systems using
   <command>ssh</command> <replaceable>USER_NAME</replaceable> <replaceable>HOST</replaceable>
   <replaceable>COMMAND</replaceable>.
   <replaceable>COMMAND</replaceable> needs to be properly quoted. Multiple
   commands can be concatenated as on a local shell:
  </para>

<screen>&prompt.user;<command>ssh root@&exampleserver; "dmesg -T | tail -n 25"</command>
&prompt.user;<command>ssh root@&exampleserver; "cat /etc/os-release &amp;&amp; uptime"</command></screen>

  <sect2 xml:id="sec-ssh-programm-x">
   <title>Starting X11 applications on a remote host</title>
   <para>
    You can run graphical applications that are installed on a
    remote machine on your local computer.
    <literal>X11Forwarding Yes</literal> must be set in the
    <filename>/etc/ssh/sshd_config</filename> file on the remote machine.
    Then, when you run <command>ssh</command> with the <option>-X</option>
    option, the <envar>DISPLAY</envar> variable is automatically set on the
    remote machine, and all X output is exported to the local machine over
    the SSH connection. At the same time, X applications started remotely
    cannot be intercepted by unauthorized individuals.
   </para>
   <para>
    A quick test is to run a simple game from the remote machine, such as
    GNOME Mines:
   </para>
   <screen>&prompt.user;<command>ssh &exampleuser_plain;@&exampleserver;</command>
Password:
Last login: Tue May 10 11:29:06 2022 from 192.168.163.13
Have a lot of fun...

&exampleuser_plain;@&exampleserver; gnome-mines</screen>
   <para>
     The remote application should appear on your local machine just as
     though it were installed locally. (Note that network lag may affect
     performance.) Close the remote application in the usual way, such as
     clicking the close button. This closes only the application, and your
     SSH session remains open.
   </para>

   <important>
    <title>X11 forwarding does not work on Wayland</title>
    <para>
     X11 forwarding requires the X Windows System, which is the default on
     &slea;, and not the Wayland display server protocol. The X Windows
     System has built-in networking, while Wayland does not.
    </para>
    <para>
     Use the following command to learn if your system runs X or Wayland:
    </para>
    <screen>&prompt.user;<command>echo $XDG_SESSION_TYPE</command>
x11</screen>
    <para>
     If Wayland is in use, it looks like the following example:
    </para>
    <screen>&prompt.user;<command>echo $XDG_SESSION_TYPE</command>
wayland</screen>
   </important>
  </sect2>

  <!-- this section needs improving and expanding -->
  <sect2 xml:id="sec-ssh-programm-forwarding">
   <title>Agent Forwarding</title>
   <para>
    By adding the <option>-A</option> option, the ssh-agent authentication
    mechanism is carried over to the next machine. This way, you can work
    from different machines without having to enter a password, but only if
    you have distributed your public key to the destination hosts and
    properly saved it there. (Refer to
    <xref linkend="sec-ssh-authentic-key-copy"/> to learn the safe way
    to copy your public keys to other hosts.)
   </para>
<!--
   <para>
    <literal>AllowAgentForwarding yes</literal> is the default in
    <filename>/etc/ssh/sshd_config</filename>. Change it to
    <literal>No</literal> to disable it.
   </para> -->
  </sect2>
 </sect1>

 <sect1 xml:id="sec-ssh-copy">
  <title><command>scp</command>&mdash;secure copy</title>
  <para>
   <command>scp</command> copies files to or from a remote machine.  If
   the user name on &wsI; is different than the user name on
   &exampleserver;, specify the latter using the
   <option><replaceable>USER_NAME</replaceable>@host</option> format. If
   the file should be copied into a directory other than the remote
   user's home directory, specify it as
   &exampleserver;:<replaceable>DIRECTORY</replaceable>. The following
   examples show how to copy a file from a local to a remote machine and
   vice versa.
  </para>

<screen>&prompt.user;scp ~/MyLetter.tex &exampleuser_plain;@&exampleserver;:/tmp <co xml:id="co-scp-local-remote"/>
&prompt.user;scp &exampleuser_plain;@&exampleserver;:/tmp/MyLetter.tex ~ <co xml:id="co-scp-remote-local"/></screen>
<calloutlist>
 <callout arearefs="co-scp-local-remote">
  <para>local to remote</para>
</callout>
 <callout arearefs="co-scp-remote-local">
  <para>remote to local</para>
 </callout>
</calloutlist>
  <tip>
   <title>The <option>-l</option> Option</title>
   <para>
    With the <command>ssh</command> command, the option
    <option>-l</option> can be used to specify a remote user (as an
    alternative to the
    <option><replaceable>USER_NAME</replaceable>@host</option>
    format). With <command>scp</command> the option <option>-l</option>
    is used to limit the bandwidth consumed by <command>scp</command>.
   </para>
  </tip>

  <para>
   After the correct password is entered, <command>scp</command> starts the
   data transfer. It displays a progress bar and the time remaining for each
   file that is copied. Suppress all output with the <option>-q</option>
   option.
  </para>

  <para>
   <command>scp</command> also provides a recursive copying feature for
   entire directories. The command
  </para>

<screen>&prompt.user;scp -r src/ sun:backup/</screen>

  <para>
   copies the entire contents of the directory <filename>src</filename>
   including all subdirectories to the <filename>~/backup</filename>
   directory on the host &exampleserver;. If this subdirectory does not
   exist, it is created automatically.
  </para>

  <para>
   The <option>-p</option> option tells <command>scp</command> to leave the
   time stamp of files unchanged. <option>-C</option> compresses the data
   transfer. This minimizes the data volume to transfer, but creates a
   heavier burden on the processors of both machines.
  </para>
 </sect1>
 <sect1 xml:id="sec-ssh-sftp">
  <title><command>sftp</command>&mdash;Secure File Transfer</title>

  <sect2 xml:id="sec-ssh-sftp-using">
   <title>Using <command>sftp</command></title>
  <para>
   If you want to copy several files from or to different locations,
   <command>sftp</command> is a convenient alternative to
   <command>scp</command>. It opens a shell with a set of commands similar
   to a regular FTP shell. Type <command>help</command> at the sftp-prompt
   to get a list of available commands. More details are available from the
   <command>sftp</command> man page.
  </para>

<screen>&prompt.user;sftp &exampleserver;
Enter passphrase for key '/home/&exampleuser_plain;/.ssh/id_rsa':
Connected to &exampleserver;.
sftp&gt; help
Available commands:
bye                                Quit sftp
cd path                            Change remote directory to 'path'
[...]</screen>
  </sect2>
  <sect2 xml:id="sec-ssh-sftp-perms">
   <title>Setting Permissions for File Uploads</title>
   <para>
    As with a regular FTP server, a user cannot only download,
        but also upload files to a remote machine running an SFTP server
        by using the <command>put</command> command. By default the
        files will be uploaded to the remote host with the same
        permissions as on the local host. There are two options to
        automatically alter these permissions:
   </para>
   <variablelist>
    <varlistentry>
     <term>Setting a umask</term>
     <listitem>
      <para>
       A umask works as a filter against the permissions of the original
       file on the local host. It can only withdraw permissions:
      </para>
      <table>
       <title/>
       <tgroup cols="3">
        <colspec colnum="1" colname="1" colwidth="33*"/>
        <colspec colnum="2" colname="2" colwidth="33*"/>
        <colspec colnum="3" colname="3" colwidth="33*"/>
        <thead>
         <row>
          <entry>
           <para>
            permissions original
           </para>
          </entry>
          <entry>
           <para>
            umask
           </para>
          </entry>
          <entry>
           <para>
            permissions uploaded
           </para>
          </entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry>
           <para>
            0666
           </para>
          </entry>
          <entry>
           <para>
            0002
           </para>
          </entry>
          <entry>
           <para>
            0664
           </para>
          </entry>
         </row>
         <row>
          <entry>
           <para>
            0600
           </para>
          </entry>
          <entry>
           <para>
            0002
           </para>
          </entry>
          <entry>
           <para>
            0600
           </para>
          </entry>
         </row>
         <row>
          <entry>
           <para>
            0775
           </para>
          </entry>
          <entry>
           <para>
            0025
           </para>
          </entry>
          <entry>
           <para>
            0750
           </para>
          </entry>
         </row>
        </tbody>
       </tgroup>
      </table>
      <para>
       To apply a umask on an SFTP server, edit the file
       <filename>/etc/ssh/sshd_configuration</filename>. Search for the line
       beginning with <literal>Subsystem sftp</literal> and add the
       <option>-u</option> parameter with the desired setting, for example:
      </para>
<screen>Subsystem sftp /usr/lib/ssh/sftp-server -u 0002</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Explicitly Setting the Permissions</term>
     <listitem>
      <para>
       Explicitly setting the permissions sets the same permissions for all
       files uploaded via SFTP. Specify a three-digit pattern such as
       <literal>600</literal>, <literal>644</literal>, or
       <literal>755</literal> with <option>-u</option>. When both
       <option>-m</option> and <option>-u</option> are specified,
       <literal>-u</literal> is ignored.
      </para>
      <para>
       To apply explicit permissions for uploaded files on an SFTP server,
       edit the file <filename>/etc/ssh/sshd_configuration</filename>.
       Search for the line beginning with <literal>Subsystem sftp</literal>
       and add the <option>-m</option> parameter with the desired setting,
       for example:
      </para>
<screen>Subsystem sftp /usr/lib/ssh/sftp-server -m 600</screen>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-ssh-sshdserver">
  <title>The SSH Daemon (<systemitem class="daemon">sshd</systemitem>)</title>

  <para>
   To work with the SSH client programs <command>ssh</command> and
   <command>scp</command>, a server (the SSH daemon) must be running in the
   background, listening for connections on <literal>TCP/IP port
   22</literal>. The daemon generates host key pairs when starting for the
   first time. Each key pair consists of a private and a public key.
   Therefore, this procedure is called public key-based. To
   guarantee the security of the communication via SSH, access to the
   private key files must be restricted to the system administrator. The
   file permissions are set accordingly by the default installation. The
   private keys are only required locally by the SSH daemon and must not be
   given to anyone else. The public key components (recognizable by the name
   extension <filename>.pub</filename>) are sent to the client requesting
   the connection. They are readable for all users.
  </para>

  <para>
   A connection is initiated by the SSH client. The waiting SSH daemon and
   the requesting SSH client exchange identification data to compare the
   protocol and software versions, and to prevent connections through the
   wrong port. Because a child process of the original SSH daemon replies to
   the request, several SSH connections can be made simultaneously.
  </para>

  <para>
   The private host and server keys are absolutely required to decrypt the
   session key and cannot be derived from the public parts. Only the
   contacted SSH daemon can decrypt the session key using its private keys.
   This initial connection phase can be watched closely by turning on
   verbose debugging using the <option>-v</option> option of the SSH client.
  </para>

  <tip>
   <title>Viewing the SSH Daemon Log File</title>
   <para>
    To watch the log entries from the <systemitem
    class="daemon">sshd</systemitem> use the following command:
   </para>
   <screen>&prompt.sudo;journalctl -u sshd</screen>
  </tip>


  <sect2>
   <title>Maintaining SSH Keys</title>
  <para>
   It is recommended to back up the private and public keys stored in
   <filename>/etc/ssh/</filename> in a secure, external location. In this
   way, key modifications can be detected or the old ones can be used again
   after having installed a new system.
  </para>

  <tip>
   <title>Existing SSH Host Keys</title>
   <para>
    If you install &productname; on a machine with existing Linux
    installations, the installation routine automatically imports the SSH
    host key with the most recent access time from an existing installation.
   </para>
  </tip>

  <para>
   When establishing a secure connection with a remote host for the first
   time, the client stores all public host keys in
   <filename>~/.ssh/known_hosts</filename>. This prevents any
   man-in-the-middle attacks&mdash;attempts by foreign SSH servers to use
   spoofed names and IP addresses. Such attacks are detected either by a
   host key that is not included in <filename>~/.ssh/known_hosts</filename>,
   or by the server's inability to decrypt the session key in the absence of
   an appropriate private counterpart.
  </para>

  <para>
   If the public keys of a host have changed (that needs to be verified
   before connecting to such a server), the offending keys can be
   removed with <command>ssh-keygen -r
   <replaceable>HOSTNAME</replaceable></command>.
  </para>
  </sect2>

  <sect2 xml:id="sec-ssh-sshdserver-rotation">
   <title>Rotating host keys</title>
   <para>
    As of version 6.8, OpenSSH includes a protocol extension that
    supports host key rotation. Server admins must periodically
    retire old host keys and create new keys, for example if a key has been
    compromised, or it is time to upgrade to stronger keys. Before OpenSSH
    6.8, if <literal>StrictHostKeyChecking</literal>
    was set to <literal>yes</literal> in <filename>ssh_config</filename>
    on client machines, clients would see a warning that the host key had
    changed, and were not allowed to connect. Then the users would have to
    manually delete the server's public key from their
    <filename>known_hosts</filename> file, reconnect, and manually accept the
    new key. Any automated SSH connections, such as scheduled backups, would
    fail.
   </para>
   <para>
     The new host key rotation scheme provides a method to distribute new
     keys without service interruptions. When clients connect, the server
     sends them a list of new keys. Then the next time they log in they are
     asked if they wish to accept the changes. Give users a few days to
     connect and receive the new keys, and then remove the old keys. The
     <filename>known_hosts</filename> files on the clients are automatically
     updated, with new keys added and the old keys removed.
   </para>
    <para>
      Setting up host key rotations requires creating new keys on the server,
      some changes to <filename>/etc/ssh/sshd_config</filename> on the
      server, and to <filename>/etc/ssh/ssh_config</filename> on the clients.
   </para>
   <para>
     First create your new key or keys. The following example creates a new
     RSA key and a new Ed25519 key, with comments. The new keys must
     have unique names. A useful convention is to name them with the creation
     date. Remember, a host key must not have a passphrase:
   </para>
   <screen>&prompt.root;<command>ssh-keygen -t rsa -f ssh_host_rsa_2022-01 -C "main server"</command>
Generating public/private rsa key pair.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in ssh_host_rsa_2022-01
Your public key has been saved in ssh_host_rsa_2022-01.pub
The key fingerprint is:
SHA256:F1FIF2aqOz7D3mGdsjzHpH/kjUWZehBN3uG7FM4taAQ main server
The key's randomart image is:
+---[RSA 3072]----+
|         .Eo*.oo |
|          .B .o.o|
|          o . .++|
|         . o ooo=|
|        S . o +*.|
|         o o.oooo|
|       .o ++oo.= |
|       .+=o+o + .|
|       .oo++..   |
+----[SHA256]-----+

&prompt.root;<command>ssh-keygen -t ed25519 -f ssh_host_ed25519_2022-01 -C "main server"</command>
Generating public/private ed25519 key pair.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in ssh_host_ed25519_2022-01
Your public key has been saved in ssh_host_ed25519_2022-01.pub
The key fingerprint is:
SHA256:2p9K0giXv7WsRnLjwjs4hJ8EFcoX1FWR4nQz6fxnjxg root@server2
The key's randomart image is:
+--[ED25519 256]--+
|   .+o ...o+     |
| . .... o *      |
|  o..  o = o     |
|  ..   .. o      |
|   o. o S  .     |
|  . oo.*+   E o  |
|   + ++==..  = o |
|    = +oo= o. . .|
|     ..=+o=      |
+----[SHA256]-----+</screen>

   <para>
     Record the fingerprints, for users to verify the new keys.
   </para>
   <para>
     Add the new key names to <filename>/etc/ssh/sshd_config</filename>, and
     uncomment any existing keys that are in use:
   </para>
   <screen>## Old keys
HostKey /etc/ssh/ssh_host_rsa_key
HostKey /etc/ssh/ssh_host_ed25519_key
HostKey /etc/ssh/ssh_host_ecdsa_key

## New replacement keys
HostKey /etc/ssh/ssh_host_rsa_2022-01
HostKey /etc/ssh/ssh_host_ed25519_2022-01</screen>

    <para>
      Save your changes, then restart <systemitem class="daemon">sshd</systemitem>:
    </para>
    <screen>&prompt.root;<command>systemctl restart sshd.service</command>
    </screen>
    <para>
      The <filename>/etc/ssh/ssh_config</filename> file on the clients must
      include the following settings:
    </para>
    <screen>UpdateHostKeys ask
StrictHostKeyChecking yes</screen>
    <para>
      Test connecting from a client by opening an SSH session to the server
      to receive the new keys list. Log out, then log back in. When you log
      back in you should see something like the following message:
    </para>
    <screen>The server has updated its host keys.
These changes were verified by the server's existing trusted key.
Deprecating obsolete hostkey: ED25519
SHA256:V28d3VpHgjsCoV04RBCZpLo5c0kEslCZDVdIUnCvqPI
Deprecating obsolete hostkey:
RSA SHA256:+NR4DVdbsUNsqJPIhISzx+eqD4x/awCCwijZ4a9eP8I
Accept updated hostkeys? (yes/no):</screen>
    <para>
      You may set <literal>UpdateHostKeys ask</literal> to
      <literal>UpdateHostKeys yes</literal> to apply the changes
      automatically, and avoid asking the user to approve the changes, though
      asking them to review the changes and compare fingerprints is safer.
    </para>
    <para>
      For more information:
    </para>

<itemizedlist>
    <listitem>
      <para>
        <xref linkend="sec-ssh-authentic-gen-key"/>
      </para>
    </listitem>
    <listitem>
     <para>
      <link xlink:href="http://blog.djm.net.au/2015/02/key-rotation-in-openssh-68.html"/>
     </para>
    </listitem>
    <listitem>
     <para>
       man 5 ssh_config, man 5 sshd_config
     </para>
    </listitem>
   </itemizedlist>
  </sect2>
 </sect1>

<sect1 xml:id="sec-ssh-authentic">
  <title>SSH Authentication Mechanisms</title>

  <para>
   In its simplest form, authentication is done by entering the user's
   password just as if logging in locally. However, having to memorize
   passwords of several users on remote machines is inefficient. What is
   more, these passwords may change. On the other hand&mdash;when
   granting &rootuser; access&mdash;an administrator needs to be able
   to quickly revoke such a permission without having to change the
   &rootuser; password.
  </para>

  <para>
   To accomplish a login that does not require to enter the remote
   user's password, SSH uses another key pair, which needs to be generated
   by the user. It consists of a public (<filename>id_rsa.pub</filename> or
   <filename>id_dsa.pub</filename>) and a private key
   (<filename>id_rsa</filename> or <filename>id_dsa</filename>).
  </para>

  <para>
   To be able to log in without having to specify the remote user's
   password, the public key of the <quote>SSH user</quote> must be
   in <filename>~/.ssh/authorized_keys</filename>. This approach also
   ensures that the remote user has got full control: adding the key
   requires the remote user's password and removing the key revokes the
   permission to log in from remote.
  </para>

  <para>
   For maximum security such a key should be protected by a passphrase which
   needs to be entered every time you use <command>ssh</command>,
   <command>scp</command>, or <command>sftp</command>. Contrary to the
   simple authentication, this passphrase is independent from the remote
   user and therefore always the same.
  </para>

  <para>
   An alternative to the key-based authentication described above, SSH also
   offers a host-based authentication. With host-based authentication, users
   on a trusted host can log in to another host on which this feature is
   enabled using the same user name. &productname; is set up for using
   key-based authentication, covering setting up host-based authentication
   on &productname; is beyond the scope of this manual.
  </para>

  <note>
<!-- fix for bug #398647 -->
   <title>File Permissions for Host-Based Authentication</title>
   <para>
    If the host-based authentication is to be used, the file
    <filename>/usr/lib/ssh/ssh-keysign</filename> should
    have the setuid bit set, which is not the default setting in
    &productname;. In such case, set the file permissions manually. You
    should use <filename>/etc/permissions.local</filename> for this purpose,
    to make sure that the setuid bit is preserved after security updates of
    <package>openssh</package>.
   </para>
  </note>

  <sect2 xml:id="sec-ssh-authentic-gen-key">
   <title>Generating Client and Host SSH keys</title>
   <para>
     There are several key types to choose from: DSA, RSA, ECDSA, ECDSA-SK,
     Ed25519, and Ed25519-SK. DSA was deprecated several years, and disabled
     in OpenSSH 7.0 and should not be used. RSA is the most universal as it
     is older, and more widely used.
   </para>
   <para>
     Ed25519 and ECDSA are stronger and faster. Ed25519 is
     considered to be the strongest. If you must support older clients
     that do not support Ed25519, create both Ed25519 and RSA host keys.
   </para>
   <note>
     <title>Older clients may be unsafe</title>
     <para>
       Some older SSH clients do not support ECDSA and ED25519. ECDSA and
       ED25519 were released with OpenSSH 6.5 in 2014. It is
       important to keep security services updated, and, if possible,
       to not allow unsafe old clients.
     </para>
   </note>
   <para>
     SSH keys serve two purposes: authenticating servers with host keys, and
     authenticating clients. Host keys are stored in
     <filename>/etc/ssh</filename>. Client keys are specific to users, and
     are stored in <filename>/home/<replaceable>user</replaceable>/.ssh</filename>.
   </para>
   <para>
     Host keys must not have passphrases.
   </para>
   <para>
     In most cases, private client keys should have strong passwords.
   </para>
   <para>
     The following procedure shows how to create client keys.
   </para>

   <procedure xml:id="pro-ssh-key-client">
     <title>Creating client SSH key pairs</title>
    <step>
     <para>
      To generate a client key pair with the default parameters (RSA, 3072
      bits), use the <command>ssh-keygen</command> command with no options.
      Protect your private key with a strong passphrase:
     </para>
     <screen>&prompt.user;<command>ssh-keygen</command>
Generating public/private rsa key pair.
Enter file in which to save the key (/home/user/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/user/.ssh/id_rsa
Your public key has been saved in /home/user/.ssh/id_rsa.pub
The key fingerprint is:
SHA256:z0uJIuc7Doy07bFTe1ppZHLVrkD/bWWlBAF/PcHjblU user@server2
The key's randomart image is:
+---[RSA 3072]----+
|          ..o... |
|           o . +E|
|        . . o +.=|
|       . o . o o+|
|  .   . S . . o +|
| . =  .= * + . = |
|  o *.o.= * . +  |
|   ..Bo+.. . .   |
|    oo==  .      |
+----[SHA256]-----+</screen>
    </step>
    <step>
      <para>
        Create an RSA key pair with a longer bit length:
      </para>
      <screen>&prompt.user;<command>ssh-keygen -b 4096</command></screen>
      <para>
        OpenSSH RSA keys can be a maximum of 16,384 bits. However, longer bit
        lengths are not necessarily more desirable. See the GnuPG FAQ for
        more information, <link xlink:href="https://www.gnupg.org/faq/gnupg-faq.html#no_default_of_rsa4096"/>.
      </para>
    </step>
    <step>
      <para>
      Create an RSA key pair with a custom name and a comment:
    </para>
    <screen>&prompt.user;<command>ssh-keygen -f <replaceable>backup-server-key -C "infrastructure backup server"</replaceable></command>
      </screen>
    </step>
    <step>
     <para>
       Create an Ed25519 key pair with a comment:
     </para>
     <screen>&prompt.user;<command>ssh-keygen -t ed25519 -f <replaceable>ldap-server-key -C "Internal HTTP server"</replaceable></command>
     </screen>
     <para>
       Ed25519 keys are fixed at 256 bits, which is equivalent in
       cryptographic strength to RSA 4096.
     </para>
    </step>
   </procedure>

    <para>
      Host keys are managed a little differently. A host key must not
      have a passphrase, and the key pairs are stored in <filename>/etc/ssh</filename>.
      OpenSSH automatically generates a set of host keys when it is
      installed, like the following example:
    </para>
    <screen>&prompt.user;<command>ls -l /etc/ssh</command>
total 608
-rw------- 1 root root 577834 2021-05-06 04:48 moduli
-rw-r--r-- 1 root root   2403 2021-05-06 04:48 ssh_config
-rw-r----- 1 root root   3420 2021-05-06 04:48 sshd_config
-rw------- 1 root root   1381 2022-02-10 06:55 ssh_host_dsa_key
-rw-r--r-- 1 root root    604 2022-02-10 06:55 ssh_host_dsa_key.pub
-rw------- 1 root root    505 2022-02-10 06:55 ssh_host_ecdsa_key
-rw-r--r-- 1 root root    176 2022-02-10 06:55 ssh_host_ecdsa_key.pub
-rw------- 1 root root    411 2022-02-10 06:55 ssh_host_ed25519_key
-rw-r--r-- 1 root root     96 2022-02-10 06:55 ssh_host_ed25519_key.pub
-rw------- 1 root root   2602 2022-02-10 06:55 ssh_host_rsa_key
-rw-r--r-- 1 root root    568 2022-02-10 06:55 ssh_host_rsa_key.pub</screen>

    <para>
      <command>ssh-keygen</command> has a special option, <option>-A</option>,
      for creating new host keys. This creates new keys for each of the key
      types for which host keys do not exist, with the default key file path,
      an empty passphrase, default bit size for the key type, and an empty
      comment. The following example creates a complete new
      set of keys by first deleting the existing keys, then creating a new
      set:
    </para>
    <screen>&prompt.sudo;<command>rm /etc/ssh/ssh_host*</command>
&prompt.sudo;<command>ssh-keygen -A</command></screen>
    <para>
      You can replace selected key pairs by first deleting only the
      keys you want to replace, because <command>ssh-keygen -A</command>
      does not replace existing keys.
    </para>
    <important>
      <para>
        <command>ssh-keygen -A</command> still creates DSA keys, even though
        they have been deprecated as unsafe for several years. In OpenSSH 7.0
        they are still created, but disabled by not being listed in
        <filename>sshd_config</filename>. You may safely delete DSA keys.
      </para>
    </important>
    <para>
      When you want to rotate host keys, you must create the new keys
      individually, because they must exist at the same time as your
      old host keys. Your clients will authenticate with the old keys,
      and then receive the list of new keys. They need unique names,
      to not conflict with the old keys. The following example creates new
      RSA and Ed25519 host keys, labeled with the year and month they were
      created. Remember, the new host ukeys must not have passphrases:
    </para>
    <screen>&prompt.user;<command>cd /etc/ssh</command>
&prompt.sudo;<command>ssh-keygen -b 4096 -f "ssh_host_rsa_2022_02"</command>
&prompt.sudo;<command>ssh-keygen -t ed25519 -f "ssh_host_ed25519_2022_02"</command></screen>
    <para>
      You may name your new keys whatever you want.
    </para>
  </sect2>

  <sect2 xml:id="sec-ssh-authentic-key-copy">
   <title>Copying an SSH Key</title>
   <para>
    To copy a public SSH key to <filename>~/.ssh/authorized_keys</filename>
    of a user on a remote machine, use the command
    <command>ssh-copy-id</command>. To copy your personal key
    stored under <filename>~/.ssh/id_rsa.pub</filename> you may use the
    short form. To copy DSA keys or keys of other users, you need
    to specify the path:
   </para>
  <screen>&prompt.user;<prompt>~/.ssh/id_rsa.pub</prompt>
ssh-copy-id -i &exampleuser_plain;@&exampleserver;

&prompt.user;<prompt>~/.ssh/id_dsa.pub</prompt>
ssh-copy-id -i ~/.ssh/id_dsa.pub  &exampleuser_plain;@&exampleserver;

&prompt.user;<prompt>~notme/.ssh/id_rsa.pub</prompt>
ssh-copy-id -i ~notme/.ssh/id_rsa.pub  &exampleuser_plain;@&exampleserver;</screen>
   <para>
    To successfully copy the key, you need to enter the remote
    user's password. To remove an existing key, manually edit
    <filename>~/.ssh/authorized_keys</filename>.
   </para>
  </sect2>

  <sect2 xml:id="sec-ssh-authentic-agent">
   <title>Using the <command>ssh-agent</command></title>
   <para>
    When doing lots of secure shell operations it is cumbersome to type the
    SSH passphrase for each such operation. Therefore, the SSH package
    provides another tool, <command>ssh-agent</command>, which retains the
    private keys for the duration of an X or terminal session. All other
    windows or programs are started as clients to the
    <command>ssh-agent</command>. By starting the agent, a set of
    environment variables is set, which will be used by
    <command>ssh</command>, <command>scp</command>, or
    <command>sftp</command> to locate the agent for automatic login. See
    the <command>ssh-agent</command> man page for details.
   </para>
   <para>
    After the <command>ssh-agent</command> is started, you need to add your
    keys by using <command>ssh-add</command>. It will prompt for the
    passphrase. After the password has been provided once, you can use the
    secure shell commands within the running session without having to
    authenticate again.
   </para>
   <sect3 xml:id="sec-ssh-authentic-agent-x">
    <title>Using <command>ssh-agent</command> in an X Session</title>
    <para>
     On &productname;, the <command>ssh-agent</command> is automatically
     started by the &gnome; display manager. To also invoke
     <command>ssh-add</command> to add your keys to the agent at the
     beginning of an X session, do the following:
    </para>
    <procedure>
     <step>
      <para>
       Log in as the desired user and check whether the file
       <filename>~/.xinitrc</filename> exists.
      </para>
     </step>
     <step>
      <para>
       If it does not exist, use an existing template or copy it from
       <filename>/etc/skel</filename>:
      </para>
<screen>if [ -f ~/.xinitrc.template ]; then mv ~/.xinitrc.template ~/.xinitrc; \
else cp /etc/skel/.xinitrc.template ~/.xinitrc; fi</screen>
     </step>
     <step>
      <para>
       If you have copied the template, search for the following lines and
       uncomment them. If <filename>~/.xinitrc</filename> already existed,
       add the following lines (without comment signs).
      </para>
<screen># if test -S "$SSH_AUTH_SOCK" -a -x "$SSH_ASKPASS"; then
#       ssh-add &lt; /dev/null
# fi</screen>
     </step>
     <step>
      <para>
       When starting a new X session, you will be prompted for your SSH
       passphrase.
      </para>
     </step>
    </procedure>
   </sect3>
   <sect3 xml:id="sec-ssh-authentic-agent-terminal">
    <title>Using <command>ssh-agent</command> in a Terminal Session</title>
    <para>
     In a terminal session you need to manually start the
     <command>ssh-agent</command> and then call <command>ssh-add</command>
     afterward. There are two ways to start the agent. The first example
     given below starts a new Bash shell on top of your existing shell. The
     second example starts the agent in the existing shell and modifies the
     environment as needed.
    </para>
<screen>&prompt.user;ssh-agent -s /bin/bash
eval $(ssh-agent)
    </screen>
    <para>
     After the agent has been started, run <command>ssh-add</command> to
     provide the agent with your keys.
    </para>
   </sect3>
  </sect2>

<!-- fs 2012-10-02:

     Not sure what to do with this...

    <sect2 id="sec-ssh-authentic-host-based">
   <title>Host-based Authentication</title>
   <para></para>
  </sect2>
-->
 </sect1>
 <sect1 xml:id="sec-ssh-restrict-logins">
  <title>Restricting SSH Logins</title>
  <para>
   The SSH service on a machine can be restricted to allow logins only from a
   certain IP subnet for a given account. Perform the following steps to
   configure user remote login restrictions for <command>ssh</command> (<xref
   linkend="sec-ssh-programm"/>), <command>scp</command> (<xref
   linkend="sec-ssh-copy"/>), and <command>sftp</command> (<xref
   linkend="sec-ssh-sftp"/>.
  </para>
  <procedure xml:id="pro-ssh-restrict-logins">
   <!-- cwickert 2021-09-24 following lines are the 'new' format of procedures
    with title and introduction inside. Commented out for consistency for now.
   -->
   <!-- <title>Configuring user remote login restrictions</title>
   <para>
    Perform the following steps to configure user remote login restrictions:
    </para> -->
   <step>
    <para>
     Edit the file <filename>/etc/pam.d/sshd</filename> and append the following
     at the end of the <literal>auth</literal> block:
    </para>
    <screen>auth required pam_access.so</screen>
   </step>
   <step>
    <para>
     Edit the file <filename>/etc/security/access.conf</filename> to configure
     individual restrictions. In this example the users &rootuser; and
     &exampleuser; are restricted to the &exampledomain1ip;.0/&subnetmask;
     network, while the &exampleuserII; user can only login from within the
     &exampledomain2ip;.0/&subnetmask; network:
    </para>
<screen>
+ : root : <replaceable>&exampledomain1ip;.0</replaceable>/<replaceable>&subnetmask;</replaceable>
+ : &exampleuser_plain; : <replaceable>&exampledomain1ip;.0</replaceable>/<replaceable>&subnetmask;</replaceable>
+ : &exampleuserII_plain; : <replaceable>&exampledomain2ip;.0</replaceable>/<replaceable>&subnetmask;</replaceable>
- : ALL : ALL</screen>
   <para>
    Do not forget the last line which denies access for all other users from all
    sources, but be careful not to lock yourself out of the system.
   </para>
   <para>
    For more configuration options, refer to the examples in the file and to
    <command>man access.conf</command>.
   </para>
   </step>
  </procedure>
  <warning>
   <title>Do Not Use <command>pam-config</command></title>
   <para>
    Do not use the <command>pam-config</command> utility here. It only supports
    <systemitem>pam_access</systemitem> as a global module. The configuration
    above is not suitable to be used globally for all services and can
    completely deny access to the system.
   </para>
  </warning>

 </sect1>
 <sect1 xml:id="sec-ssh-port-forwarding">
  <title>Port Forwarding</title>

  <para>
   <command>ssh</command> can also be used to redirect TCP/IP connections.
   This feature, also called <literal>SSH tunneling</literal>, redirects TCP
   connections to a certain port to another machine via an encrypted
   channel.
  </para>

  <para>
   With the following command, any connection directed to &wsI; port 25
   (SMTP) is redirected to the SMTP port on &exampleserver;. This is
   especially useful for those using SMTP servers without SMTP-AUTH or
   POP-before-SMTP features. From any arbitrary location connected to a
   network, e-mail can be transferred to the <quote>home</quote> mail server
   for delivery.
  </para>

<screen>&prompt.root;ssh -L 25:&exampleserver;:25 &wsI;</screen>

  <para>
   Similarly, all POP3 requests (port&nbsp;110) on &wsI; can be
   forwarded to the POP3 port of &exampleserver; with this command:
  </para>

<screen>&prompt.root;ssh -L 110:&exampleserver;:110 &wsI;</screen>

  <para>
   Both commands must be executed as &rootuser;, because the connection
   is made to privileged local ports. E-mail is sent and retrieved by
   normal users in an existing SSH connection. The SMTP and POP3 host
   must be set to <literal>localhost</literal> for this to
   work. Additional information can be found in the manual pages for
   each of the programs described above and in the OpenSSH package
   documentation under
   <filename>/usr/share/doc/packages/openssh</filename>.
  </para>
 </sect1>

 <sect1 xml:id="sec-ssh-publickey">
  <title>Adding and Removing Public Keys on an Installed System</title>
  <para>
   In some environments, it is convenient or necessary to log in over SSH.
   As such, the user needs to provide a public SSH key. To add or remove
   an SSH key, proceed as follows:
  </para>
  <procedure>
   <step>
    <para>Open &yast;.</para>
   </step>
   <step>
    <para>
      Under <guimenu>Security and Users</guimenu>, open the
     <guimenu>User and Group Management</guimenu> module.
    </para>
   </step>
   <step>
    <para>
     Select the user you want to change and press <guimenu>Edit</guimenu>.
    </para>
   </step>
   <step>
    <para>
     Switch to the <guimenu>SSH Public Key</guimenu> tab.
    </para>
   </step>
   <step>
    <para>
     Add or remove your public key(s). If you add a public SSH key, look
     for the file extension <filename class="extension">.pub</filename>.
    </para>
   </step>
   <step>
    <para>Confirm with <guimenu>Ok</guimenu>.</para>
   </step>
  </procedure>

  <para>
   Your public SSH key is saved in <filename>~/.ssh/authorized_keys</filename>.
  </para>
 </sect1>

 <sect1 xml:id="sec-security-ssh-moreinfo">
  <title>For More Information</title>

  <para/>

  <variablelist>
   <varlistentry>
    <term><link xlink:href="https://www.openssh.com"/>
    </term>
    <listitem>
     <para>
      The home page of OpenSSH
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><link xlink:href="https://en.wikibooks.org/wiki/OpenSSH"/>
    </term>
    <listitem>
     <para>
      The OpenSSH Wikibook
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>man sshd</command>
    </term>
    <listitem>
     <para>
      The man page of the OpenSSH daemon
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>man ssh_config</command>
    </term>
    <listitem>
     <para>
      The man page of the OpenSSH SSH client configuration files
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>man scp</command>
    </term>
    <term><command>man sftp</command>
    </term>
    <term><command>man slogin</command>
    </term>
    <term><command>man ssh</command>
    </term>
    <term><command>man ssh-add</command>
    </term>
    <term><command>man ssh-agent</command>
    </term>
    <term><command>man ssh-copy-id</command>
    </term>
    <term><command>man ssh-keyconvert</command>
    </term>
    <term><command>man ssh-keygen</command>
    </term>
    <term><command>man ssh-keyscan</command>
    </term>
    <listitem>
     <para>
      Man pages of several binary files to securely copy files
      (<command>scp</command>, <command>sftp</command>), to log in
      (<command>slogin</command>, <command>ssh</command>), and to manage
      keys.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>
     <filename>/usr/share/doc/packages/openssh/README.SUSE</filename>
    </term>
    <term>
     <filename>/usr/share/doc/packages/openssh/README.FIPS</filename>
    </term>
    <listitem>
     <para>
      &suse; package specific documentation; changes in defaults with respect to
      upstream, notes on FIPS mode etc.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
</chapter>
