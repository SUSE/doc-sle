<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="64bit_issues.xml" version="5.0" xml:id="cha.64bit">
 <title>64 位元系統環境的 32 位元和 64 位元應用程式</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info><indexterm>
 <primary> 64 位元 Linux</primary></indexterm> 
 <para>
  <phrase role="productname"><phrase os="sles">SUSE® Linux Enterprise Server</phrase></phrase> 可用於<phrase os="sles">多種</phrase> 64 位元平台。但這並不表示所有包含的應用程式都已移植到 64 位元平台。<phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 支援在 64 位元系統環境中使用 32 位元應用程式。本章簡略說明這項支援在 64 位元 <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 平台上的執行方式。它說明 32 位元應用程式的執行方式 (執行期間支援) 以及如何編譯 32 位元應用程式，讓它們在 32 位元和 64 位元兩種系統環境都可執行。另外，您可找到關於核心 API 和 32 位元應用程式如何在 64 位元核心下執行的相關資訊。
 </para>
 <para>
  適用於 64 位元平台 POWER、z Systems 和 AMD64/Intel 64 的 <phrase os="sles"><phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase></phrase> 可讓現有的 32 位元應用程式<quote>無需額外設定</quote> <phrase os="sles">即可在 64 位元環境中執行。對應的 32 位元平台為︰用於 POWER 的 ppc 和用於 AMD64/Intel 64 的 x86。</phrase>。這項支援意謂您可以繼續使用偏好的 32 位元應用程式，無需等到對應的 64 位元連接埠上市。<phrase os="sles">目前的 POWER 系統以 32 位元模式執行大部分應用程式，不過您可以執行 64 位元應用程式。</phrase>
 </para>
 <sect1 xml:id="sec.64bit.runt">
  <title>執行期間支援</title><indexterm>

  <primary> 64 位元 Linux</primary>

  <secondary>執行期間支援</secondary></indexterm> 

  <important>
   <title>不同應用程式版本之間的衝突</title>
   <para>
    如果應用程式有 32 位元和 64 位元兩種版本，同時安裝二種版本，一定會發生問題。在這種狀況下，可在兩種版本中選定一種來安裝並使用。
   </para>
   <para>
    此規則的一個例外是 PAM (可插入驗證模組)。<phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 在驗證程序中使用 PAM 做為使用者與應用程式之間的溝通層。在另外還可執行 32 位元應用程式的 64 位元作業系統上，一律要安裝兩個版本的 PAM 模組。
   </para>
  </important>

  <para>
   要正確執行，每一個應用程式都需要一些程式庫。不幸的是，這些程式庫的 32 位元和 64 位元版本，名稱都一樣。它們必須透過其他方法來區分彼此。
  </para>

  <para>
   要保留與 32 位元版本的相容性，程式庫儲存在系統中的位置，與在 32 位元環境中的位置相同。在 32 位元和 64 位元環境中，<filename>libc.so.6</filename> 的 32 位元版本都位於 <filename>/lib/libc.so.6</filename>。
  </para>

  <para>
   所有 64 位元程式庫和物件檔案都位於名為 <filename>lib64</filename> 的目錄。以往儲存在 <filename>/lib</filename> 和 <filename>/usr/lib</filename> 下的 64 位元物件檔案，現在放在 <filename>/lib64</filename> 和 <filename>/usr/lib64</filename> 目錄下。這表示在 <filename>/lib</filename> 和 <filename>/usr/lib</filename> 之下，有預留空間給 32 位元程式庫使用，因而兩種版本的檔案名稱能夠保持不變。
  </para>

  <para>
   32 位元 <filename>/lib</filename> 目錄的子目錄，如果包含不取決於字數的資料內容，則不會移動。此配置與 LSB (Linux Standards Base) 以及 FHS (File System Hierarchy Standard) 相容。
  </para>
 </sect1>
 <sect1 xml:id="sec.64bit.devel">
  <title>軟體開發</title><indexterm>

  <primary> 64 位元 Linux</primary>

  <secondary>軟體開發</secondary></indexterm> 

  <para os="sles;osuse">
   所有 64 位元架構都支援 64 位元物件的開發。對 32 位元編譯的支援層級需視結構而定。GCC (GNU 編譯器集合) 和 Binutils (包括組合器 <command>as</command> 以及連結器 <command>ld</command>) 中的工具鏈有多種實作選項︰
  </para>

  <para>
   Biarch 開發工具鏈可以產生 32 位元和 64 位元二種物件。這種工具鏈對於 32 位元和 64 位元物件的產生都提供支援。幾乎所有平台都預設支援 64 位元物件的編譯。如果使用特殊旗標，就可以產生 32 位元物件。此特殊旗標是適用於 GCC 的 <option>-m32</option>。Binutil 的旗標視結構而定，但是 GCC 會將正確的旗標傳送至連結器和組合器。Biarch 開發工具鏈目前可用於 amd64 (支援 x86 和 amd64 指令的開發)、z Systems 和 POWER。32 位元物件一般是建立在 POWER 平台上。要產生 64 位元物件，必須使用 <literal>-m64</literal> 旗標。
  </para>

  

  <para>
   所有標頭檔案必須使用與結構無關的形式來編寫。安裝的 32 位元和 64 位元程式庫，必須有一個與已安裝標頭檔案相符的 API (應用程式設計介面)。標準 <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 環境根據此原則而設計。對於手動更新的程式庫，請自行解決這些問題。
  </para>
 </sect1>
 <sect1 xml:id="sec.64bit.biarch">
  <title>Biarch 平台的軟體編譯</title>

  <para>
   若要在 biarch 結構上，為其他結構開發二進位程式，必須為第二個結構額外安裝相關程式庫。如果第二個架構是 32 位元架構，這些套件稱為 <systemitem class="resource">rpmname- 32bit</systemitem><phrase os="sles"> 或 <systemitem class="resource">rpmname-x86</systemitem>；如果第二個架構是 64 位元架構，則套件稱為 <systemitem class="resource">rpmname-64bit</systemitem></phrase>。您還需要 <systemitem class="resource">rpmname-devel</systemitem> 套件的各個標頭和程式庫，以及 <systemitem class="resource">rpmname-devel-32bit</systemitem><phrase os="sles"> 或 <systemitem class="resource">rpmname-devel-64bit</systemitem></phrase> 第二個結構的開發程式庫。
  </para>

  <para os="sles;osuse">
   例如，若要在第二個架構為 32 位元架構的系統 (x86_64 <command>或 z Systems</command>) 上編譯使用 <phrase os="sles">libaio</phrase> 的程式，您需要以下 RPM︰
  </para>

  <variablelist os="sles;osuse">
   <varlistentry>
    <term>libaio-32bit</term>
    <listitem>
     <para>
      32 位元執行期間套件
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>libaio-devel-32bit</term>
    <listitem>
     <para>
      32 位元開發的標題和程式庫
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>libaio</term>
    <listitem>
     <para>
      64 位元執行期間套件
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>libaio-devel</term>
    <listitem>
     <para>
      64 位元開發標題和程式庫
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   大部份開放原始碼程式使用的程式組態是以 <command>autoconf</command> 為基礎。若要使用 <command>autoconf</command> 為第二個結構設定程式，請覆寫 <command>autoconf</command> 的一般編譯器和連結器設定，方法是執行包含其他環境變數的 <command>configure</command> 程序檔。
  </para>

  <para>
   以下範例表示的是第二個架構為 x86 的 x86_64 系統︰<phrase os="sles">對於以 ppc 為第二個架構的 POWER，其範例都與此類似。</phrase>
  </para>

  <procedure>
   <step>
    <para>
     使用 32 位元編譯器︰
    </para>
<screen>CC="gcc -m32"</screen>
   </step>
   <step>
    <para>
     指示連結器處理 32 位元物件 (務必使用 <command>gcc</command> 做為連結器前端)︰
    </para>
<screen>LD="gcc -m32"</screen>
   </step>
   <step>
    <para>
     設定組合器來產生 32 位元物件︰
    </para>
<screen>AS="gcc -c -m32"</screen>
   </step>
   <step>
    <para>
     指定連結器旗標，例如 32 位元程式庫的位置︰
    </para>
<screen>LDFLAGS="-L/usr/lib"</screen>
   </step>
   <step>
    <para>
     指定 32 位元目標代碼程式庫的位置︰
    </para>
<screen>--libdir=/usr/lib</screen>
   </step>
   <step>
    <para>
     指定 32 位元 X 程式庫的位置︰
    </para>
<screen>--x-libraries=/usr/lib</screen>
   </step>
  </procedure>

  <para>
   並非每一個程式都需要所有這些變數。將它們配合各程式使用。
  </para>

  <para>
   以下是在 x86_64<phrase os="sles">、POWER 或 z Systems</phrase> 上呼叫 <command>configure</command> 以編譯原生 32 位元應用程式的範例︰
  </para>

<screen>CC="gcc -m32"
LDFLAGS="-L/usr/lib;"
./configure --prefix=/usr --libdir=/usr/lib --x-libraries=/usr/lib
make
make install</screen>
 </sect1>
 <sect1 xml:id="sec.64bit.kernel">
  <title>核心規格</title><indexterm>

  <primary> 64 位元 Linux</primary>

  <secondary>核心規格</secondary></indexterm> 

  <para>
   AMD 64/Intel 64<phrase os="sles">、POWER 和 z Systems</phrase> 適用的 64 位元核心提供 64 位元和 32 位元兩種核心 ABI (應用程式二進位介面)。後者與相對應 32 位元核心的 ABI 是相同的。這表示 32 位元應用程式可以用與 32 位元核心溝通相同的方式，來與 64 位元核心溝通。
  </para>

  <para>
   32 位元系統模擬的 64 位元核心呼叫，不支援系統程式使用的所有 API。這要視平台而定。因此，有少數應用程式 (例如 <command>lspci</command>) 必須<phrase os="sles">在非 POWER 平台上以 64 位元程式的形式編譯，才能正常運作。在 IBM z Systems 上，並非所有 ioctl 都在 32 位核心 ABI 中可用</phrase>。
  </para>

  <para>
   64 位元核心只可以載入為此核心特別編譯的 64 位元核心模組。它無法使用 32 位元核心模組。
  </para>

  <tip>
   <title>核心可載入模組</title>
   <para>
    部份應用程式需要個別的核心可載入式模組。如果您想在 64 位元系統環境使用這種 32 位元應用程式，請洽詢此應用程式的提供者以及 SUSE，確定是否可以取得此模組的核心可載入式模組的 64 位元版本以及核心 API 的 32 位元編譯版本。
   </para>
  </tip>
 </sect1>
</chapter>
