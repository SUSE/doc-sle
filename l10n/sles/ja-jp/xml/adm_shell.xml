<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="adm_shell.xml" version="5.0" xml:id="cha-adm-shell">

 <title>BashとBashスクリプト</title>
 <info>
  <abstract>
   <para>
    今日、多数のユーザが、GNOMEなどのGUI(グラフィカルユーザインターフェース)を介してコンピュータを使用しています。GUIは多くの機能を提供していますが、自動タスクを実行する際には用途は限定されています。シェルはGUIを適切に補完するものです。この章では、シェル(ここではBashシェル)のいくつかの側面について概要を説明します。
   </para>
  </abstract>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>

 <sect1 xml:id="sec-adm-whatistheshell">
  <title><quote>シェル</quote>とは何か?</title>



  <para>
   従来、<emphasis></emphasis>Linuxシェルとは、Bash(Bourne again Shell)のことでした。この章では、Bashを<quote>シェル</quote>と呼びます。シェルはBashの他にもあり(ash、csh、ksh、zshなど)、異なる機能と特性を持っています。他のシェルの詳細については、YaSTで<emphasis></emphasis>「シェル」を検索してください。
  </para>

  <sect2 xml:id="sec-adm-configfiles">
   <title>Bashの環境設定ファイル</title>
   <para>
    シェルは、次のようにして呼び出すことができます。
   </para>
   <orderedlist spacing="normal">
    <listitem>
     <formalpara>
      <title>対話型ログインシェル</title>
      <para>
       コンピュータへのログイン時に、<option>--login</option>オプションを使用してBashを呼び出す場合か、SSHを使用してリモートコンピュータへログインする場合に使用します。
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title><quote>通常の</quote>対話型シェル</title>
      <para>
       xtermやkonsole、gnome-terminalなどのコマンドラインインタフェース(CLI)ツールの起動時には、通常、この形式を使用します。
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>非対話型シェル</title>
      <para>
       コマンドラインからシェルスクリプトを呼び出す場合に呼び出されます。
      </para>
     </formalpara>
    </listitem>
   </orderedlist>
   <para>
    使用するシェルのタイプによって、異なる設定ファイルを読み込みます。次のテーブルには、それぞれ、ログインシェル設定ファイルと非ログインシェル設定ファイルが示されています。
   </para>
   <table xml:id="tab-adm-shell-config-loginshells">
    <title>ログインシェル用Bash設定ファイル</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>
        <para>
         ファイル
        </para>
       </entry>
       <entry>
        <para>
         説明
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         <filename>/etc/profile</filename>
        </para>
       </entry>
       <entry>
        <para>
         このファイルは変更しないでください。変更しても、次の更新で変更内容が破棄される可能性があります。
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>/etc/profile.local</filename>
        </para>
       </entry>
       <entry>
        <para>
         <filename>/etc/profile</filename>を拡張する場合は、このファイルを使用します。
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>/etc/profile.d/</filename>
        </para>
       </entry>
       <entry>
        <para>
         特定プログラムのシステム全体にわたる設定ファイルを含みます。
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>~/.profile</filename>
        </para>
       </entry>
       <entry>
        <para>
         ログインシェル用のユーザ固有の設定をここに挿入します。
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    ログインシェルは、<xref linkend="tab-adm-shell-configs-nonloginshells"/>に示す設定ファイルも参照することに注意してください。
   </para>
   <table xml:id="tab-adm-shell-configs-nonloginshells">
    <title>非ログインシェル用Bash設定ファイル</title>
    <tgroup cols="2">
     <tbody>
      <row>
       <entry>
        <para>
         <filename>/etc/bash.bashrc</filename>
        </para>
       </entry>
       <entry>
        <para>
         このファイルは変更しないでください。変更しても、次の更新で変更内容が破棄される可能性があります。
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>/etc/bash.bashrc.local</filename>
        </para>
       </entry>
       <entry>
        <para>
         Bashのシステム全体にわたる変更を挿入する場合のみ、このファイルを使用します。
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>~/.bashrc</filename>
        </para>
       </entry>
       <entry>
        <para>
         ユーザ固有の設定をここに挿入します。
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    さらに、Bashでは、次のファイルも使用します。
   </para>
   <table>
    <title>Bash用特殊ファイル</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>
        <para>
         ファイル
        </para>
       </entry>
       <entry>
        <para>
         説明
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         <filename>~/.bash_history</filename>
        </para>
       </entry>
       <entry>
        <para>
         入力したすべてのコマンドのリストを含みます。
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         <filename>~/.bash_logout</filename>
        </para>
       </entry>
       <entry>
        <para>
         ログアウト時に実行されます。
        </para>
       </entry>
       </row>
       <row>
       <entry>
        <para>
         <filename>~/.alias</filename>
        </para>
       </entry>
       <entry>
        <para>
         よく使用されるコマンドのユーザ定義エイリアス。エイリアスの定義の詳細については、<command>man 1 alias</command>を参照してください。
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <bridgehead>非ログインシェル</bridgehead>
   <para>
    ユーザがシステムにログインするのをブロックする特殊なシェル(<systemitem>/bin/false</systemitem>と<systemitem>/sbin/nologin</systemitem>)があります。ユーザがシステムにログインしようとすると、両方ともサイレントに失敗します。これはシステムユーザのセキュリティ対策として意図されたものですが、最新のLinuxオペレーティングシステムには、PAMやAppArmorなど、システムアクセスを制御するためのより効果的なツールがあります。
   </para>
   <para>
    <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase>のデフォルトでは、人間のユーザに<systemitem>/bin/bash</systemitem>を、システムユーザに<systemitem>/bin/false</systemitem>または<systemitem>/sbin/nologin</systemitem>を割り当てます。歴史的な理由のため、<systemitem class="username">nobody</systemitem>ユーザは<systemitem>/bin/bash</systemitem>を使用します。これは、システムユーザのデフォルトとして使用されていた最小限の特権を持つユーザであるためです。ただし、<systemitem class="username">nobody</systemitem>を使用することにより得られたわずかなセキュリティも、複数のシステムユーザが使用すると失われます。これを<systemitem>/sbin/nologin</systemitem>に変更できるはずです。それをテストする最も早い方法は、変更を行い、サービスやアプリケーションを中断させていないかどうかを確認することです。
   </para>
   <para>
    次のコマンドを使用して、<filename>/etc/passwd</filename>で、すべてのユーザ、システム、および人間のユーザに割り当てられているシェルを一覧にします。出力は、システムのサービスおよびユーザによって異なります。
   </para>
<screen><prompt>&gt; </prompt>sort -t: -k 7 /etc/passwd | awk -F: '{print $1"\t" $7}' | column -t
tux               /bin/bash
nobody            /bin/bash
root              /bin/bash
avahi             /bin/false
chrony            /bin/false
dhcpd             /bin/false
dnsmasq           /bin/false
ftpsecure         /bin/false
lightdm           /bin/false
mysql             /bin/false
postfix           /bin/false
rtkit             /bin/false
sshd              /bin/false
tftp              /bin/false
unbound           /bin/false
bin               /sbin/nologin
daemon            /sbin/nologin
ftp               /sbin/nologin
lp                /sbin/nologin
mail              /sbin/nologin
man               /sbin/nologin
nscd              /sbin/nologin
polkitd           /sbin/nologin
pulse             /sbin/nologin
qemu              /sbin/nologin
radvd             /sbin/nologin
rpc               /sbin/nologin
statd             /sbin/nologin
svn               /sbin/nologin
systemd-coredump  /sbin/nologin
systemd-network   /sbin/nologin
systemd-timesync  /sbin/nologin
usbmux            /sbin/nologin
vnc               /sbin/nologin
wwwrun            /sbin/nologin
messagebus        /usr/bin/false
scard             /usr/sbin/nologin</screen>
  </sect2>

  <xi:include href="fs_structure_i.xml"/>
 </sect1>
 <sect1 xml:id="sec-adm-shellscripts">
  <title>シェルスクリプトの作成</title>

  <para>
   シェルスクリプトは、データの収集、テキスト内のワードやフレーズの検索など、さまざまな有用なタスクの実行に便利な方法です。次の例では、小型のシェルスクリプトでテキストをプリントします。
  </para>

  <example>
   <title>テキストをプリントするシェルスクリプト</title>
<screen>#!/bin/sh <co xml:id="co-adm-shell-shebang"/>
# Output the following line: <co xml:id="co-adm-shell-comment"/>
echo "Hello World" <co xml:id="co-adm-shell-echo"/></screen>
   <calloutlist>
    <callout arearefs="co-adm-shell-shebang">
     <para>
      1行目は、このファイルがスクリプトであることを示す<emphasis>Shebang</emphasis>文字(<literal>#! </literal>)で始まります。<emphasis>Shebang</emphasis>の後に指定されたインタープリタによってスクリプトが実行されます。この場合、指定されたインタープリタは<command>/bin/sh</command>です。
     </para>
    </callout>
    <callout arearefs="co-adm-shell-comment">
     <para>
      2行目は、ハッシュ記号で始まるコメントです。意図を理解しにくい行にはコメントすることをお勧めします。適切にコメントすると、行の目的および機能を覚えることができます。また、他の読み手もスクリプトを理解できるかもしれません。コメントは開発コミュニティにおいてグッドプラクティスとみなされます。
     </para>
    </callout>
    <callout arearefs="co-adm-shell-echo">
     <para>
      3番目の行で、組み込みコマンド<command>echo</command>を使用して、対応するテキストを出力します。
     </para>
    </callout>
   </calloutlist>
  </example>

  <para>
   このスクリプトを実行するには、その前にいくつかの前提条件があります。
  </para>

  <orderedlist spacing="normal">
   <listitem>
    <para>
     すべてのスクリプトには(上記の例のように) Shebang行が含まれている必要があります。この行がない場合は、インタプリタを手動で呼び出す必要があります。
    </para>
   </listitem>
   <listitem>
    <para>
     スクリプトの保存場所はどこでも構いません。ただし、シェルの検索先ディレクトリを保存場所にすることをお勧めします。シェルのサーチパスは、環境変数<envar>PATH</envar>で設定されます。一般に、標準ユーザには<filename>/usr/bin</filename>への書き込みアクセスはありません。このため、スクリプトはユーザのディレクトリ<filename>~/bin/</filename>に保存することを推奨します。上記の例では、名前は<filename>hello.sh</filename>です。
    </para>
   </listitem>
   <listitem>
    <para>
     スクリプトには、実行可能パーミッションが必要です。次のコマンドで、パーミッションを設定してください。
    </para>
<screen><prompt>&gt; </prompt>chmod +x ~/bin/hello.sh</screen>
   </listitem>
  </orderedlist>

  <para>
   これらの前提条件をすべて満たしたら、次の方法でスクリプトを実行できます。
  </para>

  <orderedlist spacing="normal">
   <listitem>
    <formalpara>
     <title>絶対パス</title>
     <para>
      スクリプトは絶対パスで実行できます。この例では、<command>~/bin/hello.sh</command>です。
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>任意の場所</title>
     <para>
      <envar>PATH</envar>環境変数にスクリプトが存在するディレクトリが含まれている場合、スクリプトを<command>hello.sh</command>で実行できます。
     </para>
    </formalpara>
   </listitem>
  </orderedlist>
 </sect1>
 <sect1 xml:id="sec-adm-shell-redirect">
  <title>コマンドイベントのリダイレクト</title>

  <para>
   各コマンドは、入力または出力用として、3つのチャネルを使用できます。:
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <formalpara>
     <title>標準出力</title>
     <para>
      デフォルトの出力チャネル。コマンドで何かをプリントする際には標準出力チャネルが使用されます。
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>標準入力</title>
     <para>
      コマンドでユーザまたは他のコマンドからの入力を必要とする場合は、このチャネルが使用されます。
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>標準エラー</title>
     <para>
      このチャネルは、エラーレポーティングに使用されます。
     </para>
    </formalpara>
   </listitem>
  </itemizedlist>

  <para>
   これらのチャネルをリダイレクトするには、次の方法を使用できます。
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>Command &gt; File</literal>
    </term>
    <listitem>
     <para>
      コマンド出力をファイルに保存します。既存ファイルは削除されます。たとえば、<command>ls</command>コマンドの出力を<filename>listing.txt</filename>ファイルに書き込みます。
     </para>
<screen><prompt>&gt; </prompt>ls &gt; listing.txt</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>Command &gt;&gt; File</literal>
    </term>
    <listitem>
     <para>
      コマンド出力をファイルに追加します。たとえば、<command>ls</command>コマンドの出力を<filename>listing.txt</filename>ファイルに追加します。
     </para>
<screen><prompt>&gt; </prompt>ls &gt;&gt; listing.txt</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>Command &lt; File</literal>
    </term>
    <listitem>
     <para>
      ファイルを読み込み、指定されたコマンドへの入力とします。たとえば、ファイルのコンテンツを<command>read</command>コマンドで読み込み、変数に入力します。
     </para>
<screen><prompt>&gt; </prompt>read a &lt; foo</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>Command1 | Command2</literal>
    </term>
    <listitem>
     <para>
      左側のコマンドの出力を右側のコマンドの入力にします。たとえば、<command>cat</command>コマンドは<filename>/proc/cpuinfo</filename>ファイルの内容を出力します。この出力を<command>grep</command>で使用して、<literal>cpu</literal>を含む行のみをフィルタします。
     </para>
<screen><prompt>&gt; </prompt>cat /proc/cpuinfo | grep cpu</screen>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   各チャネルには、対応する<emphasis>ファイル記述子</emphasis>があります。標準入力には0(ゼロ)、標準出力には1、標準エラーには2が割り当てられています。このファイル記述子を<literal>&lt;</literal>文字または<literal>&gt;</literal>文字の前に挿入できます。たとえば、次の行では、<filename>foo</filename>で始まるファイルを検索しますが、そのファイルを<filename>/dev/null</filename>にリダイレクトすることでエラーメッセージを抑制します。
  </para>

<screen><prompt>&gt; </prompt>find / -name "foo*" 2&gt;/dev/null</screen>
 </sect1>
 <sect1 xml:id="sec-adm-alias">
  <title>エイリアスの使用</title>

  <para>
   エイリアスは、1つ以上のコマンドのショートカット定義です。エイリアスの構文は、次のとおりです。
  </para>

<screen>alias <replaceable>NAME</replaceable>=<replaceable>DEFINITION</replaceable></screen>

  <para>
   たとえば、次の行は、エイリアス<command>lt</command>を定義しています。このエイリアスは、長いリストを出力し(<option>-l</option>オプション)、そのリストを変更時刻でソートし(<option>-t</option>オプション)、ソート順と逆の順序でプリントします(<option>-r</option>オプション)。
  </para>

<screen><prompt>&gt; </prompt>alias lt='ls -ltr'</screen>

  <para>
   すべてのエイリアス定義を表示するには、<command>alias</command>を使用します。<command>unalias</command>で対応するエイリアス名を指定して、エイリアスを削除します。
  </para>
 </sect1>
 <sect1 xml:id="sec-adm-variables">
  <title>Bashでの変数の使用</title>

  <para>
   シェル変数は、グローバル変数またはローカル変数として使用できます。グローバル変数(つまり、環境変数)は、すべてのシェルでアクセスできます。対照的に、ローカル変数は、現在のシェルでのみアクセスできます。
  </para>

  <para>
   すべての環境変数を表示するには、<command>printenv</command>コマンドを使用します。変数の値を知る必要がある場合は、変数の名前を引数として挿入します。
  </para>

<screen><prompt>&gt; </prompt>printenv PATH</screen>

  <para>
   変数はグローバルでもローカルでも、<command>echo</command>で表示できます。
  </para>

<screen><prompt>&gt; </prompt>echo $PATH</screen>

  <para>
   ローカル変数を設定するには、変数名の後に等号を入れ、その後に値を指定します。
  </para>

<screen><prompt>&gt; </prompt>PROJECT="SLED"</screen>

  <para>
   等号の前後にスペースを挿入しないでください。スペースを挿入すると、エラーになります。環境変数を設定するには、<command>export</command>を使用します。
  </para>

<screen><prompt>&gt; </prompt>export NAME="tux"</screen>

  <para>
   変数を削除するには、<command>unset</command>を使用します。
  </para>

<screen><prompt>&gt; </prompt>unset NAME</screen>

  <para>
   次のテーブルに、シェルスクリプトで使用できる共通環境変数を示します。
  </para>

  <table xml:id="tab-adm-envars">
   <title>便利な環境変数</title>
   <tgroup cols="2">
    <tbody>
     <row>
      <entry>
       <para>
        <envar>HOME</envar>
       </para>
      </entry>
      <entry>
       <para>
        現在のユーザのホームディレクトリ
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>HOST</envar>
       </para>
      </entry>
      <entry>
       <para>
        現在のホスト名
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>LANG</envar>
       </para>
      </entry>
      <entry>
       <para>
        ツールをローカライズする場合、ツールは、この環境変数からの言語を使用します。英語を<literal>C</literal>に設定することも可能です。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>PATH</envar>
       </para>
      </entry>
      <entry>
       <para>
        シェルのサーチパス。コロンで区切ったディレクトリのリスト
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>PS1</envar>
       </para>
      </entry>
      <entry>
       <para>
        各コマンドの前にプリントされる通常のプロンプトを指定します。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>PS2</envar>
       </para>
      </entry>
      <entry>
       <para>
        複数行コマンドの実行時にプリントされるセカンダリプロンプトを指定します。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>PWD</envar>
       </para>
      </entry>
      <entry>
       <para>
        現在の作業ディレクトリ
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <envar>ユーザ</envar>
       </para>
      </entry>
      <entry>
       <para>
        現在のユーザ
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <sect2 xml:id="sec-adm-variables-argument">
   <title>引数変数の使用</title>

   <para>
    たとえば、スクリプト<command>foo.sh</command>は、次のように実行できます。
   </para>
<screen><prompt>&gt; </prompt>foo.sh "Tux Penguin" 2000 </screen>
   <para>
    スクリプトに渡される引数すべてにアクセスするには、位置パラメータが必要です。これらのパラメータは、最初の引数には<envar>$1</envar>、2つ目の引数には<envar>$2</envar>という順序で割り当てます。パラメータは最大9つまで使用できます。スクリプト名を取得するには、<envar>$0</envar>を使用します。
   </para>
   <para>
    次のスクリプト<command>foo.sh</command>は、1から4までのすべての引数をプリントします。
   </para>
<screen>#!/bin/sh
echo \"$1\" \"$2\" \"$3\" \"$4\"</screen>
   <para>
    このスクリプトを既出例の引数を使用して実行すると、次の結果が出力されます。
   </para>
<screen>"Tux Penguin" "2000" "" ""</screen>

  </sect2>

  <sect2 xml:id="sec-adm-shell-varsubst">
   <title>変数置換の使用</title>
   <para>
    変数置換では、変数のコンテンツに、左側または右側からパターンを適用します。次のリストに、可能な構文形式を示します。
   </para>
   <variablelist>
    <varlistentry>
     <term><literal>${VAR#pattern}</literal>
     </term>
     <listitem>
      <para>
       左側から最も短い一致を削除します。
      </para>
<screen><prompt>&gt; </prompt>file=/home/tux/book/book.tar.bz2
<prompt>&gt; </prompt>echo ${file#*/}
home/tux/book/book.tar.bz2</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>${VAR##pattern}</literal>
     </term>
     <listitem>
      <para>
       左側から最も長い一致を削除します。
      </para>
<screen><prompt>&gt; </prompt>file=/home/tux/book/book.tar.bz2
<prompt>&gt; </prompt>echo ${file##*/}
book.tar.bz2</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>${VAR%pattern}</literal>
     </term>
     <listitem>
      <para>
       右側から最も短い一致を削除します。
      </para>
<screen><prompt>&gt; </prompt>file=/home/tux/book/book.tar.bz2
<prompt>&gt; </prompt>echo ${file%.*}
/home/tux/book/book.tar</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>${VAR%%pattern}</literal>
     </term>
     <listitem>
      <para>
       右側から最も長い一致を削除します。
      </para>
<screen><prompt>&gt; </prompt>file=/home/tux/book/book.tar.bz2
<prompt>&gt; </prompt>echo ${file%%.*}
/home/tux/book/book</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>${VAR/pattern_1/pattern_2}</literal>
     </term>
     <listitem>
      <para>
       <replaceable>VAR</replaceable>のコンテンツを<replaceable>PATTERN_1</replaceable>から<replaceable>PATTERN_2</replaceable>に置換します。
      </para>
<screen><prompt>&gt; </prompt>file=/home/tux/book/book.tar.bz2
<prompt>&gt; </prompt>echo ${file/tux/wilber}
/home/wilber/book/book.tar.bz2</screen>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>
 </sect1>
 <sect1 xml:id="sec-adm-shell-grouping">
  <title>コマンドのグループ化と結合</title>

  <para>
   シェルでは、条件付き実行のため、コマンドを結合し、グループ化することができます。各コマンドが返す終了コードにより、コマンドの成功または失敗が判別されます。終了コードが0(ゼロ)の場合、コマンドは成功しました。それ以外はすべて、コマンド固有のエラーをマークします。
  </para>

  <para>
   次に、コマンドをグループ化する方法を示します。
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>Command1 ; Command2</literal>
    </term>
    <listitem>
     <para>
      コマンドをシーケンシャルに実行します。終了コードはチェックされません。次の行では、各コマンドの終了コードにかかわらず、<command>cat</command>でファイルのコンテンツを表示し、次に、<command>ls</command>でファイルプロパティをプリントします。
     </para>
<screen><prompt>&gt; </prompt>cat filelist.txt ; ls -l filelist.txt</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>Command1 &amp;&amp; Command2</literal>
    </term>
    <listitem>
     <para>
      左のコマンドが成功した場合、右のコマンドを実行します(論理AND)。次の行では、ファイルのコンテンツを表示し、そのコマンドが成功した場合のみ、ファイルのプロパティをプリントします(このリストの前の項目と比較してください)。
     </para>
<screen><prompt>&gt; </prompt>cat filelist.txt &amp;&amp; ls -l filelist.txt</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>Command1 || Command2</literal>
    </term>
    <listitem>
     <para>
      左のコマンドが失敗した場合、右のコマンドを実行します(論理OR)次の行では、<filename>/home/tux/foo</filename>でのディレクトリ作成に失敗した場合のみ、<filename>/home/wilber/bar</filename>内にディレクトリを作成します。
     </para>
<screen><prompt>&gt; </prompt>mkdir /home/tux/foo || mkdir /home/wilber/bar</screen>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>funcname(){ ... }</literal>
    </term>
    <listitem>
     <para>
      シェル関数を作成します。位置パラメータを使用して、関数の引数にアクセスできます。次の行では、短いメッセージをプリントする関数<literal>hello</literal>を定義します。
     </para>
<screen><prompt>&gt; </prompt>hello() { echo "Hello $1"; }</screen>
     <para>
      この関数は、次のように呼び出せます。
     </para>
<screen><prompt>&gt; </prompt>hello Tux</screen>
     <para>
      結果は、次のようにプリントされます。
     </para>
<screen>Hello Tux</screen>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 xml:id="sec-adm-shell-commonconstructs">
  <title>よく使用されるフローコンストラクトの操作</title>

  <para>
   スクリプトのフローを制御するため、シェルでは、<command>while</command>、<command>if</command>、<command>for</command>、および<command>case</command>の各構文を使用します。
  </para>



  <sect2 xml:id="sec-adm-shell-if">
   <title>if制御コマンド</title>
   <para>
    <command>if</command>コマンドは、式のチェックに使用されます。たとえば、次のコードは、現在のユーザがTuxであるかどうかをテストします。
   </para>
<screen>if test $USER = "tux"; then
  echo "Hello Tux."
else
  echo "You are not Tux."
fi</screen>
   <para>
    テスト式は、複雑にすることも、シンプルにすることも可能です。次の式は、ファイル<filename>foo.txt</filename>が存在するかどうかをチェックします。
   </para>
<screen>if test -e /tmp/foo.txt ; then
  echo "Found foo.txt"
fi</screen>
   <para>
    test式は、角括弧で短縮することもできます。
   </para>
<screen>if [ -e /tmp/foo.txt ] ; then
  echo "Found foo.txt"
fi</screen>
   <para>
    その他の役に立つ式については、<link xlink:href="https://bash.cyberciti.biz/guide/If..else..fi"/>を参照してください。
   </para>
  </sect2>

  <sect2 xml:id="sec-adm-shell-for">
   <title><command>for</command>コマンドによるループの作成</title>
   <para>
    <command>for</command>ループを使用すると、エントリのリストにコマンドを実行できます。たとえば、次のコードは、現在のディレクトリ内のPNGファイルの情報をプリントします。
   </para>
<screen>for i in *.png; do
 ls -l $i
done</screen>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-adm-shell-moreinfo">
  <title>詳細情報</title>

  <para>
   Bashに関する重要な情報は、マニュアルページ<command>man bash</command>に記載されています。このトピックの詳細については、次のリストを参照してください。
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     <link xlink:href="http://tldp.org/LDP/Bash-Beginners-Guide/html/index.html"/>—Bash Guide for Beginners
    </para>
   </listitem>
   <listitem>
    <para>
     <link xlink:href="http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html"/>—BASH Programming - Introduction HOW-TO
    </para>
   </listitem>
   <listitem>
    <para>
     <link xlink:href="http://tldp.org/LDP/abs/html/index.html"/>—Advanced Bash-Scripting Guide
    </para>
   </listitem>
   <listitem>
    <para>
     <link xlink:href="http://www.grymoire.com/Unix/Sh.html"/>—Sh - the Bourne Shell
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
</chapter>
