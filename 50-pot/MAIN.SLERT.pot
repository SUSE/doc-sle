msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2018-08-18 23:17+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Put one translator per line, in the form NAME <EMAIL>, YEAR1, YEAR2
msgctxt "_"
msgid "translator-credits"
msgstr ""

#. (itstool) path: article/title
#: xml/MAIN.SLERT.xml:17
msgid "Quick Start"
msgstr ""

#. (itstool) path: article/subtitle
#: xml/MAIN.SLERT.xml:18
msgid "<phrase role=\"productname\"><phrase os=\"osuse\">openSUSE Leap</phrase><phrase os=\"sles\">SUSE Linux Enterprise Server</phrase><phrase os=\"sled\">SUSE Linux Enterprise Desktop</phrase><phrase os=\"slerte\">SUSE Linux Enterprise Real Time Extension</phrase></phrase> <phrase role=\"productnumber\"><phrase os=\"osuse\">42.3</phrase><phrase os=\"sles;sled;slerte\">12 SP3</phrase></phrase>"
msgstr ""

#. (itstool) path: info/productnumber
#: xml/MAIN.SLERT.xml:20
msgid "<phrase role=\"productnumber\"><phrase os=\"osuse\">42.3</phrase><phrase os=\"sles;sled;slerte\">12 SP3</phrase></phrase>"
msgstr ""

#. (itstool) path: info/productname
#: xml/MAIN.SLERT.xml:21
msgid "<phrase role=\"productname\"><phrase os=\"osuse\">openSUSE Leap</phrase><phrase os=\"sles\">SUSE Linux Enterprise Server</phrase><phrase os=\"sled\">SUSE Linux Enterprise Desktop</phrase><phrase os=\"slerte\">SUSE Linux Enterprise Real Time Extension</phrase></phrase>"
msgstr ""

#. (itstool) path: abstract/para
#: xml/MAIN.SLERT.xml:23
msgid "SUSE Linux Enterprise Real Time Extension is an add-on to SUSEÂ® Linux Enterprise that allows you to run tasks which require deterministic real-time processing, in a SUSE Linux Enterprise environment. SUSE Linux Enterprise Real Time Extension meets this requirement by offering several different options for CPU and I/O scheduling, CPU shielding and setting CPU affinities to processes."
msgstr ""

#. (itstool) path: bugtracker/url
#: xml/MAIN.SLERT.xml:33
msgid "https://bugzilla.suse.com/enter_bug.cgi"
msgstr ""

#. (itstool) path: bugtracker/component
#: xml/MAIN.SLERT.xml:34
msgid "Documentation"
msgstr ""

#. (itstool) path: bugtracker/product
#: xml/MAIN.SLERT.xml:35
msgid "SUSE Linux Enterprise Real Time Extension 11 SP4 (SLERTE 11 SP4)"
msgstr ""

#. (itstool) path: bugtracker/assignee
#: xml/MAIN.SLERT.xml:36
msgid "taroth@suse.com"
msgstr ""

#. (itstool) path: sect1/title
#: xml/MAIN.SLERT.xml:42
msgid "Installing SUSE Linux Enterprise Real Time Extension"
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:44
msgid "To install SUSE Linux Enterprise Real Time Extension 11 SP1, start a regular SUSE Linux Enterprise Server 11 SP1 installation and select SUSE Linux Enterprise Real Time Extension 11 SP1 as an Add-On product during the installation. Alternately, if SUSE Linux Enterprise Server is already installed, you can start the Add-On Product installation from YaST. However, you need to select the -rt kernel flavor as the default using the YaST Boot Loader configurator, as in this alternate case, that is not done automatically."
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:53
msgid "SUSE Linux Enterprise Real Time Extension always needs a SUSE Linux Enterprise Server SP1 base, it cannot be installed in stand-alone mode. Refer to the SUSE Linux Enterprise Server <citetitle>Administration Guide</citetitle> manual, Section <quote>Installing Add-On Products</quote> at <link xlink:href=\"http://www.suse.com/doc/sles11/book_sle_deployment/?page=/documentation/sles11/book_sle_deployment/data/cha_add-ons.html\"/> to learn more about installing add-on products."
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:61
msgid "The following sections provide a brief introduction to the tools and possibilities of SUSE Linux Enterprise Real Time Extension."
msgstr ""

#. (itstool) path: sect1/title
#: xml/MAIN.SLERT.xml:67
msgid "Managing CPU Sets with <command>cset</command>"
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:69
msgid "In some circumstances, it is beneficial to be able to run specific tasks only on defined CPUs. For this reason, the Linux kernel provides a feature called cpuset. The feature cpuset provides the means to do a so called <quote>soft partitioning</quote> of the system. Dedicated CPUs, together with some predefined memory, work on several tasks."
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:77
msgid "The command <command>cset</command> provides the high level functionality to set up and manipulate CPU Sets."
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:82
msgid "<command>cset</command> consists of one super command called <literal>shield</literal> and the regular commands <literal>set</literal> and <literal>proc</literal>. The purpose of the super command <literal>shield</literal> is to create a common CPU shielding setup within one step by combining regular commands. An example for setting up a CPU shield is:"
msgstr ""

#. (itstool) path: sect1/screen
#: xml/MAIN.SLERT.xml:93
#, no-wrap
msgid ""
"cset shield --cpu=3"
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:95
msgid "This will shield CPU3 and keep on a 4-way machine CPU0-CPU2 unshielded. The argument of the <option>--cpu</option> parameter accepts comma separated lists of CPUs including range specifications:"
msgstr ""

#. (itstool) path: sect1/screen
#: xml/MAIN.SLERT.xml:101
#, no-wrap
msgid ""
"cset --cpu=1,3,5-7"
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:103
msgid "On a 8-way machine this command will shield CPU1, CPU3, CPU5, CPU6 and CPU7. CPU0, CPU2 and CPU4 will remain unshielded. Already existing CPU shields could be extended by the same command. For example adding CPU4 to the mentioned CPU set can be done in the following way:"
msgstr ""

#. (itstool) path: sect1/screen
#: xml/MAIN.SLERT.xml:110
#, no-wrap
msgid ""
"cset --cpu=1,3-7"
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:112
msgid "CPU1, CPU3, CPU5 to CPU6 were already shielded and only CPU4 will additionally be shielded. Technically the command is updating the current CPU shield schema. If the number of shielded CPUs should be reduced and CPU1 should be unshielded this is done by calling:"
msgstr ""

#. (itstool) path: sect1/screen
#: xml/MAIN.SLERT.xml:119
#, no-wrap
msgid ""
"cset --cpu=3-7"
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:121
msgid "Now only CPU3, CPU4, CPU5, CPU6 and CPU7 are shielded and CPU0, CPU1 and CPU2 are available for system usage."
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:128
msgid "Once the CPU shielding is set up you can display the current configuration by running <command>cset shield</command> without additional parameters:"
msgstr ""

#. (itstool) path: sect1/screen
#: xml/MAIN.SLERT.xml:136
#, no-wrap
msgid ""
"cset shield\n"
"cset: --&gt; shielding system active with\n"
"cset: \"system\" cpuset of: 0-2 cpu, with: 47\n"
"cset: \"user\" cpuset of:  3-7 cpu,  with: 0\n"
""
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:142
msgid "By default, CPU shielding consists at least of three cpusets:"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:148
msgid "<literal>root</literal> exists always and contains all available CPUs."
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:153
msgid "<literal>system</literal> is the cpuset of unshielded CPUs."
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:158
msgid "<literal>user</literal> is the cpuset of shielded CPUs"
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:166
msgid "Certain processes or groups of processes can be assigned to a shielded cpuset, once the CPU set is created. To start a new process in the shielded CPU set use the <command>--exec</command> parameter:"
msgstr ""

#. (itstool) path: sect1/screen
#: xml/MAIN.SLERT.xml:172
#, no-wrap
msgid ""
"cset --exec &lt;application&gt;"
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:174
msgid "To move already running processes to the shielded CPU set use the <command>--shield</command> parameter which accepts a comma separated list and range specifications of PIDs:"
msgstr ""

#. (itstool) path: sect1/screen
#: xml/MAIN.SLERT.xml:180
#, no-wrap
msgid ""
"cset --shield=1,2,600-700"
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:182
msgid "This moves processes with PID 1, 2 and from 600 to 700 to the shielded CPU set. If there is a gap in the range from 600 to 700, then only those available process will be moved to the shield without warning. <command>cset</command> handles threads like processes and will also interpret TIDs and assign them to the required CPU set."
msgstr ""

#. (itstool) path: warning/para
#: xml/MAIN.SLERT.xml:195
msgid "Note that there is no checking of the processes you request to move into the shield with the <command>--shield</command> command. This means that the tool will happily move any process, even kernel threads, that are bound to specific CPUs with this command. You can cause a complete system lockup by indiscriminately specifying arbitrary PIDs to the <option>--shield</option> command."
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:207
msgid "The number of currently shielded processes are shown with the same command that is used to show the current CPU shield setup. Additionally adding the <command>--verbose</command> parameter lists shielded and unshielded processes:"
msgstr ""

#. (itstool) path: sect1/screen
#: xml/MAIN.SLERT.xml:214
#, no-wrap
msgid ""
"cset shield --verbose\n"
"cset: --&gt; shielding system active with\n"
"cset: \"system\" cpuset of: 0-2,4-15 cpu, with:\n"
"   USER       PID  PPID S TASK NAME\n"
"      -------- ----- ----- - ---------\n"
"         root         1     0 S init [3]\n"
"[...]\n"
"\n"
"cset: \"user\" cpuset of:    3 cpu, with: 1\n"
"   USER       PID  PPID S TASK NAME\n"
"      -------- ----- ----- - ---------\n"
"         root     10202 10170 S application\n"
""
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:230
msgid "To remove a process (or group of processes) from the CPU shield use the <command>--unshield</command> parameter. The argument for the <command>--unshield</command> is similar to the <command>--shield</command> parameter, which accepts a comma separated list of PIDs/TIDs and range specifications:"
msgstr ""

#. (itstool) path: sect1/screen
#: xml/MAIN.SLERT.xml:238
#, no-wrap
msgid ""
"cset --unshield=2,650-655"
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:240
msgid "This will unshield the process with the PID 2 and the processes in range of 650 and 655."
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:247
msgid "Deleting CPU sets is done with the <command>cset</command> parameter <option>--reset</option>. This will unshield all CPUs and migrate dedicated processes to all available CPUs again."
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:255
msgid "For more detailed information about options and parameters of the subcommand <command>shield</command>, consult the help of <command>cset</command> by running:"
msgstr ""

#. (itstool) path: sect1/screen
#: xml/MAIN.SLERT.xml:261
#, no-wrap
msgid ""
"cset help shield"
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:265
msgid "More detailed configuration of cpusets can be done with the <command>cset</command> commands <option>set</option> and <option>proc</option>."
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:273
msgid "The subcommand <option>set</option> is used to create, modify and destroy cpusets. Compared to the supercommand <option>shield</option>, the <option>set</option> subcommand is additionally able to assign memory nodes for NUMA machines."
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:280
msgid "Besides assigning memory nodes, the subcommand <command>set</command> can be used to create cpusets in a tree-like structure, rooted at the <literal>root</literal> cpuset."
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:288
msgid "To create a cpuset with the subcommand <command>set</command> you only need to specify the CPUs which should be used by a comma separated list or a range specification:"
msgstr ""

#. (itstool) path: sect1/screen
#: xml/MAIN.SLERT.xml:294
#, no-wrap
msgid ""
"cset set --cpu=1-7 \"/one\""
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:296
msgid "This command will create a cpuset called <quote>one</quote> with assigned CPUs from CPU1 to CPU7. To specify a new cpuset called <quote>two</quote> and that is a subset of <quote>one</quote>, proceed as follows:"
msgstr ""

#. (itstool) path: sect1/screen
#: xml/MAIN.SLERT.xml:302
#, no-wrap
msgid ""
"cset set --cpu=6 \"/one/two\""
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:308
msgid "Cpusets follow certain rules. Children can only include CPUs that the parents already have. If you try to specify a different cpuset, the kernel cpuset subsystem will not let you create that cpuset. For example, if you create a cpuset that contains CPU3, and then attempt to create a child of that cpuset with a CPU other than 3, you will get an error, and the cpuset will not be created. The resulting error is somewhat cryptic and is usually <quote>Permission denied</quote>."
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:320
msgid "To list a table containing useful information like cpu list and memory list use the <option>-r</option> parameter. The <quote>-X</quote> column shows the exclusive state of CPU or memory. The <quote>path</quote> column shows the real path in the virtual file system <literal>cpuset</literal>."
msgstr ""

#. (itstool) path: sect1/screen
#: xml/MAIN.SLERT.xml:329
#, no-wrap
msgid ""
"cpuset set -r"
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:333
msgid "On NUMA machines memory nodes can be assigned to a cpuset similar to CPUs. The <command>--mem</command> parameter of the subcommand <command>set</command> allows a comma separated and inclusive range specification of memory nodes. This example will assign MEM1, MEM3, MEM4, MEM5 and MEM6 to the cpuset <quote>new_set</quote>:"
msgstr ""

#. (itstool) path: sect1/screen
#: xml/MAIN.SLERT.xml:341
#, no-wrap
msgid ""
"cset set --mem=1,3-6 new_set"
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:343
msgid "Additionally, with the <option>--cpu_exclusive</option> and <option>--mem_exclusive</option> parameters (without any additional arguments) set the CPUs or memory nodes exclusive to a cpuset:"
msgstr ""

#. (itstool) path: sect1/screen
#: xml/MAIN.SLERT.xml:350
#, no-wrap
msgid ""
"cset set --cpu_exclusive \"/one\""
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:352
msgid "The status of exclusive state of CPU or memory is shown in the \"-X\" column when running:"
msgstr ""

#. (itstool) path: sect1/screen
#: xml/MAIN.SLERT.xml:359
#, no-wrap
msgid ""
"cset set -r "
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:363
msgid "For more detailed information about options and parameters of the subcommand <option>set</option>, consult the help of <command>cset</command> by running:"
msgstr ""

#. (itstool) path: sect1/screen
#: xml/MAIN.SLERT.xml:369
#, no-wrap
msgid ""
"cset help set"
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:373
msgid "Once the cpuset is initialized, the subcommand <option>proc</option> can start processes on certain cpusets with the <option>--exec</option> parameter. The following will start the application <literal>fastapp</literal> within the cpuset <literal>new_set</literal>:"
msgstr ""

#. (itstool) path: sect1/screen
#: xml/MAIN.SLERT.xml:380
#, no-wrap
msgid ""
"cset proc --exec --set new_set fastapp"
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:384
msgid "To move an already running process inside an already existing cpuset use the parameter <command>--move</command>, which accepts a comma separated list and range specifications of PIDs. The following command will move processes with PID 2442 and within range of 3000 to 3200 into the cpuset <literal>new_set</literal>:"
msgstr ""

#. (itstool) path: sect1/screen
#: xml/MAIN.SLERT.xml:392
#, no-wrap
msgid ""
"cset proc --move 2442,3000-3200 new_set"
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:396
msgid "Listing processes running within a specific cpuset can be done by using the parameter <option>--list</option>."
msgstr ""

#. (itstool) path: sect1/screen
#: xml/MAIN.SLERT.xml:401
#, no-wrap
msgid ""
"cset proc --list new_set"
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:405
msgid "The subcommand <option>proc</option> is also able to move the entire list of processes within one cpuset to another cpuset by using the parameters <option>--fromset</option> and <option>--toset</option>. This will move all process assigned to <literal>old_set</literal> and assign them to <literal>new_set</literal>:"
msgstr ""

#. (itstool) path: sect1/screen
#: xml/MAIN.SLERT.xml:413
#, no-wrap
msgid ""
"cset proc --move --fromset old_set \\\n"
"   --toset new_set"
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:418
msgid "For more detailed information about options and parameters of the subcommand <command>proc</command>, consult the help of <command>cset</command> by running:"
msgstr ""

#. (itstool) path: sect1/screen
#: xml/MAIN.SLERT.xml:424
#, no-wrap
msgid ""
"cset help proc"
msgstr ""

#. (itstool) path: sect1/title
#: xml/MAIN.SLERT.xml:428
msgid "Set real-time attributes of a process with <command>chrt</command>"
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:430
msgid "The <command>chrt</command> command allows to manipulate the real-time attributes, like scheduling policy and priority, of an already running process or to execute a new process with specified real-time attributes."
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:436
msgid "It is highly recommend for applications which should experience the full advantages of real-time and do not use real-time specific attributes by their own. To get these full real-time experiences, this application should be called with the <command>chrt</command> command and the right set of scheduler policy and priority parameters."
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:444
msgid "With the following command line all running processes with their real-time specific attributes are shown. <literal>class</literal> shows the current scheduler policy and <literal>rtprio</literal> the real-time priority:"
msgstr ""

#. (itstool) path: sect1/screen
#: xml/MAIN.SLERT.xml:451
#, no-wrap
msgid ""
"ps -eo pid,tid,class,rtprio,comm\n"
"...\n"
" 1437  1437 FF      40  fastapp\n"
""
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:456
msgid "The above truncated example shows the <literal>fastapp</literal> process with PID 1437 running and with scheduler policy <literal>SCHED_FIFO</literal> and priority 40. Scheduler policy abbreviations are:"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:465
msgid "TS - SCHED_OTHER"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:470
msgid "FF - SCHED_FIFO"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:475
msgid "RR - SCHED_RR"
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:481
msgid "It is also possible to get the current scheduler policy and priority of single processes by passing to <command>chrt</command> the PID of the process with the parameter <command>-p</command>:"
msgstr ""

#. (itstool) path: sect1/screen
#: xml/MAIN.SLERT.xml:487
#, no-wrap
msgid ""
"chrt -p 1437"
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:489
msgid "Scheduler policies have different minimum and maximum priority values. Minimum and maximum values for each available scheduler policy can be retrieved with <command>chrt</command>:"
msgstr ""

#. (itstool) path: sect1/screen
#: xml/MAIN.SLERT.xml:495
#, no-wrap
msgid ""
"chrt -m"
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:497
msgid "To change the scheduler policy and the priority of a running process, <command>chrt</command> provides parameter <command>--fifo</command> for <literal>SCHED_FIFO</literal>, <command>--rr</command> for <literal>SCHED_RR</literal> and <command>--other</command> for <literal>SCHED_OTHER</literal>. This example will change the scheduler policy to <literal>SCHED_FIFO</literal> with priority 42 for PID 1437:"
msgstr ""

#. (itstool) path: sect1/screen
#: xml/MAIN.SLERT.xml:506
#, no-wrap
msgid ""
"chrt --fifo -p 42 1437"
msgstr ""

#. (itstool) path: warning/para
#: xml/MAIN.SLERT.xml:509
msgid "Handle changing of real-time attributes of processes with care. Increasing the priority of certain processes can harm the entire system, depending on the behavior of the process. In some cases, this could lead to a complete system lockup or bad influence on certain devices."
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:519
msgid "For more information about chrt, consult the manual page of chrt:"
msgstr ""

#. (itstool) path: sect1/screen
#: xml/MAIN.SLERT.xml:523
#, no-wrap
msgid ""
"man 1 chrt"
msgstr ""

#. (itstool) path: sect1/title
#: xml/MAIN.SLERT.xml:1136
msgid "Specifying a CPU Affinity with <command>taskset</command>"
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:1138
msgid "The default behavior of the kernel, is to keep a process running on the same CPU, if the system load is balanced over the available CPUs. Otherwise, the kernel tries to improve the load balancing by moving processes to an idling CPU. In some situations, however, it is desirable to set a CPU affinity for a given process. In this case, the kernel will not move the process away from the selected CPUs. For example, if you use shielding, the shielded CPUs will not run any process that does not have an affinity to the shielded CPUs. Another possibility is to run all low priority tasks on a selected CPU to remove load from the other CPUs."
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:1150
msgid "Note, that if a task is running inside a specific cpuset, the affinity mask must match at least one of the CPUs available in this set. The <command>taskset</command> command will not move a process outside the cpuset it is running in."
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:1157
msgid "To set or retrieve the CPU affinity of a task, a bitmask is used, that is represented by a hexadecimal number. If you count the bits of this bitmask, the lowest bit represents the first logical CPU as they are found in <filename>/proc/cpuinfo</filename>. For example:"
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1166
msgid "<literal>0x00000001</literal>"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1169
msgid "is processor #0."
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1175
msgid "<literal>0x00000002</literal>"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1178
msgid "is processor #1."
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1184
msgid "<literal>0x00000003</literal>"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1187
msgid "is processor #0 and processor #1."
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1193
msgid "<literal>0xFFFFFFFE</literal>"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1196
msgid "all but the first CPU."
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:1203
msgid "If a given mask does not contain any valid CPU on the system, an error is returned. If taskset returns without an error, the given program has been scheduled to the specified list of CPUs."
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:1209
msgid "The command <command>taskset</command> can either be used to start a new process with a given CPU affinity, or to redefine the CPU affinity of a already running process."
msgstr ""

#. (itstool) path: variablelist/title
#: xml/MAIN.SLERT.xml:1216
#: xml/MAIN.SLERT.xml:1327
msgid "Examples"
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1218
msgid "<option>taskset -p <replaceable>PID</replaceable></option>"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1221
msgid "Retrieves the current CPU affinity of the process with PID <literal>pid</literal>."
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1228
msgid "<option>taskset -p <replaceable>MASK</replaceable><replaceable>pid</replaceable></option>"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1231
msgid "Sets the CPU affinity of the process with PID <literal>pid</literal> to <literal>mask</literal>."
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1238
msgid "<option>taskset <replaceable>MASK</replaceable><replaceable>command</replaceable></option>"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1241
msgid "Runs <literal>command</literal> with a CPU affinity of <literal>mask</literal>."
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:1249
msgid "For more detailed information about <command>taskset</command>, consult the manual page. <command>man 1 taskset</command>"
msgstr ""

#. (itstool) path: sect1/title
#: xml/MAIN.SLERT.xml:1255
msgid "Changing I/O Priorities with <command>ionice</command>"
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:1257
msgid "Handling I/O is one of the critical issues for all high-performance systems. If a task has lots of CPU power available, but must wait for the disk, it will not work as efficiently as it could. The Linux kernel provides three different scheduling classes to determine the I/O handling for a process. All of these classes can be fine-tuned with a nice level."
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1267
msgid "The <emphasis>Best Effort</emphasis> Scheduler"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1269
msgid "The <emphasis>Best Effort</emphasis> scheduler is the default I/O scheduler, and is used for all processes that do not specify a different I/O scheduler class. By default, this scheduler sets its nice level according to the nice value of the running process."
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1275
msgid "There are eight different nice levels available for this scheduler. The lowest priority is represented by a nice level of seven, the highest priority is zero."
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1280
msgid "This scheduler has the scheduling class number <literal>2</literal>."
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1286
msgid "The <emphasis>Real Time</emphasis> Scheduler"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1288
msgid "The real-time I/O class always gets the highest priority for disk access. The other schedulers will only be served, if no real-time request is present. This scheduling class may easily lock up the system if not implemented with care."
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1294
msgid "The real-time scheduler defines nice levels just like the <emphasis>Best Effort</emphasis> scheduler."
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1298
msgid "This scheduler has the scheduling class number <literal>1</literal>."
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1304
msgid "The <emphasis>Idle</emphasis> Scheduler"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1306
msgid "The <emphasis>Idle</emphasis> scheduler does not define any nice levels. I/O is only done in this class, if no other scheduler runs an I/O request. This scheduler has the lowest available priority and can be used for processes that are not time-critical."
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1312
msgid "This scheduler has the scheduling class number <literal>3</literal>."
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:1319
msgid "To change I/O schedulers and nice values, use the <command>ionice</command> command. This provides a means to tune the scheduler of already running processes, or to start new processes with specific I/O settings."
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1329
msgid "<command>ionice -c3 -p$$</command>"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1332
msgid "Sets the scheduler of the current shell to <literal>Idle</literal>."
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1338
msgid "<command>ionice</command>"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1341
msgid "Without additional parameters, this prints the I/O scheduler settings of the current shell."
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1348
msgid "<command>ionice -c1 -p42 -n2</command>"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1351
msgid "Sets the scheduler of the process with process id <literal>42</literal> to <literal>Real Time</literal>, and its nice value to <literal>2</literal>."
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1359
msgid "<command>ionice -c3 /bin/bash</command>"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1362
msgid "Starts the Bash shell with the <literal>Idle</literal> I/O scheduler."
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:1369
msgid "For more detailed information about <command>ionice</command>, consult the manual page. <command>man 1 ionice</command>"
msgstr ""

#. (itstool) path: sect1/title
#: xml/MAIN.SLERT.xml:1375
msgid "Changing the I/O Scheduler for Block Devices"
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:1377
msgid "The Linux kernel provides several block device schedulers that can be selected individually for each block device. All but the <literal>noop</literal> scheduler perform a kind of ordering of requested blocks to reduce head movements on the hard disk. If you use an external storage system that has its own scheduler, you should disable the Linux internal reordering by selecting the <literal>noop</literal> scheduler."
msgstr ""

#. (itstool) path: variablelist/title
#: xml/MAIN.SLERT.xml:1388
msgid "The Linux I/O Schedulers"
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1390
msgid "noop"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1392
msgid "The <emphasis>noop</emphasis> scheduler is a very simple scheduler, that performs basic merging and sorting on I/O requests. This scheduler is mainly used for specialized environments that run their own schedulers optimized for the used hardware, such as storage systems or hardware RAID controllers."
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1403
msgid "anticipatory"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1405
msgid "The main principle of <emphasis>anticipatory</emphasis> scheduling is, that after a read, the scheduler simply expects further reads from userspace. For this reason, after a read completes, the anticipatory scheduler will do nothing for a few milliseconds, giving userspace the possibility to ask for another read. If such a read is requested, it will be performed immediately. Otherwise, the scheduler continues with doing writes after a short timeout."
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1414
msgid "The advantage of this procedure is a major reduction of seeks and thus, a decreased read latency. This also increases read and write bandwidth."
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1423
msgid "deadline"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1425
msgid "The main point of <emphasis>deadline</emphasis> scheduling is to try hard to answer a request before a given deadline. This results in very good I/O for a random single I/O in real-time environments."
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1430
msgid "In principle, the <emphasis>deadline</emphasis> uses two lists with all requests. One is sorted by block sequences to reduce seeking latencies, the other is sorted by expire times for each request. Normally, requests are served according to the block sequence, but if a request reaches its deadline, the scheduler starts to work on this request."
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1444
msgid "cfq"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1446
msgid "The <emphasis>Completely Fair Queuing</emphasis> scheduler uses a separate I/O queue for each process. All of these queues get a similar time slice for disk access. With this procedure, the <emphasis>CFQ</emphasis> tries to divide the bandwidth evenly between all requesting processes. This scheduler has a similar throughput as the <emphasis>anticipatory</emphasis> scheduler, but the maximum latency is much shorter."
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1455
msgid "For the average system, this scheduler yields the best results, and thus, is the default I/O scheduler on SUSE Linux Enterprise systems."
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:1465
msgid "To print the current scheduler of a block device like <filename>/dev/sda</filename>, use the following command:"
msgstr ""

#. (itstool) path: sect1/screen
#: xml/MAIN.SLERT.xml:1470
#, no-wrap
msgid ""
"cat /sys/block/sda/queue/scheduler\n"
"noop anticipatory deadline [cfq]"
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:1473
msgid "In this case, the scheduler for <filename>/dev/sda</filename> is set to <literal>cfq</literal>, the <literal>Completely Fair Queuing</literal> scheduler. This is the default scheduler on SUSE Linux Enterprise Real Time Extension."
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:1479
msgid "To change the schedulers, echo one of the names <literal>noop</literal>, <literal>anticipatory</literal>, <literal>deadline</literal>, or <literal>cfq</literal> into <filename>/sys/block/&lt;device&gt;/scheduler</filename>. For example, if you want to set the I/O scheduler of the device <filename>/dev/sda</filename> to <literal>noop</literal>, use the command <command>echo \"noop\" &gt; /sys/block/sda/scheduler</command>. To set other variables in the <filename>/sys</filename> file system, use a similar approach."
msgstr ""

#. (itstool) path: sect1/title
#: xml/MAIN.SLERT.xml:1492
msgid "Tuning the Block Device I/O Scheduler"
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:1494
msgid "All schedulers, except for the <emphasis>noop</emphasis> scheduler, have several common parameters that may be tuned for each block device. You can access these parameters with <filename>sysfs</filename> in the <filename>/sys/block/&lt;device&gt;/queue/iosched/</filename> directory. The following parameters are tuneable for the respective scheduler:"
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1509
msgid "Anticipatory Scheduler"
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1513
msgid "<option>antic_expire</option>"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1516
msgid "Time in milliseconds that the <emphasis>anticipatory</emphasis> scheduler waits for another read request close to the last read request performed. The <emphasis>anticipatory</emphasis> scheduler will not wait for upcoming read requests, if this value is set to zero."
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1526
#: xml/MAIN.SLERT.xml:1575
msgid "<option>read_expire</option>"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1529
msgid "Deadline of a read request in milliseconds. This scheduler also controls the interval between expired requests. By default, read_expire is set to 125 milliseconds. Thus, it can take up to 250 milliseconds until the next read request on the list is served."
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1538
#: xml/MAIN.SLERT.xml:1587
msgid "<option>write_expire</option>"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1541
#: xml/MAIN.SLERT.xml:1590
msgid "Similar to <option>read_expire</option> for write requests."
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1547
msgid "<option>read_batch_expire</option>"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1550
msgid "If write requests are scheduled, this is the time in milliseconds that reads are served before pending writes get a time slice. If writes are more important than reads, set this value lower than <option>read_expire</option>."
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1559
msgid "<option>write_batch_expire</option>"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1562
msgid "Similar to <option>read_batch_expire</option> for write requests."
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1571
msgid "Deadline Scheduler"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1578
msgid "The main focus of this scheduler is to limit the start latency for a request to a given time. Therefore, for each request, a deadline is calculated from the current time plus the value of <option>read_expire</option> in milliseconds."
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1596
msgid "<option>fifo_batch</option>"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1599
msgid "If a request hits its deadline, it is necessary to move the request from the sorted I/O scheduler list to the dispatch queue. The variable <option>fifo_batch</option> controls how many requests are moved, depending on the cost of each request."
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1608
msgid "<option>front_merges</option>"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1611
msgid "The scheduler normally tries to find contiguous I/O requests and merges them. There are two kinds of merges: The new I/O request may be in front of the existing I/O request (front merge), or it may follow behind the existing request (back merge). Most merges are back merges. Therefore, you can disable the front merge functionality by setting <option>front_merges</option> to <literal>0</literal>."
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1623
msgid "<option>write_starved</option>"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1626
msgid "In case some read or write requests hit their deadline, the scheduler prefers the read requests by default. To prevent write requests from being postponed forever, the variable <option>write_starved</option> controls how often read requests are preferred until write requests are preferred over read requests."
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1646
msgid "CFQ Scheduler"
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1650
msgid "<option>back_seek_max</option> and <option>back_seek_penalty</option>"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1654
msgid "The <emphasis>CFQ</emphasis> scheduler normally uses a strict ascending elevator. When needed, it also allows small backward seeks, but it puts some penalty on them. The maximum backward sector seek is defined with <option>back_seek_max</option>, and the multiplier for the penalty is set by <option>back_seek_penalty</option>."
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1665
msgid "<option>fifo_expire_async</option> and <option>fifo_expire_sync</option>"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1669
msgid "The <option>fifo_expire_*</option> variables define the timeout in milliseconds for asynchronous and synchronous I/O requests. Typically, <option>fifo_expire_async</option> affects write and <option>fifo_expire_sync</option> affects both, read and write operations."
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1679
msgid "<option>quantum</option>"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1682
msgid "Defines the number of I/O requests to dispatch when the block device is idle."
msgstr ""

#. (itstool) path: varlistentry/term
#: xml/MAIN.SLERT.xml:1689
msgid "<option>slice_async</option>, <option>slice_async_rq</option>, <option>slice_sync</option>, and <option>slice_idle</option>"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1693
msgid "These variables define the time slices a block device gets for synchronous or asynchronous operations."
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1699
msgid "<option>slice_async</option> and <option>slice_sync</option> represent the length of an asynchronous or synchronous disk slice in milliseconds."
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1706
msgid "<option>slice_async_rq</option> defines for how many requests an asynchronous disk slice lasts."
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1712
msgid "<option>slice_idle</option> defines how long a sync slice may idle."
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:1733
msgid "The system default Block Device I/O Scheduler could be also set by the kernel parameter <literal>elevator=</literal>,for example <literal>elevator=deadline</literal> to change the I/O Scheduler to <literal>deadline</literal>."
msgstr ""

#. (itstool) path: sect1/title
#: xml/MAIN.SLERT.xml:1754
msgid "For More Information"
msgstr ""

#. (itstool) path: sect1/para
#: xml/MAIN.SLERT.xml:1756
msgid "A lot of information about real-time implementations and administration can be found on the Internet. The following list contains several selected links:"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1770
msgid "More detailed information about the Real-Time Linux Development and an introduction how to write a Real-Time application can be found in the Real-Time Linux Community Wiki. <link xlink:href=\"http://rt.wiki.kernel.org\"/>, <link xlink:href=\"http://rt.wiki.kernel.org/index.php/HOWTO:_Build_an_RT-application\"/>"
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1779
msgid "The cpuset feature of the kernel is explained in <filename>/usr/src/linux/Documentation/cpusets.txt</filename>. More detailed documentation is available from <link xlink:href=\"http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi/linux/bks/SGI_Admin/books/LX_Resource_AG/sgi_html/ch04.html\"/>, <link xlink:href=\"http://www.bullopensource.org/cpuset/\"/>, and <link xlink:href=\"http://lwn.net/Articles/127936/\"/>."
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1789
msgid "An overview of CPU and I/O schedulers available in Linux can be found at <link xlink:href=\"http://aplawrence.com/Linux/linux26_features.html\"/>."
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1796
msgid "Detailed information about the anticipatory I/O scheduler is available at <link xlink:href=\"http://www.cs.rice.edu/~ssiyer/r/antsched/antio.html\"/> and <link xlink:href=\"http://www.cs.rice.edu/~ssiyer/r/antsched/\"/>."
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1804
msgid "For more information about the deadline I/O scheduler, refer to <link xlink:href=\"http://lwn.net/2002/0110/a/io-scheduler.php3\"/>, or <link xlink:href=\"http://kerneltrap.org/node/431\"/>. In your installed system, find further information in <filename>/usr/src/linux/Documentation/block/deadline-iosched.txt</filename>."
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1813
msgid "The CFQ I/O scheduler is covered in detail in <link xlink:href=\"http://en.wikipedia.org/wiki/CFQ\"/>."
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1819
msgid "General information about I/O scheduling in Linux is available at <link xlink:href=\"http://lwn.net/Articles/101029/\"/>, <link xlink:href=\"http://lwn.net/Articles/114273/\"/>, and <link xlink:href=\"http://donami.com/118\"/>."
msgstr ""

#. (itstool) path: listitem/para
#: xml/MAIN.SLERT.xml:1831
msgid "A lot of information about real-time can be found at <link xlink:href=\"http://linuxdevices.com/articles/AT6476691775.html\"/>."
msgstr ""

