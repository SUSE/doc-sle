<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="cha-systemd">
 <title>The &systemd; daemon</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker></dm:bugtracker>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>
 <para>
  &systemd; is responsible for initializing the system, and it has the
  process ID 1. &systemd; is started directly by the kernel and resists
  signal&nbsp;9, which normally terminates processes.
  All other programs are either started directly by &systemd; or by one of its
  child processes. &systemd; is a replacement for the System V init daemon and
  fully compatible with System V init (by supporting init scripts).
 </para>
 <para>
  The main advantage of &systemd; is that it considerably speeds up boot time by
  parallelizing service starts. Furthermore, &systemd; only starts a service when
  it is really needed. Daemons are not started unconditionally at
  boot time, but when being required for the first time. &systemd; also
  supports Kernel Control Groups (cgroups), creating snapshots, and restoring
  the system state. For more details see <link
  xlink:href="http://www.freedesktop.org/wiki/Software/systemd/"/>.
 </para>
   
 <sect1 xml:id="sec-boot-systemd-concept">
  <title>The &systemd; concept</title>
  <para>
   The following section explains the concept behind &systemd;.
  </para>
  <para>
    &systemd; is a system and session manager for Linux, compatible with System V
    and LSB init scripts.
    The main features of &systemd; include:
  </para>
    <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>
      parallelization capabilities
     </para>
    </listitem>
    <listitem>
     <para>
      socket and D-Bus activation for starting services
     </para>
    </listitem>
    <listitem>
     <para>
      on-demand starting of daemons
     </para>
    </listitem>
    <listitem>
     <para>
      tracking of processes using Linux cgroups
     </para>
    </listitem>
    <listitem>
     <para>
      creating snapshots and restoring of the system state
     </para>
    </listitem>
    <listitem>
     <para>
      maintains mount and automount points
     </para>
    </listitem>
    <listitem>
     <para>
      implements an elaborate transactional dependency-based service control
      logic
     </para>
    </listitem>
   </itemizedlist>

   <sect2 xml:id="sec-boot-systemd-unitfile">
   <title>Unit file</title>
   <para>
    A unit configuration file contains information about a service, a socket, a
    device, a mount point, an automount point, a swap file or partition, a
    start-up target, a watched file system path, a timer controlled and supervised
    by &systemd;, a temporary system state snapshot, a resource management slice
    or a group of externally created processes.
   </para>
   <para>
    <quote>Unit file</quote> is a generic term used by &systemd; for the following:
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <formalpara>
      <title>Service</title>
      <para>
       Information about a process (for example running a daemon); file ends with
       .service
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Targets</title>
      <para>
       Used for grouping units and as synchronization points during start-up; file
       ends with .target
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Sockets</title>
      <para>
       Information about an IPC or network socket or a file system FIFO, for
        socket-based activation (like <systemitem class="daemon">inetd</systemitem>);
        file ends with .socket
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Path</title>
      <para>
       Used to trigger other units (for example running a service when files change);
       file ends with .path
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Timer</title>
      <para>
       Information about a timer controlled, for timer-based activation; file ends with
       .timer
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Mount point</title>
      <para>
       Usually auto-generated by the fstab generator; file ends with .mount
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Automount point</title>
      <para>
       Information about a file system automount point; file ends with .automount
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Swap</title>
      <para>
       Information about a swap device or file for memory paging; file ends with .swap
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Device</title>
      <para>
       Information about a device unit as exposed in the sysfs/udev(7) device tree; file
       ends with .device
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Scope / slice</title>
      <para>
       A concept for hierarchically managing resources of a group of processes; file ends
       with .scope/.slice
      </para>
     </formalpara>
    </listitem>
   </itemizedlist>
     
   <para>
    For more information about &systemd; unit files, see
    <link xlink:href="http://www.freedesktop.org/software/systemd/man/systemd.unit.html"/>
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-boot-systemd-basics">
  <title>Basic usage</title>

  <para>
   The System V init system uses several commands to handle services&mdash;the init scripts, <command>insserv</command>, <command>telinit</command> and others. &systemd; makes it easier to manage services, since there is only one command to memorize for the majority of service-handling tasks: <command>systemctl</command>.
   It uses the <quote>command plus subcommand</quote> notation like <command>git</command> or <command>zypper</command>:
  </para>

<screen>systemctl <replaceable>GENERAL OPTIONS</replaceable> <replaceable>SUBCOMMAND</replaceable> <replaceable>SUBCOMMAND OPTIONS</replaceable></screen>

  <para>
   See <command>man 1 systemctl</command> for a complete manual.
  </para>

  <tip>
   <title>Terminal output and Bash completion</title>
   <para>
    If the output goes to a terminal (and not to a pipe or a file, for example), &systemd; commands send long output to a pager by default.
    Use the <option>--no-pager</option> option to turn off paging mode.
   </para>
   <para>
    &systemd; also supports bash-completion, allowing you to enter the first letters of a subcommand and then press <keycap function="tab"/>.
    This feature is only available in the <systemitem>bash</systemitem> shell and requires the installation of the package <systemitem class="resource">bash-completion</systemitem>.
   </para>
  </tip>

  <sect2 xml:id="sec-boot-systemd-basics-services">
   <title>Managing services in a running system</title>
   <para>
    Subcommands for managing services are the same as for managing a service with System V init (<command>start</command>, <command>stop</command>, ...).
    The general syntax for service management commands is as follows:
   </para>
   <variablelist>
    <varlistentry>
     <term>&systemd;</term>
     <listitem>
<screen>systemctl reload|restart|start|status|stop|<replaceable>...</replaceable> <replaceable>MY_SERVICE(S)</replaceable></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>System V init</term>
     <listitem>
<screen>rc<replaceable>MY_SERVICE(S)</replaceable> reload|restart|start|status|stop|<replaceable>...</replaceable></screen>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    &systemd; allows you to manage several services in one go.
    Instead of executing init scripts one after the other as with System V init, execute a command like the following:
   </para>
<screen>&prompt.sudo;systemctl start <replaceable>MY_1ST_SERVICE</replaceable> <replaceable>MY_2ND_SERVICE</replaceable></screen>
   <para>
    To list all services available on the system:
   </para>
<screen>&prompt.sudo;systemctl list-unit-files --type=service</screen>
   <para>
    The following table lists the most important service management commands for &systemd; and System V init:
   </para>
   <table rowsep="1">
    <title>Service management commands</title>
    <tgroup cols="3">
     <colspec colnum="1" colname="1" colwidth="50*"/>
     <colspec colnum="2" colname="2" colwidth="30*"/>
     <colspec colnum="3" colname="3" colwidth="20*"/>
     <thead>
      <row>
       <entry colname="1">
        <para>
         Task
        </para>
       </entry>
       <entry colname="2">
        <para>
         &systemd; Command
        </para>
       </entry>
       <entry colname="3">
        <para>
         System V init Command
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Starting</title>
         <para/>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>start</screen>
       </entry>
       <entry colname="3">
<screen>start</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Stopping</title>
         <para/>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>stop</screen>
       </entry>
       <entry colname="3">
<screen>stop</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Restarting</title>
         <para>
          Shuts down services and starts them afterward.
          If a service is not yet running it will be started.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>restart</screen>
       </entry>
       <entry colname="3">
<screen>restart</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Restarting conditionally</title>
         <para>
          Restarts services if they are currently running.
          Does nothing for services that are not running.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>try-restart</screen>
       </entry>
       <entry colname="3">
<screen>try-restart</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Reloading</title>
         <para>
          Tells services to reload their configuration files without interrupting operation.
          Use case: Tell Apache to reload a modified <filename>httpd.conf</filename> configuration file.
          Note that not all services support reloading.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>reload</screen>
       </entry>
       <entry colname="3">
<screen>reload</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Reloading or restarting</title>
         <para>
          Reloads services if reloading is supported, otherwise restarts them.
          If a service is not yet running it will be started.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>reload-or-restart</screen>
       </entry>
       <entry colname="3">
<screen>n/a</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Reloading or restarting conditionally</title>
         <para>
          Reloads services if reloading is supported, otherwise restarts them if currently running.
          Does nothing for services that are not running.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>reload-or-try-restart</screen>
       </entry>
       <entry colname="3">
<screen>n/a</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Getting detailed status information</title>
         <para>
          Lists information about the status of services.
          The &systemd; command shows details such as description, executable, status, cgroup, and messages last issued by a service (see <xref linkend="sec-boot-systemd-basics-services-debugging"/>).
          The level of details displayed with the System V init differs from service to service.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>status</screen>
       </entry>
       <entry colname="3">
<screen>status</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Getting short status information</title>
         <para>
          Shows whether services are active or not.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>is-active</screen>
       </entry>
       <entry colname="3">
<screen>status</screen>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-basics-services-enabling">
   <title>Permanently enabling/disabling services</title>
   <para>
    The service management commands mentioned in the previous section let you manipulate services for the current session. &systemd; also lets you permanently enable or disable services, so they are automatically started when requested or are always unavailable.
    You can either do this by using &yast;, or on the command line.
   </para>
   <sect3 xml:id="sec-boot-systemd-basics-services-enabling-cmd">
    <title>Enabling/disabling services on the command line</title>
    <para>
     The following table lists enabling and disabling commands for &systemd; and System V init:
    </para>
    <important>
     <title>Service start</title>
     <para>
      When enabling a service on the command line, it is not started automatically.
      It is scheduled to be started with the next system start-up or runlevel/target change.
      To immediately start a service after having enabled it, explicitly run <command>systemctl start <replaceable>MY_SERVICE</replaceable></command> or <command>rc <replaceable>MY_SERVICE</replaceable> start</command>.
     </para>
    </important>
    <table rowsep="1">
     <title>Commands for enabling and disabling services</title>
     <tgroup cols="3">
      <colspec colnum="1" colname="1" colwidth="32*"/>
      <colspec colnum="2" colname="2" colwidth="40*"/>
      <colspec colnum="3" colname="3" colwidth="28*"/>
      <thead>
       <row>
        <entry colname="1">
         <para>
          Task
         </para>
        </entry>
        <entry colname="2">
         <para>
          &systemd; Command
         </para>
        </entry>
        <entry colname="3">
         <para>
          System V init Command
         </para>
        </entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Enabling</title>
          <para/>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl enable <replaceable>MY_SERVICE(S)</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>insserv <replaceable>MY_SERVICE(S)</replaceable></command>, <command>chkconfig -a <replaceable>MY_SERVICE(S)</replaceable></command>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Disabling</title>
          <para/>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl disable <replaceable>MY_SERVICE(S)</replaceable>.service</command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>insserv -r <replaceable>MY_SERVICE(S)</replaceable></command>, <command>chkconfig -d <replaceable>MY_SERVICE(S)</replaceable></command>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Checking</title>
          <para>
           Shows whether a service is enabled or not.
          </para>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl is-enabled <replaceable>MY_SERVICE</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>chkconfig <replaceable>MY_SERVICE</replaceable></command>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Re-enabling</title>
          <para>
           Similar to restarting a service, this command first disables and then enables a service.
           Useful to re-enable a service with its defaults.
          </para>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl reenable <replaceable>MY_SERVICE</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/a
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Masking</title>
          <para>
           After <quote>disabling</quote> a service, it can still be started manually.
           To completely disable a service, you need to mask it.
           Use with care.
          </para>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl mask <replaceable>MY_SERVICE</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/a
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Unmasking</title>
          <para>
           A service that has been masked can only be used again after it has been unmasked.
          </para>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl unmask <replaceable>MY_SERVICE</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/a
         </para>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-boot-systemd-boot">
  <title>System start and target management</title>

  <para>
   The entire process of starting the system and shutting it down is maintained by &systemd;.
   From this point of view, the kernel can be considered a background process to maintain all other processes and adjust CPU time and hardware access according to requests from other programs.
  </para>

  <sect2 xml:id="sec-boot-systemd-targets">
   <title>Targets compared to runlevels</title>
   <para>
    With System V init the system was booted into a so-called <quote>Runlevel</quote>.
    A runlevel defines how the system is started and what services are available in the running system.
    Runlevels are numbered; the most commonly known ones are <literal>0</literal> (shutting down the system), <literal>3</literal> (multiuser with network) and <literal>5</literal> (multiuser with network and display manager).
   </para>
   <para>
    &systemd; introduces a new concept by using so-called <quote>target units</quote>.
    However, it remains fully compatible with the runlevel concept.
    Target units are named rather than numbered and serve specific purposes.
    For example, the targets <systemitem>local-fs.target</systemitem> and <systemitem>swap.target</systemitem> mount local file systems and swap spaces.
   </para>
   <para>
    The target <systemitem>graphical.target</systemitem> provides a multiuser system with network and display manager capabilities and is equivalent to runlevel 5.
    Complex targets, such as <systemitem>graphical.target</systemitem> act as <quote>meta</quote> targets by combining a subset of other targets.
    Since &systemd; makes it easy to create custom targets by combining existing targets, it offers great flexibility.
   </para>
   <para>
    The following list shows the most important &systemd; target units.
    For a full list refer to <command>man 7 systemd.special</command>.
   </para>
   <variablelist>
    <title>Selected &systemd; target units</title>
    <varlistentry>
     <term><systemitem>default.target</systemitem></term>
     <listitem>
      <para>
       The target that is booted by default.
       Not a <quote>real</quote> target, but rather a symbolic link to another target like <systemitem>graphic.target</systemitem>.
       Can be permanently changed via &yast; (see <xref linkend="sec-boot-runlevel-edit"/>).
       To change it for a session, use the kernel parameter <literal>systemd.unit=<replaceable>MY_TARGET.target</replaceable></literal> at the boot prompt.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>emergency.target</systemitem></term>
     <listitem>
      <para>
       Starts an emergency shell on the console.
       Only use it at the boot prompt as <literal>systemd.unit=emergency.target</literal>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>graphical.target</systemitem></term>
     <listitem>
      <para>
       Starts a system with network, multiuser support and a display manager.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>halt.target</systemitem></term>
     <listitem>
      <para>
       Shuts down the system.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mail-transfer-agent.target</systemitem></term>
     <listitem>
      <para>
       Starts all services necessary for sending and receiving mails.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>multi-user.target</systemitem></term>
     <listitem>
      <para>
       Starts a multiuser system with network.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>reboot.target</systemitem></term>
     <listitem>
      <para>
       Reboots the system.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>rescue.target</systemitem></term>
     <listitem>
      <para>
       Starts a single-user system without network.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    To remain compatible with the System V init runlevel system, &systemd; provides special targets named <literal>runlevel<replaceable>X</replaceable>.target</literal> mapping the corresponding runlevels numbered <replaceable>X</replaceable>.
   </para>
   <para>
    If you want to know the current target, use the command: <command>systemctl get-default</command>
   </para>
   <table rowsep="1">
    <title>System V runlevels and &systemd; target units</title>
    <tgroup cols="3">
     <colspec colnum="1" colname="1" colwidth="20*"/>
     <colspec colnum="2" colname="2" colwidth="40*"/>
     <colspec colnum="3" colname="3" colwidth="40*"/>
     <thead>
      <row>
       <entry>
        <para>
         System V runlevel
        </para>
       </entry>
       <entry>
        <para>
         &systemd; target
        </para>
       </entry>
       <entry>
        <para>
         Purpose
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         0
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel0.target</systemitem>, <systemitem>halt.target</systemitem>, <systemitem>poweroff.target</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         System shutdown
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         1, S
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel1.target</systemitem>, <systemitem>rescue.target</systemitem>,
        </para>
       </entry>
       <entry>
        <para>
         Single-user mode
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         2
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel2.target</systemitem>, <systemitem>multi-user.target</systemitem>,
        </para>
       </entry>
       <entry>
        <para>
         Local multiuser without remote network
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         3
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel3.target</systemitem>, <systemitem>multi-user.target</systemitem>,
        </para>
       </entry>
       <entry>
        <para>
         Full multiuser with network
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         4
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel4.target</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         Unused/User-defined
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         5
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel5.target</systemitem>, <systemitem>graphical.target</systemitem>,
        </para>
       </entry>
       <entry>
        <para>
         Full multiuser with network and display manager
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         6
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel6.target</systemitem>, <systemitem>reboot.target</systemitem>,
        </para>
       </entry>
       <entry>
        <para>
         System reboot
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <important>
    <title>&systemd; ignores <filename>/etc/inittab</filename></title>
    <para>
     The runlevels in a System V init system are configured in <filename>/etc/inittab</filename>. &systemd; does <emphasis>not</emphasis> use this configuration.
     Refer to <xref linkend="sec-boot-systemd-custom-targets"/> for instructions on how to create your own bootable target.
    </para>
   </important>
   <sect3 xml:id="sec-boot-systemd-targets-commands">
    <title>Commands to change targets</title>
    <para>
     Use the following commands to operate with target units:
    </para>
    <informaltable rowsep="1">
     <tgroup cols="3">
      <colspec colnum="1" colname="1" colwidth="20*"/>
      <colspec colnum="2" colname="2" colwidth="50*"/>
      <colspec colnum="3" colname="3" colwidth="30*"/>
      <thead>
       <row>
        <entry colname="1">
         <para>
          Task
         </para>
        </entry>
        <entry colname="2">
         <para>
          &systemd; Command
         </para>
        </entry>
        <entry colname="3">
         <para>
          System V init Command
         </para>
        </entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry colname="1">
         <para>
          Change the current target/runlevel
         </para>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl isolate</command> <replaceable>MY_TARGET</replaceable>.target
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>telinit</command> <replaceable>X</replaceable>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          Change to the default target/runlevel
         </para>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl default</command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/a
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          Get the current target/runlevel
         </para>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl list-units --type=target</command>
         </para>
         <para>
          With &systemd; there is usually more than one active target.
          The command lists all currently active targets.
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>who -r</command>
         </para>
         <para>
          or
         </para>
         <para>
          <command>runlevel</command>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          persistently change the default runlevel
         </para>
        </entry>
        <entry colname="2">
         <para>
          Use the &ycc_runlevel; or run the following command:
         </para>
         <para>
          <command>ln -sf /usr/lib/systemd/system/</command> <replaceable>MY_TARGET</replaceable>.target /etc/systemd/system/default.target
         </para>
        </entry>
        <entry colname="3">
         <para>
          Use the &ycc_runlevel; or change the line
         </para>
         <para>
          <command>id:</command> <replaceable>X</replaceable>:initdefault:
         </para>
         <para>
          in <filename>/etc/inittab</filename>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          Change the default runlevel for the current boot process
         </para>
        </entry>
        <entry colname="2">
         <para>
          Enter the following option at the boot prompt
         </para>
         <para>
          <command>systemd.unit=</command> <replaceable>MY_TARGET</replaceable>.target
         </para>
        </entry>
        <entry colname="3">
         <para>
          Enter the desired runlevel number at the boot prompt.
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          Show a target's/runlevel's dependencies
         </para>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl show -p "Requires"</command> <replaceable>MY_TARGET</replaceable>.target
         </para>
         <para>
          <command>systemctl show -p "Wants"</command> <replaceable>MY_TARGET</replaceable>.target
         </para>
         <para>
          <quote>Requires</quote> lists the hard dependencies (the ones that must be resolved), whereas <quote>Wants</quote> lists the soft dependencies (the ones that get resolved if possible).
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/a
         </para>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-debug">
   <title>Debugging system start-up</title>
   <para>
    &systemd; offers the means to analyze the system start-up process.
    You can review the list of all services and their status (rather than having to parse <filename>/var/log/</filename>). &systemd; also allows you to scan the start-up procedure to find out how much time each service start-up consumes.
   </para>
   <sect3 xml:id="sec-boot-systemd-debug-review">
    <title>Review start-up of services</title>
    <para>
     To review the complete list of services that have been started since booting the system, enter the command <command>systemctl</command>.
     It lists all active services like shown below (shortened).
     To get more information on a specific service, use <command>systemctl status <replaceable>MY_SERVICE</replaceable></command>.
    </para>
    <example>
     <title>List active services</title>
<screen>&prompt.root;systemctl
UNIT                        LOAD   ACTIVE SUB       JOB DESCRIPTION
[...]
iscsi.service               loaded active exited    Login and scanning of iSC+
kmod-static-nodes.service   loaded active exited    Create list of required s+
libvirtd.service            loaded active running   Virtualization daemon
nscd.service                loaded active running   Name Service Cache Daemon
chronyd.service             loaded active running   NTP Server Daemon
polkit.service              loaded active running   Authorization Manager
postfix.service             loaded active running   Postfix Mail Transport Ag+
rc-local.service            loaded active exited    /etc/init.d/boot.local Co+
rsyslog.service             loaded active running   System Logging Service
[...]
LOAD   = Reflects whether the unit definition was properly loaded.
ACTIVE = The high-level unit activation state, i.e. generalization of SUB.
SUB    = The low-level unit activation state, values depend on unit type.

161 loaded units listed. Pass --all to see loaded but inactive units, too.
To show all installed unit files use 'systemctl list-unit-files'.</screen>
    </example>
    <para>
     To restrict the output to services that failed to start, use the <option>--failed</option> option:
    </para>
    <example>
     <title>List failed services</title>
<screen>&prompt.root;systemctl --failed
UNIT                   LOAD   ACTIVE SUB    JOB DESCRIPTION
apache2.service        loaded failed failed     apache
NetworkManager.service loaded failed failed     Network Manager
plymouth-start.service loaded failed failed     Show Plymouth Boot Screen

[...]</screen>
    </example>
   </sect3>
   <sect3 xml:id="sec-boot-systemd-debug-time">
    <title>Debug start-up time</title>
    <para>
     To debug system start-up time, &systemd; offers the <command>systemd-analyze</command> command.
     It shows the total start-up time, a list of services ordered by start-up time and can also generate an SVG graphic showing the time services took to start in relation to the other services.
    </para>
    <variablelist>
     <varlistentry>
      <term>Listing the system start-up time</term>
      <listitem>
<screen>&prompt.root;systemd-analyze
Startup finished in 2666ms (kernel) + 21961ms (userspace) = 24628ms</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Listing the services start-up time</term>
      <listitem>
<screen>&prompt.root;systemd-analyze blame
    15.000s backup-rpmdb.service
    14.879s mandb.service
     7.646s backup-sysconfig.service
     4.940s postfix.service
     4.921s logrotate.service
     4.640s libvirtd.service
     4.519s display-manager.service
     3.921s btrfsmaintenance-refresh.service
     3.466s lvm2-monitor.service
     2.774s plymouth-quit-wait.service
     2.591s firewalld.service
     2.137s initrd-switch-root.service
     1.954s ModemManager.service
     1.528s rsyslog.service
     1.378s apparmor.service
    [...]
</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Services start-up time graphics</term>
      <listitem>
<screen>&prompt.root;systemd-analyze plot &gt; &wsIname;-startup.svg</screen>
       <informalfigure>
        <mediaobject>
         <imageobject role="fo">
          <imagedata fileref="systemd_startup.svg" width="75%" format="SVG"/>
         </imageobject>
         <imageobject role="html">
          <imagedata fileref="systemd_startup.png" width="75%" format="PNG"/>
         </imageobject>
        </mediaobject>
       </informalfigure>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3 xml:id="sec-boot-systemd-debug-complete">
    <title>Review the complete start-up process</title>
    <para>
     The commands above list the services that are started and their start-up times.
     For a more detailed overview, specify the following parameters at the boot prompt to instruct &systemd; to create a verbose log of the complete start-up procedure.
    </para>
<screen>systemd.log_level=debug systemd.log_target=kmsg</screen>
    <para>
     Now &systemd; writes its log messages into the kernel ring buffer.
     View that buffer with <command>dmesg</command>:
    </para>
<screen>&prompt.user;dmesg -T | less</screen>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-sysv-compatibility">
   <title>System V compatibility</title>
   <para>
    &systemd; is compatible with System V, allowing you to still use existing System V init scripts.
    However, there is at least one known issue where a System V init script does not work with &systemd; out of the box: starting a service as a different user via <command>su</command> or <command>sudo</command> in init scripts will result in a failure of the script, producing an <quote>Access denied</quote> error.
   </para>
   <para>
    When changing the user with <command>su</command> or <command>sudo</command>, a PAM session is started.
    This session will be terminated after the init script is finished.
    As a consequence, the service that has been started by the init script will also be terminated.
    To work around this error, proceed as follows:
   </para>
   <procedure>
    <step>
     <para>
      Create a service file wrapper with the same name as the init script plus the file name extension <filename>.service</filename>:
     </para>
<screen>[Unit]
Description=<replaceable>DESCRIPTION</replaceable>
After=network.target

[Service]
User=<replaceable>USER</replaceable>
Type=forking<co xml:id="co-service-wrapper-type"/>
PIDFile=<replaceable>PATH TO PID FILE</replaceable><xref linkend="co-service-wrapper-type" xrefstyle="select:label nopage"/>
ExecStart=<replaceable>PATH TO INIT SCRIPT</replaceable> start
ExecStop=<replaceable>PATH TO INIT SCRIPT</replaceable> stop
ExecStopPost=/usr/bin/rm -f <replaceable>PATH TO PID FILE</replaceable><xref linkend="co-service-wrapper-type" xrefstyle="select:label nopage"/>

[Install]
WantedBy=multi-user.target<co xml:id="co-service-wrapper-target"/></screen>
     <para>
      Replace all values written in <replaceable>UPPERCASE LETTERS</replaceable> with appropriate values.
     </para>
     <calloutlist>
      <callout arearefs="co-service-wrapper-type">
       <para>
        Optional&mdash;only use if the init script starts a daemon.
       </para>
      </callout>
      <callout arearefs="co-service-wrapper-target">
       <para>
        <literal>multi-user.target</literal> also starts the init script when booting into <literal>graphical.target</literal>.
        If it should only be started when booting into the display manager, user <literal>graphical.target</literal> here.
       </para>
      </callout>
     </calloutlist>
    </step>
    <step>
     <para>
      Start the daemon with <command>systemctl start <replaceable>APPLICATION</replaceable></command>.
     </para>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-boot-runlevel-edit">
  <title>Managing services with &yast;</title>

  <para>
   Basic service management can also be done with the &yast; &ycc_runlevel; module.
   It supports starting, stopping, enabling and disabling services.
   It also lets you show a service's status and change the default target.
   Start the &yast; module with <menuchoice> <guimenu>&yast;</guimenu> <guimenu>System</guimenu> <guimenu>&ycc_runlevel;</guimenu> </menuchoice>.
  </para>

  <figure xml:id="fig-yast2-runlevel">
   <title>&ycc_runlevel;</title>
   <mediaobject>
    <imageobject role="fo">
     <imagedata fileref="yast2_runlevel.png" width="75%" format="PNG"/>
    </imageobject>
    <imageobject role="html">
     <imagedata fileref="yast2_runlevel.png" width="75%" format="PNG"/>
    </imageobject>
   </mediaobject>
  </figure>

  <variablelist>
   <varlistentry>
    <term>Changing the <guimenu>Default system target</guimenu></term>
    <listitem>
     <para>
      To change the target the system boots into, choose a target from the <guimenu>Default System Target</guimenu> drop-down box.
      The most often used targets are <guimenu>Graphical Interface</guimenu> (starting a graphical login screen) and <guimenu>Multi-User</guimenu> (starting the system in command line mode).
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Starting or stopping a service</term>
    <listitem>
     <para>
      Select a service from the table.
      The <guimenu>State</guimenu> column shows whether it is currently running (<guimenu>Active</guimenu>) or not (<guimenu>Inactive</guimenu>).
      Toggle its status by choosing <guimenu>Start</guimenu> or <guimenu>Stop</guimenu>.
     </para>
     <para>
      Starting or stopping a service changes its status for the currently running session.
      To change its status throughout a reboot, you need to enable or disable it.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Defining service start-up behavior</term>
    <listitem>
     <para>
      Services can either be started automatically at boot time or manually.
      Select a service from the table.
      The <guimenu>Start</guimenu> column shows whether it is currently started <guimenu>Manually</guimenu> or <guimenu>On Boot</guimenu>.
      Toggle its status by choosing <guimenu>Start Mode</guimenu>.
     </para>
     <para>
      To change a service status in the current session, you need to start or stop it as described above.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>View a status messages</term>
    <listitem>
     <para>
      To view the status message of a service, select it from the list and choose <guimenu>Show Details</guimenu>.
      The output you will see is identical to the one generated by the command <command>systemctl</command> <option>-l</option> status <replaceable>MY_SERVICE</replaceable>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 xml:id="sec-boot-systemd-custom">
  <title>Customizing <systemitem>systemd</systemitem></title>

  <para>
   The following sections contain some examples for <systemitem>systemd</systemitem> customization.
  </para>

  <warning>
   <title>Preventing your customization from being overwritten</title>
   <para>
    When customizing &systemd;, always use the directory <filename>/etc/systemd/</filename>, <emphasis>never</emphasis> use <filename>/usr/lib/systemd/</filename>.
    Otherwise your changes will be overwritten by the next update of &systemd;.
   </para>
  </warning>

  <sect2 xml:id="sec-boot-systemd-custom-service">
   <title>Customizing unit files</title>
   <para>
    The recommended way to customize unit files is to use the <command>systemctl edit <replaceable>SERVICE</replaceable></command> command.
    This command starts the default text editor and creates a directory with the <filename>override.conf</filename> file in <filename>/etc/systemd/system/<replaceable>NAME</replaceable>.service.d/</filename>.
    The command also ensures that the running &systemd; process is notified about the changes.
   </para>
   <para>
    Alternatively, you can open a copy of the original file for editing instead of a blank file by running <command>systemctl edit --full <replaceable>SERVICE</replaceable></command>.
    When editing the file, make sure that you do not remove any of the existing sections.
   </para>
   <para>
    As an exercise, change how long the system waits for &mariadb; to start.
    As root, run <command>systemctl edit --full mariadb.service</command>.
    The file opened will look similar to the following:
   </para>
<screen>
[Unit]
Description=MySQL server
Wants=basic.target
Conflicts=mariadb.target
After=basic.target network.target

[Install]
WantedBy=multi-user.target
Alias=mysql.service

[Service]
Restart=on-abort
Type=notify
ExecStartPre=/usr/lib/mysql/mysql-systemd-helper  install
ExecStartPre=/usr/lib/mysql/mysql-systemd-helper  upgrade
ExecStart=/usr/lib/mysql/mysql-systemd-helper     start

# Configures the time to wait for start-up/stop
TimeoutSec=300

# Prevent writes to /usr, /boot, and /etc
ProtectSystem=full

# Prevent accessing /home, /root and /run/user
ProtectHome=true

UMask=007</screen>
   <para>
    Adjust the <literal>TimeoutSec</literal> value and save the changes.
    To enable the changes, as root, run <command>systemctl daemon-reload</command>.
   </para>
   <para>
    For further information, refer to the man pages that can be evoked with the <command>man 1 systemctl</command> command.
   </para>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-custom-drop-in">
   <title>Creating drop-in files</title>
   <para>
    For minor changes of a configuration file, use so-called drop-in files.
    Drop-in files let you extend the configuration of unit files without having to edit or override the unit files themselves.
   </para>
   <para>
    For example, to change a single value for the <replaceable>FOOBAR</replaceable> service located in <filename>/usr/lib/systemd/system/<replaceable>FOOBAR.SERVICE</replaceable></filename>, proceed as follows:
   </para>
   <procedure>
    <step>
     <para>
      Create a directory called <filename>/etc/systemd/system/<replaceable>FOOBAR</replaceable>.service.d/</filename>.
     </para>
     <para>
      Note the <literal>.d</literal> suffix.
      The directory must otherwise be named like the service that you want to patch with the drop-in file.
     </para>
    </step>
    <step>
     <para>
      In that directory, create a file <filename><replaceable>your_modification</replaceable>.conf</filename>.
     </para>
     <para>
      Make sure it only contains the line with the value that you want to modify.
     </para>
    </step>
    <step>
     <para>
      Save your changes to the file.
     </para>
    </step>
   </procedure>
   <!--  bsc#1182491 -->
   <note>
    <title>Avoiding name conflicts</title>
    <para>
    To avoid name conflicts between your drop-in files and files shipped by
    &suse;, it is recommended to prefix all drop-in filenames with a two-digit
    number and a dash: for example, <filename>80-override.conf</filename>.
    </para>
    <para>
     The following ranges are reserved:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <literal>0-19</literal> is reserved for &systemd; upstream
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>20-25</literal> is reserved for &systemd; shipped by &suse;
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>26-29</literal> is reserved for &suse; packages (other than systemd)
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>50</literal> is reserved for drop-in files created with <command>systemctl set-property</command>.
      </para>
     </listitem>
    </itemizedlist>
    <para>
    Use a two-digit number above this range to ensure that none of the drop-in
    files shipped by &suse; will override your own drop-in files.
    </para>
    <para>
    You can use <command>systemctl cat $UNIT</command> to list and verify which
    files are taken into account in the units configuration.
    </para>
   </note>
  </sect2>

  <sect2 xml:id="systemd-xinetd-conversion">
   <title>Converting <systemitem>xinetd</systemitem> services to &systemd;</title>
   <para>
    Since the release of &productname; 15, the <systemitem>xinetd</systemitem> infrastructure has been removed.
    This section outlines how to convert existing custom <systemitem>xinetd</systemitem> service files to &systemd; sockets.
   </para>
   <para>
    For each <systemitem>xinetd</systemitem> service file, you need at least two &systemd; unit files: the socket file (<filename>*.socket</filename>) and an associated service file (<filename>*.service</filename>).
    The socket file tells &systemd; which socket to create, and the service file tells &systemd; which executable to start.
   </para>
   <para>
    Consider the following example <systemitem>xinetd</systemitem> service file:
   </para>
<screen>&prompt.root;cat /etc/xinetd.d/example
service example
{
  socket_type = stream
  protocol = tcp
  port = 10085
  wait = no
  user = user
  group = users
  groups = yes
  server = /usr/libexec/example/exampled
  server_args = -auth=bsdtcp exampledump
  disable = no
}</screen>
   <para>
    To convert it to &systemd;, you need the following two matching files:
   </para>
<screen>&prompt.root;cat /usr/lib/systemd/system/example.socket
[Socket]
ListenStream=0.0.0.0:10085
Accept=false

[Install]
WantedBy=sockets.target</screen>
<screen>&prompt.root;cat /usr/lib/systemd/system/example.service
[Unit]
Description=example

[Service]
ExecStart=/usr/libexec/example/exampled -auth=bsdtcp exampledump
User=user
Group=users
StandardInput=socket
</screen>
   <para>
    For a complete list of the &systemd; 'socket' and 'service' file options, refer to the systemd.socket and systemd.service manual pages (<command>man 5 systemd.socket</command>, <command>man 5 systemd.service</command>).
   </para>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-custom-targets">
   <title>Creating custom targets</title>
   <para>
    On System V init &suse; systems, runlevel 4 is unused to allow administrators to create their own runlevel configuration. &systemd; allows you to create any number of custom targets.
    It is suggested to start by adapting an existing target such as <systemitem>graphical.target</systemitem>.
   </para>
   <procedure>
    <step>
     <para>
      Copy the configuration file <filename>/usr/lib/systemd/system/graphical.target</filename> to <filename>/etc/systemd/system/<replaceable>MY_TARGET</replaceable>.target</filename> and adjust it according to your needs.
     </para>
    </step>
    <step>
     <para>
      The configuration file copied in the previous step already covers the required (<quote>hard</quote>) dependencies for the target.
      To also cover the wanted (<quote>soft</quote>) dependencies, create a directory <filename>/etc/systemd/system/<replaceable>MY_TARGET</replaceable>.target.wants</filename>.
     </para>
    </step>
    <step>
     <para>
      For each wanted service, create a symbolic link from <filename>/usr/lib/systemd/system</filename> into <filename>/etc/systemd/system/<replaceable>MY_TARGET</replaceable>.target.wants</filename>.
     </para>
    </step>
    <step>
     <para>
      When you have finished setting up the target, reload the &systemd; configuration to make the new target available:
     </para>
<screen>&prompt.sudo;systemctl daemon-reload</screen>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-boot-systemd-advanced">
  <title>Advanced usage</title>

  <para>
   The following sections cover advanced topics for system administrators.
   For even more advanced &systemd; documentation, refer to Lennart Pöttering's series about &systemd; for administrators at <link xlink:href="http://0pointer.de/blog/projects"/>.
  </para>

  <sect2 xml:id="sec-boot-systemd-advanced-tmp">
   <title>Cleaning temporary directories</title>
   <para>
    &systemd; supports cleaning temporary directories regularly.
    The configuration from the previous system version is automatically migrated and active. <literal>tmpfiles.d</literal>&mdash;which is responsible for managing temporary files&mdash;reads its configuration from <filename>/etc/tmpfiles.d/*.conf</filename>, <filename>/run/tmpfiles.d/*.conf</filename>, and <filename>/usr/lib/tmpfiles.d/*.conf</filename> files.
    Configuration placed in <filename>/etc/tmpfiles.d/*.conf</filename> overrides related configurations from the other two directories (<filename>/usr/lib/tmpfiles.d/*.conf</filename> is where packages store their configuration files).
   </para>
   <para>
    The configuration format is one line per path containing action and path, and optionally mode, ownership, age and argument fields, depending on the action.
    The following example unlinks the X11 lock files:
   </para>
<screen>Type Path               Mode UID  GID  Age Argument
r    /tmp/.X[0-9]*-lock</screen>
   <para>
    To get the status the tmpfile timer:
   </para>
<screen>&prompt.sudo;systemctl status systemd-tmpfiles-clean.timer
systemd-tmpfiles-clean.timer - Daily Cleanup of Temporary Directories
 Loaded: loaded (/usr/lib/systemd/system/systemd-tmpfiles-clean.timer; static)
 Active: active (waiting) since Tue 2018-04-09 15:30:36 CEST; 1 weeks 6 days ago
   Docs: man:tmpfiles.d(5)
         man:systemd-tmpfiles(8)

Apr 09 15:30:36 &wsI; systemd[1]: Starting Daily Cleanup of Temporary Directories.
Apr 09 15:30:36 &wsI; systemd[1]: Started Daily Cleanup of Temporary Directories.</screen>
   <para>
    For more information on temporary files handling, see <command>man 5 tmpfiles.d</command>.
   </para>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-advanced-logging">
   <title>System log</title>
   <para>
    <xref linkend="sec-boot-systemd-basics-services-debugging"/> explains how to view log messages for a given service.
    However, displaying log messages is not restricted to service logs.
    You can also access and query the complete log messages written by &systemd;&mdash;the so-called <quote>Journal</quote>.
    Use the command <command>journalctl</command> to display the complete log messages starting with the oldest entries.
    Refer to <command>man 1 journalctl</command> for options such as applying filters or changing the output format.
   </para>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-advanced-snapshots">
   <title>Snapshots</title>
   <para>
    You can save the current state of &systemd; to a named snapshot and later revert to it with the <command>isolate</command> subcommand.
    This is useful when testing services or custom targets, because it allows you to return to a defined state at any time.
    A snapshot is only available in the current session and will automatically be deleted on reboot.
    A snapshot name must end in <filename>.snapshot</filename>.
   </para>
   <variablelist>
    <varlistentry>
     <term>Create a snapshot</term>
     <listitem>
<screen>&prompt.sudo;systemctl snapshot <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Delete a snapshot</term>
     <listitem>
<screen>&prompt.sudo;systemctl delete <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>View a snapshot</term>
     <listitem>
<screen>&prompt.sudo;systemctl show <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Activate a snapshot</term>
     <listitem>
<screen>&prompt.sudo;systemctl isolate <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <!-- ================================================================== -->

  <!-- bnc#892349 -->

  <sect2 xml:id="sec-boot-systemd-advanced-kernel-modules">
   <title>Loading kernel modules</title>
   <para>
    With &systemd;, kernel modules can automatically be loaded at boot time via a configuration file in <filename>/etc/modules-load.d</filename>.
    The file should be named <replaceable>MODULE</replaceable>.conf and have the following content:
   </para>
<screen># load module <replaceable>MODULE</replaceable> at boot time
<replaceable>MODULE</replaceable></screen>
   <para>
    In case a package installs a configuration file for loading a kernel module, the file gets installed to <filename>/usr/lib/modules-load.d</filename>.
    If two configuration files with the same name exist, the one in <filename>/etc/modules-load.d</filename> tales precedence.
   </para>
   <para>
    For more information, see the <systemitem>modules-load.d(5)</systemitem> man page.
   </para>
  </sect2>

  <!-- fate #316631 -->

  <sect2 xml:id="sec-boot-systemd-advanced-before-local">
   <title>Performing actions before loading a service</title>
   <para>
    With System V init actions that need to be performed before loading a service, needed to be specified in <filename>/etc/init.d/before.local </filename>.
    This procedure is no longer supported with &systemd;.
    If you need to do actions before starting services, do the following:
   </para>
   <variablelist>
    <varlistentry>
     <term>Loading kernel modules</term>
     <listitem>
      <para>
       Create a drop-in file in <filename>/etc/modules-load.d</filename> directory (see <command>man modules-load.d</command> for the syntax)
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Creating Files or Directories, Cleaning-up Directories, Changing Ownership</term>
     <listitem>
      <para>
       Create a drop-in file in <filename>/etc/tmpfiles.d</filename> (see <command>man tmpfiles.d</command> for the syntax)
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Other tasks</term>
     <listitem>
      <para>
       Create a system service file, for example <filename>/etc/systemd/system/before.service</filename>, from the following template:
      </para>
<screen>[Unit]
Before=<replaceable>NAME OF THE SERVICE YOU WANT THIS SERVICE TO BE STARTED BEFORE</replaceable>
[Service]
Type=oneshot
RemainAfterExit=true
ExecStart=<replaceable>YOUR_COMMAND</replaceable>
# beware, executable is run directly, not through a shell, check the man pages
# systemd.service and systemd.unit for full syntax
[Install]
# target in which to start the service
WantedBy=multi-user.target
#WantedBy=graphical.target</screen>
      <para>
       When the service file is created, you should run the following commands (as &rootuser;):
      </para>
<screen>&prompt.sudo;systemctl daemon-reload
&prompt.sudo;systemctl enable before</screen>
      <para>
       Every time you modify the service file, you need to run:
      </para>
<screen>&prompt.sudo;systemctl daemon-reload</screen>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <!-- ================================================================== -->

  <sect2 xml:id="sec-boot-systemd-advanced-cgroups">
   <title>Kernel control groups (cgroups)</title>
   <para>
    On a traditional System V init system it is not always possible to clearly assign a process to the service that spawned it.
    Some services, such as Apache, spawn a lot of third-party processes (for example CGI or Java processes), which themselves spawn more processes.
    This makes a clear assignment difficult or even impossible.
    Additionally, a service may not terminate correctly, leaving some children alive.
   </para>
   <para>
    &systemd; solves this problem by placing each service into its own cgroup. cgroups are a kernel feature that allows aggregating processes and all their children into hierarchical organized groups. &systemd; names each cgroup after its service.
    Since a non-privileged process is not allowed to <quote>leave</quote> its cgroup, this provides an effective way to label all processes spawned by a service with the name of the service.
   </para>
   <para>
    To list all processes belonging to a service, use the command <command>systemd-cgls</command>.
    The result will look like the following (shortened) example:
   </para>
   <example>
    <title>List all processes belonging to a service</title>
<screen>&prompt.root;systemd-cgls --no-pager
├─1 /usr/lib/systemd/systemd --switched-root --system --deserialize 20
├─user.slice
│ └─user-1000.slice
│   ├─session-102.scope
│   │ ├─12426 gdm-session-worker [pam/gdm-password]
│   │ ├─15831 gdm-session-worker [pam/gdm-password]
│   │ ├─15839 gdm-session-worker [pam/gdm-password]
│   │ ├─15858 /usr/lib/gnome-terminal-server

[...]

└─system.slice
  ├─systemd-hostnamed.service
  │ └─17616 /usr/lib/systemd/systemd-hostnamed
  ├─cron.service
  │ └─1689 /usr/sbin/cron -n
  ├─postfix.service
  │ ├─ 1676 /usr/lib/postfix/master -w
  │ ├─ 1679 qmgr -l -t fifo -u
  │ └─15590 pickup -l -t fifo -u
  ├─sshd.service
  │ └─1436 /usr/sbin/sshd -D

[...]</screen>
   </example>
   <para>
    See <xref linkend="cha-tuning-cgroups"/> for more information about cgroups.
   </para>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-advanced-kill">
   <title>Terminating services (sending signals)</title>
   <para>
    As explained in <xref linkend="sec-boot-systemd-advanced-cgroups"/>, it is not always possible to assign a process to its parent service process in a System V init system.
    This makes it difficult to terminate a service and all of its children.
    Child processes that have not been terminated will remain as zombie processes.
   </para>
   <para>
    &systemd;'s concept of confining each service into a cgroup makes it possible to clearly identify all child processes of a service and therefore allows you to send a signal to each of these processes.
    Use <command>systemctl kill</command> to send signals to services.
    For a list of available signals refer to <command>man 7 signals</command>.
   </para>
   <variablelist>
    <varlistentry>
     <term>Sending <systemitem>SIGTERM</systemitem> to a service</term>
     <listitem>
      <para>
       <systemitem>SIGTERM</systemitem> is the default signal that is sent.
      </para>
<screen>&prompt.sudo;systemctl kill <replaceable>MY_SERVICE</replaceable></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Sending <replaceable>SIGNAL</replaceable> to a service</term>
     <listitem>
      <para>
       Use the <option>-s</option> option to specify the signal that should be sent.
      </para>
<screen>&prompt.sudo;systemctl kill -s <replaceable>SIGNAL</replaceable> <replaceable>MY_SERVICE</replaceable></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Selecting processes</term>
     <listitem>
      <para>
       By default the <command>kill</command> command sends the signal to <option>all</option> processes of the specified cgroup.
       You can restrict it to the <option>control</option> or the <option>main</option> process.
       The latter is for example useful to force a service to reload its configuration by sending <systemitem>SIGHUP</systemitem>:
      </para>
<screen>&prompt.sudo;systemctl kill -s SIGHUP --kill-who=main <replaceable>MY_SERVICE</replaceable></screen>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-dbus">
   <title>Important notes on the D-Bus service</title>
   <para>
    The D-Bus service is the message bus for communication between &systemd; clients and the systemd manager that is running as pid 1.
    Even though <systemitem class="daemon">dbus</systemitem> is a stand-alone daemon, it is an integral part of the init infrastructure.
   </para>
   <para>
    Terminating <systemitem class="daemon">dbus</systemitem> or restarting it in the running system is similar to an attempt to terminate or restart pid 1.
    It will break &systemd; client/server communication and make most &systemd; functions unusable.
   </para>
   <para>
    Therefore, terminating or restarting <systemitem
     class="daemon">dbus</systemitem> is neither recommended nor supported.
   </para>
   <para>
    Updating the <systemitem>dbus</systemitem> or <systemitem>dbus</systemitem>-related packages requires a reboot.
    When in doubt whether a reboot is necessary, run the <command>sudo zypper ps -s</command>.
    If <literal>dbus</literal> appears among the listed services, you need to reboot the system.
   </para>
   <para>
    Keep in mind that <systemitem>dbus</systemitem> is updated even when automatic updates are configured to skip the packages that require reboot.
   </para>
  </sect2>

  <!-- debug section should be at the end to be more positive -->

  <sect2 xml:id="sec-boot-systemd-basics-services-debugging">
   <title>Debugging services</title>
   <para>
    By default, &systemd; is not overly verbose.
    If a service was started successfully, no output will be produced.
    In case of a failure, a short error message will be displayed.
    However, <command>systemctl status</command> provides means to debug start-up and operation of a service.
   </para>
   <para>
    &systemd; comes with its own logging mechanism (<quote>The Journal</quote>) that logs system messages.
    This allows you to display the service messages together with status messages.
    The <command>status</command> command works similar to <command>tail</command> and can also display the log messages in different formats, making it a powerful debugging tool.
   </para>
   <variablelist>
    <varlistentry>
     <term>Show service start-up failure</term>
     <listitem>
      <para>
       Whenever a service fails to start, use <command>systemctl status <replaceable>MY_SERVICE</replaceable></command> to get a detailed error message:
      </para>
<screen>&prompt.root;systemctl start apache2
Job failed. See system journal and 'systemctl status' for details.
&prompt.root;systemctl status apache2
   Loaded: loaded (/usr/lib/systemd/system/apache2.service; disabled)
   Active: failed (Result: exit-code) since Mon, 04 Apr 2018 16:52:26 +0200; 29s ago
   Process: 3088 ExecStart=/usr/sbin/start_apache2 -D SYSTEMD -k start (code=exited, status=1/FAILURE)
   CGroup: name=systemd:/system/apache2.service

Apr 04 16:52:26 g144 start_apache2[3088]: httpd2-prefork: Syntax error on line
205 of /etc/apache2/httpd.conf: Syntax error on li...alHost&gt;</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Show last <replaceable>N</replaceable> service messages</term>
     <listitem>
      <para>
       The default behavior of the <command>status</command> subcommand is to display the last ten messages a service issued.
       To change the number of messages to show, use the <option>--lines=<replaceable>N</replaceable></option> parameter:
      </para>
<screen>&prompt.sudo;systemctl status chronyd
&prompt.sudo;systemctl --lines=20 status chronyd</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Show service messages in append mode</term>
     <listitem>
      <para>
       To display a <quote>live stream</quote> of service messages, use the <option>--follow</option> option, which works like <command>tail</command> <option>-f</option>:
      </para>
<screen>&prompt.sudo;systemctl --follow status chronyd</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Messages output format</term>
     <listitem>
      <para>
       The <option>--output=<replaceable>MODE</replaceable></option> parameter allows you to change the output format of service messages.
       The most important modes available are:
      </para>
      <variablelist>
       <varlistentry>
        <term><option>short</option></term>
        <listitem>
         <para>
          The default format.
          Shows the log messages with a human readable time stamp.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><option>verbose</option></term>
        <listitem>
         <para>
          Full output with all fields.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><option>cat</option></term>
        <listitem>
         <para>
          Terse output without time stamps.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-boot-systemd-timer-units">
  <title>&systemd; timer units</title>

  <para>
   Similar to cron, &systemd; timer units provide a mechanism for scheduling jobs on Linux.
   Although &systemd; timer units serve the same purpose as cron, they offer several advantages.
  </para>

  <itemizedlist>
   <listitem>
    <para>
     Jobs scheduled using a timer unit can depend on other &systemd; services.
    </para>
   </listitem>
   <listitem>
    <para>
     Timer units are treated as regular &systemd; services, so can be managed with <command>systemctl</command>.
    </para>
   </listitem>
   <listitem>
    <para>
     Timers can be realtime and monotonic.
    </para>
   </listitem>
   <listitem>
    <para>
     Time units are logged to the &systemd; journal, which makes it easier to monitor and troubleshoot them.
    </para>
   </listitem>
  </itemizedlist>

  <para>
   &systemd; timer units are identified by the <literal>.timer</literal> file name extension.
  </para>

  <sect2 xml:id="sec-boot-systemd-timer-types">
   <title>&systemd; timer types</title>
   <para>
    Timer units can use monotonic and realtime timers.
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Similar to cronjobs, realtime timers are triggered on calendar events.
      Realtime timers are defined using the option <option>OnCalendar</option>.
     </para>
    </listitem>
    <listitem>
     <para>
      Monotonic timers are triggered at a specified time elapsed from a certain starting point.
      The latter could be a system boot or system unit activation event.
      There are several options for defining monotonic timers including <option>OnBootSec</option>, <option>OnUnitActiveSec</option>, and <option>OnTypeSec</option>.
      Monotonic timers are not persistent, and they are reset after each reboot.
     </para>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-timer-service-units">
   <title>&systemd; timers and service units</title>
   <para>
    Every timer unit must have a corresponding &systemd; unit file it controls.
    In other words, a <filename>.timer</filename> file activates and manages the corresponding <filename>.service</filename> file.
    When used with a timer, the <filename>.service</filename> file does not require an <literal>[Install]</literal> section, as the service is managed by the timer.
   </para>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-timer-example">
   <title>Practical example</title>
   <para>
    To understand the basics of &systemd; timer units, we set up a timer that triggers the <filename>foo.sh</filename> shell script.
   </para>
   <para>
    First step is to create a &systemd; service unit that controls the shell script.
    To do this, open a new text file for editing and add the following service unit definition:
   </para>
<screen>[Unit]
Description="Foo shell script"

[Service]
ExecStart=/usr/local/bin/foo.sh</screen>
   <para>
    Save the file under the name <filename>foo.service</filename> in the directory <filename>/etc/systemd/system/</filename>.
   </para>
   <para>
    Next, open a new text file for editing and add the following timer definition:
   </para>
<screen>[Unit]
Description="Run foo shell script"

[Timer]
OnBootSec=5min
OnUnitActiveSec=24h
Unit=foo.service

[Install]
WantedBy=multi-user.target</screen>
   <para>
    The <literal>[Timer]</literal> section in the example above specifies what service to trigger (<literal>foo.service</literal>) and when to trigger it.
    In this case, the option <option>OnBootSec</option> specifies a monotonic timer that triggers the service five minutes after the system boot, while the option <option>OnUnitActiveSec</option> triggers the service 24 hours after the service has been activated (that is, the timer will trigger the service once a day).
    Finally the option <option>WantedBy</option> specifies that the timer should start when the system has reached the multi-user target.
   </para>
   <para>
    Instead of a monotonic timer, you can specify a realtime one using the option <option>OnCalendar</option>.
    The following realtime timer definition triggers the related service unit once a week, starting on Monday at 12:00.
   </para>
<screen>[Timer]
OnCalendar=weekly
Persistent=true</screen>
   <para>
    The option <option>Persistent=true</option> indicates that the service will be triggered immediately after the timer activation if the timer missed the last start time (for example, due to the system being powered off).
   </para>
   <para>
    The option <option>OnCalendar</option> can also be used to define specific dates times for triggering a service using the following format: <literal>DayOfWeek Year-Month-Day Hour:Minute:Second</literal>.
    The example below triggers a service at 5am every day:
   </para>
<screen>OnCalendar=*-*-* 5:00:00</screen>
   <para>
    You can use an asterisk to specify any value, and commas to list possible values.
    Use two values separated by .. to indicate a contiguous range.
    The following example triggers a service at 6pm on Friday of every month:
   </para>
<screen>OnCalendar=Fri *-*-1..7 18:00:00</screen>
   <para>
    To trigger a service at different times, you can specify several <option>OnCalendar</option> entries:
   </para>
<screen>OnCalendar=Mon..Fri 10:00
OnCalendar=Sat,Sun 22:00</screen>
   <para>
    In the example above, a service is triggered at 10am on week days and at 10pm on weekends.
   </para>
   <para>
    When you are done editing the timer unit file, save it under the name <filename>foo.timer</filename> in the <filename>/etc/systemd/system/</filename> directory.
    To check the correctness of the created unit files, run the following command:
   </para>
<screen>&prompt.sudo; systemd-analyze verify /etc/systemd/system/foo.*</screen>
   <para>
    If the command returns no output, the files have passed the verification successfully.
   </para>
   <para>
    To start the timer, use the command <command>sudo systemctl start foo.timer</command>.
    To enable the timer on boot, run the command <command>sudo systemctl enable foo.timer</command>.
   </para>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-timer-manage">
   <title>Managing &systemd; timers</title>
   <para>
    Since timers are treated as regular &systemd; units, you can manage them using <command>systemctl</command>.
    You can start a timer with <command>systemctl start</command>, enable a timer with <command>systemctl enable</command>, and so on.
    In addition to that, you can list all active timers using the command <command>systemctl list-timers</command>.
    To list all timers, including inactive ones, run the command <command>systemctl list-timers --all</command>.
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-boot-systemd-info">
  <title>More information</title>

  <para>
   For more information on &systemd; refer to the following online resources:
  </para>

  <variablelist>
   <varlistentry>
    <term>Homepage</term>
    <listitem>
     <para>
      <link xlink:href="http://www.freedesktop.org/wiki/Software/systemd"/>
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>&systemd; for administrators</term>
    <listitem>
     <para>
      Lennart Pöttering, one of the &systemd; authors, has written a series of blog entries (13 at the time of writing this chapter).
      Find them at <link xlink:href="http://0pointer.de/blog/projects"/>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
</chapter>
