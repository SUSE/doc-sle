<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<!-- Converted by suse-upgrade version 1.1 -->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="cha.qemu.guest_inst">
 <title>Guest Installation</title>
 <info>
      <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
        <dm:bugtracker>
          </dm:bugtracker>
      </dm:docmanager>
    </info>
    <para>
  The <systemitem class="library">libvirt</systemitem>-based tools such as
  <command>virt-manager</command>, <command>virt-install</command>, or
  <command>vm-install</command> offer convenient interfaces to set up and
  manage virtual machines. They act as a kind of wrapper for the
  <command>qemu-system-ARCH</command>command. However, it is also possible
  to use <command>qemu-system-ARCH</command> directly without using
  <systemitem class="library">libvirt</systemitem>-based tools.
 </para>
 <warning>
  <title><command>qemu-system-ARCH</command> and libvirt</title>
  <para>
   <xref linkend="gloss.vt.vm"/>s created with
   <command>qemu-system-ARCH</command> are not "visible" for the
   <systemitem class="library">libvirt</systemitem>-based tools.
  </para>
 </warning>
 <sect1 xml:id="cha.qemu.guest_inst.qemu-kvm">
  <title>Basic Installation with <command>qemu-system-ARCH</command></title>

  <para>
   In the following example, a virtual machine for a &sls; 11
   installation is created. For detailed information on the commands, refer
   to the respective man pages.
  </para>

  <para>
   If you do not already have an image of a system that you want to run in a
   virtualized environment, you need to create one from the installation
   media. In such case, you need to prepare a hard disk image, and obtain an
   image of the installation media or the media itself.
  </para>

  <para>
   Create a hard disk with <command>qemu-img</command>.
  </para>

<screen>qemu-img create<co xml:id="co.qemu-img.create"/> -f raw<co xml:id="co.qemu-img.format"/> /images/sles/hda<co xml:id="co.qemu-img.path"/> 8G<co xml:id="co.qemu-img.size"/></screen>

  <calloutlist>
   <callout arearefs="co.qemu-img.create">
    <para>
     The subcommand <option>create</option> tells
     <command>qemu-img</command> to create a new image.
    </para>
   </callout>
   <callout arearefs="co.qemu-img.format">
    <para>
     Specify the disk's format with the <option>-f</option> parameter.
    </para>
   </callout>
   <callout arearefs="co.qemu-img.path">
    <para>
     The full path to the image file.
    </para>
   </callout>
   <callout arearefs="co.qemu-img.size">
    <para>
     The size of the image&mdash;8 GB in this case. The image is created
     as a <xref linkend="gloss.vt.storage.sparse"/> file that grows when the
     disk is filled with data. The specified size defines the maximum size
     to which the image file can grow.
    </para>
   </callout>
  </calloutlist>

  <para>
   After at least one hard disk image is created, you can set up a virtual
   machine with <command>qemu-system-ARCH</command> that will boot into the
   installation system:
  </para>

<screen>qemu-system-ARCH -name "sles"<co xml:id="co.qemu-kvn.name"/>-machine accel=kvm -M pc<co xml:id="co.qemu-kvm.type"/> -m 768<co xml:id="co.qemu-kvm.memory"/> \
-smp 2<co xml:id="co.qemu-kvm.cpu"/> -boot d<co xml:id="co.qemu-kvm.boot"/> \
-drive file=/images/sles/hda,if=virtio,index=0,media=disk,format=raw<co xml:id="co.qemu-kvm.hdd"/> \
-drive file=/isos/SLES-11-SP3-DVD-x86_64-GM-DVD1.iso,index=1,media=cdrom<co xml:id="co.qemu-kvm.cdrom"/> \
-net nic,model=virtio,macaddr=52:54:00:05:11:11<co xml:id="co.qemu-kvm.nic"/> -net user\
-vga cirrus<co xml:id="co.qemu-kvm.gfx"/> -balloon virtio<co xml:id="co.qemu-kvm.balloon"/></screen>

  <calloutlist>
   <callout arearefs="co.qemu-kvn.name">
    <para>
     Name of the virtual machine that will be displayed in the window
     caption and be used for the VNC server. This name must be unique.
    </para>
   </callout>
   <callout arearefs="co.qemu-kvm.type">
    <para>
     Specifies the machine type. Use <command>qemu-system-ARCH</command>
     <option>-M ?</option> to display a list of valid parameters.
     <literal>pc</literal> is the default <guimenu>Standard PC</guimenu>.
    </para>
   </callout>
   <callout arearefs="co.qemu-kvm.memory">
    <para>
     Maximum amount of memory for the virtual machine.
    </para>
   </callout>
   <callout arearefs="co.qemu-kvm.cpu">
    <para>
     Defines an SMP system with two processors.
    </para>
   </callout>
   <callout arearefs="co.qemu-kvm.boot">
    <para>
     Specifies the boot order. Valid values are <literal>a</literal>,
     <literal>b</literal> (floppy 1 and 2), <literal>c</literal> (first hard
     disk), d<literal/> (first CD-ROM), or <literal>n</literal> to
     <literal>p</literal> (Ether-boot from network adapter 1-3). Defaults to
     <literal>c</literal>.
    </para>
   </callout>
   <callout arearefs="co.qemu-kvm.hdd">
    <para>
     Defines the first (<literal>index=0</literal>) hard disk. It will be
     accessed as a paravirtualized (<literal>if=virtio</literal>) drive in
     <literal>raw</literal> format.
    </para>
   </callout>
   <callout arearefs="co.qemu-kvm.cdrom">
    <para>
     The second (<literal>index=1</literal>) image drive will act as a
     CD-ROM.
    </para>
   </callout>
   <callout arearefs="co.qemu-kvm.nic">
    <para>
     Defines a paravirtualized (<literal>model=virtio</literal>) network
     adapter with the MAC address <literal>52:54:00:05:11:11</literal>. Be
     sure to specify a unique MAC address, otherwise a network conflict may
     occur.
    </para>
   </callout>
   <callout arearefs="co.qemu-kvm.gfx">
    <para>
     Specifies the graphic card. If you specify
     <replaceable>none</replaceable>, the graphic card will be disabled.
    </para>
   </callout>
   <callout arearefs="co.qemu-kvm.balloon">
    <para>
     Defines the paravirtualized balloon device that allows to dynamically
     change the amount of memory (up to the maximum value specified with the
     parameter <option>-m</option>).
    </para>
   </callout>
  </calloutlist>

  <para>
   After the installation of the guest operating system finishes, you can
   easily start the related virtual machine without the need to specify the
   CD-ROM device:
  </para>

<screen>qemu-system-ARCH -name "sles" -machine type=pc,accel=kvm -m 768 \
-smp 2 -boot c \
-drive file=/images/sles/hda,if=virtio,index=0,media=disk,format=raw \
-net nic,model=virtio,macaddr=52:54:00:05:11:11 \
-vga cirrus -balloon virtio
</screen>
 </sect1>
 <sect1 xml:id="cha.qemu.guest_inst.qemu-img">
  <title>Managing Disk Images with <command>qemu-img</command></title>

  <para>
   In the previous section (see
   <xref linkend="cha.qemu.guest_inst.qemu-kvm"/>), we used the
   <command>qemu-img</command> command to create an image of a hard disk.
   You can, however, use <command>qemu-img</command> for general disk image
   manipulation. This section introduces useful <command>qemu-img</command>
   subcommands to help manage the disk images flexibly.
  </para>

  <sect2 xml:id="cha.qemu.guest_inst.qemu-img.general_invocation">
   <title>General Information on qemu-img Invocation</title>
   <para>
    <command>qemu-img</command> uses subcommands (like
    <command>zypper</command> does) to do specific tasks. Each subcommand
    understands a different set of options. Some options are
    general and used by more of these subcommands, while some of them are
    unique to the related subcommand. See the qemu-img manual page
    (<command>man 1 qemu-img</command>) for a complete list of all supported
    options. <command>qemu-img</command> uses the following general syntax:
   </para>
<screen>qemu-img subcommand [options]</screen>
   <para>
    and supports the following subcommands:
   </para>
   <variablelist>
    <varlistentry>
     <term><literal>create</literal>
     </term>
     <listitem>
      <para>
       Creates a new disk image on the file system.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>check</literal>
     </term>
     <listitem>
      <para>
       Checks an existing disk image for errors.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>compare</literal>
     </term>
     <listitem>
      <para>
       Check if two images have the same content.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>map</literal>
     </term>
     <listitem>
      <para>
       Dumps the metadata of the image file name and its backing file chain.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>amend</literal>
     </term>
     <listitem>
      <para>
       Amends the image format specific options for the image file name.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>convert</literal>
     </term>
     <listitem>
      <para>
       Converts an existing disk image to a new one in a different format.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>info</literal>
     </term>
     <listitem>
      <para>
       Displays information about the relevant disk image.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>snapshot</literal>
     </term>
     <listitem>
      <para>
       Manages snapshots of existing disk images.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>commit</literal>
     </term>
     <listitem>
      <para>
       Applies changes made to an existing disk image.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>rebase</literal>
     </term>
     <listitem>
      <para>
       Creates a new base image based on an existing image.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>resize</literal>
     </term>
     <listitem>
      <para>
       Increases or decreases the size of an existing image.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="cha.qemu.guest_inst.qemu-img.create">
   <title>Creating, Converting and Checking Disk Images</title>
   <para>
    This section describes how to create disk images, check their condition,
    convert a disk image from one format to another, and get detailed
    information about a particular disk image.
   </para>
   <sect3 xml:id="cha.qemu.guest_inst.qemu-img.create.create">
    <title>qemu-img create</title>
    <para>
     Use <command>qemu-img create</command> to create a new disk image for
     your &vmguest; operating system. The command uses the following
     syntax:
    </para>
<screen>qemu-img create -f fmt<co xml:id="co.qemu_img.create.f"/> -o options<co xml:id="co.qemu_img.create.o"/> fname<co xml:id="co.qemu_img.create.filename"/> size<co xml:id="co.qemu_img.create.size"/></screen>
    <calloutlist>
     <callout arearefs="co.qemu_img.create.f">
      <para>
       The format of the target image. Supported formats are
       <literal>qed</literal>, <literal>qcow2</literal>, and
       <literal>raw</literal>.
      </para>
     </callout>
     <callout arearefs="co.qemu_img.create.o">
      <para>
       Some image formats support additional options to be passed on
       the command line. You can specify them here with the
       <literal>-o</literal> option. The <literal>raw</literal> image format
       supports only the <literal>size</literal> option, so it is possible
       to insert <literal>-o size=8G</literal> instead of adding the size
       option at the end of the command.
      </para>
     </callout>
     <callout arearefs="co.qemu_img.create.filename">
      <para>
       Path to the target disk image to be created.
      </para>
     </callout>
     <callout arearefs="co.qemu_img.create.size">
      <para>
       Size of the target disk image (if not already specified with the
       <literal>-o size=&lt;image_size&gt;</literal> option. Optional
       suffixes for the image size are <literal>K</literal> (kilobyte),
       <literal>M</literal> (megabyte), <literal>G</literal> (gigabyte), or
       <literal>T</literal> (terabyte).
      </para>
     </callout>
    </calloutlist>
    <para>
     To create a new disk image <filename>sles.raw</filename> in the
     directory <filename>/images</filename> growing up to a maximum size of
     4 GB, run the following command:
    </para>
<screen>&prompt.user;qemu-img create -f raw -o size=4G /images/sles.raw
Formatting '/images/sles.raw', fmt=raw size=4294967296

&prompt.user;ls -l /images/sles.raw
-rw-r--r-- 1 tux users 4294967296 Nov 15 15:56 /images/sles.raw

&prompt.user;qemu-img info /images/sles.raw
image: /images/sles11.raw
file format: raw
virtual size: 4.0G (4294967296 bytes)
disk size: 0
</screen>
    <para>
     As you can see, the <emphasis>virtual</emphasis> size of the newly
     created image is 4 GB, but the actual reported disk size is 0 as no
     data has been written to the image yet.
    </para>
    <tip>
     <title>&vmguest; Images on the Btrfs File System</title>
     <para>
      If you need to create a disk image on the Btrfs file system, you can
      use the <option>nocow=on</option> to reduce the performance
      overhead caused by the copy-on-write feature of Btrfs:
     </para>
<screen>qemu-img create -o nocow=on test.img 8G</screen>
     <para>
      If you, however, want use copy-on-write (for example for
      creating snapshots or sharing them across virtual machines), then
      leave the command line without the <option>nocow</option> option.
     </para>
    </tip>
   </sect3>
   <sect3 xml:id="cha.qemu.guest_inst.qemu-img.create.convert">
    <title>qemu-img convert</title>
    <para>
     Use <command>qemu-img convert</command> to convert disk images to
     another format. To get a complete list of image formats supported by
     &qemu;, run <command>qemu-img</command> <option>-h</option> and look
     at the last line of the output. The command uses the following syntax:
    </para>
<screen>qemu-img convert -c<co xml:id="co.qemu_img.convert.c"/> -f fmt<co xml:id="co.qemu_img.convert.fmt"/> -O out_fmt<co xml:id="co.qemu_img.convert.ofmt"/> -o options<co xml:id="co.qemu_img.convert.o"/> fname<co xml:id="co.qemu_img.convert.fname"/> out_fname<co xml:id="co.qemu_img.convert.ofname"/></screen>
    <calloutlist>
     <callout arearefs="co.qemu_img.convert.c">
      <para>
       Applies compression on the target disk image. Only
       <literal>qcow</literal> and <literal>qcow2</literal> formats support
       compression.
      </para>
     </callout>
     <callout arearefs="co.qemu_img.convert.fmt">
      <para>
       The format of the source disk image. It is usually autodetected
       and can therefore be omitted.
      </para>
     </callout>
     <callout arearefs="co.qemu_img.convert.ofmt">
      <para>
       The format of the target disk image.
      </para>
     </callout>
     <callout arearefs="co.qemu_img.convert.o">
      <para>
       Specify additional options relevant for the target image format. Use
       <literal>-o ?</literal> to view the list of options supported by the
       target image format.
      </para>
     </callout>
     <callout arearefs="co.qemu_img.convert.fname">
      <para>
       Path to the source disk image to be converted.
      </para>
     </callout>
     <callout arearefs="co.qemu_img.convert.ofname">
      <para>
       Path to the converted target disk image.
      </para>
     </callout>
    </calloutlist>
<screen>&prompt.user;qemu-img convert -O vmdk /images/sles.raw \
/images/sles.vmdk

&prompt.user;ls -l /images/
-rw-r--r-- 1 tux users 4294967296 16. lis 10.50 sles.raw
-rw-r--r-- 1 tux users 2574450688 16. lis 14.18 sles.vmdk
</screen>
    <para>
     To see a list of options relevant for the selected target image format,
     run the following command (replace <literal>vmdk</literal> with your
     image format):
    </para>
<screen>&prompt.user;qemu-img convert -O vmdk /images/sles.raw \
/images/sles.vmdk -o ?
Supported options:
size             Virtual disk size
backing_file     File name of a base image
compat6          VMDK version 6 image
subformat        VMDK flat extent format, can be one of {monolithicSparse \
    (default) | monolithicFlat | twoGbMaxExtentSparse | twoGbMaxExtentFlat}
scsi             SCSI image
</screen>
   </sect3>
   <sect3 xml:id="cha.qemu.guest_inst.qemu-img.create.check">
    <title>qemu-img check</title>
    <para>
     Use <command>qemu-img check</command> to check the existing disk image
     for errors. Not all disk image formats support this feature. The
     command uses the following syntax:
    </para>
<screen>qemu-img check -f fmt<co xml:id="co.qemu_img.check.fmt"/> fname<co xml:id="co.qemu_img.check.fname"/></screen>
    <calloutlist>
     <callout arearefs="co.qemu_img.check.fmt">
      <para>
       The format of the source disk image. It is usually autodetected
       and can therefore be omitted.
      </para>
     </callout>
     <callout arearefs="co.qemu_img.check.fname">
      <para>
       Path to the source disk image to be checked.
      </para>
     </callout>
    </calloutlist>
    <para>
     If no error is found, the command returns no output. Otherwise, the
     type and number of errors found is shown.
    </para>
<screen>&prompt.user;qemu-img check -f qcow2 /images/sles.qcow2
ERROR: invalid cluster offset=0x2af0000
[...]
ERROR: invalid cluster offset=0x34ab0000
378 errors were found on the image.
</screen>
   </sect3>
   <sect3 xml:id="cha.qemu.guest_inst.qemu-img.create.incr">
    <title>Increasing the Size of an Existing Disk Image</title>
    <para>
     When creating a new image, you must specify its maximum size before the
     image is created (see
     <xref linkend="cha.qemu.guest_inst.qemu-img.create.create"/>). After
     you have installed the &vmguest; and have been using it for some time, the
     initial size of the image may no longer be sufficient and you may need
     to add more space to it.
    </para>
    <para>
     To increase the size of an existing disk image by 2 Gigabytes, use:
    </para>
<screen>qemu-img resize /images/sles.raw +2GB</screen>
    <note>
     <para>
      You can resize the disk image using the formats <literal>raw</literal>,
      <literal>qcow2</literal> and <literal>qed</literal>.
      To resize an image in another formats, convert it to a supported
      format with <command>qemu-img convert</command> first.
     </para>
    </note>
    <para>
     The image now contains an empty space of 2 GB after the final
     partition. You can resize the existing partitions or add new ones.
    </para>
    <figure>
     <title>New 2GB Partition in Guest &yast; Partitioner</title>
     <mediaobject>
      <imageobject role="fo">
       <imagedata fileref="qemu_guest_partman.png" width="75%" format="PNG"/>
      </imageobject>
      <imageobject role="html">
       <imagedata fileref="qemu_guest_partman.png" width="75%" format="PNG"/>
      </imageobject>
     </mediaobject>
    </figure>
   </sect3>
  </sect2>

  <sect2 xml:id="cha.qemu.guest_inst.qemu-img.snapshots">
   <title>Managing Snapshots of Virtual Machines with qemu-img</title>
   <para>
    <xref linkend="gloss.vt.vm"/> snapshots are snapshots of the complete
    environment in which a &vmguest; is running. The snapshot includes
    the state of the processor (CPU), memory (RAM), devices, and all
    writable disks.
   </para>
   <para>
    Snapshots are helpful when you need to save your virtual machine in a
    particular state. For example, after you configured network services on
    a virtualized server and want to quickly start the virtual machine in
    the same state you last saved it. Or you can create a snapshot after the
    virtual machine has been powered off to create a backup state before you
    try something experimental and possibly make &vmguest; unstable. This
    section introduces the latter case, while the former is described in
    <xref linkend="cha.qemu.monitor"/>.
   </para>
   <para>
    To use snapshots, your &vmguest; must contain at least one writable
    hard disk image in <literal>qcow2</literal> format. This device is
    usually the first virtual hard disk.
   </para>
   <para>
    <xref linkend="gloss.vt.vm"/> snapshots are created with the
    <literal>savevm</literal> command in the interactive &qemu; monitor.
    To make identifying a particular snapshot easier, you can assign it a
    <emphasis>tag</emphasis>. For more information on &qemu; monitor, see
    <xref linkend="cha.qemu.monitor"/>.
   </para>
   <para>
    Once your <literal>qcow2</literal> disk image contains saved snapshots,
    you can inspect them with the <command>qemu-img snapshot</command>
    command.
   </para>
   <warning>
    <title>Shut Down the &vmguest;</title>
    <para>
     Do not create or delete virtual machine snapshots with the
     <command>qemu-img snapshot</command> command while the virtual machine
     is running. Otherwise, you may damage the disk image with the state of
     the virtual machine saved.
    </para>
   </warning>
   <sect3 xml:id="cha.qemu.guest_inst.qemu-img.snapshots.l">
    <title>Listing Existing Snapshots</title>
    <para>
     Use <command>qemu-img snapshot -l</command>
     <replaceable>disk_image</replaceable> to view a list of all existing
     snapshots saved in the <literal>disk_image</literal> image. You can get
     the list even while the &vmguest; is running.
    </para>
<screen>&prompt.user;qemu-img snapshot -l /images/sles.qcow2 
Snapshot list:
ID<co xml:id="co.qemu_img.snapshot.l.id"/>       TAG<co xml:id="co.qemu_img.snapshot.l.tag"/>               VM SIZE<co xml:id="co.qemu_img.snapshot.l.size"/>        DATE<co xml:id="co.qemu_img.snapshot.l.date"/>          VM CLOCK<co xml:id="co.qemu_img.snapshot.l.clock"/>
1         booting                4.4M 2013-11-22 10:51:10   00:00:20.476
2         booted                 184M 2013-11-22 10:53:03   00:02:05.394
3         logged_in              273M 2013-11-22 11:00:25   00:04:34.843
4         ff_and_term_running    372M 2013-11-22 11:12:27   00:08:44.965</screen>
    <calloutlist>
     <callout arearefs="co.qemu_img.snapshot.l.id">
      <para>
       Unique identification number of the snapshot. Usually
       auto-incremented.
      </para>
     </callout>
     <callout arearefs="co.qemu_img.snapshot.l.tag">
      <para>
       Unique description string of the snapshot. It is meant as a
       human-readable version of the ID.
      </para>
     </callout>
     <callout arearefs="co.qemu_img.snapshot.l.size">
      <para>
       The disk space occupied by the snapshot. Note that the more memory is
       consumed by running applications, the bigger the snapshot is.
      </para>
     </callout>
     <callout arearefs="co.qemu_img.snapshot.l.date">
      <para>
       Time and date the snapshot was created.
      </para>
     </callout>
     <callout arearefs="co.qemu_img.snapshot.l.clock">
      <para>
       The current state of the virtual machine's clock.
      </para>
     </callout>
    </calloutlist>
   </sect3>
   <sect3 xml:id="cha.qemu.guest_inst.qemu-img.snapshots.c">
    <title>Creating Snapshots of a Powered-Off Virtual Machine</title>
    <para>
     Use <command>qemu-img snapshot -c</command>
     <replaceable>snapshot_title</replaceable>
     <replaceable>disk_image</replaceable> to create a snapshot of the
     current state of a virtual machine that was previously powered off.
    </para>
<screen>&prompt.user;qemu-img snapshot -c backup_snapshot /images/sles.qcow2</screen>
<screen>&prompt.user;qemu-img snapshot -l /images/sles.qcow2 
Snapshot list:
ID        TAG                 VM SIZE                DATE       VM CLOCK
1         booting                4.4M 2013-11-22 10:51:10   00:00:20.476
2         booted                 184M 2013-11-22 10:53:03   00:02:05.394
3         logged_in              273M 2013-11-22 11:00:25   00:04:34.843
4         ff_and_term_running    372M 2013-11-22 11:12:27   00:08:44.965
5         backup_snapshot           0 2013-11-22 14:14:00   00:00:00.000</screen>
    <para>
     If something breaks in your &vmguest; and you need to restore the
     state of the saved snapshot (ID 5 in our example), power off your
     &vmguest; and execute the following command:
    </para>
<screen>&prompt.user;qemu-img snapshot -a 5 /images/sles.qcow2</screen>
    <para>
     The next time you run the virtual machine with
     <command>qemu-system-ARCH</command>, it will be in the state of
     snapshot number 5.
    </para>
    <note>
     <para>
      The <command>qemu-img snapshot -c</command> command is not related to
      the <literal>savevm</literal> command of &qemu; monitor (see
      <xref linkend="cha.qemu.monitor"/>). For example, you cannot apply a
      snapshot with <command>qemu-img snapshot -a</command> on a snapshot
      created with <literal>savevm</literal> in &qemu;'s monitor.
     </para>
    </note>
   </sect3>
   <sect3 xml:id="cha.qemu.guest_inst.qemu-img.snapshots.d">
    <title>Deleting Snapshots</title>
    <para>
     Use <command>qemu-img snapshot -d</command>
     <replaceable>snapshot_id</replaceable>
     <replaceable>disk_image</replaceable> to delete old or unneeded
     snapshots of a virtual machine. This saves some disk space inside the
     <literal>qcow2</literal> disk image as the space occupied by the
     snapshot data is restored:
    </para>
<screen>&prompt.user;qemu-img snapshot -d 2 /images/sles.qcow2</screen>
   </sect3>
  </sect2>

  <sect2 xml:id="cha.qemu.guest_inst.qemu-img.effect">
   <title>Manipulate Disk Images Effectively</title>
   <para>
    Imagine the following real-life situation: you are a server
    administrator who runs and manages several virtualized operating
    systems. One group of these systems is based on one specific
    distribution, while another group (or groups) is based on different
    versions of the distribution or even on a different (and maybe non-Unix)
    platform. And to make the case even more complex, individual virtual
    guest systems based on the same distribution usually differ according to
    the department and deployment: a file server typically uses a different
    setup and services than a Web server does, while both may still be based
    on &slsreg;.
   </para>
   <para>
    With &qemu; it is possible to create <quote>base</quote> disk images.
    You can use them as template virtual machines. These base images will
    save you plenty of time because you will never need to install the same
    operating system more than once.
   </para>
   <sect3 xml:id="cha.qemu.guest_inst.qemu-img.effect.base_and_derived">
    <title>Base and Derived Images</title>
    <para>
     First, build a disk image as usual and install the target system on it.
     For more information, see
     <xref linkend="cha.qemu.guest_inst.qemu-kvm"/> and
     <xref linkend="cha.qemu.guest_inst.qemu-img.create"/>. Then build a new
     image while using the first one as a base image. The base image is also
     called a <emphasis>backing</emphasis> file. After your new
     <emphasis>derived</emphasis> image is built, never
     boot the base image again, but boot the derived image instead. Several
     derived images may depend on one base image at the same time.
     Therefore, changing the base image can damage the dependencies. While
     using your derived image, &qemu; writes changes to it and uses the
     base image only for reading.
    </para>
    <para>
     It is a good practice to create a base image from a freshly installed
     (and, if needed, registered) operating system with no patches applied
     and no additional applications installed or removed. Later on, you can
     create another base image with the latest patches applied and based on
     the original base image.
    </para>
   </sect3>
   <sect3 xml:id="cha.qemu.guest_inst.qemu-img.effect.create_derived">
    <title>Creating Derived Images</title>
    <note>
     <para>
      While you can use the <literal>raw</literal> format for base images,
      you cannot use it for derived images because the
      <literal>raw</literal> format does not support the
      <literal>backing_file</literal> option. Use for example the
      <literal>qcow2</literal> format for the derived images.
     </para>
    </note>
    <para>
     For example, <filename>/images/sles_base.raw</filename> is the base
     image holding a freshly installed system.
    </para>
<screen>&prompt.user;qemu-img info /images/sles_base.raw 
image: /images/sles_base.raw
file format: raw
virtual size: 4.0G (4294967296 bytes)
disk size: 2.4G</screen>
    <para>
     The image's reserved size is 4 GB, the actual size is 2.4 GB, and its
     format is <literal>raw</literal>. Create an image derived from the
     <filename>/images/sles_base.raw</filename> base image with:
    </para>
<screen>&prompt.user;qemu-img create -f qcow2 /images/sles_derived.qcow2 \
-o backing_file=/images/sles_base.raw 
Formatting '/images/sles_derived.qcow2', fmt=qcow2 size=4294967296 \
backing_file='/images/sles_base.raw' encryption=off cluster_size=0
</screen>
    <para>
     Look at the derived image details:
    </para>
<screen>&prompt.user;qemu-img info /images/sles_derived.qcow2 
image: /images/sles_derived.qcow2
file format: qcow2
virtual size: 4.0G (4294967296 bytes)
disk size: 140K
cluster_size: 65536
backing file: /images/sles_base.raw \
(actual path: /images/sles_base.raw)</screen>
    <para>
     Although the reserved size of the derived image is the same as the size
     of the base image (4 GB), the actual size is 140 KB only. The reason is
     that only changes made to the system inside the derived image are
     saved. Run the derived virtual machine, register it, if needed, and
     apply the latest patches. Do any other changes in the system such as
     removing unneeded or installing new software packages. Then shut the
     &vmguest; down and examine its details once more:
    </para>
<screen>&prompt.user;qemu-img info /images/sles_derived.qcow2
image: /images/sles_derived.qcow2
file format: qcow2
virtual size: 4.0G (4294967296 bytes)
disk size: 1.1G
cluster_size: 65536
backing file: /images/sles_base.raw \
(actual path: /images/sles_base.raw)</screen>
    <para>
     The <literal>disk size</literal> value has grown to 1.1 GB, which is
     the disk space occupied by the changes on the file system compared to
     the base image.
    </para>
   </sect3>
   <sect3 xml:id="cha.qemu.guest_inst.qemu-img.effect.rebase">
    <title>Rebasing Derived Images</title>
    <para>
     After you have modified the derived image (applied patches, installed
     specific applications, changed environment settings, etc.), it reaches the
     desired state. At that point, you may want merge the original base image
     and the derived image to create a new base image.
    </para>
    <para>
     Your original base image (<filename>/images/sles_base.raw</filename>) holds
     a freshly installed system and can be a template for new modified base images,
     while the new one can contain the same system as the first one plus all
     security and update patches applied, for example. After you have
     created this new base image, you can use it as a template for more
     specialized derived images as well. The new base image becomes
     independent of the original one. The process of creating base images
     from derived ones is called <emphasis>rebasing</emphasis>:
    </para>
<screen>&prompt.user;qemu-img convert /images/sles_derived.qcow2 \
-O raw /images/sles_base2.raw</screen>
    <para>
     This command created the new base image
     <filename>/images/sles_base2.raw</filename> using the
     <literal>raw</literal> format.
    </para>
<screen>&prompt.user;qemu-img info /images/sles_base2.raw
image: /images/sles11_base2.raw
file format: raw
virtual size: 4.0G (4294967296 bytes)
disk size: 2.8G</screen>
    <para>
     The new image is 0.4 gigabytes bigger than the original base image. It
     uses no backing file, and you can easily create new derived images
     based upon it. This lets you create a sophisticated hierarchy of
     virtual disk images for your organization, saving a lot of time and
     work.
    </para>
   </sect3>
   <sect3 xml:id="cha.qemu.guest_inst.qemu-img.effect.mount">
    <title>Mounting an Image on a &vmhost;</title>
    <para>
     Sometimes it is useful to mount a virtual disk image under the host
     system. It is strongly recommended to read
     <xref linkend="chap.guestfs"/> and use dedicated tools to access a
     virtual machine image. But if for some reason you need to do it
     manually, just follow this guide.
    </para>
    <para>
     Linux systems can mount an internal partition of a
     <literal>raw</literal> disk image using a loopback device. The first
     example procedure is more complex but more illustrative, while the
     second one is straightforward:
    </para>
    <procedure>
     <title>Mounting Disk Image by Calculating Partition Offset</title>
     <step>
      <para>
       Set a <emphasis>loop</emphasis> device on the disk image whose
       partition you want to mount.
      </para>
<screen>&prompt.user;losetup /dev/loop0 /images/sles_base.raw</screen>
     </step>
     <step>
      <para>
       Find the <emphasis>sector size</emphasis> and the starting
       <emphasis>sector number</emphasis> of the partition you want to
       mount.
      </para>
<screen>&prompt.user;fdisk -lu /dev/loop0

Disk /dev/loop0: 4294 MB, 4294967296 bytes
255 heads, 63 sectors/track, 522 cylinders, total 8388608 sectors
Units = sectors of 1 * 512 = 512<co xml:id="co.qemu_img.loopback.sector_size"/> bytes
Disk identifier: 0x000ceca8

       Device Boot      Start         End      Blocks   Id  System
/dev/loop0p1              63     1542239      771088+  82  Linux swap
/dev/loop0p2   *     1542240<co xml:id="co.qemu_img.loopback.sector_start"/>    8385929     3421845   83  Linux</screen>
      <calloutlist>
       <callout arearefs="co.qemu_img.loopback.sector_size">
        <para>
         The disk sector size.
        </para>
       </callout>
       <callout arearefs="co.qemu_img.loopback.sector_start">
        <para>
         The starting sector of the partition.
        </para>
       </callout>
      </calloutlist>
     </step>
     <step>
      <para>
       Calculate the partition start offset:
      </para>
      <para>
       <literal>sector_size * sector_start = 512 * 1542240 = 789626880
       </literal>
      </para>
     </step>
     <step>
      <para>
       Delete the loop and mount the partition inside the disk image with
       the calculated offset on a prepared directory.
      </para>
<screen>&prompt.user;losetup -d /dev/loop0
&prompt.user;mount -o loop,offset=789626880 \
/images/sles_base.raw /mnt/sles/
&prompt.user;ls -l /mnt/sles/
total 112
drwxr-xr-x   2 root root  4096 Nov 16 10:02 bin
drwxr-xr-x   3 root root  4096 Nov 16 10:27 boot
drwxr-xr-x   5 root root  4096 Nov 16 09:11 dev
[...]
drwxrwxrwt  14 root root  4096 Nov 24 09:50 tmp
drwxr-xr-x  12 root root  4096 Nov 16 09:16 usr
drwxr-xr-x  15 root root  4096 Nov 16 09:22 var
</screen>
     </step>
     <step>
      <para>
       Copy one or more files onto the mounted partition and unmount it when
       finished.
      </para>
<screen>&prompt.user;cp /etc/X11/xorg.conf /mnt/sles/root/tmp
&prompt.user;ls -l /mnt/sles/root/tmp
&prompt.user;umount /mnt/sles/</screen>
     </step>
    </procedure>
<!-- aginies 2014-6-18 kpartx is no more present 

    <procedure>
     <title>Mounting Disk Image while Utilizing <command>kpartx</command></title>
     <step>
      <para>
       Set a <emphasis>loop</emphasis> device on the disk image whose
       partition you want to mount.
      </para>
<screen>&prompt.user;losetup /dev/loop0 /images/sles_base.raw</screen>
     </step>
     <step>
      <para>
       Create a device map from the disk image's partitions.
      </para>
<screen>&prompt.user;kpartx -a /dev/loop0</screen>
     </step>
     <step>
      <para>
       Mount any partition of the disk image on a prepared mount point.
      </para>
<screen>&prompt.user;mount /dev/mapper/loop0p1 /mnt/p1</screen>
      <para>
       You can replace <literal>loop0p1</literal> with the number of the
       partition you want to mount, for example <literal>loop0p3</literal>
       to mount the third partition on the disk image.
      </para>
     </step>
     <step>
      <para>
       Copy or move files or directories to and from the mounted partition
       as you like. Once you finish, unmount the partition and delete the
       loop.
      </para>
<screen>&prompt.user;umount /mnt/p1</screen>
<screen>&prompt.user;losetup -d /dev/loop0</screen>
     </step>
    </procedure>
    -->
    <warning>
     <title>Do not Write to Images Currently in Use</title>
     <para>
      Never mount a partition of an image of a running virtual machine in a
      <literal>read-write</literal> mode. This could corrupt the partition
      and break the whole &vmguest;.
     </para>
    </warning>
   </sect3>
  </sect2>
 </sect1>
</chapter>
