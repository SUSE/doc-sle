<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//Novell//DTD NovDoc XML V1.0//EN" "novdocx.dtd"
[
  <!ENTITY % NOVDOC.DEACTIVATE.IDREF "INCLUDE">
  <!ENTITY % entities SYSTEM "entity-decl.ent">
  %entities;
]>
<chapter id="cha.tuning.power">
 <title>Power Management</title>
<!--
 power management on the server (not mobile computers)
 Info Provider: Thomas Renniger <trenn@suse.de>
-->
 <abstract>
  <para>
   Power management aims at reducing operating costs for energy and cooling
   systems while at the same time keeping the performance of a system at a
   level that matches the current requirements. Thus, power management is
   always a matter of balancing the actual performance needs and power
   saving options for a system. Power management can be implemented and used
   at different levels of the system. A set of specifications for power
   management functions of devices and the operating system interface to
   them has been defined in the Advanced Configuration and Power Interface
   (ACPI). As power savings in server environments can primarily be achieved
   at the processor level, this chapter introduces some of the main concepts
   and highlights some tools for analyzing and influencing relevant
   parameters.
  </para>
 </abstract>
 <sect1 id="sec.tuning.power.cpu">
  <title>Power Management at CPU Level</title>

  <para>
   At the CPU level, you can control power usage in various ways. For
   example by using idling power states (C-states), changing CPU frequency
   (P-states), and throttling the CPU (T-states). The following sections
   give a short introduction to each approach and its significance for power
   savings. Detailed specifications can be found at
   <ulink url="http://www.acpi.info/spec.htm"/>.
  </para>
  
  <sect2 id="sec.tuning.power.cpu.cstates">
   <title>C-States (Processor Operating States)</title>
   <para>
    Modern processors have several power saving modes called
    <literal>C-states</literal>. They reflect the capability of an idle
    processor to turn off unused components in order to save power.
   </para>
   <para>
    When a processor is in the <literal>C0</literal> state, it is executing
    instructions. A processor running in any other C-state is idle. The
    higher the C number, the deeper the CPU sleep mode: more components are
    shut down to save power. Deeper sleep states can save large amounts of
    energy. Their downside is that they introduce latency. This means, it
    takes more time for the CPU to go back to <literal>C0</literal>.
    Depending on workload (threads waking up, triggering CPU usage and then
    going back to sleep again for a short period of time) and hardware (for
    example, interrupt activity of a network device), disabling the deepest
    sleep states can significantly increase overall performance. For details
    on how to do so, refer to
    <xref
   linkend="sec.tuning.power.tools.cpupower.idle-info"/>.
   </para>
   <para>
    Some states also have submodes with different power saving latency
    levels. Which C-states and submodes are supported depends on the
    respective processor. However, <literal>C1</literal> is always
    available.
   </para>
   <para>
    <xref linkend="tab.tuning.power.cstates"/> gives an overview of the most
    common C-states.
   </para>
   <table id="tab.tuning.power.cstates">
    <title>C-States</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>
        <para>
         Mode
        </para>
       </entry>
       <entry>
        <para>
         Definition
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         C0
        </para>
       </entry>
       <entry>
        <para>
         Operational state. CPU fully turned on.
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         C1
        </para>
       </entry>
       <entry>
        <para>
         First idle state. Stops CPU main internal clocks via software. Bus
         interface unit and APIC are kept running at full speed.
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         C2
        </para>
       </entry>
       <entry>
        <para>
         Stops CPU main internal clocks via hardware. State in which the
         processor maintains all software-visible states, but may take
         longer to wake up through interrupts.
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         C3
        </para>
       </entry>
       <entry>
        <para>
         Stops all CPU internal clocks. The processor does not need to keep
         its cache coherent, but maintains other states. Some processors
         have variations of the C3 state that differ in how long it takes to
         wake the processor through interrupts.
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    To avoid needless power consumption, it is recommended to test your
    workloads with deep sleep states enabled versus deep sleep states
    disabled. For more information, refer to
    <xref
    linkend="sec.tuning.power.tools.cpupower.idle-info"/> or the
    <command>cpupower-idle-set(1)</command> man page.
   </para>
  </sect2>

  <sect2 id="sec.tuning.power.cpu.pstates">
   <title>P-States (Processor Performance States)</title>
   <para>
    While a processor operates (in C0 state), it can be in one of several
    CPU performance states <literal>(P-states)</literal>. Whereas C-states
    are idle states (all but C0), <literal>P-states</literal> are
    operational states that relate to CPU frequency and voltage.
   </para>
   <para>
    The higher the P-state, the lower the frequency and voltage at which the
    processor runs. The number of P-states is processor-specific and the
    implementation differs across the various types. However,
    <literal>P0</literal> is always the highest-performance state (except for <xref
     linkend="sec.tuning.cpu.power.turbo"/>). Higher
    P-state numbers represent slower processor speeds and lower power
    consumption. For example, a processor in <literal>P3</literal> state run
    more slowly and uses less power than a processor running in the
    <literal>P1</literal> state. To operate at any P-state, the processor
    must be in the <literal>C0</literal> state, which means that it is
    working and not idling. The CPU P-states are also defined in the ACPI
    specification, see <ulink url="http://www.acpi.info/spec.htm"/>.
   </para>
   <para>
    C-states and P-states can vary independently of one another.
   </para>
  </sect2>

  <sect2 id="sec.tuning.cpu.power.turbo">
   <title>Turbo Features</title>
<!--taroth 2011-09-22: terminology: AMD: Turbo CORE, Intel: Turbo Boost-->
   <para>
    Turbo features allow to dynamically <literal>overtick</literal> active CPU 
    cores while other cores are in deep sleep states. This increases the performance 
    of active threads while still
    complying with Thermal Design Power (TDP) limits.
   </para>
   <para>
    However, the conditions under which a CPU core can use turbo frequencies
    are architecture-specific. Learn how to evaluate the efficiency of those
    new features in <xref linkend="sec.tuning.power.tools.cpupower"/>.
   </para>
  </sect2>
 </sect1>
 
 <!--relates to P-States-->
<!-- <sect1 id="sec.tuning.power.cpufreq">
  <title>The Linux Kernel &cpufreq; Infrastructure</title>



  <para>
   Processor performance states (P-states) and processor operating states
   (C-states) are the capability of a processor to switch between different
   supported operating frequencies and voltages to modulate power
   consumption.
  </para>

  <para>
   To dynamically scale processor frequencies at runtime, you can use the
   &cpufreq; infrastructure to set a static or dynamic power policy for the
   system. Its main components are:
  </para>

  <itemizedlist>
   <listitem>
    <para>
     The &cpufreq; subsystem, which provides a common interface to various
     low-level technologies and high-level policies.
    </para>
   </listitem>
   <listitem>
    <para>
     In-kernel governors, which are policy governors that can change the CPU
     frequency based on different criteria.
    </para>
   </listitem>
   <listitem>
    <para>
     CPU-specific drivers that implement the technology for a particular
     type of processor.
    </para>
   </listitem>
  </itemizedlist>

  <para>
   The dynamic scaling of the clock speed helps to consume less power and
   generate less heat when not operating at full capacity.
  </para>-->

  <sect1 id="sec.tuning.power.governors">
   <title>In-Kernel Governors</title>
  <para> The in-kernel governors belong to the Linux kernel &cpufreq; infrastructure and can be
   used to dynamically scale processor frequencies at runtime. You can think of the governors as a
   sort of preconfigured power scheme for the CPU. The &cpufreq; governors use P-states to
   change frequencies and lower power consumption. The dynamic governors can switch between CPU
   frequencies, based on CPU usage, to allow for power savings while not sacrificing performance.
  </para>
   <para>
    The following governors are available with the &cpufreq; subsystem:
   </para>
   <variablelist>
    <varlistentry>
     <term>Performance Governor</term>
     <listitem>
      <para>
       The CPU frequency is statically set to the highest possible for
       maximum performance. Consequently, saving power is not the focus of
       this governor.
      </para>
      <para>See also <xref linkend="sec.tuning.power.options.p-states"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Powersave Governor</term>
     <listitem>
      <para>
       The CPU frequency is statically set to the lowest possible. This can
       have severe impact on the performance, as the system will never rise
       above this frequency no matter how busy the processors are.
      </para>
      <para>
       However, using this governor often does not lead to the expected
       power savings as the highest savings can usually be achieved at idle
       through entering C-states. With the powersave governor, processes run
       at the lowest frequency and thus take longer to finish. This means it
       takes longer until the system can go into an idle C-state.
      </para>
      <para>
      <remark>taroth 2015-11-19: trenn, is the following correct?</remark>
       For &sle;, the powersave governor is the default governor.???
      </para>
      <para>
       Tuning options: The range of minimum frequencies available to the
       governor can be adjusted (for example, with the
       <command>cpupower</command> command line tool).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>On-demand Governor</term>
     <listitem>
      <para>
       The kernel implementation of a dynamic CPU frequency policy: The
       governor monitors the processor usage. As soon as it exceeds a
       certain threshold, the governor will set the frequency to the highest
       available. If the usage is less than the threshold, the next lowest
       frequency is used. If the system continues to be underemployed, the
       frequency is again reduced until the lowest available frequency is
       set.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <important>
   <title>Drivers and In-kernel Governors</title>
   <para>Not all drivers use the in-kernel governors to dynamically scale power frequency at
    runtime. For example, the <literal>intel_pstate</literal> adjusts power frequency itself. Use
    the <command>cpupower frequency-info</command> command to find out which driver your system
    uses.</para>
   <para>By default, the <literal>intel_pstate</literal> driver uses a similar policy like the
    powersave governor. However, you can also make <literal>intel_pstate</literal> statically set
    CPU frequency to the highest possible value, similar to using the performance governor. See
     <xref linkend="sec.tuning.power.options.p-states"/> for how to do so.</para>
   </important>
  </sect1>

  <!--<sect2 id="sec.tuning.power.cpufreq.files">
   <title>Related Files and Directories</title>
   <para>
    If the &cpufreq; subsystem in enabled on your system (which it is by
    default with &sls;), you can find the relevant files and directories
    under <filename>/sys/devices/system/cpu/</filename>. If you list the
    contents of this directory, you will find a
    <filename>cpu{0..x}</filename> subdirectory for each processor, and
    several other files and directories. A <filename>cpufreq</filename>
    subdirectory in each processor directory holds a number of files and
    directories that define the parameters for &cpufreq;. Some of them are
    writable (for &rootuser;), some of them are read-only. If your system
    currently uses the on-demand or conservative governor, you will see a
    separate subdirectory for those governors in
    <filename>cpufreq</filename>, containing the parameters for the
    governors.
   </para>
   <note>
    <title>Different Processor Settings</title>
    <para>
     The settings under the <filename>cpufreq</filename> directory can be
     different for each processor. If you want to use the same policies
     across all processors, you need to adjust the parameters for each
     processor. Instead of looking up or modifying the current settings
     manually (in <filename>/sys/devices/system/cpu*/cpufreq</filename>), we
     advise to use the tools provided by the
     <systemitem class="resource"
     >cpupower</systemitem> package for that.
    </para>
   </note>
  </sect2>
 </sect1>
 -->
 <sect1 id="sec.tuning.power.tools.cpupower">
  <title>The <systemitem class="resource">cpupower</systemitem> Tools</title>
   <para>The <command>cpupower</command> tools are designed to give an
      overview of <emphasis>all</emphasis> CPU power-related parameters that
      are supported on a given machine, including turbo (or boost) states.
      Use the tool set to view and modify settings of the kernel-related
      &cpufreq; and cpuidle systems as well as other settings not related to
      frequency scaling or idle states. The integrated monitoring framework
      can access both kernel-related parameters and hardware statistics and
      is thus ideally suited for performance benchmarks. It also helps you
      to identify the dependencies between turbo and idle states.
   </para>
   <para> After installing the <systemitem class="resource">cpupower</systemitem> package, view the
   available <command>cpupower</command> subcommands with
   <command>cpupower&nbsp;--help</command>. Access the general man page with
   <command>man&nbsp;cpupower</command>, and the man pages of the subcommands with
   <command>man&nbsp;cpupower-<replaceable>subcommand</replaceable></command>. 
   </para>
   
   <sect2 id="sec.tuning.power.tools.cpupower.freq-info">
    <title>Viewing Current Settings with <command>cpupower</command></title>
    <para>
     The <command>cpupower&nbsp;frequency-info</command> command shows the
     statistics of the cpufreq driver used in the Kernel. Additionally, it
     shows if turbo (boost) states are supported and enabled in the BIOS.
     Run without any options, it shows an output similar to the following:
    </para>
    <example>
     <title>Example Output of <command>cpupower frequency-info</command></title>
     <screen>&prompt.root;cpupower frequency-info
analyzing CPU 0:
  driver: intel_pstate
  CPUs which run at the same hardware frequency: 0
  CPUs which need to have their frequency coordinated by software: 0
  maximum transition latency: 0.97 ms.
  hardware limits: 1.20 GHz - 3.80 GHz
  available cpufreq governors: performance, powersave
  current policy: frequency should be within 1.20 GHz and 3.80 GHz.
                  The governor "powersave" may decide which speed to use
                  within this range.
  current CPU frequency is 3.40 GHz (asserted by call to hardware).
  boost state support:
    Supported: yes
    Active: yes
    3500 MHz max turbo 4 active cores
    3600 MHz max turbo 3 active cores
    3600 MHz max turbo 2 active cores
    3800 MHz max turbo 1 active cores</screen>
    </example>
    <para>
     To get the current values for all CPUs, use
     <command>cpupower&nbsp;-c&nbsp;all&nbsp;frequency-info</command>.
    </para>
   </sect2>
   <sect2 id="sec.tuning.power.tools.cpupower.idle-info">
    <title>Viewing and Modifying Kernel Idle Statistics with <command>cpupower</command></title>
    <para>
     The <command>idle-info</command> subcommand shows the statistics of the
     cpuidle driver used in the Kernel. It works on all architectures that
     use the cpuidle Kernel framework.
    </para>
    <example>
     <title>Example Output of <command>cpupower idle-info</command></title>
     <screen>&prompt.root;cpupower idle-info
CPUidle driver: intel_idle
CPUidle governor: menu
 
Analyzing CPU 0:
Number of idle states: 6
Available idle states: POLL C1-SNB C1E-SNB C3-SNB C6-SNB C7-SNB
POLL (DISABLED) :
Flags/Description: CPUIDLE CORE POLL IDLE
Latency: 0
Usage: 21734693
Duration: 613504305994
C1-SNB (DISABLED) :
Flags/Description: MWAIT 0x00
Latency: 2
Usage: 119654
Duration: 20118368
C1E-SNB (DISABLED) :
Flags/Description: MWAIT 0x01
Latency: 10
Usage: 6427967
Duration: 254096547488
C3-SNB (DISABLED) :
Flags/Description: MWAIT 0x10
Latency: 80
Usage: 852784
Duration: 24899712761
C6-SNB (DISABLED) :
Flags/Description: MWAIT 0x20
Latency: 104
Usage: 12768172
Duration: 1205627344418
C7-SNB (DISABLED) :
Flags/Description: MWAIT 0x30
Latency: 109
Usage: 16370427
Duration: 1017120948058</screen>
    </example>
    <para>
     After finding out which processor idle states are supported with
     <command>cpupower idle-info</command>, individual states can be
     disabled using the <command>cpupower idle-set</command> command.
     Typically one wants to disable the deepest sleep state, for example:
    </para>
<screen>cpupower idle-set -d 4</screen>
    <para>You can make this changes permanent as described in <xref
     linkend="sec.tuning.power.options-c.states"/>. But before you do
    so, check for performance or power impact.</para>
   </sect2>
   <sect2 id="sec.tuning.power.tools.cpupower.monitor">
    <title>Monitoring Kernel and Hardware Statistics with <command>cpupower</command></title>
    <para>
     Use the <command>monitor</command> subcommand to report processor topology, and monitor frequency
     and idle power state statistics over a certain period of time. The
     default interval is <literal>1</literal> second, but it can be changed
     with the <option>-i</option>. Independent processor sleep states and
     frequency counters are implemented in the tool&mdash;some retrieved
     from kernel statistics, others reading out hardware registers. The
     available monitors depend on the underlying hardware and the system.
     List them with <command>cpupower&nbsp;monitor&nbsp;-l</command>. For a
     description of the individual monitors, refer to the cpupower-monitor
     man page.
    </para>
    <para>
     The <command>monitor</command> subcommand allows you to execute
     performance benchmarks. To compare Kernel statistics with hardware
     statistics for specific workloads, concatenate the respective command, for example:</para>
    
     <screen><command>cpupower</command> <option>monitor</option> db_test.sh</screen>
    <example id="ex.cpupower.monitor">
     <title>Example <command>cpupower monitor</command> Output</title>
<screen>&prompt.root;cpupower monitor 
|Mperf               || Idle_Stats
 <co id="co.cpupower.mon.mperf"/>&nbsp;                     <co id="co.cpupower.mon.idle"/>&nbsp;
CPU | C0   | Cx   | Freq || POLL | C1   | C2   | C3
   0|  3.71| 96.29|  2833||  0.00|  0.00|  0.02| 96.32
   1| 100.0| -0.00|  2833||  0.00|  0.00|  0.00|  0.00
   2|  9.06| 90.94|  1983||  0.00|  7.69|  6.98| 76.45
   3|  7.43| 92.57|  2039||  0.00|  2.60| 12.62| 77.52
     </screen>
     <calloutlist>
      <callout arearefs="co.cpupower.mon.mperf">
       <para>
        Mperf shows the average frequency of a CPU, including boost
        frequencies, over a period of time. Additionally, it shows the
        percentage of time the CPU has been active (<literal>C0</literal>)
        or in any sleep state (<literal>Cx</literal>). The default sampling
        rate is <literal>1</literal> second and the values are read directly
        from the hardware registers. As the turbo states are managed by the
        BIOS, it is impossible to get the frequency values at a given
        instant. On modern processors with turbo features the Mperf monitor
        is the only way to find out about the frequency a certain CPU has
        been running in.
       </para>
      </callout>
      <callout arearefs="co.cpupower.mon.idle">
       <para>
        Idle_Stats shows the statistics of the cpuidle kernel subsystem. The
        kernel updates these values every time an idle state is entered or
        left. Therefore there can be some inaccuracy when cores are in an
        idle state for some time when the measure starts or ends.
       </para>
      </callout>
     </calloutlist>
     <para>
      Apart from the (general) monitors in the example above, other
      architecture-specific monitors are available. For detailed
      information, refer to the <command>cpupower-monitor</command> man
      page.
     </para>
    </example>
    <para>
     By comparing the values of the individual monitors, you can find
     correlations and dependencies and evaluate how well the power saving
     mechanism works for a certain workload. In
     <xref linkend="ex.cpupower.monitor" xrefstyle="select:label"/> you can
     see that CPU <literal>0</literal> is idle (the value of
     <literal>Cx</literal> is near 100%), but runs at a very high frequency.
     This is because the CPUs <literal>0</literal> and <literal>1</literal>
     have the same frequency values which means that there is a dependency
     between them.
    </para>
   </sect2>
   <sect2 id="sec.tuning.power.tools.cpupower.freq-set">
    <title>Modifying Current Settings with <command>cpupower</command></title>
    <para>
     You can use
     <command>cpupower&nbsp;frequency-set</command> command as &rootuser; to
     modify current settings. It allows you to set values for the minimum or
     maximum CPU frequency the governor may select or to create a new
     governor. With the <option>-c</option> option, you can also specify for
     which of the processors the settings should be modified. That makes it
     easy to use a consistent policy across all processors without adjusting
     the settings for each processor individually. For more details and the
     available options, refer to the
     <command>cpupower-freqency-set</command> man page or run
     <command>cpupower&nbsp;frequency-set <option>--help</option></command>.
    </para>
   </sect2>
  </sect1>

  <sect1 id="sec.tuning.power.tools.powertop" os="sled">
   <title>Monitoring Power Consumption with &powertop;</title>
    <para>
    You can monitor system power consumption with
    &powertop;. It helps you to identify the reasons for unnecessary high
    power consumption (for example, processes that are mainly responsible
    for waking up a processor from its idle state) and to optimize your
    system settings to avoid these. It supports both Intel and AMD
    processors. The <systemitem class="resource">powertop</systemitem>
    package is available from the &sle; SDK. For information on how to
    access the SDK, refer to <xref linkend="preface.tuning"/>.
   </para>
   <para>
    &powertop; combines various sources of information (analysis of
    programs, device drivers, kernel options, amounts and sources of
    interrupts waking up processors from sleep states) and shows them in one
    screen. <xref linkend="ex.tuning.power.powertop"/> shows which
    information categories are available:
   </para>
   <example id="ex.tuning.power.powertop">
    <title>Example &powertop; Output</title>
<screen>Cn               Avg  residency       P-states   (frequencies)
<co id="co.powertop.cstates"/>&nbsp;                <co id="co.powertop.avg"/>&nbsp;     <co id="co.powertop.residency"/>&nbsp;             <co id="co.powertop.pstates"/>&nbsp;           <co id="co.powertop.freq"/>
C0 (cpu running)        (11.6%)       2.00 Ghz       0.1%
polling         0.0ms   ( 0.0%)       2.00 Ghz       0.0%
C1              4.4ms   (57.3%)       1.87 Ghz       0.0%
C2             10.0ms   (31.1%)       1064 Mhz      99.9%


Wakeups-from-idle per second : 11.2     interval: 5.0s <co id="co.powertop.wakeups"/>
no ACPI power usage estimate available <co id="co.powertop.power"/>
<?dbsuse-fo font-size="0.7em"?>
Top causes for wakeups: <co id="co.powertop.culprits"/>
96.2% (826.0)       &lt;interrupt&gt; : extra timer interrupt
 0.9% (  8.0)     &lt;kernel core&gt; : usb_hcd_poll_rh_status (rh_timer_func)
 0.3% (  2.4)       &lt;interrupt&gt; : megasas
 0.2% (  2.0)     &lt;kernel core&gt; : clocksource_watchdog (clocksource_watchdog)
 0.2% (  1.6)       &lt;interrupt&gt; : eth1-TxRx-0
 0.1% (  1.0)       &lt;interrupt&gt; : eth1-TxRx-4

[...]

Suggestion: <co id="co.powertop.suggestions"/> Enable SATA ALPM link power management via:
echo min_power > /sys/class/scsi_host/host0/link_power_management_policy
or press the S key.</screen>
    <calloutlist>
     <callout arearefs="co.powertop.cstates">
      <para>
       The column shows the C-states. When working, the CPU is in state
       <literal>0</literal>, when resting it is in some state greater than
       <literal>0</literal>, depending on which C-states are available and
       how deep the CPU is sleeping.
      </para>
     </callout>
     <callout arearefs="co.powertop.avg">
      <para>
       The column shows average time in milliseconds spent in the particular
       C-state.
      </para>
     </callout>
     <callout arearefs="co.powertop.residency">
      <para>
       The column shows the percentages of time spent in various C-states.
       For considerable power savings during idle, the CPU should be in
       deeper C-states most of the time. In addition, the longer the average
       time spent in these C-states, the more power is saved.
      </para>
     </callout>
     <callout arearefs="co.powertop.pstates">
      <para>
       The column shows the frequencies the processor and kernel driver
       support on your system.
      </para>
     </callout>
     <callout arearefs="co.powertop.freq">
      <para>
       The column shows the amount of time the CPU cores stayed in different
       frequencies during the measuring period.
      </para>
     </callout>
     <callout arearefs="co.powertop.wakeups">
      <para>
       Shows how often the CPU is awoken per second (number of interrupts).
       The lower the number, the better. The <literal>interval</literal>
       value is the &powertop; refresh interval which can be controlled with
       the <option>-t</option> option. The default time to gather data is 5
       seconds.
      </para>
     </callout>
     <callout arearefs="co.powertop.power">
      <para>
       When running &powertop; on a laptop, this line displays the ACPI
       information on how much power is currently being used and the
       estimated time until discharge of the battery. On servers, this
       information is not available.
      </para>
     </callout>
     <callout arearefs="co.powertop.culprits">
      <para>
       Shows what is causing the system to be more active than needed.
       &powertop; displays the top items causing your CPU to awake during
       the sampling period.
      </para>
     </callout>
     <callout arearefs="co.powertop.suggestions">
      <para>
       Suggestions on how to improve power usage for this machine.
      </para>
     </callout>
    </calloutlist>
   </example>
   <para>
    For more information, refer to the &powertop; project page at
    <ulink url="https://01.org/powertop"/>.
   </para>
  </sect1>

 <sect1 id="sec.tuning.power.options">
  <title>Special Tuning Options</title>

  <para>
   The following sections highlight some of the most relevant settings that
   you might want to touch.
  </para>

 
  <sect2 id="sec.tuning.power.options.p-states">
   <title>Tuning Options for P-States</title>
   <para>
    The &cpufreq; subsystem offers several tuning options for P-states: You
    can switch between the different governors, influence minimum or maximum
    CPU frequency to be used or change individual governor parameters.
   </para>
   <para>
    To switch to another governor at runtime, use
    <command>cpupower&nbsp;frequency-set</command> with the <option>-g</option> option. For
    example, running the following command (as &rootuser;) will activate the
    performance governor:
   </para>
<screen>cpupower frequency-set -g performance</screen>
   <para>
    To set values for the minimum or maximum CPU frequency the governor may
    select, use the <option>-d</option> or <option>-u</option> option,
    respectively.
   </para>
   <para>
    If you want to disable dynamic processor frequency scaling and want the change 
    to persist also after a reboot or shutdown, use the parameter 
    <literal>CPUFREQ_PERFORMANCE_GOVERNOR</literal> <remark>taroth 2015-11-19: trenn, please check
     if the name is still up-to-date!</remark>in 
    <filename>/etc/sysconfig/cpupower.conf</filename>.
   </para>
   
   <!--/etc/sysconfig/cpupower
    
    # Config file for cpupower oneshot configuration
    # This is about power savings vs performance CPU settings
    # These are set once at boot up or get adjusted if service is restarted
    
    #
    ## Description: Disable processor frequency scaling
    ## Type:        yesno
    ## Default:     no
    #
    # Enable the processor frequency performance governor which is equal to
    # disable dynamic processor frequency scaling.
    # This makes sense (depending on your CPU):
    #   - for better performance
    #   - on latest CPUs better power savings: Work is done quicker and the more
    #     efficient processor sleep states are entered quicker and longer
    #   - benchmarking of workloads
    #
    # Only disables dynamic frequency scaling and enables frequency performance
    # mode, the value "no" has no effect
    #
    CPUFREQ_PERFORMANCE_GOVERNOR="no"
    
   -->
  </sect2>

  <sect2 id="sec.tuning.power.options-c.states">
   <title>Tuning Options for C-states</title>
   
   
   <!--/etc/sysconfig/cpupower
    
    # Config file for cpupower oneshot configuration
    # This is about power savings vs performance CPU settings
    # These are set once at boot up or get adjusted if service is restarted
    
    #
    ## Descripion: Disable processor sleep states by latency
    ## Type:       integer(1:)
    ## Default:    ""
    #
    # The value is in microseconds.
    #
    # There are fake sleep states (POLL) from the kernel which cannot
    # be switched off. Also C1 (x86) should not get disabled.
    # See cpupower-idle-info(1) and cpupower-monitor to examine supported processor
    # idle states on your system and which one got disabled by below variable.
    #
    # Disabling specific C-states may affect the ability of the processor to
    # enter extreme high frequencies (also called turbo or boost modes) which
    # may contradict with what you want to achieve (better performance). This
    # very much depends of the type of your CPU (energy efficient ones).
    #
    # To re-enable all sleep states again, use cpupower idle-set -E manually or
    # add a value which is bigger than the longest taking latency of supported
    # sleep states.
    #
    MAXIMUM_CPU_SLEEP_LATENCY=""
   -->
   <para>
    <remark>taroth 2015-11-19: todo - according to trenn, we need to discuss the following paras once
   more</remark>To disable processor sleep states depending on latency, use the
     <literal>MAXIMUM_CPU_SLEEP_LATENCY</literal> variable in
     <filename>/etc/sysconfig/cpupower.conf</filename>. <remark>taroth 2015-11-11: trenn, is the
     following correct?</remark> All sleep states that have a higher latency than the value (in
    microseconds)that you set for <literal>MAXIMUM_CPU_SLEEP_LATENCY</literal> will be disabled.
   </para>
   <para>However, use <command>cpupower-idle-info</command> and <command>cpupower-monitor</command>
    to examine the supported processor idle states on your system and which one got disabled by the
    variable, because disabling specific C-states may affect the ability of the processor to enter
    extreme high frequencies (also called turbo features), which may contradict what you want to
    achieve (better performance).</para>
  </sect2>
 </sect1>

 <sect1 id="sec.tuning.power.trouble">
  <title>Troubleshooting</title>

  <variablelist>
   <varlistentry>
    <term>BIOS options enabled?</term>
    <listitem>
     <para>
      In order to make use of C-states or P-states, check your BIOS options:
     </para>
     <itemizedlist>
      <listitem>
       <para>
        To use C-states, make sure to enable <literal>CPU C State</literal>
        or similar options to benefit from power savings at idle.
       </para>
      </listitem>
      <listitem>
       <para>
        To use P-states and the &cpufreq; governors, make sure to enable
        <literal>Processor Performance States</literal> options or similar.
       </para>
      </listitem>
     </itemizedlist>
     <para>
      In case of a CPU upgrade, make sure to upgrade your BIOS, too. The
      BIOS needs to know the new CPU and its frequency stepping in order to
      pass this information on to the operating system.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Log file information?</term>
    <listitem>
     <para>
      Check the &systemd; journal (see <xref linkend="cha.journalctl"/>) for
      any output regarding the &cpufreq; subsystem. Only severe errors are
      reported there.
     </para>
     <para>
      If you suspect problems with the &cpufreq; subsystem on your machine,
      you can also enable additional debug output. To do so, either use
      <command>cpufreq.debug=7</command> as boot parameter or execute the
      following command as &rootuser;:
     </para>
<screen>echo 7 > /sys/module/cpufreq/parameters/debug</screen>
     <para>
      This will cause &cpufreq; to log more information to
      <command>dmesg</command> on state transitions, which is useful for
      diagnosis. But as this additional output of kernel messages can be
      rather comprehensive, use it only if you are fairly sure that a
      problem exists.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 
 <sect1 id="sec.tuning.power.more">
  <title>For More Information</title>

  <itemizedlist>
   <listitem>
    <para>
     Platforms with a Baseboard Management Controller (BMC) may have
     additional power management configuration options accessible via the
     service processor. These configurations are vendor specific and
     therefore not subject of this guide. For more information, refer to the
     manuals provided by your vendor. For example, <citetitle>HP ProLiant
     Server Power Management on SUSE Linux Enterprise Server
     11&mdash;Integration Note </citetitle> provides detailed information
     how the HP platform specific power management features interact with
     the Linux Kernel. The paper is available from
     <ulink
      url="http://h18004.www1.hp.com/products/servers/technology/whitepapers/os-techwp.html"
     />.
    </para>
   </listitem>
   
   <listitem os="sled">
    <para>
     For more information about &powertop;, refer to
     <ulink url="https://01.org/powertop"/>.
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
</chapter>
