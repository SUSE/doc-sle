<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="storage_filesystems.xml" version="5.0" xml:id="cha-filesystems" xml:lang="zh-cn">
 <title>Linux 中文件系统的概述</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
  <abstract>
   <para>
    <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 随附了不同的文件系统供您选择，包括 Btrfs、Ext4、Ext3、Ext2 和 XFS。每个文件系统都有各自的优点和缺点。有关 <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 中主要文件系统的并排功能比较，请参见 <link xlink:href="https://www.suse.com/releasenotes/x86_64/SUSE-SLES/15-SP3/#file-system-comparison"/>（<citetitle>支持的文件系统比较</citetitle>）。本章概述了这些文件系统的工作原理以及它们的优点。
   </para>
  </abstract>
 </info>
 <para>
  在 SUSE Linux Enterprise 12 中，Btrfs 是操作系统的默认文件系统，XFS 是所有其他使用案例的默认文件系统。此外，SUSE 仍继续支持 Ext 系列的文件系统以及 OCFS2。根据默认设置，Btrfs 文件系统将设置为使用子卷。对于使用 snapper 基础结构的根文件系统，将会自动启用快照。有关 snapper 的详细信息，请参见<xref linkend="cha-snapper"/>。
 </para>
 <para>
  专业的高性能设置可能需要高可用性的储存系统。为符合高性能群集案例的要求，<phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 在 High Availability Extension 附加产品中加入了 OCFS2（Oracle Cluster File System 2) 与 Distributed Replicated Block Device (DRBD)。本指南中不涉及这些高级储存系统的内容。有关信息，请参见<link xlink:href="https://documentation.suse.com/sle-ha-15/html/SLE-HA-all/book-administration.html">
  <citetitle><citetitle>《SUSE Linux Enterprise High Availability Extension 管理指南》</citetitle></citetitle></link>。
 </para>
 <para>
  记住一点很重要：没有任何一种文件系统适合所有种类的应用。每个文件系统都有各自的特定优点和缺点，必须将这些因素考虑在内。此外，即使是最复杂的文件系统也不能替代合理的备份策略。
 </para>
 <para>
  本节中使用的术语<emphasis>数据完整性</emphasis>和<emphasis>数据一致性</emphasis>并不是指用户空间数据（您的应用程序写入其文件的数据）的一致性。此数据是否一致必须由应用程序本身控制。
 </para>
 <para>
  除非本节特别指明，否则设置或更改分区以及文件系统所需的一切步骤，都可以使用 YaST 分区程序（强烈推荐使用）来执行。有关信息，请参见<xref linkend="cha-expert-partitioner"/>。
 </para>
 <sect1 xml:id="sec-filesystems-glossary">
  <title>术语</title>

  <variablelist>
   <varlistentry>
    <term>元数据</term>
    <listitem>
     <para>
      文件系统内部的一种数据结构。它可确保磁盘上的所有数据都有条不紊，并且可供访问。几乎每一种文件系统都有自己的元数据结构，这也是文件系统展现出不同性能特性的原因所在。维护元数据的完整性非常重要，因为如果不这样，则可能无法访问文件系统中的所有数据。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>inode</term>
    <listitem>
     <para>
      文件系统的数据结构包含文件的各种信息，包括大小、链接数量、实际储存文件内容的磁盘块的指针、创建、修改和访问的日期与时间。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>日志</term>
    <listitem>
     <para>
      在提及文件系统时，日志是包含某种日志的磁盘上结构，文件系统将要对文件系统的元数据进行的更改储存在此日志中。日志可大大降低文件系统的恢复时间，因为有了它就不需要在系统启动时执行文件系统全面检查这一冗长的搜索程序。而只是重放日志。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 xml:id="sec-filesystems-major-btrfs">
  <title>Btrfs</title>

  <para>
   Brtfs 是由 Chris Mason 开发的一种写时复制 (COW) 文件系统。它基于 Ohad Rodeh 开发的适用于 COW 的 B 树。Btrfs 是日志记录样式的文件系统。它不记录块更改，而是将块更改写入新位置，然后链接上更改。新更改在上一次写后才提交。
  </para>

  <sect2 xml:id="sec-filesystems-major-btrfs-features">
   <title>主要功能：</title>
   <para>
    Btrfs 提供容错、修复和易于管理的功能，比如：
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>
      可写快照，允许应用更新后按需轻松回滚系统或允许备份文件。
     </para>
    </listitem>
    <listitem>
     <para>
      子卷支持：Btrfs 会在为其指派的空间池中创建默认子卷。它允许您在相同空间池中创建更多的子卷，作为不同的文件系统。子卷的数目仅受分配给池的空间所限。
     </para>
    </listitem>
    <listitem>
     <para>
      Btrfs 命令行工具中提供了在线检查和修复功能 <command>scrub</command>。它会在假设树状结构没有问题的前提下，验证数据和元数据的完整性。您可以在安装的文件系统上定期运行 scrub；正常操作期间，它将在后台运行。
     </para>
    </listitem>
    <listitem>
     <para>
      不同 RAID 级别，适用于元数据和用户数据。
     </para>
    </listitem>
    <listitem>
     <para>
      用于元数据和用户数据的不同校验和，可改进错误检测。
     </para>
    </listitem>
    <listitem>
     <para>
      与 Linux 逻辑卷管理器 (LVM) 储存对象集成。
     </para>
    </listitem>
    <listitem>
     <para>
      与 <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 上的 YaST 分区程序及 AutoYaST 整合。这还包括在多个设备 (MD) 和设备映射程序 (DM) 储存配置上创建 Btrfs 文件系统。
     </para>
    </listitem>
    <listitem>
     <para>
      从现有的 Ext2、Ext3 以及 Ext4 文件系统进行脱机迁移。
     </para>
    </listitem>
    <listitem>
     <para>
      <filename>/boot</filename> 的引导加载程序支持，允许从 Btrfs 分区引导。
     </para>
    </listitem>
    <listitem>
     
     <para>
      <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> <phrase role="productnumber"><phrase os="sles;sled"> }15 SP4</phrase></phrase> 中的 RAID0、RAID1 和 RAID10 配置文件支持多卷 Btrfs。更高的 RAID 级别尚不受支持，但安装将来发布的服务包后可能会支持。
     </para>
    </listitem>
    <listitem>
     <para>
      使用 Btrfs 命令设置透明压缩。
     </para>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 xml:id="sec-filesystems-major-btrfs-suse">
   <title><phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 上的根文件系统设置</title>
   <para>
    <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 默认设置为对根分区使用 Btrfs 和快照。快照可让您在应用更新之后有需要时轻松地回滚系统，也可让您备份文件。快照可通过 SUSE Snapper 基础结构轻松管理，如<xref linkend="cha-snapper"/>所述。有关 SUSE Snapper 项目的一般信息，请参见 OpenSUSE.org (<link xlink:href="http://snapper.io"/>) 上的 Snapper 门户网站 Wiki。
   </para>
   <para>
    使用快照回滚系统时，必须确保在回滚期间，数据（例如用户的主目录、Web 和 FTP 服务器内容或日志文件）不会遗失或被重写。这一点通过使用根文件系统上的 Btrfs 子卷实现。子卷可从快照中排除。安装期间，根据 YaST 建议，<phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 上的默认根文件系统设置包含下列子卷。由于以下原因，它们会从快照中排除。
   </para>
   <xi:include href="snapshot_excludes_i.xml"/>
   <warning>
    <title>回滚支持</title>
    <para>
     仅当您未移除任何预先配置的子卷时，SUSE 才支持回滚。不过，您可以使用 YaST 分区程序添加子卷。
    </para>
   </warning>
   <sect3 xml:id="sec-filesystems-major-btrfs-compress">
    <title>挂载压缩的 Btrfs 文件系统</title>
    <remark>toms 2015-09-16: FATE#316463</remark>
    <para>
     Btrfs 文件系统支持透明压缩。如果启用，Btrfs 将在写入时压缩文件数据，并在读取时解压缩文件数据。
    </para>
    <para>
     使用 <option>compress</option> 或 <option>compress-force</option> 挂载选项，并选择压缩算法 <literal>zstd</literal>、<literal>lzo</literal> 或 <literal>zlib</literal>（默认）。zlib 压缩的压缩率更高，而 lzo 的压缩速度更快，并且所需的 CPU 负载更小。zstd 算法提供了一种新式折衷方案，其性能接近 lzo，而压缩率与 zlib 类似。
    </para>
    <para>
     例如：
    </para>
<screen><prompt role="root"># </prompt>mount -o compress=zstd /dev/sdx /mnt</screen>
    <para>
     如果您创建了一个文件并在其中写入数据，而压缩后的结果大于或等于未压缩时的大小，则将来针对此文件执行写入操作后，Btrfs 会始终跳过压缩。如果您不希望有这种行为，请使用 <option>compress-force</option> 选项。对于包含一些初始不可压缩数据的文件而言，此选项可能很有用。
    </para>
    <para>
     请注意，压缩只会作用于新文件。如果使用 <option>compress</option> 或 <option>compress-force</option> 选项挂载文件系统，则在未压缩的情况下写入的文件将不会压缩。此外，包含 <option>nodatacow</option> 属性的文件的内容永远不会压缩：
    </para>
<screen><prompt role="root"># </prompt><command>chattr</command> +C <replaceable>FILE</replaceable>
<prompt role="root"># </prompt><command>mount</command> -o nodatacow  /dev/sdx /mnt</screen>
    <para>
     加密与任何压缩操作均无关。在此分区中写入一些数据后，请打印细节：
    </para>
<screen><prompt role="root"># </prompt>btrfs filesystem show /mnt
btrfs filesystem show /mnt
Label: 'Test-Btrfs'  uuid: 62f0c378-e93e-4aa1-9532-93c6b780749d
        Total devices 1 FS bytes used 3.22MiB
      devid    1 size 2.00GiB used 240.62MiB path /dev/sdb1</screen>
    <para>
     如果您希望此设置是永久性的，请在 <filename>/etc/fstab</filename> 配置文件中添加 <option>compress</option> 或 <option>compress-force</option> 选项。例如：
    </para>
<screen>UUID=1a2b3c4d /home btrfs subvol=@/home,<emphasis role="strong">compress</emphasis> 0 0</screen>
   </sect3>
   <sect3 xml:id="sec-filesystems-major-btrfs-suse-mount">
    <title>挂载子卷</title>
    <para>
     在 <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 上，从快照进行系统回滚的程序通过先从快照引导来执行。这样一来，您便可以在运行回滚之前，在运行的同时检查快照。只要挂载子卷，就可以实现从快照引导（通常没必要）。
    </para>
    <para>
     除了<xref linkend="sec-filesystems-major-btrfs-suse"/>中列出的子卷之外，系统中还存在一个名为 <literal>@</literal> 的卷。这是默认的子卷，将作为根分区 (<filename>/</filename>) 挂载。其他子卷将挂载到此卷中。
    </para>
    <para>
     从快照引导时，使用的不是 <literal>@</literal> 子卷，而是快照。快照中包括的文件系统部分将以只读方式挂载为 <filename>/</filename>。其他子卷将以可写入方式挂载到快照中。此状态默认为临时状态，下次重引导时将还原先前的配置。若要使它成为永久状态，请执行 <command>snapper rollback</command> 命令。这将使目前引导的快照成为新的<emphasis>默认</emphasis>子卷，在重引导之后将会使用它。
    </para>
   </sect3>
   <sect3 xml:id="sec-filesystems-major-btrfs-suse-space">
    <title>检查可用空间</title>
    
    <para>
     通常可通过运行 <command>df</command> 命令来检查文件系统的用量。在 Btrfs 文件系统上，<command>df</command> 的输出可能有误导性，因为除了原始数据分配的空间以外，Btrfs 文件系统还会为元数据分配并使用空间。
    </para>
    <para>
     因此，即使看上去仍有大量的可用空间，Btrfs 文件系统也可能会报告空间不足。发生这种情况时，为元数据分配的全部空间都已用尽。使用以下命令可检查 Btrfs 文件系统上已用和可用的空间：
    </para>
    <variablelist>
     <varlistentry>
      <term><command>btrfs filesystem show</command></term>
      <listitem>
<screen><prompt>&gt; </prompt><command>sudo</command> btrfs filesystem show /
Label: 'ROOT'  uuid: 52011c5e-5711-42d8-8c50-718a005ec4b3
        Total devices 1 FS bytes used 10.02GiB
        devid    1 size 20.02GiB used 13.78GiB path /dev/sda3</screen>
       <para>
        显示文件系统的总大小及其用量。如果最后一行中的这两个值匹配，则表示文件系统上的全部空间都已分配出去。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><command>btrfs filesystem df</command></term>
      <listitem>
<screen><prompt>&gt; </prompt><command>sudo</command> btrfs filesystem df /
Data, single: total=13.00GiB, used=9.61GiB
System, single: total=32.00MiB, used=16.00KiB
Metadata, single: total=768.00MiB, used=421.36MiB
GlobalReserve, single: total=144.00MiB, used=0.00B</screen>
       <para>
        显示文件系统的已分配 (<literal>total</literal>) 空间和已用空间值。如果元数据的 <literal>total</literal> 和 <literal>used</literal> 值基本上相等，则表示元数据的全部空间都已分配出去。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><command>btrfs filesystem usage</command></term>
      <listitem>
<screen><prompt>&gt; </prompt><command>sudo</command> btrfs filesystem usage /
Overall:
    Device size:                  20.02GiB
    Device allocated:             13.78GiB
    Device unallocated:            6.24GiB
    Device missing:                  0.00B
    Used:                         10.02GiB
    Free (estimated):              9.63GiB      (min: 9.63GiB)
    Data ratio:                       1.00
    Metadata ratio:                   1.00
    Global reserve:              144.00MiB      (used: 0.00B)

             Data     Metadata  System
Id Path      single   single    single   Unallocated
-- --------- -------- --------- -------- -----------
 1 /dev/sda3 13.00GiB 768.00MiB 32.00MiB     6.24GiB
-- --------- -------- --------- -------- -----------
   Total     13.00GiB 768.00MiB 32.00MiB     6.24GiB
   Used       9.61GiB 421.36MiB 16.00KiB</screen>
       <para>
        显示类似于前两个命令输出合并所得的数据。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     有关详细信息，请参见 <command>man 8 btrfs-filesystem</command> 和 <link xlink:href="https://btrfs.wiki.kernel.org/index.php/FAQ"/>。
    </para>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-filesystems-major-btrfs-migrate">
   <title>从 ReiserFS 和 ext 文件系统迁移到 Btrfs</title>
   <para>
    您可以使用 <command>btrfs-convert</command> 工具，将数据卷从现有 ReiserFS 或 Ext（Ext2、Ext3 或 Ext4）迁移到 Btrfs 文件系统。该过程允许您对未挂载（脱机）的文件系统进行就地转换，执行此操作可能需要使用包含 <command>btrfs-convert</command> 工具的可引导安装媒体。该工具会在原始文件系统的可用空间内构建 Btrfs 文件系统，并直接链接到其中包含的数据。设备上必须有足够用于创建元数据的可用空间，否则转换将失败。原始文件系统将保持不变，Btrfs 文件系统不会占用任何可用空间。需要的空间大小取决于文件系统的内容，可能会因其中包含的文件系统对象（例如文件、目录、扩展属性）数量而异。由于系统会直接参照数据，文件系统上的数据量不会影响转换所需的空间，但使用尾部封装且大小超过 2 KiB 的文件除外。
   </para>
   <warning>
    <title>不支持根文件系统转换</title>
    <para>
     不支持将根文件系统转换为 Btrfs，且不建议这样做。由于需要根据您的特定设置定制各种步骤，因此无法自动完成此类转换 — 该过程需要经过复杂的配置才能提供正确的回滚，<filename>/boot</filename> 必须位于根文件系统上，并且系统必须包含特定的子卷，等等。请保留现有的文件系统，或者从头开始重新安装整个系统。
    </para>
   </warning>
   <para>
    要将原始文件系统转换为 Btrfs 文件系统，请运行：
   </para>
<screen><prompt role="root"># </prompt>btrfs-convert /path/to/device</screen>
   <important>
    <title>检查 <filename>/etc/fstab</filename></title>
    <para>
     转换后，需确保 <filename>/etc/fstab</filename> 中对原始文件系统的所有参照都已调整，现指示设备包含 Btrfs 文件系统。
    </para>
   </important>
   <para>
    转换后，Btrfs 文件系统的内容将会反映源文件系统的内容。源文件系统将一直保留到您去除了在 <filename><replaceable>fs_root</replaceable>/reiserfs_saved/image</filename> 中创建的相关只读映像为止。该映像文件实际上是转换前 ReiserFS 文件系统的一个“快照”，修改 Btrfs 文件系统时不会修改该映像。要去除该映像文件，请去除 <filename>reiserfs_saved</filename> 子卷：
   </para>
<screen><prompt role="root"># </prompt>btrfs subvolume delete <replaceable>fs_root</replaceable>/reiserfs_saved</screen>
   <para>
    要将文件系统还原到原始文件系统，请使用以下命令：
   </para>
<screen><prompt role="root"># </prompt>btrfs-convert -r /path/to/device</screen>
   <warning>
    <title>更改将丢失</title>
    <para>
     您在文件系统装载为 Btrfs 文件系统时所做的任何更改都将丢失。切勿在此期间执行任何平衡操作，否则将无法正确恢复文件系统。
    </para>
   </warning>
  </sect2>

  <sect2 xml:id="sec-filesystems-major-btrfs-admin">
   <title>Btrfs 管理</title>
   <para>
    Btrfs 与 YaST 分区程序和 AutoYaST 集成。您可以在安装期间使用它来为根文件系统建立解决方案。安装之后，您可以使用 YaST 分区程序来查看和管理 Btrfs 卷。
   </para>
   <para>
    <filename>btrfsprogs</filename> 软件包中提供了 Btrfs 管理工具。有关使用 Btrfs 命令的信息，请参见 <command>man 8 btrfs</command>、<command>man 8 btrfsck</command> 和 <command>man 8 mkfs.btrfs</command> 命令。有关 Btrfs 功能的信息，请参见 <citetitle>Btrfs Wiki</citetitle>，网址为 <link xlink:href="http://btrfs.wiki.kernel.org"/>。
   </para>
  </sect2>

  <sect2 xml:id="sec-filesystems-major-btrfs-quota">
   <title>Btrfs 子卷定额支持</title>
   <para>
    Btrfs 根文件系统子卷（例如 <filename>/var/log</filename>、<filename>/var/crash</filename> 或 <filename>/var/cache</filename>）在正常运作期间可能会使用所有可用的磁盘空间，如此将导致系统故障。为避免出现此状况，<phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 提供了 Btrfs 子卷定额支持。只要根据 YaST 建议设置根文件系统，便可以启用和设置子卷定额。
   </para>
   <sect3 xml:id="setting-btrfs-quotas-using-yast">
    <title>使用 YaST 设置 Btrfs 定额</title>
    <para>
     要使用 YaST 为根文件系统的子卷设置定额，请执行以下步骤：
    </para>
    <procedure>
     <step>
      <para>
       启动 YaST 并选择<menuchoice><guimenu>系统</guimenu><guimenu>分区程序</guimenu></menuchoice>，然后单击<guimenu>是</guimenu>确认警告。
      </para>
     </step>
     <step>
      <para>
       在左侧窗格中，单击 <guimenu>Btrfs</guimenu>。
      </para>
     </step>
     <step>
      <para>
       在主窗口中，选择要为其启用子卷定额的设备，然后单击底部的<guimenu>编辑</guimenu>。
      </para>
     </step>
     <step>
      <para>
       在<guimenu>编辑 Btrfs</guimenu> 窗口中，激活<guimenu>启用子卷定额</guimenu>复选框，然后单击<guimenu>下一步</guimenu>进行确认。
      </para>
      <figure>
       <title>启用 Btrfs 定额</title>
       <mediaobject>
        <imageobject role="fo">
         <imagedata fileref="yast2_btrfs_quotas_enable.png" width="75%"/>
        </imageobject>
        <imageobject role="html">
         <imagedata fileref="yast2_btrfs_quotas_enable.png" width="75%"/>
        </imageobject>
       </mediaobject>
      </figure>
     </step>
     <step>
      <para>
       从现有子卷列表中，单击要按定额限制大小的子卷，然后单击底部的<guimenu>编辑</guimenu>。
      </para>
     </step>
     <step>
      <para>
       在<guimenu>编辑 Btrfs 的子卷</guimenu>窗口中，激活<guimenu>限制大小</guimenu>并指定最大引用大小。使用<guimenu>接受</guimenu>确认。
      </para>
      <figure>
       <title>设置子卷定额</title>
       <mediaobject>
        <imageobject role="fo">
         <imagedata fileref="yast2_btrfs_quotas_set.png" width="75%"/>
        </imageobject>
        <imageobject role="html">
         <imagedata fileref="yast2_btrfs_quotas_set.png" width="75%"/>
        </imageobject>
       </mediaobject>
      </figure>
      <para>
       新的大小限制将显示在子卷名称旁边：
      </para>
      <figure>
       <title>设备的子卷列表</title>
       <mediaobject>
        <imageobject role="fo">
         <imagedata fileref="yast2_btrfs_quotas_edit.png" width="75%"/>
        </imageobject>
        <imageobject role="html">
         <imagedata fileref="yast2_btrfs_quotas_edit.png" width="75%"/>
        </imageobject>
       </mediaobject>
      </figure>
     </step>
     <step>
      <para>
       单击<guimenu>下一步</guimenu>应用更改。
      </para>
     </step>
    </procedure>
   </sect3>
   <sect3 xml:id="setting-btrfs-quotas-using-cmdline">
    <title>在命令行上设置 Btrfs 定额</title>
    <para>
     要在命令行上设置根文件系统的子卷定额，请执行以下步骤：
    </para>
    <procedure>
     <step>
      <para>
       启用配额支持：
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> btrfs quota enable /</screen>
     </step>
     <step>
      <para>
       取得子卷列表：
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> btrfs subvolume list /</screen>
      <para>
       只能为现有子卷设置配额。
      </para>
     </step>
     <step>
      <para>
       为上一步中所列的其中一个子卷设置配额。子卷可以用路径识别（例如 <filename>/var/tmp</filename>），也可以用 <literal>0/<replaceable>子卷 ID</replaceable></literal> 识别（例如 <literal>0/272</literal>）。以下示例为 <filename>/var/tmp</filename> 设置 5 GB 配额。
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> btrfs qgroup limit 5G /var/tmp</screen>
      <para>
       大小单位可以是字节 (5000000000)、KB (5000000K)、MB (5000M) 或 GB (5G)。以字节为单位生成的值略有不同，因为 1024 字节 = 1 KiB，1024 KiB = 1 MiB，依此类推
      </para>
     </step>
     <step>
      <para>
       若要列出现有配额，请使用以下命令。<literal>max_rfer</literal> 列以字节为单位显示配额。
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> btrfs qgroup show -r /</screen>
     </step>
    </procedure>
    <tip>
     <title>取消定额</title>
     <para>
      如果您要取消现有定额，请将定额大小设置为 <literal>none</literal>：
     </para>
<screen><prompt>&gt; </prompt><command>sudo</command> btrfs qgroup limit none /var/tmp</screen>
     <para>
      若要禁用某个分区及其所有子卷的配额支持，请使用 <command>btrfs quota disable</command>：
     </para>
<screen><prompt>&gt; </prompt><command>sudo</command> btrfs quota disable /</screen>
    </tip>
   </sect3>
   <sect3 xml:id="setting-btrfs-quotas-for-more-info">
    <title>更多信息</title>
    <para>
     有关细节，请参见 <command>man 8 btrfs-qgroup</command> 和 <command>man 8 btrfs-quota</command>。Btrfs Wiki (<link xlink:href="https://btrfs.wiki.kernel.org/index.php/UseCases"/>) 上的 <citetitle>UseCases</citetitle> 页面也提供了更多信息。
    </para>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-filesystems-major-btrfs-swapping">
   <title>Btrfs 上的交换</title>
   <important>
    <title>启用交换创建快照</title>
    <para>
     如果源子卷包含任何已启用的交换文件，则您无法创建快照。
    </para>
   </important>
   <para>
    如果满足与生成的交换文件相关的以下准则，则 SLES 支持在 Btrfs 文件系统上的文件交换：
   </para>
   <itemizedlist>
    <listitem>
     <para>
      交换文件必须有 <option>NODATACOW</option> 和 <option>NODATASUM</option> 挂载选项。
     </para>
    </listitem>
    <listitem>
     <para>
      不得压缩交换文件，您可以通过设置 <option>NODATACOW</option> 和 <option>NODATASUM</option> 挂载选项来确保满足此准则。两个选项都会禁用交换文件压缩。
     </para>
    </listitem>
    <listitem>
     <para>
      在运行排它操作（例如设备调整大小、添加、去除或替换）时，或在运行平衡操作时，不能激活交换文件。
     </para>
    </listitem>
    <listitem>
     <para>
      交换文件不能是稀疏文件。
     </para>
    </listitem>
    <listitem>
     <para>
      交换文件不能是内联文件。
     </para>
    </listitem>
    <listitem>
     <para>
      交换文件必须位于<literal>单个</literal>分配配置文件系统上。
     </para>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 xml:id="sec-filesystems-major-btrfs-s-r">
   <title>Btrfs 发送/接收</title>
   <para>
    Btrfs 允许生成快照来捕获文件系统的状态。例如，Snapper 可使用此功能在系统更改之前及之后创建快照，以便允许回滚。不过，将快照与发送/接收功能结合使用还可以在远程位置创建和维护文件系统的副本。例如，此功能可用于执行增量备份。
   </para>
   <para>
    <command>btrfs send</command> 操作可计算同一子卷中两个只读快照之间的差异，并将差异发送到某个文件或 STDOUT。<command>btrfs receive</command> 操作会接收 send 命令的结果，并将其应用到快照。
   </para>
   <sect3 xml:id="sec-filesystems-major-btrfs-s-r-requires">
    <title>先决条件</title>
    <para>
     要使用发送/接收功能，需要满足以下要求：
    </para>
    <itemizedlist>
     <listitem>
      <para>
       源端（<literal>发送</literal>）和目标端（<literal>接收</literal>）各有一个 Btrfs 文件系统。
      </para>
     </listitem>
     <listitem>
      <para>
       Btrfs 发送/接收是对快照执行的，因此，相应的数据需要驻留在 Btrfs 子卷中。
      </para>
     </listitem>
     <listitem>
      <para>
       源端中的快照必须为只读模式。
      </para>
     </listitem>
     <listitem>
      <para>
       SUSE Linux Enterprise 12 SP2 或更高版本。早期版本的 SUSE Linux Enterprise 不支持发送/接收。
      </para>
     </listitem>
    </itemizedlist>
   </sect3>
   <sect3 xml:id="sec-filesystems-major-btrfs-s-r-backup">
    <title>增量备份</title>
    <para>
     以下过程展示了 Btrfs 发送/接收操作的基本用法，其中示范了如何在 <filename>/backup/data</filename>（目标端）中创建 <filename>/data</filename>（源端）的增量备份。<filename>/data</filename> 必须是一个子卷。
    </para>
    <procedure>
     <title>初始设置</title>
     <step>
      <para>
       在源端创建初始快照（在本示例中名为 <literal>snapshot_0</literal>），并确保将它写入该磁盘：
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> btrfs subvolume snapshot -r /data /data/bkp_data
sync</screen>
      <para>
       即会创建一个新子卷 <filename>/data/bkp_data</filename>。该子卷将用作后续增量备份的基础，应将它保留为参照。
      </para>
     </step>
     <step>
      <para>
       将初始快照发送到目标端。由于这是初始的发送/接收操作，因此需要发送整个快照：
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> bash -c 'btrfs send /data/bkp_data | btrfs receive /backup'</screen>
      <para>
       目标端上即会创建一个新子卷 <filename>/backup/bkp_data</filename>。
      </para>
     </step>
    </procedure>
    <para>
     完成初始设置后，可以创建增量备份，并将当前快照与先前快照之间的差异发送到目标端。操作过程始终是相同的：
    </para>
    <orderedlist>
     <listitem>
      <para>
       在源端创建新快照。
      </para>
     </listitem>
     <listitem>
      <para>
       将差异发送到目标端。
      </para>
     </listitem>
     <listitem>
      <para>
       可选：重命名和/或清理两端中的快照。
      </para>
     </listitem>
    </orderedlist>
    <procedure>
     <title>执行增量备份</title>
     <step>
      <para>
       在源端创建新快照，并确保将它写入该磁盘。在下面的示例中，快照命名为 bkp_data_<replaceable>当前日期</replaceable>：
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> btrfs subvolume snapshot -r /data /data/bkp_data_$(date +%F)
sync</screen>
      <para>
       创建新子卷，例如 <filename>/data/bkp_data_2016-07-07</filename>。
      </para>
     </step>
     <step>
      <para>
       将先前快照与您创建的快照之间的差异发送到目标端。为此，可以使用选项 <option>-p <replaceable>SNAPSHOT</replaceable></option> 指定先前的快照。
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> bash -c 'btrfs send -p /data/bkp_data /data/bkp_data_2016-07-07 \
| btrfs receive /backup'</screen>
      <para>
       即会创建一个新子卷 <filename>/backup/bkp_data_2016-07-07</filename>。
      </para>
     </step>
     <step>
      <para>
       如此我们有了四个快照，每端各有两个：
      </para>
      <simplelist><member><filename>/data/bkp_data</filename></member><member><filename>/data/bkp_data_2016-07-07</filename></member><member><filename>/backup/bkp_data</filename></member><member><filename>/backup/bkp_data_2016-07-07</filename></member>
      </simplelist>
      <para>
       现在，关于如何继续，您有三种选择：
      </para>
      <itemizedlist>
       <listitem>
        <para>
         保留两端中的所有快照。如果采用这种选择，您可以回滚到两端中的任一快照，同时会复制所有数据。不需要执行额外操作。执行后续增量备份时，请记得使用倒数第二个快照作为发送操作的父项。
        </para>
       </listitem>
       <listitem>
        <para>
         仅保留源端中的最后一个快照，保留目标端中的所有快照。此外，允许回滚到两端中的任一快照 - 要回滚到源端中的特定快照，请对整个快照执行从目标端到源端的发送/接收操作。在源端执行删除/移动操作。
        </para>
       </listitem>
       <listitem>
        <para>
         仅保留两端中的最后一个快照。采用这种方法，您会在目标端创建一个备份，该备份代表源端中生成的最后一个快照的状态。系统无法回滚到其他快照。在源端和目标端执行删除/移动操作。
        </para>
       </listitem>
      </itemizedlist>
      <substeps>
       <step>
        <para>
         如果只想保留源端中的最后一个快照，请执行以下命令：
        </para>
<screen><prompt>&gt; </prompt><command>sudo</command> btrfs subvolume delete /data/bkp_data
<prompt>&gt; </prompt><command>sudo</command> mv /data/bkp_data_2016-07-07 /data/bkp_data</screen>
        <para>
         第一条命令将删除先前的快照，第二条命令将当前快照重命名为 <filename>/data/bkp_data</filename>。这可确保备份的最后一个快照始终命名为 <filename>/data/bkp_data</filename>。因此，您也可以始终使用此子卷名称作为增量发送操作的父项。
        </para>
       </step>
       <step>
        <para>
         如果只想保留目标端中的最后一个快照，请执行以下命令：
        </para>
<screen><prompt>&gt; </prompt><command>sudo</command> btrfs subvolume delete /backup/bkp_data
<prompt>&gt; </prompt><command>sudo</command> mv /backup/bkp_data_2016-07-07 /backup/bkp_data</screen>
        <para>
         第一条命令将删除先前的备份快照，第二条命令将当前备份快照重命名为 <filename>/backup/bkp_data</filename>。这可确保最新的备份快照始终命名为 <filename>/backup/bkp_data</filename>。
        </para>
       </step>
      </substeps>
     </step>
    </procedure>
    <tip>
     <title>发送到远程目标端</title>
     <para>
      要将快照发送到远程计算机，请使用 SSH：
     </para>
<screen><prompt>&gt; </prompt>btrfs send /data/bkp_data | ssh root@jupiter.example.com 'btrfs receive /backup'</screen>
    </tip>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-filesystems-major-btrfs-deduplication">
   <title>数据去重支持</title>
   <para>
    Btrfs 支持重复数据删除功能，具体办法是以指向通用储存位置中的块单一副本的逻辑链接替换文件系统中完全相同的块。<phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 提供 <command>duperemove</command> 工具来扫描文件系统中有没有完全相同的块。在 Btrfs 文件系统上使用时，也可以用来删除这些重复的块，从而节省文件系统上的空间。系统上默认不会安装 <command>duperemove</command>。要使此功能可用，请安装软件包 <package>duperemove</package>。
   </para>
   <note>
    <title>删除重复的大型数据集</title>
    <para>
     如果您要删除重复的大量文件，请使用 <option>--hashfile</option> 选项：
    </para>
<screen><prompt>&gt; </prompt><command>sudo</command> duperemove <option>--hashfile <replaceable>HASH_FILE</replaceable></option> file1 file2 file3</screen>
    <para>
     <option>--hashfile</option> 选项会将所有指定文件的哈希储存到 <replaceable>HASH_FILE</replaceable>（而不是 RAM 中），防止耗尽 RAM。<replaceable>HASH_FILE</replaceable> 可重复使用 - 当完成生成基线哈希文件的初始运行后，即可删除对大型数据集的重复更改。
    </para>
   </note>
   <para>
    <command>duperemove</command> 可以针对一系列文件操作，也可以以递归方式扫描某个目录：
   </para>
<screen><prompt>&gt; </prompt><command>sudo</command> duperemove <replaceable>OPTIONS</replaceable> file1 file2 file3
<prompt>&gt; </prompt><command>sudo</command> duperemove -r <replaceable>OPTIONS</replaceable> directory</screen>
   <para>
    它有两种操作模式：只读和重复数据删除。以只读模式运行时（即不使用 <option>-d</option> 开关），它会扫描给定文件或目录中的重复块，并将其打印出来。此模式适用于所有文件系统。
   </para>
   <para>
    以重复数据删除模式执行 <command>duperemove</command> 仅在 Btrfs 文件系统上受支持。扫描给定文件或目录之后，将会提交重复的块以进行重复数据删除。
   </para>
   <para>
    有关详细信息，请参见 <command>man 8 duperemove</command>。
   </para>
  </sect2>

  <sect2 xml:id="btrfs-delete-subvolumes">
   <title>从根文件系统删除子卷</title>
   <para>
    出于特定目的，您可能需要从根文件系统中删除某个默认的 Btrfs 子卷。目的之一是将某个子卷（例如 <filename>@/home</filename> 或 <filename>@/srv</filename>）转换成单独设备上的文件系统。以下过程演示如何删除 Btrfs 子卷：
   </para>
   <procedure>
    <step>
     <para>
      确定要删除的子卷（例如 <filename>@/opt</filename>）。请注意，根路径始终使用子卷 ID“5”。
     </para>
<screen>
<prompt>&gt; </prompt><command>sudo</command> btrfs subvolume list /
ID 256 gen 30 top level 5 path @
ID 258 gen 887 top level 256 path @/var
ID 259 gen 872 top level 256 path @/usr/local
ID 260 gen 886 top level 256 path @/tmp
ID 261 gen 60 top level 256 path @/srv
ID 262 gen 886 top level 256 path @/root
ID 263 gen 39 top level 256 path @/opt
[...]
</screen>
    </step>
    <step>
     <para>
      查找托管根分区的设备名称：
     </para>
<screen>
<prompt>&gt; </prompt><command>sudo</command> btrfs device usage /
/dev/sda1, ID: 1
  Device size:            23.00GiB
  Device slack:              0.00B
  Data,single:             7.01GiB
  Metadata,DUP:            1.00GiB
  System,DUP:             16.00MiB
  Unallocated:            14.98GiB
</screen>
    </step>
    <step>
     <para>
      在单独的挂载点（例如 <filename>/mnt</filename>）上挂载根文件系统（ID 为 5 的子卷）：
     </para>
<screen><prompt>&gt; </prompt><command>sudo</command> mount -o subvolid=5 /dev/sda1 /mnt</screen>
    </step>
    <step>
     <para>
      从挂载的根文件系统中删除 <filename>@/opt</filename> 分区：
     </para>
<screen><prompt>&gt; </prompt><command>sudo</command> btrfs subvolume delete /mnt/@/opt</screen>
    </step>
    <step>
     <para>
      卸载以前挂载的根文件系统：
     </para>
<screen><prompt>&gt; </prompt><command>sudo</command> umount /mnt</screen>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-filesystems-major-xfs">
  <title>XFS</title>

  <para>
   SGI 在 20 世纪 90 年代初开始开发 XFS，最初计划将 XFS 作为 IRIX OS 的文件系统。开发 XFS 的目的是创建一个高性能的 64 位日志文件系统来满足对计算能力的极高要求。XFS 适合操纵大型文件，在高端硬件上表现优异。XFS 是 <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 中数据分区的默认文件系统。
  </para>

  <para>
   快速回顾 XFS 的关键功能可解释为什么此文件系统经证明在高端计算方面是其他日志文件系统的强大竞争对手。
  </para>

  <variablelist>
   <varlistentry>
    <term>高可伸缩性</term>
    <listitem>
     <para>
      XFS 使用分配组来提供高可伸缩性
     </para>
     <para>
      在创建 XFS 文件系统时，文件系统底层的块设备被分成 8 个或 8 个以上相同大小的线性区域。这些区域称为<emphasis>分配组</emphasis>。每个分配组管理自己的 inode 和可用空间。实际上，可以将分配组看作文件系统中的文件系统。因为分配组相互独立，所以内核可同时对多个分配组进行寻址。此功能是 XFS 优异的可伸缩性关键之所在。独立分配组的概念自然适合多处理器系统的需要。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>性能较高</term>
    <listitem>
     <para>
      XFS 通过有效管理磁盘空间来提供高性能
     </para>
     <para>
      可用空间和 inode 是由分配组内的 B<superscript>+</superscript> 树处理的。使用 B<superscript>+</superscript> 树将大大增强 XFS 的性能和可伸缩性。XFS 使用<emphasis>延迟分配</emphasis>，它可以通过将进程分为两部分而处理分配。将挂起事务储存在 RAM 中并保留适当数量的空间。XFS 仍不决定应储存数据的准确位置（即不指出文件系统块）。此决定将被延迟到最后的时刻。某些生存期很短的临时数据可能永远不会被储存到磁盘上，这是因为在 XFS 决定保存它们的实际位置时，这些数据可能已经过时了。以这种方式，XFS 增强了写性能并减少了文件系统分段。因为延迟分配引起写事件的频率比其他文件系统引起写事件的频率要低，所以如果写操作期间发生系统崩溃，则数据丢失可能会更加严重。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>进行预分配以避免文件系统碎片</term>
    <listitem>
     <para>
      在将数据写入文件系统前，XFS <emphasis>保留</emphasis>（预分配）文件所需的可用空间。这样会大大减少文件系统碎片的数目。因为文件的内容不会分散在整个文件系统中，所以性能得以提高。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <sect2 xml:id="sec-filesystems-major-prealloc">
   <title>XFS 格式</title>
   <para>
    <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 支持 XFS 文件系统的<quote>磁盘格式</quote> (v5)。这种格式的主要优点包括，所有 XFS 元数据的自动检查总数、文件类型支持以及支持文件更多数量的访问控制列表。
   </para>
   <para>
    请注意，低于 3.12 版的 SUSE Linux Enterprise 内核、低于 3.2.0 版的 <literal>xfsprogs</literal> 以及在 SUSE Linux Enterprise 12 之前发布的 GRUB 2 版本均不支持这种格式。
   </para>
   <important>
    <title>V4 已弃用</title>
    <para>
     XFS 正在弃用采用 V4 格式的文件系统。此文件系统格式是由以下命令创建的：
    </para>
<screen>mkfs.xfs -m crc=0 <replaceable>DEVICE</replaceable></screen>
    <para>
     该格式在 SLE 11 和更低版本中使用，目前它通过 <command>dmesg</command> 创建警告消息：
    </para>
<screen>Deprecated V4 format (crc=0) will not be supported after September 2030</screen>
    <para>
     如果您在 <command>dmesg</command> 命令的输出中看到上述消息，建议将文件系统更新到 V5 格式：
    </para>
    <procedure>
     <step>
      <para>
       将数据备份到另一台设备。
      </para>
     </step>
     <step>
      <para>
       在该设备上创建文件系统。
      </para>
<screen>mkfs.xfs -m crc=1 <replaceable>DEVICE</replaceable></screen>
     </step>
     <step>
      <para>
       从已更新的设备上的备份恢复数据。
      </para>
     </step>
    </procedure>
   </important>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-filesystems-major-ext2">
  <title>Ext2</title>

  <para>
   Ext2 的原身可以追溯到 Linux 历史的早期。其前身是“扩展文件系统”，于 1992 年 4 月实施，集成在 Linux 0.96c 中。扩展文件系统经历了数次修改，后来才称为 Ext2，曾经是多年来最受欢迎的 Linux 文件系统。但随着日志文件系统的创建以及其恢复时间的缩短，Ext2 的重要性逐渐降低。
  </para>

  <para>
   简要总结 Ext2 的优点有助于您了解为什么它以前是（在某些领域现在仍是）许多 Linux 用户最喜欢使用的 Linux 文件系统。
  </para>

  <variablelist>
   <varlistentry>
    <term>可靠性和速度</term>
    <listitem>
     <para>
      Ext2 是一个<quote>老古董</quote>，它经历了许多改进和频繁的测试。这可能是人们经常称之为坚如磐石的文件系统的原因。在系统中断后，如果无法彻底卸装文件系统，则 e2fsck 将开始分析文件系统数据。系统使元数据恢复一致的状态，并将挂起的文件或数据块写入指定的目录（名为 <filename>lost+found</filename>）。与日志文件系统相比，e2fsck 会分析整个文件系统，而不仅仅是元数据中最近修改的位。这种操作所花的时间要远远超过检查日志文件系统的日志数据所花的时间。根据文件系统的大小，此过程可能需要半小时或更长时间。因此，对于任何要求高可用性的服务器，不要选择 Ext2。但是，因为 Ext2 不维护日志且使用的内存也更少，所以其速度往往快于其他文件系统。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>可方便地升级</term>
    <listitem>
     <para>
      因为 Ext3 以 Ext2 代码为基础并且共享 Ext2 的磁盘上格式和元数据格式，所以从 Ext2 升级到 Ext3 非常容易。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 xml:id="sec-filesystems-major-ext3">
  <title>Ext3</title>

  <para>
   Ext3 由 Stephen Tweedie 设计。与所有其他下一代文件系统不同，Ext3 并没有采用全新的设计原则。它是在 Ext2 的基础上设计的。这两个文件系统密切关联。可以方便地在 Ext2 文件系统上建立 Ext3 文件系统。Ext2 和 Ext3 最重要的区别是 Ext3 支持日志。总之，Ext3 有三个主要优点：
  </para>

  <sect2 xml:id="sec-filesystems-major-ext3-upgrade">
   <title>可方便并高度可靠地从 ext2 升级</title>
   <para>
    Ext2 的代码为 Ext3 奠定了坚实的基础，使后者成为受到高度评价的下一代文件系统。在 Ext3 中，它的可靠性和稳定性与日志文件系统的优点完美地结合在一起。不像转换至其他日志文件系统（例如 XFS）那么费时（备份整个文件系统，然后从头开始重新创建），转换到 Ext3 只需几分钟时间。升级到 Ext3 还很安全，因为从头重新创建整个文件系统可能会出现问题。考虑到等待升级到日志文件系统的现有 Ext2 系统的数量，就很容易明白为什么 Ext3 对许多系统管理员来说如此重要。从 Ext3 降级到 Ext2 与升级一样简单。将 Ext3 文件系统完全卸载，然后重新挂载成 Ext2 文件系统即可。
   </para>
  </sect2>

  

  <sect2 xml:id="sec-filesystems-major-ext3-ext22ext3a">
   <title>将 ext2 文件系统转换为 ext3</title>
   <para>
    要将 Ext2 文件系统转换为 Ext3：
   </para>
   <procedure>
    <step>
     <para>
      作为 <systemitem class="username">root</systemitem> 用户运行 <command>tune2fs -j</command> 来创建 Ext3 日志。
     </para>
     <para>
      此命令将用默认参数创建 Ext3 日志。
     </para>
     <para>
      要指定日志的大小和所驻留的设备，请改为运行 <command>tune2fs</command> <option>-J</option>，同时使用所需的日志选项 <option>size=</option> 和 <option>device=</option>。<command>tune2fs</command> 手册页中有关于 <command>tune2fs</command> 程序的更多信息。
     </para>
    </step>
    <step>
     <para>
      作为 <systemitem class="username">root</systemitem> 用户编辑文件 <filename>/etc/fstab</filename>，以将为相应分区指定的文件系统类型从 <literal>ext2</literal> 更改为 <literal>ext3</literal>，然后保存更改。
     </para>
     <para>
      这确保可以正确识别出 Ext3 文件系统。此更改将在下次重引导后生效。
     </para>
    </step>
    <step>
     <para>
      若引导已设置为 Ext3 分区的根文件系统，请在 <literal>initrd</literal> 中添加模块 <literal>ext3</literal> 和 <filename>jbd</filename>。操作步骤如下：
     </para>
     <substeps performance="required">
      <step>
       <para>
        打开或创建 <filename>/etc/dracut.conf.d/filesystem.conf</filename> 并添加以下行（请注意前导空格）：
       </para>
<screen>force_drivers+=" ext3 jbd"</screen>
      </step>
      <step>
       <para>
        然后运行 <command>dracut</command> <option>-f</option> 命令。
       </para>
      </step>
     </substeps>
    </step>
    <step>
     <para>
      重新启动系统。
     </para>
    </step>
   </procedure>
  </sect2>

  
 </sect1>
 <sect1 xml:id="sec-filesystems-major-ext4">
  <title>Ext4</title>

  <para>
   2006 年，Ext4 做为 Ext3 的传承面市。它是扩展的文件系统版本中的最新文件系统。Ext4 最初旨在增大储存大小，它支持最大大小为 1 EiB 的卷、最大大小为 16 TiB 的文件和无限个子目录。Ext4 使用区域（而不是传统的直接和间接块指针）来映射文件内容。使用区域可以改善在磁盘中存储数据以及从中检索数据的功能。
  </para>

  <para>
   Ext4 还引入了多项性能增强功能，例如延迟块分配和速度大幅加快的文件系统检查例程。Ext4 还支持日志校验和，并可提供以纳秒度量的时间戳，因而更加可靠。Ext4 完全反向兼容于 Ext2 和 Ext3，后两个文件系统都可以作为 Ext4 挂载。
  </para>

  <note>
   <title>Ext4 上的 Ext3 功能</title>
   <para>
    Ext4 内核模块中的 Ext4 驱动程序完全支持 Ext3 功能。
   </para>
  </note>

  <sect2 xml:id="sec-filesystems-major-ext4-performance">
   <title>可靠性和性能</title>
   <para>
    某些其他日志文件系统采用<quote>仅元数据</quote>的日志方法。这意味着元数据始终保持一致的状态，但无法自动保证文件系统数据本身一致。Ext4 的设计既可以照顾到元数据，又可以照顾到数据。<quote>照顾</quote>的程度可以自定义。以 <option>data=journal</option> 模式挂载 Ext4 可以提供最高安全性（数据完整性），但由于要将元数据和数据都记入日志，因此可能会降低系统速度。另一种方法是使用 <option>data=ordered</option> 模式，此模式可确保数据和元数据的完整性，但只对元数据使用日志。文件系统驱动程序收集与一次元数据更新对应的所有数据块。这些数据块在更新元数据之前被写入磁盘中。这样，在不牺牲性能的情况下，元数据和数据的一致性得以实现。可使用的第三个挂载选项是 <option>data=writeback</option>，它允许数据在其元数据已经提交至日志后再写入主要文件系统。在性能方面，此选项常被认为是最佳选项。但它在维护内部文件系统完整性的同时，允许以前的数据在系统崩溃并恢复后再次出现在文件中。Ext4 使用 <option>data=ordered</option> 选项作为默认值。
   </para>
  </sect2>

  <sect2 xml:id="sec-filesystems-major-ext4-inodesize">
   <title>Ext4 文件系统 inode 大小及 inode 数量</title>
   <para>
    inode 用于存储文件的相关信息及其在文件系统中的块位置。为了让 inode 有空间可以容纳扩展属性以及 ACL，默认的 inode 大小已增大至 256 字节。
   </para>
   <para>
    当您创建新的 Ext4 文件系统时，系统将根据可创建的 Inode 总数预先分配 Inode 表格中的空间。每 inode 的字节数比率以及文件系统的大小决定了可以创建的 inode 数量。建立文件系统时，将根据每 inode 字节数的单位空间创建 inode：
   </para>
<screen>number of inodes = total size of the file system divided by the number of bytes per inode</screen>
   <para>
    inode 的数量控制着文件系统中可容纳的文件数：一个文件对应一个 inode。
   </para>
   <important>
    <title>无法更改现有 Ext4 文件系统的 inode 大小</title>
    <para>
     inode 分配完毕后，将无法更改 inode 大小的设置或每 inode 的字节数比率。如果不使用其他设置重新创建文件系统，或不扩展文件系统，则无法添加 Inode。超过 inode 最大数量时，只有删除部分文件才能在文件系统上创建新文件。
    </para>
   </important>
   <para>
    新建 Ext4 文件系统时，您可以指定 inode 大小和每 inode 的字节数比率，以控制文件系统上可容纳 inode 空间占用量以及文件数量。如果未指定块大小、inode 大小以及每 inode 的字节数比率值，则将应用 <filename>/etc/mked2fs.conf</filename> 中的默认值。有关信息，请参见 <filename>mke2fs.conf(5)</filename> 手册页。
   </para>
   <para>
    使用以下指标：
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <formalpara>
      <title>inode 大小：</title>
      <para>
       默认的 inode 大小为 256 字节。指定字节值，即介于 128 字节（含）到块大小（含）之间的 2 的乘方值，如 128、256、512，以此类推。只有当 Ext4 文件系统上不使用扩展属性或 ACL 时才可使用 128 字节。
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>每 inode 的字节数比率：</title>
      <para>
       默认的每 inode 的字节数比率为 16384 字节。有效的每 inode 的字节数比率值必须是大于等于 1024 字节的 2 的乘方值，如 1024、2048、4096、8192、16384、32768，以此类推。该值不应小于文件系统的块大小，因为块大小是用于存储数据的最小空间大块。Ext4 文件系统的默认块大小为 4 KiB。
      </para>
     </formalpara>
     <para>
      此外，请考虑需要储存的文件数量及大小。例如，如果您的文件系统上将会有许多小文件，则可以指定一个较小的每 inode 的字节数比率，这样会增加 inode 的数量。如果文件系统将储存超大型文件，您可以指定一个较大的每 Inode 的字节数比率，这样可减少可能的 Inode 数。
     </para>
     <para>
      通常情况下，最好要保证有足够多的 inode 可供使用。如果 inode 数量过少且文件很小，则可能当磁盘上的文件数量已达最大值时实际上磁盘却还很空。如果 inode 过多且文件很大，则可能虽然报告仍有可用空间，但却无法使用，这是因为您无法在为 inode 预留的空间中新建文件。
     </para>
    </listitem>
   </itemizedlist>
   <para>
    使用以下任何一种方法设置 inode 大小以及每 inode 的字节数比率：
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <formalpara>
      <title>修改所有新 Ext4 文件系统的默认设置：</title>
      <para>
       在文本编辑器中，修改 <filename>/etc/mke2fs.conf</filename> 文件的 <literal>defaults</literal> 部分，以为 <literal>inode_size</literal> 和 <literal>inode_ratio</literal> 设置所需的默认值。这些值将应用到所有新的 Ext4 文件系统。例如：
      </para>
     </formalpara>
<screen>blocksize = 4096
inode_size = 128
inode_ratio = 8192</screen>
    </listitem>
    <listitem>
     <formalpara>
      <title>在命令行处：</title>
      <para>
       新建 Ext4 文件系统时，将 inode 大小 (<literal>-I 128</literal>) 以及每 inode 的字节数比率 (<literal>-i 8192</literal>) 传递给 <command>mkfs.ext4(8)</command> 命令或 <command>mke2fs(8)</command> 命令。例如，使用以下任一命令：
      </para>
     </formalpara>
<screen><prompt>&gt; </prompt><command>sudo</command> mkfs.ext4 -b 4096 -i 8092 -I 128 /dev/sda2
<prompt>&gt; </prompt><command>sudo</command> mke2fs -t ext4 -b 4096 -i 8192 -I 128 /dev/sda2</screen>
    </listitem>
    <listitem>
     <formalpara>
      <title>在使用 YaST 安装期间：</title>
      <para>
       在安装期间，新建 Ext4 文件系统时要传递 inode 大小和每 inode 的字节数比率值。在<guimenu>专家分区程序</guimenu>中选择分区，然后单击<guimenu>编辑</guimenu>。在<guimenu>格式化选项</guimenu>下，选择<guimenu>格式化设备</guimenu><guimenu>Ext4</guimenu>，然后单击<guimenu>选项</guimenu>。在<guimenu>格式化选项</guimenu>对话框中，从<guimenu>块大小（字节）</guimenu>、<guimenu>每 inode 的字节数</guimenu>和 <guimenu>Inode 大小</guimenu>下拉框中选择所需的值。
      </para>
     </formalpara>
     <para>
      例如，在<guimenu>块大小 (B)</guimenu> 下拉框中选择 4096、在<guimenu>每 inode 的字节数</guimenu>下拉框中选择 8192、在 <guimenu>Inode 大小</guimenu>下拉框中选择 128，然后单击<guimenu>确定</guimenu>。
     </para>
     <informalfigure>
      <mediaobject>
       <imageobject role="fo">
        <imagedata fileref="ext4_inode_yast_a.png" width="60%"/>
       </imageobject>
       <imageobject role="html">
        <imagedata fileref="ext4_inode_yast_a.png" width="100%"/>
       </imageobject>
      </mediaobject>
     </informalfigure>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 xml:id="sec-upgrade-to-ext4">
   <title>升级到 Ext4</title>
   <important>
    <title>备份数据</title>
    <para>
     在对文件系统执行任何更新之前，请备份文件系统上的所有数据。
    </para>
   </important>
   <procedure>
    <title>升级到 Ext4</title>
    <step>
     <para>
      要从 Ext2 或 Ext3 进行升级，必须启用以下功能：
     </para>
     <variablelist>
      <title>Ext4 所需的功能</title>
      <varlistentry>
       <term>extents</term>
       <listitem>
        <para>
         硬盘上的邻接块，用于使文件彼此相连并防止出现碎片
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>unint_bg</term>
       <listitem>
        <para>
         迟缓 inode 表初始化
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>dir_index</term>
       <listitem>
        <para>
         针对大目录的哈希 b 树查找
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>在 Ext2 上：<literal>as_journal</literal></term>
       <listitem>
        <para>
         在 Ext2 文件系统上启用日志。
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
     <para>
      要启用这些功能，请运行：
     </para>
     <itemizedlist>
      <listitem>
       <para>
        在 Ext3 上：
       </para>
<screen><prompt role="root"># </prompt>tune2fs -O extents,uninit_bg,dir_index <replaceable>DEVICE_NAME</replaceable></screen>
      </listitem>
      <listitem>
       <para>
        在 Ext2 上：
       </para>
<screen><prompt role="root"># </prompt>tune2fs -O extents,uninit_bg,dir_index,has_journal <replaceable>DEVICE_NAME</replaceable></screen>
      </listitem>
     </itemizedlist>
    </step>
    <step>
     <para>
      以 <systemitem class="username">root</systemitem> 身份编辑 <filename>/etc/fstab</filename> 文件：将 <literal>ext3</literal> 或 <literal>ext2</literal> 记录更改为 <literal>ext4</literal>。此更改将在下次重引导后生效。
     </para>
    </step>
    <step>
     <para>
      要引导 Ext4 分区上设置的文件系统，请在 <literal>initramfs</literal> 中添加模块 <literal>ext4</literal> 和 <literal>jbd</literal>。打开或创建 <filename>/etc/dracut.conf.d/filesystem.conf</filename> 并添加以下行：
     </para>
<screen>force_drivers+=" ext4 jbd"</screen>
     <para>
      需要通过运行以下命令来重写现有的 dracut <filename>initramfs</filename>：
     </para>
<screen>dracut -f</screen>
    </step>
    <step>
     <para>
      重引导系统。
     </para>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-filesystems-major-reiser">
  <title>ReiserFS</title>

  <para>
   <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 15 中完全去除了 ReiserFS 支持。要将现有分区迁移到 Btrfs，请参见<xref linkend="sec-filesystems-major-btrfs-migrate"/>。
  </para>
 </sect1>
 <sect1 xml:id="sec-filessytems-zfs">
  <title>OpenZFS 和 ZFS</title>

  <para>
   OpenZFS 和 ZFS 文件系统都不受 SUSE 的支持。ZFS 是一个闭源文件系统，因此不可由 SUSE 使用。用于约束 OpenZFS 的 CDDL 许可证与 GPL 许可证不兼容。但是，Btrfs 相应地为 OpenZFS 提供了一个优异的替代方案。ZFS 完全受 SUSE 的支持。
  </para>
 </sect1>
 <sect1 xml:id="sec-filesystems-other">
  <title>其他受支持的文件系统</title>

  <para role="intro">
   <xref linkend="tab-filesystems-other" xrefstyle="TableXRef"/>对 linux 支持的其他一些文件系统进行了总结。支持这些文件系统主要是为了确保与不同类型的媒体或异操作系统实现兼容和数据交换。
  </para>

  <table xml:id="tab-filesystems-other">
   <title>Linux 中的文件系统类型</title>
   <tgroup cols="2">
    <colspec colnum="1" colname="1" colwidth="2381*"/>
    <colspec colnum="2" colname="2" colwidth="7620*"/>
    <thead>
     <row>
      <entry>
       <para>
        文件系统类型
       </para>
      </entry>
      <entry>
       <para>
        说明
       </para>
      </entry>
     </row>
    </thead>
    <tbody>
     
     
     <row>
      <entry>
       <para>
        <systemitem>iso9660</systemitem>
       </para>
      </entry>
      <entry>
       <para>
        CD-ROM 上的标准文件系统。
       </para>
      </entry>
     </row>
     
     <row>
      <entry>
       <para>
        <systemitem>msdos</systemitem>
       </para>
      </entry>
      <entry>
       <para>
        <filename>fat</filename>（最初由 DOS 使用的文件系统）现在已被多种操作系统采用。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <systemitem>nfs</systemitem>
       </para>
      </entry>
      <entry>
       <para>
        网络文件系统：在此文件系统中，可以将数据储存在网络中的任何计算机上，并可以通过网络授予访问权限。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <systemitem>ntfs</systemitem>
       </para>
      </entry>
      <entry>
       <para>
        Windows NT 文件系统；只读。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <systemitem>exfat</systemitem>
       </para>
      </entry>
      <entry>
       <para>
        为使用闪存（例如 USB 闪存盘和 SD 卡）而优化的文件系统。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <systemitem>smbfs</systemitem>
       </para>
      </entry>
      <entry>
       <para>
        Windows 等产品使用服务器消息块来支持通过网络启用文件访问。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <systemitem>ufs</systemitem>
       </para>
      </entry>
      <entry>
       <para>
        供 BSD、SunOS 和 NextStep 使用。只在只读方式下支持此文件系统。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <systemitem>umsdos</systemitem>
       </para>
      </entry>
      <entry>
       <para>
        MS-DOS 上的 Unix：在标准 <filename>fat</filename> 文件系统之上应用，通过创建特殊文件获得 Unix 功能（权限、链接和长文件名）。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <systemitem>vfat</systemitem>
       </para>
      </entry>
      <entry>
       <para>
        虚拟 FAT：<literal>fat</literal> 文件系统的扩展（支持长文件名）。
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>
 <sect1 xml:id="sec-blacklist-filsystem">
  <title>已阻止的文件系统</title>

  <para>
   出于安全原因，已阻止某些文件系统自动挂载。这些文件系统通常不再受到维护，并且不太常用。但是，可以装载这些文件系统的内核模块，因为内核中 API 仍是兼容的。将用户可挂载的文件系统和可卸设备上自动挂载的文件系统结合使用可能会导致非特权用户触发内核模块自动装载，并可能导致可卸设备储存潜在恶意的数据。
  </para>

  <para>
   要获取不允许自动挂载的文件系统列表，请运行以下命令：
  </para>

<screen><prompt>&gt; </prompt><command>sudo</command> rpm -ql suse-module-tools  | sed -nE 's/.*blacklist_fs-(.*)\.conf/\1/p'</screen>

  <para>
   如果您尝试使用 <command>mount</command> 命令挂载包含已阻止文件系统的设备，该命令将输出错误消息，例如：
  </para>

<screen>mount: /mnt/mx: unknown filesystem type 'minix' (hint: possibly blacklisted, see mount(8)).</screen>

  <para>
   要允许挂载文件系统，需要从阻止列表中去除特定的文件系统。每个已阻止的文件系统具有自身的配置文件，例如，<systemitem>efs</systemitem> 的配置文件是 <filename>/lib/modules.d/60-blacklist_fs-efs.conf</filename>。但是，请不要编辑这些文件，因为每当更新软件包 <literal>suse-module-tools</literal> 时，就会重写这些文件。要允许自动挂载已阻止的文件系统，可使用以下选项：
  </para>

  <itemizedlist>
   <listitem>
    <para>
     创建指向 <filename>/dev/null</filename> 的符号链接，例如，为 <emphasis>efs</emphasis> 文件系统创建以下符号链接：
    </para>
<screen><prompt>&gt; </prompt><command>sudo</command> ln -s /dev/null /etc/modules.d/60-blacklist_fs-efs.conf</screen>
   </listitem>
   <listitem>
    <para>
     将配置文件复制到 <filename>/etc/modprobe.d</filename>：
    </para>
<screen><prompt>&gt; </prompt><command>sudo</command> cp /lib/modules.d/60-blacklist_fs-efs.conf /etc/modprobe.d/60-blacklist_fs-efs.conf</screen>
    <para>
     在配置文件中注释掉以下语句：
    </para>
<screen># blacklist omfs</screen>
   </listitem>
  </itemizedlist>

  <para>
   即使无法自动挂载某个文件系统，您也可以直接使用 <command>modprobe</command> 装载该文件系统的相应内核模块：
  </para>

<screen><prompt>&gt; </prompt><command>sudo</command> modprobe <replaceable>FILESYSTEM</replaceable>
</screen>

  <para>
   例如，对于 <systemitem>cramfs</systemitem> 文件系统，输出如下所示：
  </para>

<screen>unblacklist: loading cramfs file system module
unblacklist: Do you want to un-blacklist cramfs permanently (&lt;y&gt;es/&lt;n&gt;o/n&lt;e&gt;ver)? y
unblacklist: cramfs un-blacklisted by creating /etc/modprobe.d/60-blacklist_fs-cramfs.conf</screen>

  <para>
   如果您选择 <emphasis>yes</emphasis>，则 <command>modprobe</command> 命令会调用一个脚本用于创建从所提供文件系统的配置文件到 <filename>/dev/null</filename> 的符号链接。因此，会从阻止列表中去除该文件系统。
  </para>
 </sect1>
 <sect1 xml:id="sec-filesystems-lfs">
  <title>Linux 中的大型文件支持</title>

  <para>
   最初，Linux 支持的最大文件大小为 2 GiB（2<superscript>31</superscript> 字节）。除非文件系统支持大型文件，否则 32 位系统上的最大文件大小为 2 GiB。
  </para>

  <para>
   目前，所有标准文件系统都具有 LFS（大型文件支持）功能，理论上可支持的最大文件大小为 2<superscript>63</superscript> 字节。<xref linkend="tab-filesystems-maxsize" xrefstyle="TableXRef"/>概述了 Linux 文件和文件系统的当前磁盘上格式的限制。表中的数字基于文件系统使用 4 KiB 块大小的假设得出，这是通用的标准。使用不同的块大小，结果也就不同。使用较稀疏的块时，<xref linkend="tab-filesystems-maxsize" xrefstyle="TableXRef"/>中的最大文件大小可能会大于文件系统的实际大小。
  </para>

  <note>
   <title>二进制倍数</title>
   <para>
    在此文档中：1024 字节 = 1 KiB；1024 KiB = 1 MiB；1024 MiB = 1 GiB；1024 GiB = 1 TiB；1024 TiB = 1 PiB；1024 PiB = 1 EiB（另请参见 <link xlink:href="http://physics.nist.gov/cuu/Units/binary.html"><citetitle>NIST：二进制倍数的前缀</citetitle></link>）。
   </para>
  </note>

  <table xml:id="tab-filesystems-maxsize">
   <title>文件和文件系统的最大大小（磁盘格式，4 KiB 块大小)</title>
   <tgroup cols="3">
    <colspec colnum="1" colname="1" colwidth="3334*"/>
    <colspec colnum="2" colname="2" colwidth="3334*"/>
    <colspec colnum="3" colname="3" colwidth="3334*"/>
    <thead>
     <row>
      <entry>
       <para>
        文件系统（4 KiB 块大小）
       </para>
      </entry>
      <entry>
       <para>
        最大文件系统大小
       </para>
      </entry>
      <entry>
       <para>
        最大文件大小
       </para>
      </entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <para>
        Btrfs
       </para>
      </entry>
      <entry>
       <para>
        16 EiB
       </para>
      </entry>
      <entry>
       <para>
        16 EiB
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        Ext3
       </para>
      </entry>
      <entry>
       <para>
        16 TiB
       </para>
      </entry>
      <entry>
       <para>
        2 TiB
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        Ext4
       </para>
      </entry>
      <entry>
       <para>
        1 EiB
       </para>
      </entry>
      <entry>
       <para>
        16 TiB
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        OCFS2（高可用性扩展中可使用的群集感知文件系统）
       </para>
      </entry>
      <entry>
       <para>
        16 TiB
       </para>
      </entry>
      <entry>
       <para>
        1 EiB
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        XFS
       </para>
      </entry>
      <entry>
       <para>
        16 EiB
       </para>
      </entry>
      <entry>
       <para>
        8 EiB
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        NFSv2（客户端）
       </para>
      </entry>
      <entry>
       <para>
        8 EiB
       </para>
      </entry>
      <entry>
       <para>
        2 GiB
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        NFSv3/NFSv4（客户端）
       </para>
      </entry>
      <entry>
       <para>
        8 EiB
       </para>
      </entry>
      <entry>
       <para>
        8 EiB
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <important>
   <title>限制</title>
   <para>
    <xref linkend="tab-filesystems-maxsize" xrefstyle="TableXRef"/>介绍了有关磁盘上格式的限制。Linux 内核自身的大小限制同样适用于其处理的文件和文件系统大小。下面介绍了这些限制：
   </para>
   <variablelist>
    <varlistentry>
     <term>文件大小</term>
     <listitem>
      <para>
       在 32 位系统上，文件不能超过 2 TiB（2<superscript>41</superscript> 字节）。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>文件系统大小</term>
     <listitem>
      <para>
       文件系统最大可以为 2<superscript>73</superscript> 个字节。但是，目前可用的硬件尚不会超出这一限制。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </important>
 </sect1>
 <sect1 xml:id="sec-filesystems-stor-limits">
  <title>Linux 内核储存的限制</title>

  <para>
   <xref linkend="tab-filesystems-stor-limits" xrefstyle="TableXRef"/> 总结了与 <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 相关联的储存的内核限制。
  </para>

  <table xml:id="tab-filesystems-stor-limits">
   <title>储存限制</title>
   <tgroup cols="2">
    <colspec colnum="1" colname="1" colwidth="5001*"/>
    <colspec colnum="2" colname="2" colwidth="5001*"/>
    <thead>
     <row>
      <entry>
       <para>
        储存功能
       </para>
      </entry>
      <entry>
       <para>
        限制
       </para>
      </entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <para>
        支持的 LUN 最大数量
       </para>
      </entry>
      <entry>
       <para>
        每个目标 16384 个 LUN。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        每一个单独 LUN 的最大路径数量
       </para>
      </entry>
      <entry>
       <para>
        默认情况下没有限制。每个路径视作一个常规 LUN。
       </para>
       <para>
        每个目标的 LUN 数量以及每个 HBA 的目标数量决定了实际的限制（光纤通道 HBA 为 16777215）。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        HBA 的最大数量
       </para>
      </entry>
      <entry>
       <para>
        不限.实际限制取决于系统的 PCI 槽的数量。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        每个操作系统使用 device-mapper-multipath 的最大路径数量（总计）
       </para>
      </entry>
      <entry>
       <para>
        大约为 1024。实际数量取决于每个多路径设备的设备号字符串长度。它是 multipath-tools 中的一个编译时间变量，如果此限制会导致问题，则可提高其值。
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        每一个块设备的最大大小
       </para>
      </entry>
      <entry>
       <para>
        最多 8 EiB。
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>
 <sect1 xml:id="sec-filesystems-trouble-trim">
  <title>释放未使用的文件系统块</title>

  <para>
   在固态硬盘 (SSD) 和精简配置的卷中，释放未被文件系统使用的块会很有用。在支持 <literal>unmap</literal> 和 <literal>TRIM</literal> 操作的所有文件系统上，<phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 完全支持执行这种操作。
  </para>

  <para>
   有两种常用的 TRIM 操作 — 联机 <literal>TRIM</literal> 和定期 <literal>TRIM</literal>。释放设备的最合适方法取决于您的用例。一般情况下，建议使用定期 TRIM，尤其是当设备具有足够的可用块时。如果设备经常接近容量耗尽状态，则最好使用联机 TRIM。
  </para>

  <important>
   <title>设备对 <literal>TRIM</literal> 操作的支持</title>
   <para>
    在尝试使用 <literal>TRIM</literal> 操作之前，请始终校验您的设备是否支持该操作。否则，您可能会丢失该设备上的数据。要校验是否支持 <literal>TRIM</literal> 操作，请运行以下命令：
   </para>
<screen><prompt>&gt; </prompt><command>sudo</command> lsblk --discard</screen>
   <para>
    该命令会输出有关所有可用块设备的信息。如果 <literal>DISC-GRAN</literal> 和 <literal>DISC-MAX</literal> 列的值不为零，则表示设备支持 <literal>TRIM</literal> 操作。
   </para>
  </important>

  <sect2 xml:id="sec-filesystems-periodic-trim">
   <title>定期 TRIM</title>
   <para>
    定期 TRIM 由 <systemitem class="daemon">systemd</systemitem> 定期调用的 <command>fstrim</command> 命令进行处理。您也可以手动运行该命令。
   </para>
   <para>
    要安排定期 TRIM，请如下所示启用 <literal>fstrim.timer</literal>：
   </para>
<screen><prompt>&gt; </prompt><command>sudo</command> systemctl enable fstrim.timer</screen>
   <para>
    <systemitem class="daemon">systemd</systemitem> 在 <filename>/usr/lib/systemd/system</filename> 中创建一个单元文件。默认情况下，该服务每周运行一次，这种频率通常已足够。但是，您可以通过将 <literal>OnCalendar</literal> 选项配置为所需值来更改频率。
   </para>
   <para>
    <command>fstrim</command> 的默认行为是丢弃文件系统中的所有块。您可以在调用该命令时使用选项来修改此行为。例如，可以传递 <literal>offset</literal> 选项来定义释放过程的起始位置。有关细节，请参见 <command>man fstrim</command>。
   </para>
   <para>
    <command>fstrim</command> 命令可对储存在 <filename>/etc/fstab</filename> 文件中的支持 <literal>TRIM</literal> 操作的所有设备执行释放 — 为此，请在调用该命令时使用 <literal>-A</literal> 选项。
   </para>
   <para>
    要禁用特定设备的释放，请如下所示将选项 <literal>X-fstrim.notrim</literal> 添加到 <filename>/etc/fstab</filename> 文件中：
   </para>
<screen>UID=83df497d-bd6d-48a3-9275-37c0e3c8dc74  /  btrfs  defaults,X-fstrim.notrim                      0  0
</screen>
  </sect2>

  <sect2 xml:id="sec-filesystem-online-trim">
   <title>联机 TRIM</title>
   <para>
    每次向设备写入数据时，都会对该设备执行联机 TRIM。
   </para>
   <para>
    要启用设备的联机 TRIM，请如下所示将 <literal>discard</literal> 选项添加到 <filename>/etc/fstab</filename> 文件中：
   </para>
<screen>UID=83df497d-bd6d-48a3-9275-37c0e3c8dc74  /  btrfs  defaults,discard</screen>
   <para>
    或者，在 Ext4 文件系统上，可以使用 <command>tune2fs</command> 命令在 <filename>/etc/fstab</filename> 中设置 <literal>discard</literal> 选项：
   </para>
<screen><prompt>&gt; </prompt><command>sudo</command> tune2fs -o discard <replaceable>DEVICE</replaceable></screen>
   <para>
    如果设备是结合 <literal>discard</literal> 选项通过 <command>mount</command> 挂载的，则也要将 <literal>discard</literal> 选项添加到 <filename>/etc/fstab</filename>：
   </para>
<screen><prompt>&gt; </prompt><command>sudo</command> mount -o discard <replaceable>DEVICE</replaceable></screen>
   <note>
    <title>联机 TRIM 的缺点</title>
    <para>
     使用 <literal>discard</literal> 选项可能会缩短某些低质量 SSD 设备的使用寿命。联机 TRIM 还可能会影响设备的性能，例如，在删除大量数据的情况下。在这种情况下，可能会重新分配一个擦除块，并在短时间后，再次将同一擦除块标记为未使用。
    </para>
   </note>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-filesystems-trouble">
  <title>文件系统查错</title>

  <para>
   本节说明文件系统的一些已知问题和可能的解决方案。
  </para>

  <sect2 xml:id="sec-filesystems-trouble-btrfs-volfull">
   <title>Btrfs 错误：设备上没有剩余空间</title>
   <para>
    使用 Btrfs 文件系统的根 (<filename>/</filename>) 分区停止接受数据。您收到错误<quote><literal>设备上没有剩余空间</literal></quote>。
   </para>
   <para>
    请参见下列各部分，了解有关此问题的可能原因和预防措施的信息。
   </para>
   <sect3 xml:id="sec-filesystems-trouble-btrfs-volfull-snapshots">
    <title>Snapper 快照使用的磁盘空间</title>
    <para>
     如果 Snapper 是针对 Btrfs 文件系统运行的，则<quote><literal>设备上没有剩余空间</literal></quote>问题通常是由于系统上做为快照储存的数据过多所致。
    </para>
    <para>
     您可以从 Snapper 中去除一些快照，不过，快照不会立即删除，可能不能释放您需要的空间容量。
    </para>
    <para>
     若要从 Snapper 中删除文件：
    </para>
    <procedure>
     <step>
      <para>
       打开一个终端控制台。
      </para>
     </step>
     <step>
      <para>
       在命令提示符处，输入 <command>btrfs filesystem show</command>，例如：
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> btrfs filesystem show
Label: none uuid: 40123456-cb2c-4678-8b3d-d014d1c78c78
 Total devices 1 FS bytes used 20.00GB
 devid 1 size 20.00GB used 20.00GB path /dev/sda3</screen>
     </step>
     <step>
      <para>
       输入
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> btrfs fi balance start <replaceable>MOUNTPOINT</replaceable> -dusage=5</screen>
      <para>
       此命令会尝试将数据重新放置在空的或接近空的数据块中，从而允许收回空间并将其重新指派给元数据。此操作可能需要一些时间（1 TB 数据可能需要很多小时），不过，在此期间系统仍可以使用。
      </para>
     </step>
     <step>
      <para>
       列出快照程序中的快照。输入
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> snapper -c root list</screen>
     </step>
     <step>
      <para>
       从 Snapper 中删除一或多个快照。输入
      </para>
<screen><prompt>&gt; </prompt><command>sudo</command> snapper -c root delete <replaceable>SNAPSHOT_NUMBER(S)</replaceable></screen>
      <para>
       务必先删除最旧的快照。快照生成的时间越长，其占用的空间就越大。
      </para>
     </step>
    </procedure>
    <para>
     为了避免此问题发生，您可以更改 Snapper 清理算法。有关详细信息，请参见 <xref linkend="sec-snapper-manage-metadata-cleanup"/>。控制快照清理的配置值为 <envar>EMPTY_*</envar>、<envar>NUMBER_*</envar> 和 <envar>TIMELINE_*</envar>。
    </para>
    <para>
     如果在文件系统磁盘上搭配使用 Snapper 和 Btrfs，建议您保留两倍于标准储存建议的磁盘空间容量。YaST 分区程序会自动在 Btrfs 储存建议中为根文件系统建议标准磁盘空间的两倍容量。
    </para>
   </sect3>
   <sect3 xml:id="sec-filesystems-trouble-btrfs-volfull-var">
    <title>日志、崩溃和缓存文件使用的磁盘空间</title>
    <para>
     如果系统磁盘填满了数据，您可以尝试从 <filename>/var/log</filename>、<filename>/var/crash</filename>、<filename>/var/lib/systemd/coredump</filename> 和 <filename>/var/cache</filename> 中删除文件。
    </para>
    <para>
     Btrfs <systemitem class="username">root</systemitem> 文件系统子卷 <filename>/var/log</filename>、<filename>/var/crash</filename> 和 <filename>/var/cache</filename> 在正常运作情况下可能会使用所有可用的磁盘空间，此时将导致系统故障。为避免出现此状况，<phrase role="productname"><phrase os="sles">SUSE Linux Enterprise Server</phrase></phrase> 提供了 Btrfs 子卷配额支持。有关详细信息，请参见 <xref linkend="sec-filesystems-major-btrfs-quota"/>。
    </para>
    <para>
     在测试和开发计算机上，尤其是当应用程序频繁崩溃时，您也可能想查看 <filename>/var/lib/systemd/coredump</filename>，内核转储就储存在其中。
    </para>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-filesystems-trouble-balance">
   <title>Btrfs：跨设备平衡数据</title>
   <para>
    <command>btrfs balance</command> 命令是 <package>btrfs-progs</package> 软件包的一部分。它可以在以下示例情况下平衡 Btrfs 文件系统上的块组：
   </para>
   <itemizedlist>
    <listitem>
     <para>
      假设您有一个 1 TB 驱动器，其中的 600 GB 被数据使用，然后又添加了另一个 1 TB 驱动器。理论上，平衡后将导致每个驱动器上各有 300 GB 的已用空间。
     </para>
    </listitem>
    <listitem>
     <para>
      您的设备上有大量接近空的区块。在执行平衡清除这些区块之前，它们的空间都将不可用。
     </para>
    </listitem>
    <listitem>
     <para>
      您需要根据其使用百分比压缩半空的块组。以下命令将平衡使用率等于或小于 5% 的块组：
     </para>
<screen><prompt>&gt; </prompt><command>sudo</command> btrfs balance start -dusage=5 /</screen>
     <tip>
      <para>
       <filename>/usr/lib/systemd/system/btrfs-balance.timer</filename> 计时器负责每月清理未使用的块组。
      </para>
     </tip>
    </listitem>
    <listitem>
     <para>
      您需要清除块设备的未满部分，更均匀地分布数据。
     </para>
    </listitem>
    <listitem>
     <para>
      您需要在不同的 RAID 类型之间迁移数据。例如，要将一组磁盘上的数据从 RAID1 转换到 RAID5，请运行以下命令：
     </para>
<screen><prompt>&gt; </prompt><command>sudo</command> btrfs balance start -dprofiles=raid1,convert=raid5 /</screen>
    </listitem>
   </itemizedlist>
   <tip>
    <para>
     要微调 Btrfs 文件系统上平衡数据的默认行为（例如，平衡的频率或挂载点），请检查并自定义 <filename>/etc/sysconfig/btrfsmaintenance</filename>。相关选项以 <option>BTRFS_BALANCE_</option> 开头。
    </para>
   </tip>
   <para>
    有关 <command>btrfs balance</command> 命令用法的细节，请参见其手册页 (<command>man 8 btrfs-balance</command>)。
   </para>
  </sect2>

  <sect2 xml:id="sec-filesystems-trouble-defrag">
   <title>不要在 SSD 中进行碎片整理</title>
   <para>
    Linux 文件系统包含相应的机制用于避免数据碎片，因此通常没有必要执行碎片整理。但在某些使用场合下，数据碎片不可避免，而对硬盘进行碎片整理可以明显提高性能。
   </para>
   <para>
    这种做法仅适用于传统的硬盘。在使用闪存储存数据的固态硬盘 (SSD) 中，固件提供的算法可以确定要将数据写入哪些芯片。数据通常分散在设备的各个位置。因此，对 SSD 进行碎片整理并不能获得所需的效果，反而会因为写入不必要的数据而缩短 SSD 的寿命。
   </para>
   <para>
    出于上述原因，SUSE 肯定地建议<emphasis>不要</emphasis>对 SSD 进行碎片整理。某些供应商还会警告对其固态硬盘进行碎片整理所产生的后果。这些品牌包括但不限于：
   </para>
   <itemizedlist>
    <listitem>
     <para>
      HPE 3PAR StoreServ All-Flash
     </para>
    </listitem>
    <listitem>
     <para>
      HPE 3PAR StoreServ Converged Flash
     </para>
    </listitem>
   </itemizedlist>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-filesystems-info">
  <title>更多信息</title>

  <para>
   上面介绍的每个文件系统项目都有自己的主页，可以在其中找到邮件列表信息、更多文档和常见问题：
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     Kernel.org 上的 Btrfs Wiki：<link xlink:href="https://btrfs.wiki.kernel.org/"/>
    </para>
   </listitem>
   <listitem>
    <para>
     E2fsprogs: Ext2/3/4 File System Utilities: <link xlink:href="http://e2fsprogs.sourceforge.net/"/>
    </para>
   </listitem>
   <listitem>
    <para>
     OCFS2 Project（OCFS2 项目）：<link xlink:href="https://oss.oracle.com/projects/ocfs2/"/>
    </para>
   </listitem>
  </itemizedlist>

  <para>
   Wikipedia 项目上的“Comparison of File Systems”（文件系统比较，网址：<link xlink:href="http://en.wikipedia.org/wiki/Comparison_of_file_systems#Comparison"/>）中提供了对各种文件系统（不仅仅是 Linux 文件系统）更深入的比较。
  </para>
 </sect1>
</chapter>
