<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="ulp.xml" version="5.0" xml:id="cha-ulp" xml:lang="zh-tw">
 <title>使用者空間即時修補</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
  <abstract>
   <para>
    本文件介紹使用者空間即時修補的基本原理和用法。
   </para>
  </abstract>
 </info>
 <sect1 xml:id="sec-ulp">
  <title>關於使用者空間即時修補</title>

  <para>
   使用者空間即時修補 (ULP) 是指將修補程式套用至執行中程序所用程式庫而不中斷該程序的過程。使用做為 <systemitem>libpulp</systemitem> 一部分的 <systemitem>ulp</systemitem> 工具來執行即時修補操作。
  </para>

  <para>
   <systemitem>libpulp</systemitem> 是可實現使用者空間即時修補的架構。它由 <systemitem>libpulp.so</systemitem> 程式庫和用於使程式庫可即時修補以及套用線上修補程式的工具 (<systemitem>ulp</systemitem> 二進位檔案) 組成。
  </para>

  <sect2 xml:id="sec-ulp-prereqs">
   <title>先決條件</title>
   <para>
    若要使 ULP 正常運作，必須符合兩個要求。
   </para>
   <itemizedlist>
    <listitem>
     <para>
      若要使程式庫可即時修補，必須使用 <option>-fpatchable-function-entry</option> GCC 旗標編譯程式庫。不需要變更程式庫原始碼。
     </para>
    </listitem>
    <listitem>
     <para>
      程序必須預先載入 <systemitem>libpulp.so</systemitem> 程式庫。
     </para>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 xml:id="sec-ulp-libpulp">
   <title>使用 libpulp</title>
   <para>
    若要對應用程式使用 <systemitem>libpulp</systemitem>，必須執行以下步驟：
   </para>
   <orderedlist>
    <listitem>
     <para>
      使程式庫可即時修補。
     </para>
    </listitem>
    <listitem>
     <para>
      啟動應用程式時，使用以下指令預先載入 <systemitem>libpulp</systemitem>：<command>LD_PRELOAD=/usr/lib64/libpulp.so ./<replaceable>APPLICATION</replaceable></command>。
     </para>
    </listitem>
   </orderedlist>
   <sect3 xml:id="sec-ulp-prep-lib">
    <title>準備可即時修補的程式庫</title>
    <para>
     為了使程式庫能夠即時修補，它必須在所有函數呼叫中包含 <literal>NOP</literal> 序言。GCC 版本 8 及更新版本以及 SUSE Linux Enterprise Server 隨附的 GCC 版本專門為此提供了 <option>-fpatchable-function-entry</option>。因此，在 AMD64/Intel 64 架構上，使用 <option>-fpatchable-function-entry=16,14</option> 旗標編譯一個以 C 撰寫的程式庫就足以使該程式庫可即時修補。
    </para>
    <para>
     Glibc、libssl.so.1.1 和 libcrypto.so.1.1 程式庫原本就可在 SUSE Linux Enterprise 15 SP4 上即時修補。
    </para>
   </sect3>
   <sect3 xml:id="sec-ulp-livepatch-check">
    <title>檢查程式庫是否可即時修補</title>
    <para>
     若要檢查程式庫是否可即時修補，請使用以下指令：
    </para>
<screen>ulp livepatchable <replaceable>LIBRARY</replaceable></screen>
   </sect3>
   <sect3 xml:id="sec-ulp-apply-livepatch">
    <title>套用線上修補程式</title>
    <para>
     可以使用 <systemitem>ulp trigger</systemitem> 指令套用線上修補程式，例如：
    </para>
<screen>ulp trigger -p <replaceable>PID</replaceable> <replaceable>LIVEPATCH</replaceable>.ulp</screen>
    <para>
     在此範例中，<literal>PID</literal> 是執行中程序的 PID，該程序使用的程式庫要進行修補，<literal>LIVEPATCH.ulp</literal> 是實際的線上修補程式檔案。
    </para>
    <para>
     <literal>live patching succeeded</literal> 訊息表示即時修補操作成功。
    </para>
   </sect3>
   <sect3 xml:id="sec-ulp-revert-livepatch">
    <title>回復即時修補程式</title>
    <para>
     <command>ulp trigger</command> 可用於回復即時修補程式。可以透過兩種方式回復即時修補程式。您可以透過套用相應的 <filename>.rev</filename> 修補程式來回復即時修補程式：
    </para>
<screen>ulp trigger -p <replaceable>PID</replaceable> <replaceable>LIVEPATCH</replaceable>.rev</screen>
    <para>
     或者，可以移除與特定程式庫關聯的所有修補程式。例如：
    </para>
<screen>ulp trigger -p <replaceable>PID</replaceable> --revert-all=<replaceable>LIBRARY</replaceable></screen>
    <para>
     在上面的範例中，<replaceable>LIBRARY</replaceable> 指的是實際的程式庫，例如：<systemitem>libcrypto.so.1.1</systemitem>。
    </para>
    <para>
     當原始即時修補程式的原始碼不可用時，或者當您希望移除特定的舊修補程式並套用新修補程式，但又不想讓目標應用程式執行可能不安全的代碼時，後一種方法可能很有用。例如：
    </para>
<screen>ulp trigger -p <replaceable>PID</replaceable>  --revert-all=libcrypto.so.1.1 new_livepatch2.ulp</screen>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-ulp-info">
  <title>更多資訊</title>

  <para>
   專案的 <link xlink:href="https://github.com/SUSE/libpulp">Git 儲存庫</link>中提供了有關 <systemitem>libpulp</systemitem> 的更多資訊。
  </para>
 </sect1>
</chapter>
