<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "generic-entities.ent">
    %entities;
]>

<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="cha-security-firewall">
 <title>Masquerading and firewalls</title>
 <info>
      <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
        <dm:bugtracker>
        </dm:bugtracker>
	<dm:translation>yes</dm:translation>
      </dm:docmanager>
    </info>
 <para>
  Whenever Linux is used in a network environment, you can use the
  kernel functions that allow the manipulation of network packets to
  maintain a separation between internal and external network areas. The
  Linux <systemitem>netfilter</systemitem> framework provides the means
  to establish an effective firewall that keeps different networks
  apart. Using iptables&mdash;a generic table structure for the
  definition of rule sets&mdash;precisely controls the packets allowed to
  pass a network interface. Such a packet filter can be set up using
  &firewalld; and its graphical interface <command>firewall-config</command>.
 </para>
 <para>
  &productname; <phrase os="sles;sled">15 GA</phrase><phrase os="osuse">15.0</phrase>
  introduces &firewalld; as the new default software firewall, replacing
  &susefirewall;.
  &susefirewall; has not been removed from &productname;
  <phrase os="sles;sled">15 GA</phrase><phrase os="osuse">15.0</phrase>
  and is still part of the main repository, though not installed by default.
  This chapter provides guidance for configuring &firewalld;, and migrating
  from &susefirewall; for users who have upgraded from older &productname;
  releases.
 </para>

 <sect1 xml:id="sec-security-firewall-iptables">
  <title>Packet filtering with iptables</title>

  <para>
   This section discusses the low-level details of packet filtering. The
   components <systemitem>netfilter</systemitem> and
   <systemitem>iptables</systemitem> are responsible for the filtering and
   manipulation of network packets and for network address translation (NAT).
   The filtering criteria and any actions associated with them are stored in
   chains, which must be matched one after another by individual network
   packets as they arrive. The chains to match are stored in tables. The
   <command>iptables</command> command allows you to alter these tables and
   rule sets.
  </para>

  <para>
   The Linux kernel maintains three tables, each for a particular category
   of functions of the packet filter:
  </para>

  <variablelist>
   <varlistentry>
    <term>filter</term>
    <listitem>
     <para>
      This table holds the bulk of the filter rules, because it implements
      the <emphasis>packet filtering</emphasis> mechanism in the stricter
      sense, which determines whether packets are let through
      (<literal>ACCEPT</literal>) or discarded (<literal>DROP</literal>),
      for example.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>nat</term>
    <listitem>
     <para>
      This table defines any changes to the source and target addresses of
      packets. Using these functions also allows you to implement
      <emphasis>masquerading</emphasis>, which is a special case of NAT used
      to link a private network with the Internet.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>mangle</term>
    <listitem>
     <para>
      The rules held in this table make it possible to manipulate values
      stored in IP headers (such as the type of service).
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   These tables contain several predefined chains to match packets:
  </para>

  <variablelist>
   <varlistentry>
    <term>PREROUTING</term>
    <listitem>
     <para>
      This chain is applied to all incoming packets.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>INPUT</term>
    <listitem>
     <para>
      This chain is applied to packets destined for the system's internal
      processes.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>FORWARD</term>
    <listitem>
     <para>
      This chain is applied to packets that are only routed through the
      system.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>OUTPUT</term>
    <listitem>
     <para>
      This chain is applied to packets originating from the system itself.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>POSTROUTING</term>
    <listitem>
     <para>
      This chain is applied to all outgoing packets.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   <xref linkend="fig-fire-table"/> illustrates the paths along which a
   network packet may travel on a given system. For the sake of simplicity,
   the figure lists tables as parts of chains, but in reality these chains
   are held within the tables themselves.
  </para>

  <para>
   In the simplest case, an incoming packet destined for the system itself
   arrives at the <literal>eth0</literal> interface. The packet is first
   referred to the <literal>PREROUTING</literal> chain of the
   <literal>mangle</literal> table then to the <literal>PREROUTING</literal>
   chain of the <literal>nat</literal> table. The following step, concerning
   the routing of the packet, determines that the actual target of the
   packet is a process of the system itself. After passing the
   <literal>INPUT</literal> chains of the <literal>mangle</literal> and the
   <literal>filter</literal> table, the packet finally reaches its target,
   provided that the rules of the <literal>filter</literal> table allow this.
  </para>

  <figure xml:id="fig-fire-table">
   <title>iptables: a packet's possible paths</title>
   <mediaobject>
    <imageobject role="fo">
     <imagedata width="75%" fileref="fire_tables.svg"/>
    </imageobject>
    <imageobject role="html">
     <imagedata width="65%" fileref="fire_tables.png"/>
    </imageobject>
   </mediaobject>
  </figure>
 </sect1>
 <sect1 xml:id="sec-security-firewall-masq">
  <title>Masquerading basics</title>

  <para>
   Masquerading is the Linux-specific form of NAT (network address
   translation) and can be used to connect a small LAN with the
   Internet.  LAN hosts use IP
   addresses from the private range (see
   <xref linkend="sec-network-addresses-route"/>) and on the Internet
   official IP addresses are used. To be able to connect
   to the Internet, a LAN host's private address is translated to an official
   one. This is done on the router, which acts as the gateway between the
   LAN and the Internet. The underlying principle is a simple one: The
   router has more than one network interface, typically a network card and
   a separate interface connecting with the Internet. While the latter links
   the router with the outside world, one or several others link it with the
   LAN hosts. With these hosts in the local network connected to the network
   card (such as <literal>eth0</literal>) of the router, they can send any
   packets not destined for the local network to their default gateway or
   router.
  </para>

  <important>
   <title>Using the correct network mask</title>
   <para>
    When configuring your network, make sure both the broadcast address and
    the netmask are the same for all local hosts. Failing to do so prevents
    packets from being routed properly.
   </para>
  </important>

  <para>
   As mentioned, whenever one of the LAN hosts sends a packet destined for
   an Internet address, it goes to the default router. However, the router
   must be configured before it can forward such packets. For security
   reasons, this is not enabled in a default installation. To enable it, add
   the line <literal>net.ipv4.ip_forward = 1</literal> in the file
   <filename>/etc/sysctl.conf</filename>. Alternatively do this via &yast;,
   for example by calling <command>yast routing ip-forwarding on</command>.
  </para>

  <para>
   The target host of the connection can see your router, but knows nothing
   about the host in your internal network where the packets originated.
   This is why the technique is called masquerading. Because of the address
   translation, the router is the first destination of any reply packets.
   The router must identify these incoming packets and translate their
   target addresses, so packets can be forwarded to the correct host in the
   local network.
  </para>

  <para>
   With the routing of inbound traffic depending on the masquerading table,
   there is no way to open a connection to an internal host from the
   outside. For such a connection, there would be no entry in the table. In
   addition, any connection already established has a status entry assigned
   to it in the table, so the entry cannot be used by another connection.
  </para>

  <para>
   As a consequence of all this, you might experience some problems with
   several application protocols, such as ICQ, cucme, IRC (DCC, CTCP), and
   FTP (in PORT mode). Web browsers, the standard FTP program, and many
   other programs use the PASV mode. This passive mode is much less
   problematic as far as packet filtering and masquerading are concerned.
  </para>
 </sect1>
 <sect1 xml:id="sec-security-firewall-fw">
  <title>Firewalling basics</title>

  <para>
   <emphasis>Firewall</emphasis> is probably the term most widely used to
   describe a mechanism that controls the data flow between networks.
   Strictly speaking, the mechanism described in this section is called a
   <emphasis>packet filter</emphasis>. A packet filter regulates the data flow
   according to certain criteria, such as protocols, ports, and IP addresses.
   This allows you to block packets that, according to their addresses, are
   not supposed to reach your network. To allow public access to your Web
   server, for example, explicitly open the corresponding port. However, a
   packet filter does not scan the contents of packets with legitimate
   addresses, such as those directed to your Web server. For example, if
   incoming packets were intended to compromise a CGI program on your Web
   server, the packet filter would still let them through.
  </para>

  <para>
   A more effective but more complex mechanism is the combination of several
   types of systems, such as a packet filter interacting with an application
   gateway or proxy. In this case, the packet filter rejects any packets
   destined for disabled ports. Only packets directed to the application
   gateway are accepted. This gateway or proxy pretends to be the actual
   client of the server. In a sense, such a proxy could be considered a
   masquerading host on the protocol level used by the application. One
   example for such a proxy is Squid, an HTTP and FTP proxy server. To use
   Squid, the browser must be configured to communicate via the proxy. Any
   HTTP pages or FTP files requested are served from the proxy cache and
   objects not found in the cache are fetched from the Internet by the
   proxy.
  </para>

  <para>
   The following section focuses on the packet filter that comes with
   &productname;. For further information about packet filtering and
   firewalling, read the <link
   xlink:href="http://www.tldp.org/HOWTO/Firewall-HOWTO.html">Firewall
   HOWTO</link>.
  </para>
 </sect1>
 <sect1 xml:id="sec-security-firewall-firewalld">
  <title>&firewalld;</title>
  <note>
   <title>&firewalld; replaces &susefirewall;</title>
   <para>

    &productname; <phrase os="sles;sled">15 GA</phrase><phrase os="osuse">15.0</phrase>
    introduces &firewalld; as the new default software firewall, replacing
    &susefirewall;.
    &susefirewall; has not been removed from &productname;
    <phrase os="sles;sled">15 GA</phrase><phrase os="osuse">15.0</phrase>
    and is still part of the main repository, though not installed by default.
    If you are upgrading from a release older than &productname;
    <phrase os="sles;sled">15 GA</phrase><phrase os="osuse">15.0</phrase>,
    &susefirewall; will be unchanged and you must manually upgrade to
    &firewalld; (see <xref linkend="sec-security-firewall-upgrade"/>).
   </para>
  </note>
  <para>
   &firewalld; is a daemon that maintains the system's
   <command>iptables</command> rules and offers a D-Bus interface for
   operating on them. It comes with a command line utility
   <command>firewall-cmd</command> and a graphical user interface
   <command>firewall-config</command> for interacting with it. Since
   &firewalld; is running in the background and provides a well defined
   interface it allows other applications to request changes to the iptables
   rules, for example to set up virtual machine networking.
  </para>
  <para>
   &firewalld; implements different security zones. Several predefined
   zones like <literal>internal</literal> and <literal>public</literal> exist.
   The administrator can define additional custom zones if desired. Each
   zone contains its own set of iptables rules. Each network interface is a
   member of exactly one zone. Individual connections can also be assigned to
   a zone based on the source addresses.
  </para>

  <para>
   Each zone represents a certain level of trust. For example the
   <literal>public</literal> zone is not trusted, because other computers in
   this network are not under your control (suitable for Internet or wireless
   hotspot connections). On the other hand the <literal>internal</literal> zone
   is used for networks that <emphasis>are</emphasis> under your control, like a
   home or company network. By utilizing zones this way, a host can offer
   different kinds of services to trusted networks and untrusted networks in a
   defined way.
  </para>

  <para>
   For more information about the predefined zones and their meaning in
   &firewalld;, refer to its manual at
   <link xlink:href="http://www.firewalld.org/documentation/zone/predefined-zones.html"/>.
  </para>

  <note>
    <title>No zone assigned behavior</title>
    <para>
     The initial state for network interfaces is to be assigned to no zone at
     all. In this case the network interface will be implicitly handled in the
     default zone, which can be determined by calling <command>firewall-cmd
      --get-default-zone</command>. If not configured otherwise, the default
     zone is the <literal>public</literal> zone.
    </para>
  </note>

  <para>
   The &firewalld; packet filtering model allows any outgoing connections to
   pass. Outgoing connections are connections that are actively established by
   the local host. Incoming connections that are established by remote hosts are
   blocked if the respective service is not allowed in the zone in
   question. Therefore, each of the interfaces with incoming traffic must be
   placed in a suitable zone to allow for the desired services to be
   accessible. For each of the zones, define the services or protocols you
   need.
  </para>

  <para>
   An important concept of &firewalld; is the distinction between two separate
   configurations: the <emphasis>runtime</emphasis> and the
   <emphasis>permanent</emphasis> configuration. The runtime configuration
   represents the currently active rules, while the permanent configuration
   represents the saved rules that will be applied when restarting
   &firewalld;. This allows to add temporary rules that will be discarded after
   restarting &firewalld;, or to experiment with new rules while being able to
   revert back to the original state. When you are changing the configuration,
   you need to be aware of which configuration you are editing. How this is done
   is discussed in <xref
   linkend="sec-security-firewall-firewalld-configurations"/>.
  </para>

  <para>
   To perform the &firewalld; configuration using the graphical
   user interface <command>firewall-config</command> refer to its <link
   xlink:href="http://www.firewalld.org/documentation/utilities/firewall-config.html">documentation</link>.
   In the following section we will be looking at how to perform typical
   &firewalld; configuration tasks using <command>firewall-cmd</command> on the
   command line.
  </para>

  <sect2 xml:id="sec-security-firewall-firewalld-nm" os="sles;sled">
   <title>Configuring the firewall with &nm;</title>
   <para>
    The &nm; supports a basic configuration of &firewalld;
    by selecting zones.
   </para>
   <para>
    When editing a wired or wireless connection, go to the
    <emphasis>Identity</emphasis> tab in the configuration window and
    use the <literal>Firewall Zone</literal> drop-down box.
   </para>
  </sect2>
  
  <sect2 xml:id="sec-security-firewall-firewalld-yast" os="sles;sled">
   <title>Configuring the Firewall with &yast;</title>
   <para>
     The <command>yast firewall</command> module supports a basic 
     configuration of &firewalld;. It provides a zone 
     selector, services selector, and ports selector. It does not support
     creating custom iptables rules, and limits zone creation and 
     customization to selecting services and ports.
   </para>
  </sect2>

  <sect2 xml:id="sec-security-firewall-firewalld-cmd">
   <title>Configuring the firewall on the command line</title>
   <sect3>
    <title>Firewall start-up</title>

    <para>
     &firewalld; will be installed and enabled by default. It is a regular
     &systemd; service that can be configured via <command>systemctl</command>
     or the &yast; Services Manager.
    </para>

    <important>
     <title>Automatic firewall configuration</title>
     <para> After the installation, &yast; automatically starts &firewalld; and
     leaves all interfaces in the default <literal>public</literal> zone. If a
     server application is configured and activated on the system, &yast; can
     adjust the firewall rules via the options <guimenu>Open Ports on Selected
     Interface in Firewall</guimenu> or <guimenu>Open Ports on
     Firewall</guimenu> in the server configuration modules. Some server module
     dialogs include a <guimenu>Firewall Details</guimenu> button for
     activating additional services and ports.
     </para>
    </important>
   </sect3>

   <sect3 xml:id="sec-security-firewall-firewalld-configurations">
    <title>Runtime versus permanent configuration</title>

    <para>
     By default all <command>firewall-cmd</command> commands operate on the
     runtime configuration. You can apply most operations to the permanent
     configuration <emphasis>only</emphasis> by adding the
     <literal>--permanent</literal> parameter. When doing so the change will
     only affect the permanent configuration and will not be effective
     immediately in the runtime configuration. There is currently no way to add
     a rule to both runtime and permanent configurations in a single invocation.
     To achieve this you can apply all necessary changes to the runtime
     configuration and when all is working as expected issue the following
     command:
    </para>

    <screen>&prompt.root;<command>firewall-cmd --runtime-to-permanent</command></screen>

    <para>
     This will write all current runtime rules into the permanent configuration.
     Any temporary modifications you or other programs may have made to the
     firewall in other contexts are made permanent this way. If you are unsure
     about this, you can also take the opposite approach to be on the safe side:
     Add new rules to the permanent configuration and reload &firewalld; to
     make them active.
    </para>

    <note>
     <para>
      Some configuration items, like the default zone, are shared by both the
      runtime and permanent configurations. Changing them will reflect in both
      configurations at once.
     </para>
    </note>

    <para>
     To revert the runtime configuration to the permanent configuration and
     thereby discard any temporary changes, two possibilities exist, either via
     the &firewalld; command line interface or via &systemd;:
    </para>

    <screen>&prompt.root;<command>firewall-cmd --reload</command></screen>

    <screen>&prompt.root;<command>systemctl reload firewalld</command></screen>

    <para>
     For brevity the examples in the following sections will always operate on
     the runtime configuration, if applicable. Adjust them accordingly to make
     them permanent.
    </para>
   </sect3>

   <sect3>
    <title>Assignment of interfaces to zones</title>

    <para>
     You can list all network interfaces currently assigned to a zone like this:
    </para>
    <screen>&prompt.root;<command>firewall-cmd --zone=public --list-interfaces</command>
eth0</screen>

    <para>
     Similarly you can query which zone a specific interface is assigned to:
    </para>

    <screen>&prompt.root;<command>firewall-cmd --get-zone-of-interface=eth0</command>
public</screen>

    <para>
     The following command lines assign an interface to a zone. The variant
     using <literal>--add-interface</literal> will only work if
     <literal>eth0</literal> is not already assigned to another zone. The
     variant using <literal>--change-interface</literal> will always work,
     removing <literal>eth0</literal> from its current zone if necessary:
    </para>

    <screen>&prompt.root;<command>firewall-cmd --zone=internal --add-interface=eth0</command>
&prompt.root;<command>firewall-cmd --zone=internal --change-interface=eth0</command></screen>

    <para>
      Any operations without an explicit <literal>--zone</literal> argument will
      implicitly operate on the default zone. This pair of commands can be used
      for getting and setting the default zone assignment:
    </para>

    <screen>&prompt.root;<command>firewall-cmd --get-default-zone</command>
dmz
&prompt.root;<command>firewall-cmd --set-default-zone=public</command></screen>

    <important>
     <para>
      Any network interfaces not explicitly assigned to a zone will be
      automatically part of the default zone. Changing the default zone will
      reassign all those network interfaces immediately for the permanent and
      runtime configurations. You should never use a trusted zone like
      <literal>internal</literal> as the default zone, to avoid unexpected
      exposure to threats. For example hotplugged network interfaces like USB
      Ethernet interfaces would automatically become part of the trusted zone in
      such cases.
     </para>

     <para>
      Also note that interfaces that are not explicitly part of any zone will
      not appear in the zone interface list. There is currently no command to
      list unassigned interfaces. Due to this it is best to avoid unassigned
      network interfaces during regular operation.
     </para>
    </important>
   </sect3>

   <sect3 xml:id="sec-security-firewall-firewalld-cmd-ports">
    <title>Making network services accessible</title>

    <para>
     &firewalld; has a concept of <emphasis>services</emphasis>. A service
     consists of definitions of ports and protocols. These definitions
     logically belong together in the context of a given network service like
     a Web or mail server protocol. The following commands can be used to get
     information about predefined services and their details:
    </para>

    <screen>&prompt.root;<command>firewall-cmd --get-services</command>
[...] dhcp dhcpv6 dhcpv6-client dns docker-registry [...]
&prompt.root;<command>firewall-cmd --info-service dhcp</command>
dhcp
  ports: 67/udp
  protocols:
  source-ports:
  modules:
  destination:</screen>

    <para>
     These service definitions can be used for easily making the associated
     network functionality accessible in a zone. This command line will open the
     HTTP Web server port in the internal zone, for example:
    </para>

    <screen>&prompt.root;<command>firewall-cmd --add-service=http --zone=internal</command></screen>

    <para>
     The removal of a service from a zone is performed using the counterpart
     command <literal>--remove-service</literal>. You can also define custom
     services using the <literal>--new-service</literal> subcommand. Refer to
     <link xlink:href="http://www.firewalld.org/documentation/howto/add-a-service.html"/>
     for more details on how to do this.
    </para>

    <para>
     If you just want to open a single port by number, you can use the following
     approach. This will open TCP port 8000 in the internal zone:
    </para>

    <screen>&prompt.root;<command>firewall-cmd --add-port=8000/tcp --zone=internal</command></screen>

    <para>
     For removal use the counterpart command <literal>--remove-port</literal>.
    </para>

    <tip>
     <title>Temporarily opening a service or port</title>
     <para>
      &firewalld; supports a <literal>--timeout</literal> parameter that allows
      to open a service or port for a limited time duration. This can be helpful
      for quick testing and makes sure that closing the service or port will not
      be forgotten. To allow the <literal>imap</literal> service in the
      <literal>internal</literal> zone for 5 minutes, you would call
     </para>
     <screen>&prompt.root;<command>firewall-cmd --add-service=imap --zone=internal --timeout=5m</command></screen>
    </tip>

   </sect3>

   <sect3>
    <title>Lockdown mode</title>

    <para>
     &firewalld; offers a <emphasis>lockdown mode</emphasis> that prevents
     changes to the firewall rules while it is active. Since applications can
     automatically change the firewall rules via the D-Bus interface, and
     depending on the PolicyKit rules regular users may be able to do the same,
     it can be helpful to prevent changes in some situations. You can find more
     information about this at
     <link xlink:href="https://fedoraproject.org/wiki/Features/FirewalldLockdown"/>.
    </para>

    <para>
     It is important to understand that the lockdown mode feature
     provides no real security, but merely protection against accidental or
     benign attempts to change the firewall. The way the lockdown mode is
     currently implemented in &firewalld; provides no security against malicious
     intent, as is pointed out at
     <link xlink:href="http://seclists.org/oss-sec/2017/q3/139"/>.
    </para>

   </sect3>

   <sect3>
    <title>Adding custom <command>iptables</command> rules</title>

    <para>
     &firewalld; claims exclusive control over the host's
     <systemitem>netfilter</systemitem> rules. You should never modify
     firewall rules using other tools like <command>iptables</command>. Doing
     so could confuse &firewalld; and break security or functionality.
    </para>

    <para>
     If you need to add custom firewall rules that aren't covered by
     &firewalld; features then there are two ways to do so. To directly pass
     raw <command>iptables</command> syntax you can use the
     <literal>--direct</literal> option. It expects the table, chain, and
     priority as initial arguments and the rest of the command line is passed
     as is to <command>iptables</command>. The following example adds a
     connection tracking rule for the forwarding filter table:
    </para>

    <screen>&prompt.root;<command>firewall-cmd  --direct --add-rule ipv4 filter FORWARD 0 -i eth0 -o eth1 \
    -p tcp --dport 80 -m state --state NEW,RELATED,ESTABLISHED -j ACCEPT</command></screen>

    <para>
     Additionally, &firewalld; implements so called <emphasis>rich
     rules</emphasis>, an extended syntax for specifying
     <command>iptables</command> rules in an easier way. You can find the
     syntax specification at
     <link xlink:href="http://www.firewalld.org/documentation/man-pages/firewalld.richlanguage.html"/>.
     The following example drops all IPv4 packets originating from a certain
     source address:
    </para>

    <screen>&prompt.root;<command>firewall-cmd --zone=public --add-rich-rule='rule family="ipv4" \
    source address="192.168.2.4" drop'</command></screen>
   </sect3>

   <sect3>
    <title>Routing, forwarding, and masquerading</title>

    <para>
     &firewalld; is not designed to run as a fully fledged router. The
     basic functionality for typical home router setups is available. For a
     corporate production router you should not use &firewalld;, however, but
     use dedicated router and firewall devices instead. The following provides
     just a few pointers on what to look for to utilize routing in &firewalld;:
    </para>

    <itemizedlist mark="bullet" spacing="normal">
     <listitem>
      <para>
       First of all IP forwarding needs to be enabled as outlined in
       <xref linkend="sec-security-firewall-masq"/>.
      </para>
     </listitem>
     <listitem>
      <para>
       To enable IPv4 masquerading, for example in the
       <literal>internal</literal> zone, issue the following command.
      </para>
      <screen>&prompt.root;<command>firewall-cmd --zone=internal --add-masquerade</command></screen>
     </listitem>
     <listitem>
      <para>
       &firewalld; can also enable port forwarding. The following command will
       forward local TCP connections on port 80 to another host:
      </para>
      <screen>&prompt.root;<command>firewall-cmd --zone=public \
    --add-forward-port=port=80:proto=tcp:toport=80:toaddr=192.168.1.10</command></screen>
     </listitem>
    </itemizedlist>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-security-firewall-firewalld-rpcports">
   <title>Accessing services listening on dynamic ports</title>

   <para>
    Some network services do not listen on predefined port numbers. Instead
    they operate based on the <literal>portmapper</literal> or
    <literal>rpcbind</literal> protocol. We will use the term
    <literal>rpcbind</literal> from here on. When one of these services
    starts, it chooses a random local port and talks to
    <literal>rpcbind</literal> to make the port number known.
    <literal>rpcbind</literal> itself is listening on a well known port.
    Remote systems can then query <literal>rpcbind</literal> about the network
    services it knows about and on which ports they are listening. Not many
    programs use this approach anymore today. Popular examples are
    Network Information Services (NIS; <command>ypserv</command> and
    <command>ypbind</command>) and the Network File System (NFS) version 3.
   </para>

   <note>
    <title>About NFSv4</title>
    <para>
     The newer NFSv4 only requires the single well known
     TCP port 2049. For protocol version 4.0 the kernel parameter
     <literal>fs.nfs.nfs_callback_tcpport</literal> may need to be set
     to a static port (see <xref linkend="ex-security-firewall-nfscallback"/>).
     Starting with protocol version 4.1 this setting has also become
     unnecessary.
    </para>
   </note>

   <para>
    The dynamic nature of the <literal>rpcbind</literal> protocol makes
    it difficult to make the affected services behind the firewall accessible.
    &firewalld; does not support these services by itself. For manual configuration,
    see <xref linkend="sec-security-firewall-firewalld-rpcports-static" />.
    Alternatively, &productname; provides a helper script. For details, see
    <xref linkend="sec-security-firewall-firewalld-rpcports-helper" />.
   </para>

   <sect3 xml:id="sec-security-firewall-firewalld-rpcports-static">
    <title>Configuring static ports</title>
    <para>
     One possibility is to configure all involved network services to use
     fixed port numbers. Once this is done, the fixed ports can be opened in
     &firewalld; and everything should work. The actual port numbers used are
     at your discretion but should not clash with any well known port numbers
     assigned to other services. See <xref linkend="tab-security-firewall-sysconfigports"/>
     for a list of the available configuration items for NIS and NFSv3
     services. Note that depending on your actual NIS or NFS configuration,
     not all of these ports may be required for your setup.
    </para>

    <table xml:id="tab-security-firewall-sysconfigports">
     <title>Important sysconfig variables for static port configuration</title>
     <tgroup cols="3">
      <colspec colnum="1" colname="1" colwidth="3*"/>
      <colspec colnum="2" colname="2" colwidth="2*"/>
      <colspec colnum="3" colname="3" colwidth="2*"/>
      <thead>
       <row>
        <entry>
         <para>
          File Path
         </para>
        </entry>
        <entry>
         <para>
          Variable Name
         </para>
        </entry>
        <entry>
         <para>
          Example Value
         </para>
        </entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry morerows='4'>
         <filename>
          /etc/sysconfig/nfs
         </filename>
        </entry>
        <entry>
         MOUNTD_PORT
        </entry>
        <entry>
         21001
        </entry>
       </row>
       <row>
        <entry>
         STATD_PORT
        </entry>
        <entry>
         21002
        </entry>
       </row>
       <row>
        <entry>
         LOCKD_TCPPORT
        </entry>
        <entry>
         21003
        </entry>
       </row>
       <row>
        <entry>
         LOCKD_UDPPORT
        </entry>
        <entry>
         21003
        </entry>
       </row>
       <row>
        <entry>
         RQUOTAD_PORT
        </entry>
        <entry>
         21004
        </entry>
       </row>
       <row>
        <entry>
         <filename>
          /etc/sysconfig/ypbind
         </filename>
        </entry>
        <entry>
         YPBIND_OPTIONS
        </entry>
        <entry>
         -p 24500
        </entry>
       </row>
       <row>
        <entry morerows='2'>
         <filename>
          /etc/sysconfig/ypserv
         </filename>
        </entry>
        <entry>
         YPXFRD_ARGS
        </entry>
        <entry>
         -p 24501
        </entry>
       </row>
       <row>
        <entry>
         YPSERV_ARGS
        </entry>
        <entry>
         -p 24502
        </entry>
       </row>
       <row>
        <entry>
         YPPASSWDD_ARGS
        </entry>
        <entry>
         --port 24503
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <para>
     You will need to restart any related services that are affected by these
     static port configurations for the changes to take effect. You can see
     the currently assigned rpcbind ports by using the command
     <command>rpcinfo -p</command>. On success only the statically configured
     ports should show up there.
    </para>

    <para>
     Apart from the port configuration for network services running in
     userspace there are also ports that are used by the Linux kernel directly
     when it comes to NFS. One of these ports is
     <literal>nfs_callback_tcpport</literal>. It is only required for NFS
     protocol versions older than 4.1. There is a sysctl named
     <literal>fs.nfs.nfs_callback_tcpport</literal> to configure this port.
     This sysctl node only appears dynamically when NFS mounts are active.
     Therefore it is best to configure the port via kernel module
     parameters. This can be achieved by creating a file as shown in
     <xref linkend="ex-security-firewall-nfscallback"/>.
    </para>

    <example xml:id="ex-security-firewall-nfscallback">
     <title>Callback port configuration for the <literal>nfs</literal> kernel module in <filename>/etc/modprobe.d/60-nfs.conf</filename></title>
<screen>options nfs callback_tcpport=21005
</screen>
    </example>

    <para>
     To make this change effective it is easiest to reboot the machine.
     Otherwise all NFS services need to be stopped and the
     <literal>nfs</literal> kernel module needs to be reloaded. To verify the
     active NFS callback port, check the output of
     <command>cat /sys/module/nfs/parameters/callback_tcpport</command>.
    </para>

    <para>
     For easy handling of the now statically configured RPC ports, it is useful
     to create a new &firewalld; service definition. This service definition
     will group all related ports and, for example, makes it easy to make them
     accessible in a specific zone. In
     <xref linkend="ex-security-firewall-newrpcservice"/> this is done for the
     NFS ports as they have been configured in the accompanying examples.
    </para>

    <example xml:id="ex-security-firewall-newrpcservice">
     <title>Commands to define a new &firewalld; RPC service for NFS</title>
<screen>&prompt.root;<command>firewall-cmd --permanent --new-service=nfs-rpc</command>
&prompt.root;<command>firewall-cmd --permanent --service=nfs-rpc --set-description="NFS related, statically configured RPC ports"</command>
# add UDP and TCP ports for the given sequence
&prompt.root;<command>for port in 21001 21002 21003 21004; do
    firewall-cmd --permanent --service=nfs-rpc --add-port ${port}/udp --add-port ${port}/tcp
done</command>
# the callback port is TCP only
&prompt.root;<command>firewall-cmd --permanent --service=nfs-rpc --add-port 21005/tcp</command>

# show the complete definition of the new custom service
&prompt.root;<command>firewall-cmd --info-service=nfs-rpc --permanent -v</command>
nfs-rpc
  summary:
  description: NFS and related, statically configured RPC ports
  ports: 4711/tcp 21001/udp 21001/tcp 21002/udp 21002/tcp 21003/udp 21003/tcp 21004/udp 21004/tcp
  protocols:
  source-ports:
  modules:
  destination:

# reload firewalld to make the new service definition available
&prompt.root;<command>firewall-cmd --reload</command>

# the new service definition can now be used to open the ports for example in the internal zone
&prompt.root;<command>firewall-cmd --add-service=nfs-rpc --zone=internal</command>
</screen>
    </example>
   </sect3>

   <sect3 xml:id="sec-security-firewall-firewalld-rpcports-helper">
    <title>Using <package>firewall-rpcbind-helper</package> for configuring static ports</title>
    <para>
     The steps to configure static ports as shown in the previous section can
     be simplified by using the &suse; helper tool
     <command>firewall-rpc-helper.py</command>. Install it with
     <command>zypper in firewalld-rpcbind-helper</command>.
    </para>
    <para>
     The tool allows interactive configuration of the service patterns
     discussed in the previous section. It can also display current port
     assignments and can be used for scripting. For details, see
     <command>firewall-rpc-helper.py --help</command>.
    </para>
   </sect3>
  </sect2>
 </sect1>

 <sect1 xml:id="sec-security-firewall-upgrade">
  <title>Migrating from &susefirewall;</title>
  <note>
   <title>Creating a &firewalld; configuration for &ay;</title>
   <para>
    See the <citetitle>Firewall Configuration</citetitle> section of the
    &ayguide; to learn how to create a &firewalld; configuration for &ay;.
   </para>
  </note>
  <remark>
   FIXME: Very unsure if the following upgrade scenario has _any_ bearing on
   Leap 15.2 anymore, since we don't even support upgrades from anything before
   Leap 15.1. Not sure whether to just profile away the entire section.
   - sknorr, 2020-07-02
  </remark>
  <para>
   When upgrading from
   <phrase os="sles;sled">any service pack of &productname; 12</phrase>
   <phrase os="osuse">any version of &productname; before 15.0</phrase>
   to &productname; &productnumber;, &susefirewall;
   is not changed and remains active. There is no automatic migration, so you must
   migrate to &firewalld; manually. &firewalld; includes a helper migration
   script, <command>susefirewall2-to-firewalld</command>. Depending on the
   complexity of your &susefirewall; configuration, the script may perform a
   perfect migration, or it may fail. Most likely it will partially succeed and you
   will have to review your new &firewalld; configuration and make adjustments.
  </para>
  <para>
   The resulting configuration will make &firewalld; behave somewhat like
   &susefirewall;. To take full advantage of &firewalld;'s features you may elect to
   create a new configuration, rather than trying to migrate your old configuration.
   It is safe to run the <command>susefirewall2-to-firewalld</command> script
   with no options, as it makes no permanent changes to your system. However, if
   you are administering the system remotely you could get locked out.
  </para>
  <para>
   Install and run <command>susefirewall2-to-firewalld</command>:
  </para>
<screen>&prompt.root;zypper in susefirewall2-to-firewalld
&prompt.root;susefirewall2-to-firewalld
INFO: Reading the /etc/sysconfig/SuSEfirewall2 file
INFO: Ensuring all firewall services are in a well-known state.
INFO: This will start/stop/restart firewall services and it's likely
INFO: to cause network disruption.
INFO: If you do not wish for this to happen, please stop the script now!
5...4...3...2...1...Lets do it!
INFO: Stopping firewalld
INFO: Restarting SuSEfirewall2_init
INFO: Restarting SuSEfirewall2
INFO: DIRECT: Adding direct rule="ipv4 -t filter -A INPUT -p udp -m udp --dport 5353 -m pkttype
  --pkt-type multicast -j ACCEPT"
[...]
INFO: Enabling direct rule=ipv6 -t filter -A INPUT -p udp -m udp --dport 546 -j ACCEPT
INFO: Enabling direct rule=ipv6 -t filter -A INPUT -p udp -m udp --dport 5353 -m pkttype
  --pkt-type multicast -j ACCEPT
INFO: Enable logging for denied packets
INFO: ##########################################################
INFO:
INFO: The dry-run has been completed. Please check the above output to ensure
INFO: that everything looks good.
INFO:
INFO: ###########################################################
INFO: Stopping firewalld
INFO: Restarting SuSEfirewall2_init
INFO: Restarting SuSEfirewall2
</screen>
  <para>
   This results in a lot of output, which you may wish to direct to a file for easier review:
  </para>
<screen>&prompt.root;susefirewall2-to-firewalld | tee newfirewallrules.txt</screen>
  <para>
   The script supports these options:
  </para>
  <variablelist>
   <varlistentry>
    <term><command>-c</command></term>
    <listitem>
     <para>
      Commit changes. The script will make changes to the system, so make sure you only use
      this option if you are really happy with the proposed changes. This <emphasis>will</emphasis>
      reset your current &firewalld; configuration, so make sure you make backups!
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>-d</command></term>
    <listitem>
     <para>
      Super noisy. Use it to file bug reports but be careful to mask sensitive information.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>-h</command></term>
    <listitem>
     <para>
      This message.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>-q</command></term>
    <listitem>
     <para>
      No output. Errors will not be printed either!
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>-v</command></term>
     <listitem>
      <para>
       Verbose mode. It will print warnings and other informative messages.
      </para>
     </listitem>
   </varlistentry>
  </variablelist>
 </sect1>

 <sect1 xml:id="sec-security-firewall-info">
  <title>More information</title>
  <para>
   The most up-to-date information and other documentation about the &firewalld;
   package is found in <filename>/usr/share/doc/packages/firewalld</filename>.
   The home page of the netfilter and iptables project, <link
    xlink:href="http://www.netfilter.org"/>, provides a large collection of
   documents about iptables in general in many languages.
  </para>
 </sect1>
</chapter>
